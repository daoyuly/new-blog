{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.css","path":"main.0cf68a.css","modified":0,"renderable":1},{"_id":"themes/yilia/source/slider.e37972.js","path":"slider.e37972.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/main.0cf68a.js","path":"main.0cf68a.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/mobile.992cbe.js","path":"mobile.992cbe.js","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","path":"fonts/default-skin.b257fa.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","path":"fonts/iconfont.16acc2.ttf","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","path":"fonts/iconfont.45d7ee.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","path":"fonts/iconfont.b322fa.eot","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","path":"fonts/iconfont.8c627f.woff","modified":0,"renderable":1},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","path":"fonts/tooltip.4004ff.svg","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/default-skin.png","path":"img/default-skin.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":0,"renderable":1},{"_id":"themes/yilia/source/img/preloader.gif","path":"img/preloader.gif","modified":0,"renderable":1}],"Cache":[{"_id":"themes/landscape/.gitignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1580214814379},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1580214814379},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1580214814380},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1580214814380},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1580214814380},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1580214814387},{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1580214690365},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1580214814380},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1580214814380},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1580214814381},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1580214814381},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1580214814381},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1580214814381},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1580214814381},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1580214814381},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1580214814381},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1580214814382},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1580214814382},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1580214814382},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1580214814387},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1580214814386},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1580214814387},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1580214814387},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1580214814388},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580214814387},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580214814387},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1580214814387},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1580214814382},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1580214814382},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1580214814382},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1580214814383},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1580214814383},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1580214814383},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1580214814383},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1580214814385},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1580214814386},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1580214814386},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1580214814386},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1580214814386},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1580214814386},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1580214814388},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1580214814390},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1580214814398},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1580214814399},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1580214814400},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1580214814400},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1580214814399},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1580214814400},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1580214814400},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1580214814402},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1580214814402},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1580214814403},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1580214814403},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1580214814385},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1580214814385},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1580214814384},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1580214814385},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1580214814388},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1580214814388},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1580214814389},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1580214814390},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1580214814390},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1580214814390},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1580214814390},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1580214814393},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1580214814392},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1580214814396},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1580214814400},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1580214814401},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1580214814401},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1580214814401},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1580214814402},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1580214814401},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1580214814395},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1580214814398},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1580214814394},{"_id":"public/2020/01/28/hello-world/index.html","hash":"75c758cf7213482df8f338083b968fa1cff35b12","modified":1580215174085},{"_id":"public/archives/index.html","hash":"983599362f24f0d8c254486d41a726421fd815bf","modified":1666443493094},{"_id":"public/archives/2020/index.html","hash":"d1575ce0a5d8ffabf382b5e180e4e376338e65b9","modified":1666443493094},{"_id":"public/archives/2020/01/index.html","hash":"809bdeac58ddda3ff12ab1d43ddd4e3ab3a17cc7","modified":1666443493094},{"_id":"public/index.html","hash":"09911badf68d0cf96234b47791183c8a4246ea57","modified":1666443493094},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1580215174085},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1580215174085},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1580215174085},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1580215174085},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1580215174085},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1580215174085},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1580215174085},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1580215174085},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1580215174085},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1580215174085},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1580215174085},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1580215174085},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1580215174085},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1580215174085},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1580215174085},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1580215174085},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1580215174085},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1580215174085},{"_id":"public/css/style.css","hash":"5f8dadd37d0052c557061018fe6f568f64fced9b","modified":1580215174085},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1580215174085},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1580215174085},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1580215174085},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1580215174085},{"_id":"source/.DS_Store","hash":"7477b33f74b0992a4e26164996cdf4c2d233b3b0","modified":1664702200343},{"_id":"source/_posts/周报.md","hash":"0d4991892ef311c25bceea675bb3377b9ed9f092","modified":1580272129070},{"_id":"source/_posts/如何选择一个看起来更松快的车厢.md","hash":"5d49c3a1f2c507d3db288cf24d65ba7c1332ba64","modified":1580280765539},{"_id":"source/_posts/常见的心理学效应.md","hash":"6b33e8dc2ceb5e30e39297b20cd34f4f588355e6","modified":1580266554012},{"_id":"source/_posts/技术demo.md","hash":"3fb3707815de3f837c48f7039caab91bd1c1a59f","modified":1580280765534},{"_id":"source/_posts/活在当下.md","hash":"b51dc4aaf9063142ce18c0310eea06b2e3cecc0a","modified":1583202326284},{"_id":"source/_posts/管理学效应.md","hash":"d7e4e4069ed040be343ed155f06f265d401f190a","modified":1580280765533},{"_id":"source/_posts/养娃1.md","hash":"4eb1905e9f4037b1573c8b0395e53602a5eff9a4","modified":1580266554946},{"_id":"themes/yilia/.babelrc","hash":"b1b76475ac17dc9e2fa50af96c9e31eea2d0f2b4","modified":1580259029721},{"_id":"themes/yilia/.editorconfig","hash":"da6d022b8f4d9c961e2f8f80677e92af8de0db4d","modified":1580259029721},{"_id":"themes/yilia/.eslintignore","hash":"df0a50b13cc00acb749226fee3cee6e0351fb1d9","modified":1580259029722},{"_id":"themes/yilia/.eslintrc.js","hash":"5696ae049de010ed3786768b0c359f14c05b5ec6","modified":1580259029722},{"_id":"themes/yilia/.gitattributes","hash":"e0f24dceeb1e6878a1dd9b01a2b9df1bc037a867","modified":1580259029722},{"_id":"themes/yilia/.gitignore","hash":"9c4b7d27a1e3e5efa0c8ed143a032a85d586b03b","modified":1580259029722},{"_id":"themes/yilia/README.md","hash":"1bf755806af9d8874bd22e1abbdaaa24328ef4dc","modified":1580259029722},{"_id":"themes/yilia/_config.yml","hash":"b5b40b2c2b2a519ce3fcfcf5325a1fb7edd6ee23","modified":1666443487196},{"_id":"themes/yilia/package.json","hash":"367cb9579d35968a942c243ab248a5f5ebfaf462","modified":1580259029733},{"_id":"themes/yilia/webpack.config.js","hash":"05ba46a4ae744272f5312e684928910dccad3755","modified":1580259029754},{"_id":"themes/yilia/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1580259029723},{"_id":"themes/yilia/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1580259029723},{"_id":"themes/yilia/languages/fr.yml","hash":"84ab164b37c6abf625473e9a0c18f6f815dd5fd9","modified":1580259029723},{"_id":"themes/yilia/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1580259029724},{"_id":"themes/yilia/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1580259029724},{"_id":"themes/yilia/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1580259029724},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1580259029725},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1580259029732},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1580259029732},{"_id":"themes/yilia/layout/index.ejs","hash":"a35dc900203f9d8dd863ea4c1722198d6d457ec8","modified":1580259029733},{"_id":"themes/yilia/layout/layout.ejs","hash":"0a332bdbd3b86c231d690614687f5b97186b85d5","modified":1580259029733},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580259029733},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1580259029733},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1580259029733},{"_id":"themes/yilia/source/main.0cf68a.css","hash":"dfe50daaf7863bb34024cd3651916b2391c91e02","modified":1666441795815},{"_id":"themes/yilia/source/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1580259029754},{"_id":"themes/yilia/source-src/css.ejs","hash":"94dbdb02ca11849e415d54fb28546a598f2cffb1","modified":1580259029734},{"_id":"themes/yilia/source-src/script.ejs","hash":"c21381e1317db7bb157f1d182b8c088cb7cba411","modified":1580259029748},{"_id":"themes/yilia/layout/_partial/toc.ejs","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580259029731},{"_id":"themes/yilia/source/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1580259029752},{"_id":"themes/yilia/source/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1580259029753},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"b86b248720ad415ec1b5fee53fb583776c776f83","modified":1580259029725},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1580259029726},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"630c6ec866d056657d3d91e34b4c64eb993c0654","modified":1580259029726},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"1f7d4819b7f67602c4a1b99871808d2160b60978","modified":1580259029726},{"_id":"themes/yilia/layout/_partial/aside.ejs","hash":"8edbd7993b9b061611a193533a664e2e85eae748","modified":1580259029726},{"_id":"themes/yilia/layout/_partial/baidu-analytics.ejs","hash":"f0e6e88f9f7eb08b8fe51449a8a3016273507924","modified":1580259029727},{"_id":"themes/yilia/layout/_partial/css.ejs","hash":"236f8a377b2e4e35754319c3029bcd4a4115431d","modified":1580259029727},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1580259029727},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1580259029727},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"492110f44176413b0105f0a1c49e0e25ef9242a8","modified":1666440893312},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1580259029728},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"183d7ca4ba8e7c80694ffdc8cf39957092238346","modified":1580259029728},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"151a1ef2173ba7b6789d349f0f8da89616cc1394","modified":1580259029728},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"7fbbfabf5e29525b24ada14613c21a26789132b4","modified":1580259029728},{"_id":"themes/yilia/layout/_partial/tools.ejs","hash":"c41341b9618e591538e1136a2d1637587c1bbd90","modified":1580259029732},{"_id":"themes/yilia/layout/_partial/viewer.ejs","hash":"e495790b2abe2290875817e42bd505bc611d3e26","modified":1580259029732},{"_id":"themes/yilia/source/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1580259029748},{"_id":"themes/yilia/source/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1580259029749},{"_id":"themes/yilia/source/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1580259029749},{"_id":"themes/yilia/source/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1580259029750},{"_id":"themes/yilia/source/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1580259029750},{"_id":"themes/yilia/source/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1580259029750},{"_id":"themes/yilia/source/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1580259029751},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1580259029751},{"_id":"themes/yilia/source/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1580259029751},{"_id":"themes/yilia/source-src/css/_core.scss","hash":"24f347a2412abbf58318369152504da9538f8d3b","modified":1580259029734},{"_id":"themes/yilia/source-src/css/archive.scss","hash":"7d27e22ac898e8fafec14549e940c73cbea1fba8","modified":1580259029734},{"_id":"themes/yilia/source-src/css/article-inner.scss","hash":"d79f2d35a06de83a2a226ca790b7a0a34789c115","modified":1580259029735},{"_id":"themes/yilia/source-src/css/_function.scss","hash":"93a50dd19a93485712da1f8d0a1672482dd1eabc","modified":1580259029734},{"_id":"themes/yilia/source-src/css/article-main.scss","hash":"3fad68bd74260326f83090b0974dd80707e7bac7","modified":1580259029735},{"_id":"themes/yilia/source-src/css/article-nav.scss","hash":"43e507f2a48504079afd9471353337e23ca47470","modified":1580259029735},{"_id":"themes/yilia/source-src/css/article.scss","hash":"0f6d61af99ed4db87f8589db1feaea7747b55963","modified":1580259029735},{"_id":"themes/yilia/source-src/css/aside.scss","hash":"578a67464dd0f542197f7fcee158c991db058563","modified":1580259029735},{"_id":"themes/yilia/source-src/css/comment.scss","hash":"cafe3834017a3bf47420f37543725025225a2c89","modified":1580259029736},{"_id":"themes/yilia/source-src/css/fonts.scss","hash":"97b8fba41c914145710b90091f400b845879577f","modified":1580259029737},{"_id":"themes/yilia/source-src/css/footer.scss","hash":"7c995410b25baaf61dfc5e148e22ca60330abcd3","modified":1580259029739},{"_id":"themes/yilia/source-src/css/global.scss","hash":"b4cb4f45a55d4250cd9056f76dab2a3c0dabcec4","modified":1580259029739},{"_id":"themes/yilia/source-src/css/grid.scss","hash":"849a29fcd7150214fcf7b9715fa5dc71d1f9b896","modified":1580259029739},{"_id":"themes/yilia/source-src/css/highlight.scss","hash":"3719994c2c9393813cc1d42b657205c368a329cb","modified":1580259029740},{"_id":"themes/yilia/source-src/css/left.scss","hash":"0d30c0e7cdb831c3881a017006c782f2214ac195","modified":1580259029741},{"_id":"themes/yilia/source-src/css/main.scss","hash":"2f86a014af93583caba78a563d9549826bf28294","modified":1580259029741},{"_id":"themes/yilia/source-src/css/mobile-slider.scss","hash":"f053c609d84df0dd9eee1d11ddf0c19163a456be","modified":1580259029741},{"_id":"themes/yilia/source-src/css/mobile.scss","hash":"ace041d72f95b419f6a5e443191703c2b62007f4","modified":1580259029742},{"_id":"themes/yilia/source-src/css/page.scss","hash":"bf206bb7f7d0967bc8b7fdf01b7ffc99aff9ba88","modified":1580259029742},{"_id":"themes/yilia/source-src/css/reward.scss","hash":"80a4fcf9171d4a33235da96ac8a2b7dcabc45dfb","modified":1580259029742},{"_id":"themes/yilia/source-src/css/scroll.scss","hash":"9c8dfd1c76854ef063494ca76fac6360b391ed6d","modified":1580259029742},{"_id":"themes/yilia/source-src/css/share.scss","hash":"150c6425f6582e7ec78a873256ce49c9930e8805","modified":1580259029743},{"_id":"themes/yilia/source-src/css/social.scss","hash":"724162ccf3977e70a45d189abfaa20b6e2fba87b","modified":1580259029743},{"_id":"themes/yilia/source-src/css/tags-cloud.scss","hash":"c8aa84fca93862d3caae77c552873b8610f33327","modified":1580259029743},{"_id":"themes/yilia/source-src/css/tags.scss","hash":"ac67a3c7097849206244db9b0ba91daaba017ef5","modified":1580259029744},{"_id":"themes/yilia/source-src/css/tools.scss","hash":"ce4e3faf8a9cfc29a296f3633fa34345158cb81c","modified":1666441250530},{"_id":"themes/yilia/source-src/css/tooltip.scss","hash":"53d5a554bc2f38e9bb3d26400a47767013c05216","modified":1580259029745},{"_id":"themes/yilia/source-src/js/anm.js","hash":"4a4c5d82b09a3063f91a434388e6aa064fd7fd98","modified":1580259029746},{"_id":"themes/yilia/source-src/js/Q.js","hash":"d011af172064b6c6e0c7051d8f9879373ddac113","modified":1580259029745},{"_id":"themes/yilia/source-src/js/aside.js","hash":"754f771264548a6c5a8ad842908e59ae4e7ed099","modified":1580259029746},{"_id":"themes/yilia/source-src/js/browser.js","hash":"04095b38cfd4316a23f8eb14b1ffaf95f78a4260","modified":1580259029746},{"_id":"themes/yilia/source-src/js/fix.js","hash":"d6782d53c992e712af39c84e804eccaf38830b94","modified":1580259029746},{"_id":"themes/yilia/source-src/js/main.js","hash":"3894e60827c817319e43c9ff3ed045fc3d7336ce","modified":1580259029746},{"_id":"themes/yilia/source-src/js/mobile.js","hash":"4d823b039fd296d24a454eae5a798b93c44560cb","modified":1580259029747},{"_id":"themes/yilia/source-src/js/report.js","hash":"445bb99b2ffdfaf64c2c9a319ecbc63d38ea8504","modified":1580560844925},{"_id":"themes/yilia/source-src/js/share.js","hash":"b090f82cf80cba7da764753906d9e2cc2acdf30d","modified":1580259029747},{"_id":"themes/yilia/source-src/js/slider.js","hash":"e846bcc5aac9c68b93f7b8de353df54d8d29f666","modified":1580259029747},{"_id":"themes/yilia/source-src/js/util.js","hash":"8456e9d6b19532742582c99b2fb9d09e146e1c58","modified":1580259029748},{"_id":"themes/yilia/source-src/js/viewer.js","hash":"2577deb6a9fe4f5436360b2ce9afcc7f9a7f0116","modified":1580259029748},{"_id":"themes/yilia/layout/_partial/script.ejs","hash":"4cb685f07e89dd5175c2a576e73a1a957aec5637","modified":1580259029731},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"0809a4829aabeb4e911a3ed04ec28db4df7dfe3f","modified":1580259029729},{"_id":"themes/yilia/layout/_partial/post/changyan.ejs","hash":"5f99b55980da64a723a8e14d5a7daba0d6504647","modified":1580259029729},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"ef71c4081e866a494367575c59610e7e6339ece0","modified":1580259029729},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1580259029729},{"_id":"themes/yilia/layout/_partial/post/gitment.ejs","hash":"e68bbac9ffb1ad27b56837c9abad6ed6bb7daa0c","modified":1580259029729},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"1036c8e4e1a7bc935ba173744da735a0d6ed09cd","modified":1580259029730},{"_id":"themes/yilia/layout/_partial/post/share.ejs","hash":"5dccfbe165b23a101f1333cc65ed8efbd197453c","modified":1580259029730},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"2e783e68755abb852760eb0e627a3fbb50a05a55","modified":1580259029730},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1580259029730},{"_id":"themes/yilia/layout/_partial/post/wangyiyun.ejs","hash":"ea41c462168d9697caef9485862e9cac718a12c1","modified":1580259029731},{"_id":"themes/yilia/source-src/css/core/_animation.scss","hash":"63a37f26276f9207405afe0f2d65339ce295bbaf","modified":1580259029736},{"_id":"themes/yilia/source-src/css/core/_media-queries.scss","hash":"491ab3378d5c11005ba65c607608bb36b368a9d5","modified":1580259029736},{"_id":"themes/yilia/source-src/css/core/_mixin.scss","hash":"3bba5c77bad5981eac859fe05c9561d580ba7fa9","modified":1580259029736},{"_id":"themes/yilia/source-src/css/core/_reset.scss","hash":"fab871fa93bd542e76a71a56428f2994a4aaf443","modified":1580259029736},{"_id":"themes/yilia/source-src/css/core/_variables.scss","hash":"fb511c505d1309249f21dc577d4ad2bad99a764f","modified":1580259029737},{"_id":"themes/yilia/source-src/css/fonts/iconfont.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1580259029737},{"_id":"themes/yilia/source-src/css/fonts/iconfont.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1580259029738},{"_id":"themes/yilia/source-src/css/fonts/iconfont.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1580259029738},{"_id":"themes/yilia/source-src/css/img/checkered-pattern.png","hash":"049262fa0886989d750637b264bed34ab51c23c8","modified":1580259029740},{"_id":"themes/yilia/source-src/css/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1580259029740},{"_id":"themes/yilia/source-src/css/img/tooltip.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1580259029741},{"_id":"themes/yilia/source-src/css/fonts/iconfont.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1580259029738},{"_id":"source/_posts/_hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1580271699180},{"_id":"public/content.json","hash":"7ad9891f9d660c21823437c3c31cefa0429b9e30","modified":1666439317264},{"_id":"public/2020/01/28/技术demo/index.html","hash":"5ed27133ee1495abe0f17fbdbdc68992bf6e5c00","modified":1580272736038},{"_id":"public/2020/01/28/管理学效应/index.html","hash":"b5b0e58b0f291add60e8afd09d7e2d1eff9b449d","modified":1580272736038},{"_id":"public/2020/01/28/活在当下/index.html","hash":"43e00ac795c8304f28223d20a239bb78844daae1","modified":1580272736038},{"_id":"public/2020/01/28/如何选择一个看起来更松快的车厢/index.html","hash":"9787d110d40a253748dfa0c7c1b77618bf96e1de","modified":1580272736038},{"_id":"public/2017/09/27/常见的心理学效应/index.html","hash":"088e7d61d69ebccc8991acba286723342894f352","modified":1645261543533},{"_id":"public/2017/09/27/周报/index.html","hash":"c75808703c901404dbd1aec831afd761403d149f","modified":1645261543533},{"_id":"public/2017/09/27/养娃1/index.html","hash":"fa6bacb3bc9810dee1e7459d766b4dbe05278da3","modified":1587929931576},{"_id":"public/archives/2017/index.html","hash":"078a511cd187918935367a59212d4bd336963732","modified":1666443493094},{"_id":"public/archives/2017/09/index.html","hash":"a3e8eac6681165093ee1f8df2df23f8f874a844d","modified":1666443493094},{"_id":"public/tags/生活-养娃/index.html","hash":"10f7aabdb0e1e9315c69b699993703c9546add9e","modified":1666443493094},{"_id":"public/fonts/default-skin.b257fa.svg","hash":"2ac727c9e092331d35cce95af209ccfac6d4c7c7","modified":1580272736038},{"_id":"public/fonts/iconfont.8c627f.woff","hash":"aa9672cb097f7fd73ae5a03bcd3d9d726935bc0a","modified":1580272736038},{"_id":"public/fonts/iconfont.16acc2.ttf","hash":"f342ac8bf4d937f42a7d6a0032ad267ab47eb7f2","modified":1580272736038},{"_id":"public/fonts/iconfont.45d7ee.svg","hash":"f9304e5714d20861be7d8f4d36687e88e86b9e1b","modified":1580272736038},{"_id":"public/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1580272736038},{"_id":"public/fonts/iconfont.b322fa.eot","hash":"bc8c5e88f4994a852041b4d83f126d9c4d419b4a","modified":1580272736038},{"_id":"public/fonts/tooltip.4004ff.svg","hash":"397fe4b1093bf9b62457dac48aa15dac06b54a3c","modified":1580272736038},{"_id":"public/img/default-skin.png","hash":"ed95a8e40a2c3478c5915376acb8e5f33677f24d","modified":1580272736038},{"_id":"public/img/preloader.gif","hash":"6342367c93c82da1b9c620e97c84a389cc43d96d","modified":1580272736038},{"_id":"public/slider.e37972.js","hash":"6dec4e220c89049037eebc44404abd8455d22ad7","modified":1580272736038},{"_id":"public/main.0cf68a.css","hash":"88079cef59217c5c1b0dbf858d194f6261f0a931","modified":1666441022656},{"_id":"public/main.0cf68a.js","hash":"993fadeb5f6d296e9d997a49ee20dc97333ceab7","modified":1580272736038},{"_id":"public/mobile.992cbe.js","hash":"01b35e71e37aa2849664eb5daf26daede2278398","modified":1580272736038},{"_id":"source/_posts/_读书笔记-神之时间管理术.md","hash":"c7a3f78324554d9367c88388ab9425dcd6482ef6","modified":1643532124414},{"_id":"source/_posts/shell学习.md","hash":"b60d828092c75211e6dd24daf5d741841e2796b6","modified":1580561169267},{"_id":"public/2020/01/30/shell学习/index.html","hash":"272deaf96a3e4222507dc4350adc121e52b64e43","modified":1645261543533},{"_id":"public/2017/09/27/如何选择一个看起来更松快的车厢/index.html","hash":"11a3532b4aef3afcd79ab7535812669c3a958b96","modified":1645261543533},{"_id":"public/2017/09/27/活在当下/index.html","hash":"00c4d8d959478de1d7f555a4b70c046129bb26d5","modified":1645261543533},{"_id":"public/2017/09/27/技术demo/index.html","hash":"e6fd26312700b1279e4b4006f77158666d47b83c","modified":1645261543533},{"_id":"public/2017/09/27/管理学效应/index.html","hash":"bcd249ec1e88125a38bb5ac90411c65beb496484","modified":1645261543533},{"_id":"public/tags/shell-语言学习/index.html","hash":"e517dd9aad88b13408b8c478aa0aaaced0af16ca","modified":1666443493094},{"_id":"source/_posts/nginx.md","hash":"21dd8c718fd6414179053df784a5a36c62e43448","modified":1580561390341},{"_id":"public/2020/02/01/nginx/index.html","hash":"36093d15276d02db99f86b088ffb4315895dca3b","modified":1645261543533},{"_id":"public/tags/nginx/index.html","hash":"1489d2c7ef6650ac23ce3d08515656fe28139af2","modified":1666443493094},{"_id":"public/archives/2020/02/index.html","hash":"006763c9e9cff42db45b4fddb1fc2f04511a3d21","modified":1666443493094},{"_id":"source/_posts/_android 架构学习心得.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580803515787},{"_id":"source/_posts/_okscoket学习心得.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580803534618},{"_id":"source/_posts/_新型冠状病毒.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1580561336974},{"_id":"source/_posts/git服务器搭建.md","hash":"acfa38198fc67a1cd37397487fa349c4b31c40eb","modified":1580803660861},{"_id":"public/tags/git/index.html","hash":"6500cc27b4db0c3fde38d2ecf23c1b68bea40dc7","modified":1666443493094},{"_id":"public/2020/02/04/git服务器搭建/index.html","hash":"aec8b809416b5994d600827977a8c162a9029902","modified":1645261543533},{"_id":"source/_posts/公式相声之浅见.md","hash":"a1c14682ff056db411f6b491857fdd984d3775ca","modified":1613451480191},{"_id":"public/archives/page/2/index.html","hash":"e47f1a4c11a273db8985941914e8e5854aa3e4c3","modified":1666443493094},{"_id":"public/2020/02/04/公式相声之浅见/index.html","hash":"bd57cecd62c99e08e6ccb9fdfdb273a60b87deb6","modified":1645261543533},{"_id":"public/page/2/index.html","hash":"1a02f637425247cf075860407e12cc205cee96aa","modified":1666443493094},{"_id":"public/tags/社会思考/index.html","hash":"be154ce6254b8a61983755395b2e907592560fc0","modified":1666443493094},{"_id":"source/_posts/_uc用收藏夹留住了我吗.md","hash":"9fbea54cb9c4e41cf4e6168b692c626ad21119b1","modified":1581229602078},{"_id":"source/_posts/mac下解压缩报22错误.md","hash":"dade856aa3ca1d243e8769dacae1593fcb18b0e3","modified":1581225442474},{"_id":"source/_posts/_扛疫.md","hash":"f54c5fce8fd5433998cfc491a35c7f0d73ffe52c","modified":1590336725576},{"_id":"public/2020/02/09/mac下解压缩报22错误/index.html","hash":"476dbe482681a295b16078c3a9fe187905d2278f","modified":1581338707366},{"_id":"public/tags/日常/index.html","hash":"205106d18ec2c4fa0b086d26febfccac35cbbb8a","modified":1666443493094},{"_id":"source/_posts/机会来的时候，你准备好了吗.md","hash":"bc8a361736fc11e121ab782d19a4fdf15568d2b7","modified":1613451448905},{"_id":"public/tags/反思-个人成长/index.html","hash":"042d71fef3ae75abcd349d80e171be6e70c9f2ad","modified":1666443493094},{"_id":"public/2020/02/10/机会来的时候，你准备好了吗/index.html","hash":"13ca33e368d0cf6e527d183446a80001746d58c9","modified":1645261543533},{"_id":"source/_posts/shell学习: 提取文本，升级版本号.md","hash":"58d3e3c8c1b28286c28903a51b1afbc26fb6a3c2","modified":1582131038637},{"_id":"public/2020/02/20/shell学习: 提取文本，升级版本号/index.html","hash":"92242153175a5b859b23b11f1b9960438797dd44","modified":1645261543533},{"_id":"source/_posts/_ffmpeg基本使用.md","hash":"4d5c3f2e1c6b0c2baeb71e611d6f0e021fcd0394","modified":1582131988477},{"_id":"source/_posts/mac下解压报22错误.md","hash":"8585835cdd86606d355be5bfc8a8a6e6daba5702","modified":1582135510441},{"_id":"source/_posts/发票的半自动填写.md","hash":"a58799d1175cb79d2441cdb69abddc4eeb121960","modified":1582305920175},{"_id":"public/2020/02/09/mac下解压报22错误/index.html","hash":"66b113dd85f94d193418c0cde0d11b831605d956","modified":1645261543533},{"_id":"public/2020/02/22/发票的半自动填写/index.html","hash":"8cad0e65760cbed45ca72a8c1d64dedd14c3ce9e","modified":1645261543533},{"_id":"public/tags/日常-自制-创意/index.html","hash":"94cce36dcc363f2a6776a51ef23f746c31e62d9b","modified":1666443493094},{"_id":"source/_posts/EventBus源码解析(一).md","hash":"b4eaafb08c8ac1c3c7c8d0cd1603c8e5932bcbd5","modified":1613451506321},{"_id":"public/2020/02/27/EventBus源码解析(一)/index.html","hash":"a21433d278eca0488e3f999060b6a421a2660d28","modified":1645261543533},{"_id":"public/tags/java-android-EventBus/index.html","hash":"10c577fbca06adba9a394fbd9ec039bfd69f42f7","modified":1666443493094},{"_id":"source/_posts/android手机执行go程序.md","hash":"2337d83c5534cea5459650deabc9c698e98ed19b","modified":1583163014494},{"_id":"public/2020/03/02/android手机执行go程序/index.html","hash":"727ea341067c8b99b6eb7eef8eaa3f16da649ad4","modified":1645261543533},{"_id":"public/archives/2020/03/index.html","hash":"c71b9e2e1f397ce665bf90fa23143cb4cbfbccb7","modified":1666443493094},{"_id":"public/tags/go-android-linux-刷机-root/index.html","hash":"6eb81051667854c253f0f8b26f4c9aa8dbb45c14","modified":1666443493094},{"_id":"source/_posts/go入门.md","hash":"f34f621a5771b0977dc164146fe51e2aa8352e71","modified":1613451521896},{"_id":"source/_posts/indexedDB杂想.md","hash":"4caee0f3885aa69f3bd2af41270b83532ea46591","modified":1586155842038},{"_id":"public/2020/04/06/indexedDB杂想/index.html","hash":"b881bdcfad82bb598b004ac7345a12f34794351a","modified":1645261543533},{"_id":"public/2020/03/02/go入门/index.html","hash":"4526b729c1758f5885457fc3fcd3d6bcc62482a9","modified":1645261543533},{"_id":"public/archives/2020/page/2/index.html","hash":"aedfaaeceef375654d5a13d84b220a8b98d6dcb6","modified":1666443493094},{"_id":"public/archives/2020/04/index.html","hash":"ff9f8dc4f66017a5ca3e16fdff8d11abd61ad9f3","modified":1666443493094},{"_id":"public/tags/go-语言学习/index.html","hash":"e7a1ec7574e47cf93f9a90a304bb8fe25f37b127","modified":1666443493094},{"_id":"public/tags/技术杂想/index.html","hash":"7ba58674b14881b2caee9eb25d2fb4f21c78b425","modified":1666443493094},{"_id":"source/_posts/20200404.md","hash":"0e085bff9d15aa1be1fb22137dbf3b64e6eea5fa","modified":1613451496217},{"_id":"public/2020/04/04/20200404/index.html","hash":"788f29379ab312951f6a1ec2780eb58656c7d3b6","modified":1645261543533},{"_id":"public/tags/社会-感悟/index.html","hash":"9008e6655ff75d58314de5914ce507c50c0b7667","modified":1666443493094},{"_id":"source/_posts/一起的一起.md","hash":"78ce5407fd00ce9d9c70e48bd4d912bcea11818a","modified":1588431491353},{"_id":"source/_posts/python之禅.md","hash":"8587db68ec7bd5e0c0a0f7058e4bacb4953dd95f","modified":1587926266335},{"_id":"public/2020/04/27/python之禅/index.html","hash":"c726a102f50279fe2fb523ef746a59e73c4c8f88","modified":1645261543533},{"_id":"public/2020/04/27/一起的一起/index.html","hash":"69db26f3f0e0c383940bea83059a5b49d53cc907","modified":1645261543533},{"_id":"public/tags/人生感悟/index.html","hash":"90a5cfaf7d44202f72998da40c2d817d078213a9","modified":1666443493094},{"_id":"public/tags/Python-语言学习/index.html","hash":"7628a4ea8796ec5ce66416e2dcde9e80e8f6f2db","modified":1666443493094},{"_id":"public/page/3/index.html","hash":"e62d322e51cf74c10392b9eb25ff9efe93fe02e5","modified":1666443493094},{"_id":"public/archives/page/3/index.html","hash":"1e72896ac6765d9196f5750ba5fab1a329e9cca5","modified":1666443493094},{"_id":"source/_posts/养娃日志1.md","hash":"4eb1905e9f4037b1573c8b0395e53602a5eff9a4","modified":1588431301740},{"_id":"source/_posts/养娃日志2.md","hash":"054297266b795fe73ef28aa4ec47367c81ce4f4c","modified":1613451485107},{"_id":"public/2020/05/02/养娃日志2/index.html","hash":"3e72f113ac08cc937635cb338443b89cd7333a63","modified":1645261543533},{"_id":"public/2017/09/27/养娃日志1/index.html","hash":"180352cc0a628126a13191b136736dda64903744","modified":1645261543533},{"_id":"public/archives/2020/05/index.html","hash":"e107ed677d8dc88c5f90d026a18273f881943537","modified":1666443493094},{"_id":"source/_posts/软件兴国.md","hash":"1f6a502dfbe6e4e38299c001a36a592be27ce2c9","modified":1613451324611},{"_id":"public/2020/05/24/软件兴国/index.html","hash":"59759a3847057a8454a3155cc72be482ddee804c","modified":1645261543533},{"_id":"public/tags/随想/index.html","hash":"710fb542fa2565bfbd8cfed49c34a20c922d3b5c","modified":1666443493094},{"_id":"source/_posts/jd 集锦.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599368556302},{"_id":"source/_posts/何为领袖之国.md","hash":"9a00bcee2c2eddd58a98950951f97cba714f262d","modified":1599370607819},{"_id":"source/_posts/关于横财.md","hash":"f059390c55afd8a2250ab8b888997b5f39c75c7b","modified":1613451477377},{"_id":"source/_posts/学习1.md","hash":"baaf208b9968db9c76674b2269501c74bb52e468","modified":1599369717693},{"_id":"source/_posts/学习2.md","hash":"1a8040c612eef6514863c67eb1a834ad6057ae7f","modified":1599369785461},{"_id":"source/_posts/我的扛疫.md","hash":"6a0f175e762a744767c641e89ada50c194676c34","modified":1599370375698},{"_id":"source/_posts/江湖.md","hash":"b00c30979eecf25358464e6d0d95174a4e92c2d3","modified":1613451403740},{"_id":"source/_posts/随机与确定的随想.md","hash":"6da818a2e6b6c9e03509844d1d9d0eb22bb94b66","modified":1599371635486},{"_id":"public/2020/08/20/何为领袖之国/index.html","hash":"6a5ebb548efdc362cf2db6e7126b9d488b9ee9b6","modified":1645261543533},{"_id":"public/2020/08/07/江湖/index.html","hash":"6fff513a908c5900dec74393def8e481569fb3e2","modified":1645261543533},{"_id":"public/2020/09/06/关于横财/index.html","hash":"29047cf5c577d711524d8ec4c6d70ca083a4decb","modified":1645261543533},{"_id":"public/2020/09/06/jd 集锦/index.html","hash":"d4f6caf0b1c91b7eb2e751bef7085438d0a0e4b0","modified":1599370839700},{"_id":"public/2020/07/01/学习2/index.html","hash":"1e3104d937e2d1e50538b539d41193e0da6bbcc0","modified":1645261543533},{"_id":"public/2020/06/28/学习1/index.html","hash":"0efeb573fb8801b38eb1c64d378aef3e49c3a9b0","modified":1645261543533},{"_id":"public/2020/06/27/随机与确定的随想/index.html","hash":"ed2e53a092894e1338c5ab1c055f73fa69718386","modified":1645261543533},{"_id":"public/2020/01/29/我的扛疫/index.html","hash":"a3abf742c3b5ee4632a1902c50c5859c620bc2ec","modified":1645261543533},{"_id":"public/archives/page/4/index.html","hash":"4b52eaa1080ed06ed773ca0bd8e8b08d57e60492","modified":1666443493094},{"_id":"public/archives/2020/07/index.html","hash":"363c5f01e90bb65aefded2196a008776be150b43","modified":1666443493094},{"_id":"public/archives/2020/06/index.html","hash":"8ac0b5d7f0e894831730ab83c818ff59882242a6","modified":1666443493094},{"_id":"public/archives/2020/09/index.html","hash":"7f9f9f8fa874cfb7ab3c26d9020fbd8ee9db6d1d","modified":1666443493094},{"_id":"public/archives/2020/08/index.html","hash":"40d28ba07a0bb358e17f7cf28b9798691c88d9eb","modified":1666443493094},{"_id":"public/archives/2020/page/3/index.html","hash":"24862d972c6f69a8703341f6b0acc6091866a6f7","modified":1666443493094},{"_id":"public/page/4/index.html","hash":"cfaad07f5435c4d700554b3c6e03918f5eb538cb","modified":1666443493094},{"_id":"source/_posts/_jd 集锦.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1599370918592},{"_id":"source/_posts/大娘去世.md","hash":"9490b3d5375fdd7af6c761a3595d551e348ea387","modified":1600964957061},{"_id":"public/2020/09/24/大娘去世/index.html","hash":"5c3d9e39cc2c513ac1baf07ab3f3ee64b05914ab","modified":1610274638113},{"_id":"source/_posts/_大娘去世.md","hash":"a25aad6539dd34a756c3e6ccb6a71a286b0c163d","modified":1643532531367},{"_id":"source/_posts/软件设计的哲学-ch1.md","hash":"b740ae07f6e3aa0cc198fecced9f1e2f53bb06b1","modified":1613452422686},{"_id":"source/_posts/软件设计的哲学-ch11.md","hash":"bb448603ff6d2ecf2370b55b595a8f4bab2978ec","modified":1613451223382},{"_id":"source/_posts/软件设计的哲学-ch12.md","hash":"7244cebe642ed808add534c226b964128e1d2fc9","modified":1613451218256},{"_id":"source/_posts/软件设计的哲学-ch10.md","hash":"8a644d5a2e1e7a21d674fbee4984c34ccab6e4ec","modified":1613451228198},{"_id":"source/_posts/软件设计的哲学-ch14.md","hash":"81a012f4cc369276c53bd6f7b56f4d5285c827de","modified":1613451206183},{"_id":"source/_posts/软件设计的哲学-ch15.md","hash":"c4a825209cdeb8d69c51c7b49e8f19e3fd1c9d70","modified":1613451199799},{"_id":"source/_posts/软件设计的哲学-ch16.md","hash":"5b2183d43e2a851658c8cc8274379798f1584db3","modified":1613451195271},{"_id":"source/_posts/软件设计的哲学-ch17.md","hash":"5792e1cc85bfdb1d68c8b6658cfbb35c2eae4912","modified":1613451190568},{"_id":"source/_posts/软件设计的哲学-ch18.md","hash":"83bc03a96da973f859872e12be956eb3ac3b7914","modified":1613451185167},{"_id":"source/_posts/软件设计的哲学-ch19.md","hash":"391354764a1b0f1e01a441dc4b93f780e7869a22","modified":1613451180728},{"_id":"source/_posts/软件设计的哲学-ch2.md","hash":"29e1faa6f8a4ffffcdb29eb01d667ea31fb21d2a","modified":1613450956378},{"_id":"source/_posts/软件设计的哲学-ch20.md","hash":"655bdbdf4c0237ca68d54036b4f2755b36fc08a3","modified":1613451062862},{"_id":"source/_posts/软件设计的哲学-ch21.md","hash":"457849f1b585b3f25a020b27d7a82ed6eefbfaa6","modified":1666440518740},{"_id":"source/_posts/软件设计的哲学-ch3.md","hash":"b345dd6986e2de9fdda4b932bee2d0bb20a422c3","modified":1613450973816},{"_id":"source/_posts/软件设计的哲学-ch5.md","hash":"7c8dc62241b8b8c1c746930e90fd3e7e8da3e763","modified":1613451573340},{"_id":"source/_posts/软件设计的哲学-ch4.md","hash":"fde8c9e0903bf32b9402b3170894fef24ee2fcad","modified":1613450981287},{"_id":"source/_posts/软件设计的哲学-ch6.md","hash":"17ea82d9ce09284a615486c168c614236df62016","modified":1613451248262},{"_id":"source/_posts/软件设计的哲学-ch7.md","hash":"ade8db1bec5876a9451080b31b42b38447bd53af","modified":1613451243029},{"_id":"source/_posts/软件设计的哲学-ch8.md","hash":"4b33f7783bdb12fff771572d981c616643a23d1a","modified":1613451118634},{"_id":"source/_posts/软件设计的哲学-ch9.md","hash":"70e342bfae1c65d5b555f28f99206cb3efb0001e","modified":1613451234868},{"_id":"source/docs/README.md","hash":"8019d050997684896b9064816756db808c60073d","modified":1613396414292},{"_id":"source/docs/ch1.md","hash":"82009baf36a5a27bf121d7ed8272c7b032abc68c","modified":1613396414293},{"_id":"source/docs/ch11.md","hash":"63c1f7aa2d11221d4989a87a4423b72cbbe9274d","modified":1613396414293},{"_id":"source/docs/ch10.md","hash":"94d91662a3ba505a6ef1f606e38eee0baac478ad","modified":1613400897570},{"_id":"source/docs/.DS_Store","hash":"03c5b230f4a77e0b872523ff24f7a04ecfdfbeab","modified":1613396701140},{"_id":"source/docs/ch12.md","hash":"b644434ddb1d59d2ae773154ba96125677aa221d","modified":1613396414294},{"_id":"source/docs/ch14.md","hash":"9b8a9754194ebfd9e932789f738694f96ab381bd","modified":1613396414295},{"_id":"source/docs/ch15.md","hash":"1a438d7a745d6f35bbde63f231acc5f8b5b9e76f","modified":1613396414295},{"_id":"source/docs/ch16.md","hash":"9588cb72b0855070b778b03af97f839b7e0c0a36","modified":1613396414295},{"_id":"source/docs/ch17.md","hash":"2ce2cfa34d66bcdad365021e7831cc1c31f4581f","modified":1613396414296},{"_id":"source/docs/ch18.md","hash":"4f8780559ceb376a6a5825fd58765ebb72b634e8","modified":1613396414296},{"_id":"source/docs/ch2.md","hash":"cc3945df3f525639b708445bf0c8bd185776ff79","modified":1613400897572},{"_id":"source/docs/ch19.md","hash":"6356599005104b8d26604e6b0bb843e17b6f4264","modified":1613396414296},{"_id":"source/docs/ch20.md","hash":"eaaca1ce8d5661b98a4e5f6d30784278322e853a","modified":1613400897570},{"_id":"source/docs/ch21.md","hash":"31da7f0333fb2361a09b73f4f0d648ee9bcfffb5","modified":1613396414298},{"_id":"source/docs/ch3.md","hash":"876c45844b22b0a36054915ae1daf5c977b1f166","modified":1613400897570},{"_id":"source/docs/ch4.md","hash":"288e45c5521a282031d4acef7df2da6b93879c0b","modified":1613400897571},{"_id":"source/docs/ch5.md","hash":"51ec049dd0ccd00895ee089e7e0a80233f90f308","modified":1613400897570},{"_id":"source/docs/ch6.md","hash":"008eb0192d6215d82e26097606181f999a90d617","modified":1613396414299},{"_id":"source/docs/ch7.md","hash":"4c3dc273e7159c6be72a6cdc5b50b986955279c2","modified":1613400897570},{"_id":"source/docs/ch8.md","hash":"312f8586490a0a9bfd5240055a65c62774c37a58","modified":1613396414300},{"_id":"source/docs/ch9.md","hash":"48abbfe90132812711974b2fd908b2c823cd81af","modified":1613400897570},{"_id":"source/docs/preface.md","hash":"f35ac560a2357c9fcbf0a4d69d45b4c6761d5848","modified":1613396414308},{"_id":"source/docs/summary.md","hash":"f8683c531e8ba8ffbc20e9e19f188ff644cdf2cf","modified":1613396414309},{"_id":"source/_posts/软件设计的哲学-ch13.md","hash":"1365884663b45c73c606862b8bb7669566ffa9b8","modified":1613451213095},{"_id":"source/docs/ch13.md","hash":"9b8201c48c19f845164899a29c5dbe4d0e85d41e","modified":1613396414294},{"_id":"source/docs/cover.jpeg","hash":"774c52dab78066e3fb2212da38229e7a2e91941d","modified":1613396414302},{"_id":"source/docs/.vuepress/config.js","hash":"d584537c8d82cd3e672639ce1a41d3671249e58d","modified":1613396414292},{"_id":"source/docs/figures/00009.gif","hash":"e4fdf8dfd7a4cc847df67be738547b9cbc35b213","modified":1613396414302},{"_id":"source/docs/figures/00013.jpeg","hash":"e508f09c005650b16029795bf4e23bbea19ea688","modified":1613396414303},{"_id":"source/docs/figures/00012.jpeg","hash":"2c4f7cdeebab59bad18dc8f8fbbc1a66c96e31aa","modified":1613396414303},{"_id":"source/docs/figures/00014.gif","hash":"394ccef578e57eafca80c2a2ed971d84dbcb46cf","modified":1613396414304},{"_id":"source/docs/figures/00011.jpeg","hash":"366e71620bf0b6e414ab882f48b7283e5ab275ff","modified":1613396414303},{"_id":"source/docs/figures/00017.gif","hash":"fd10cace9fe5450532f517740e5339559519b2af","modified":1613396414305},{"_id":"source/docs/figures/00015.jpeg","hash":"e1dc4a396ebe3efd1f3b28625c640fbc1d3b3058","modified":1613396414304},{"_id":"source/docs/figures/00016.gif","hash":"e25e16a4c9764cfa23631b00e8a8f6a0ce67015e","modified":1613396414304},{"_id":"source/docs/figures/00018.gif","hash":"389f714db56720278066da71d33969fd1172e560","modified":1613396414305},{"_id":"source/docs/figures/00019.jpeg","hash":"1413b98934728741b52f4d76da58b6cdccc0ac2c","modified":1613396414305},{"_id":"source/docs/figures/00021.jpeg","hash":"41a9ce2fa7c53ddbb657ea8dc7817c09391cf4fa","modified":1613396414307},{"_id":"source/docs/figures/00022.jpeg","hash":"458e3dd1a2831d959ac144368c3a6a3581be695b","modified":1613396414307},{"_id":"source/docs/figures/00023.gif","hash":"3c418b7b4e6ed064400557a9d1a473a434647524","modified":1613396414308},{"_id":"source/docs/figures/00024.gif","hash":"4ef7f534c3de7c94759f8bb74067a22e59e38c28","modified":1613396414308},{"_id":"source/docs/figures/00010.jpeg","hash":"2fc2b2c678a8033c26c797e8cbef986bed7a310d","modified":1613396414302},{"_id":"source/docs/figures/00020.jpeg","hash":"0a585568cb937e6bdfbe1b8460b0bdc9a0c21374","modified":1613396414306},{"_id":"public/docs/README.html","hash":"22a8ad09a0b20a17abdfd1407ac7074bc062535b","modified":1613401072950},{"_id":"public/docs/ch21.html","hash":"c0b0e17f569cb49665b54e02a5d42165ed5ff78a","modified":1613401072950},{"_id":"public/docs/ch17.html","hash":"548926a0dcee718ed9c3c8c6b1496830719b1c9c","modified":1613401072950},{"_id":"public/docs/ch8.html","hash":"b90f7422471a078e04941bd794cabe5646eb22eb","modified":1613401072950},{"_id":"public/docs/preface.html","hash":"8c3669f6e6a16dd4919af3b507fddea23baa4415","modified":1613401072950},{"_id":"public/docs/ch1.html","hash":"a24730fd323d6a1f5f1573c7105e5699021dce5a","modified":1613401072950},{"_id":"public/docs/ch16.html","hash":"244f795e254e6cbdcaf73659933463de497a598d","modified":1613401072950},{"_id":"public/docs/ch18.html","hash":"c8560bbe1e3419ac87a36390bd5fb5ed2203afe1","modified":1613401072950},{"_id":"public/docs/ch3.html","hash":"b26b79f8cf6cf9fa89e760fec81665ef691e4e6f","modified":1613401072950},{"_id":"public/docs/ch6.html","hash":"4e56ef7e6694fde46fbb092d53680ce409d8f418","modified":1613401072950},{"_id":"public/docs/ch14.html","hash":"e1adfa2ea0b54744c055f91538fc7d9cc81a1eee","modified":1613401072950},{"_id":"public/docs/ch2.html","hash":"0e53c6232d26208758235470cdea26a751d70a42","modified":1613401072950},{"_id":"public/docs/ch19.html","hash":"ceed2a2e8195fbb26348fffe3a61bb013247a6ec","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch8/index.html","hash":"2fbfd75b8f2ed5865621495f7fc696834b358f2d","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch6/index.html","hash":"b988ef8b5e153f870121ba45facd0917b5690007","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch4/index.html","hash":"ee529d3b6f3facaa4e06608587d9141a91eb8b7c","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch3/index.html","hash":"eddcf7d078dce9c7a70b53b4aff57a7702c8bba7","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch21/index.html","hash":"8abec395a079b54551c9ec2ce5d489bdc5d903b5","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch2/index.html","hash":"328344497db03340665d49be8dcd98dcf65d1fb8","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch19/index.html","hash":"b08d635914dc45d776cf17b6b6d4a8ed9e5721e9","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch18/index.html","hash":"ec8be067da7ca822a250b985008df2511b9d4885","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch14/index.html","hash":"c3021a883935421a6359f142ac6ad113cbeb7350","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch17/index.html","hash":"ff68f587402ed6d45694b1e18114395e92d4a229","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch16/index.html","hash":"a36bf78a112681c0dbb86271398b71e3fcef436d","modified":1613401072950},{"_id":"public/2021/02/15/软件设计的哲学-ch1/index.html","hash":"8608e1eed0245918159a416c17b97615c94ec348","modified":1613401072950},{"_id":"public/archives/page/5/index.html","hash":"44c476c1010fdef2add0d8ea925da091a8860c79","modified":1666443493094},{"_id":"public/archives/2021/index.html","hash":"fcf6d6ac12aa493b73d534cfccfe72e4013b6624","modified":1666443493094},{"_id":"public/archives/2021/02/page/2/index.html","hash":"bbdaa1d0ae9853f56d42171f6d3fa3e659f29629","modified":1666443493094},{"_id":"public/archives/2021/page/2/index.html","hash":"1c7e210ea29457035604ad47923bc9d296699233","modified":1666443493094},{"_id":"public/archives/2021/02/index.html","hash":"6c56db87eebae1f36529e5fbf22a38469402d805","modified":1666443493094},{"_id":"public/page/5/index.html","hash":"cee1fe5af76f4bf171ce46c32df9dc3ef8e4bcc0","modified":1666443493094},{"_id":"public/docs/figures/00009.gif","hash":"e4fdf8dfd7a4cc847df67be738547b9cbc35b213","modified":1613401072950},{"_id":"public/docs/figures/00013.jpeg","hash":"e508f09c005650b16029795bf4e23bbea19ea688","modified":1613401072950},{"_id":"public/docs/figures/00014.gif","hash":"394ccef578e57eafca80c2a2ed971d84dbcb46cf","modified":1613401072950},{"_id":"public/docs/figures/00011.jpeg","hash":"366e71620bf0b6e414ab882f48b7283e5ab275ff","modified":1613401072950},{"_id":"public/docs/figures/00017.gif","hash":"fd10cace9fe5450532f517740e5339559519b2af","modified":1613401072950},{"_id":"public/docs/figures/00018.gif","hash":"389f714db56720278066da71d33969fd1172e560","modified":1613401072950},{"_id":"public/docs/figures/00024.gif","hash":"4ef7f534c3de7c94759f8bb74067a22e59e38c28","modified":1613401072950},{"_id":"public/docs/figures/00023.gif","hash":"3c418b7b4e6ed064400557a9d1a473a434647524","modified":1613401072950},{"_id":"public/docs/figures/00010.jpeg","hash":"2fc2b2c678a8033c26c797e8cbef986bed7a310d","modified":1613401072950},{"_id":"public/docs/figures/00012.jpeg","hash":"2c4f7cdeebab59bad18dc8f8fbbc1a66c96e31aa","modified":1613401072950},{"_id":"public/docs/figures/00015.jpeg","hash":"e1dc4a396ebe3efd1f3b28625c640fbc1d3b3058","modified":1613401072950},{"_id":"public/docs/figures/00016.gif","hash":"e25e16a4c9764cfa23631b00e8a8f6a0ce67015e","modified":1613401072950},{"_id":"public/docs/figures/00019.jpeg","hash":"1413b98934728741b52f4d76da58b6cdccc0ac2c","modified":1613401072950},{"_id":"public/docs/figures/00022.jpeg","hash":"458e3dd1a2831d959ac144368c3a6a3581be695b","modified":1613401072950},{"_id":"public/docs/figures/00021.jpeg","hash":"41a9ce2fa7c53ddbb657ea8dc7817c09391cf4fa","modified":1613401072950},{"_id":"public/docs/figures/00020.jpeg","hash":"0a585568cb937e6bdfbe1b8460b0bdc9a0c21374","modified":1613401072950},{"_id":"public/docs/cover.jpeg","hash":"774c52dab78066e3fb2212da38229e7a2e91941d","modified":1613401072950},{"_id":"public/2021/02/21/软件设计的哲学-ch21/index.html","hash":"53839def8d68d99a7e16786b6550341f40db7de0","modified":1645263167959},{"_id":"public/2021/02/20/软件设计的哲学-ch20/index.html","hash":"82f56438a6ef737a30c4a8d054801279c1f95fce","modified":1645261543533},{"_id":"public/2021/02/19/软件设计的哲学-ch19/index.html","hash":"7aba6d56b49813dc0021fdfdee87163eb5b8ac15","modified":1645261543533},{"_id":"public/2021/02/17/软件设计的哲学-ch17/index.html","hash":"5093187842d0ede6d87bd3befbf618dfe90b7529","modified":1645261543533},{"_id":"public/2021/02/18/软件设计的哲学-ch18/index.html","hash":"ca1f3fa4edb8c38fc18b8313fae9f0941e3ad9ab","modified":1645261543533},{"_id":"public/2021/02/15/软件设计的哲学-ch15/index.html","hash":"6b66404c51c5c7ed2c1e74b1331105aeb355274a","modified":1645261543533},{"_id":"public/2021/02/16/软件设计的哲学-ch16/index.html","hash":"35c9538f0989f64b6600f470ad63ee454f960849","modified":1645261543533},{"_id":"public/2021/02/12/软件设计的哲学-ch12/index.html","hash":"c92ca1ca9ccaa15f69f1f970ce70a48152ef9e45","modified":1645261543533},{"_id":"public/2021/02/14/软件设计的哲学-ch14/index.html","hash":"4edb457e991d14e6d1bae005d6bef0414e003c4e","modified":1645261543533},{"_id":"public/2021/02/13/软件设计的哲学-ch13/index.html","hash":"5a7714c5252e7d3380ef4294f4305743cf1b9dda","modified":1645261543533},{"_id":"public/2021/02/11/软件设计的哲学-ch11/index.html","hash":"25203df9d4f063430c729d65132104fa774e2fb7","modified":1645261543533},{"_id":"public/2021/02/10/软件设计的哲学-ch10/index.html","hash":"997e42f023833d9fc42622616d72845198b284c8","modified":1645261543533},{"_id":"public/2021/02/09/软件设计的哲学-ch9/index.html","hash":"fa40cd053934047efcaf6f75e69410c294a33aa0","modified":1645261543533},{"_id":"public/2021/02/08/软件设计的哲学-ch8/index.html","hash":"6b0a64dc6820357180e71f759fdddd595e13dd43","modified":1645261543533},{"_id":"public/2021/02/07/软件设计的哲学-ch7/index.html","hash":"fb7d327a8eec74e67f06abf8092c90b7fe32a339","modified":1645261543533},{"_id":"public/2021/02/06/软件设计的哲学-ch6/index.html","hash":"64e614448fe7b2fffdfe5ac110853e7f48af9911","modified":1645261543533},{"_id":"public/2021/02/02/软件设计的哲学-ch2/index.html","hash":"da9c7600851ecec2594d6c4a22d5351377b589e8","modified":1645261543533},{"_id":"public/2021/02/05/软件设计的哲学-ch5/index.html","hash":"71021bd3ad6b283b3b1eaa8eedb24b6dae80e600","modified":1645261543533},{"_id":"public/2021/02/04/软件设计的哲学-ch4/index.html","hash":"469f9319a3b28b43c187ef3386406537762a3dd4","modified":1645261543533},{"_id":"public/2021/02/03/软件设计的哲学-ch3/index.html","hash":"9ffb002dd2bad14ea0dd075b728029510e222750","modified":1645261543533},{"_id":"public/2021/02/01/软件设计的哲学-ch1/index.html","hash":"1585e0f294cc58e88f764ec54f1383d6128e1071","modified":1645261543533},{"_id":"public/archives/2021/page/3/index.html","hash":"daa74c476a6f642a4e6c4506f89dce4b2f3dfec1","modified":1666443493094},{"_id":"public/archives/2021/02/page/3/index.html","hash":"490f3192a8a2e4284a40082816f953f23c525f89","modified":1666443493094},{"_id":"public/tags/软件设计的哲学-软件开发-方法论/index.html","hash":"4eacb70b5131e7d179b0eabc439696d25ace9bcd","modified":1666443493094},{"_id":"public/tags/软件设计的哲学-软件开发-方法论/page/2/index.html","hash":"54b5a7fee68e5079e66f7ce09851bb9577a48a7a","modified":1666443493094},{"_id":"public/archives/page/6/index.html","hash":"513319463ccf1fea5e053084a5357f0601da6172","modified":1666443493094},{"_id":"public/page/6/index.html","hash":"774247d3c98dc3a9ba568b4823f769f0c3800c7c","modified":1666443493094},{"_id":"source/_posts/北漂的日子（七）.md","hash":"6c6de8fc41842107a7617ae5606ed7b544b81674","modified":1643562776156},{"_id":"source/_posts/北漂的日子（二）.md","hash":"4833f820c883e58f74814f44392ff5e1126cad45","modified":1643563178244},{"_id":"source/_posts/北漂的日子（一）.md","hash":"234dfd72c06425a231f5f598af84e66c3308f6d0","modified":1643563319456},{"_id":"source/_posts/北漂的日子（九）平凡的一年终于过去了.md","hash":"c41a90f21ca4949dbba5f993b15916c740fb81c3","modified":1643562633601},{"_id":"source/_posts/北漂的日子（五）.md","hash":"4df8871e68f7f093280802aa3c5bc6d492d24077","modified":1643562966873},{"_id":"source/_posts/北漂的日子（八）.md","hash":"d488e72940a8f57305af7ab523df9b10aad530de","modified":1643562707077},{"_id":"source/_posts/北漂的日子（六）.md","hash":"46093042f3fe57b09fbc5babfb2f31e0dbe72664","modified":1643562891200},{"_id":"source/_posts/北漂的日子（十三）致敬2014.md","hash":"6ab7f015386ccbfe115baf3d5412cc38f5d8f78e","modified":1643562454775},{"_id":"source/_posts/北漂的日子（十二）《一句顶一万句》读后感-.md","hash":"055950c433bb1efe5dc3d3d58cf665ba23af1a35","modified":1643562449752},{"_id":"source/_posts/北漂的日子（十一）阴雨天北戴河水鸟.md","hash":"dbf6d549f2c0e58208af8314c8ea808823f018d6","modified":1643562465645},{"_id":"source/_posts/北漂的日子（十四）杂说.md","hash":"b41cd6885040ef1d2a60b8dd318370453913bf65","modified":1643562460413},{"_id":"source/_posts/北漂的日子（十五）写在2022年的尾巴.md","hash":"8162b35f225a595b54d007bb27870796854d8bbd","modified":1645263164834},{"_id":"source/_posts/北漂的日志（三）.md","hash":"2aeeb0ae974b86fcfeb610173286e0e84c8f8749","modified":1643563135800},{"_id":"source/_posts/北漂的日子（四）.md","hash":"2e024d7af873ff7597fffa5bd92513e51c67d4b1","modified":1643563037793},{"_id":"source/_posts/北漂的日子（十）致我们终将逝去的童贞.md","hash":"b02e45e9cb3206397c1b57647a11ed12fd388250","modified":1643562441003},{"_id":"public/2022/01/31/北漂的日子（十五）写在2022年的尾巴/index.html","hash":"a7c4e079711b3985656a630f888d2d0feaa202fe","modified":1645263167959},{"_id":"public/2015/10/29/北漂的日子（十四）杂说/index.html","hash":"7778782ad4bb6b9d352399c5fa6d64a0f4e48682","modified":1645261543533},{"_id":"public/2015/01/09/北漂的日子（十三）致敬2014/index.html","hash":"601b8136e09d98ed349831755369cc89e46d1c92","modified":1645261543533},{"_id":"public/2014/12/21/北漂的日子（十二）《一句顶一万句》读后感-/index.html","hash":"2bcdb51deb06d59f01e69b3908f477b036c6b05f","modified":1645261543533},{"_id":"public/2014/06/22/北漂的日子（十一）阴雨天北戴河水鸟/index.html","hash":"5470d6e362d55b91f355b11b4448adc8c5cb9e43","modified":1645261543533},{"_id":"public/2014/06/01/北漂的日子（十）致我们终将逝去的童贞/index.html","hash":"3924ba63570550154f0ced7eae9f8a9b3ca77344","modified":1645261543533},{"_id":"public/2014/01/04/北漂的日子（九）平凡的一年终于过去了/index.html","hash":"e0f16fb9a8d34b50e3221fc1ff8988e5256b53d0","modified":1645261543533},{"_id":"public/2013/09/02/北漂的日子（八）/index.html","hash":"6de178825ecf19230999c1ed7598e6b461d5d9db","modified":1645261543533},{"_id":"public/2013/04/21/北漂的日子（七）/index.html","hash":"70b05fab38738c5267bfe39d21dbcf49419af3eb","modified":1645261543533},{"_id":"public/2012/11/27/北漂的日子（六）/index.html","hash":"3bd3bdaacca9edada96e645452f5280289812e53","modified":1645261543533},{"_id":"public/2012/11/03/北漂的日子（五）/index.html","hash":"394e95d8f83563b1ad36cc3491701633807c0598","modified":1645261543533},{"_id":"public/2012/10/31/北漂的日子（四）/index.html","hash":"507775e83722c85da87bde4f7c730d66411d5c0c","modified":1645261543533},{"_id":"public/2012/10/23/北漂的日志（三）/index.html","hash":"9b2b4d17b01213db8b9541e46e0b395460ade815","modified":1645261543533},{"_id":"public/2012/08/19/北漂的日子（二）/index.html","hash":"94fc75d9f325e98b4d23e488a61663b0e1acabb3","modified":1645261543533},{"_id":"public/2012/08/19/北漂的日子（一）/index.html","hash":"711770bc894ee878eba54f9a63b03c764bbea153","modified":1645261543533},{"_id":"public/archives/page/7/index.html","hash":"4eb7e705cb6ddad7c3e1366fe32745ad3c3734f5","modified":1666443493094},{"_id":"public/archives/2012/index.html","hash":"b385777bee325794b2da786865463b6690efb1d3","modified":1666443493094},{"_id":"public/archives/2012/08/index.html","hash":"69ecbc8444ad871567ea281eca7d65fb9180e1f6","modified":1666443493094},{"_id":"public/archives/2012/10/index.html","hash":"17fd75e0cd0ab70ad4606154fa7abd205427bd9c","modified":1666443493094},{"_id":"public/archives/2012/11/index.html","hash":"bef6ee8aa98716530b36e74106f5b55a811038bd","modified":1666443493094},{"_id":"public/archives/2013/index.html","hash":"a8a0394f731108edd67a6a3d0d58c75d3f518566","modified":1666443493094},{"_id":"public/archives/2013/04/index.html","hash":"e66137b9dea70c7b8a16a8273b4518d29f2ff4c1","modified":1666443493094},{"_id":"public/archives/2013/09/index.html","hash":"839fd462c59cf1c25d4b85ecbe09858d7e9720a6","modified":1666443493094},{"_id":"public/archives/2014/index.html","hash":"fd2ab3d4bc997e22a4c924c389d5ab3ce3e1d55d","modified":1666443493094},{"_id":"public/archives/2014/01/index.html","hash":"9642bfc39a4889e1dc8f14033101214d70ce7989","modified":1666443493094},{"_id":"public/archives/2014/06/index.html","hash":"0ddba642696fd9029071a29728c998f996ce61a7","modified":1666443493094},{"_id":"public/archives/2014/12/index.html","hash":"2dc907b396f183c60f98b5f2db7ffd0051e6627a","modified":1666443493094},{"_id":"public/archives/2015/index.html","hash":"baf7cf044d4c9f1237884068d65e56ea7e356e5d","modified":1666443493094},{"_id":"public/archives/2015/01/index.html","hash":"fd71c57964bbd41773cd59edc8ec9a7977491e46","modified":1666443493094},{"_id":"public/archives/2015/10/index.html","hash":"f30a72d90e009453fc730b52a7137d5fb18fb9a4","modified":1666443493094},{"_id":"public/archives/2022/index.html","hash":"41c23d64e7b513fbc022adc7bf34779017eee41f","modified":1666443493094},{"_id":"public/archives/2022/01/index.html","hash":"73ebc5a027beb2f6452043dc80a84973bec9f365","modified":1666443493094},{"_id":"public/page/7/index.html","hash":"eb03b17d7698636e611a383cde4d406294921b7e","modified":1666443493094},{"_id":"public/2022/北漂的日子（十五）写在2022年的尾巴/index.html","hash":"18679abf4ff1e3ed11d0c5ba247e8e59c8270247","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch20/index.html","hash":"1465c07cac3e145488165fa3fce2c26cd1284379","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch21/index.html","hash":"4948a05e1b82cc57aae46412b8a073fb9510c5bc","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch19/index.html","hash":"312141470f8b4c8880f64d3328a199f268bb6418","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch18/index.html","hash":"bd0648a88ff52052c17c817fd3534726ea069374","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch17/index.html","hash":"5fdaeb3c6d5a315b7bd9ca7e0de5a75eb68b5156","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch16/index.html","hash":"df37983bff2faba26c1b5c6f811ff2d95a7f854c","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch15/index.html","hash":"b071e16bf7e1fd4963fa6735148be3a697847788","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch14/index.html","hash":"87e71daec5ab5e81150a7f859403c011a85fa77a","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch13/index.html","hash":"02ddbc525c28b13262abc9901edb8660dbb148f4","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch12/index.html","hash":"db5776ec536bf4e494fd1231d839292b99910f0d","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch11/index.html","hash":"1bdcd71a3d39815de5acd5a6459537bdf61db5f2","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch10/index.html","hash":"b1d96985a147ec069a9934a27017c4733cb6010b","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch9/index.html","hash":"beb5b128ec905a6163d178d0ebe0038889405a11","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch8/index.html","hash":"b727a0d9b071fdc9fd9022c1fd8f979906c6f925","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch7/index.html","hash":"df58dca0708b072bda93eb60e449e0bbe940822e","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch6/index.html","hash":"7639ee504299e7ec14a749a957c4cc9b3f50a545","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch5/index.html","hash":"2bdbd4163a21e936ba92401af54af450a40f7ef0","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch4/index.html","hash":"536292a3b128c1b66eaff3a7f15c66cfef8ead7f","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch3/index.html","hash":"94f482ecb0aadf5a52164392f7efeec031f13fe1","modified":1666443493094},{"_id":"public/2020/关于横财/index.html","hash":"5831708d5c4a4451e1bf24ae7e7780b60e379eb4","modified":1666443493094},{"_id":"public/2020/何为领袖之国/index.html","hash":"451e1fb9f3cbe12f45bdc68308defc56ec4b35a1","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch1/index.html","hash":"29aaaa4765615d05d124cf33adcf8ed718a4fc9f","modified":1666443493094},{"_id":"public/2020/江湖/index.html","hash":"e5718357eb34ea30810b376270f83dd403dae8c1","modified":1666443493094},{"_id":"public/2020/学习2/index.html","hash":"d8551b3891a298b2bb90475552cbabade602b64e","modified":1666443493094},{"_id":"public/2020/学习1/index.html","hash":"813d0068b9df70dd6a357d9939ad7ab30e7ee6c0","modified":1666443493094},{"_id":"public/2020/随机与确定的随想/index.html","hash":"73c8bd50a54a054210588f10dd10076dfd4154c5","modified":1666443493094},{"_id":"public/2020/软件兴国/index.html","hash":"0ebfd728801e35b254be7d62847f8f3c8b171a63","modified":1666443493094},{"_id":"public/2020/python之禅/index.html","hash":"12c932dcaa181e32bc74ee70bcafcbdae757d9bb","modified":1666443493094},{"_id":"public/2020/养娃日志2/index.html","hash":"18372b88a312a714e0fe0ab61d7bb652b279de8e","modified":1666443493094},{"_id":"public/2020/一起的一起/index.html","hash":"50e829ea38e556f9832f448c6140ca2c5eb86847","modified":1666443493094},{"_id":"public/2020/indexedDB杂想/index.html","hash":"a930a03048f9423d0af805898edaaeb30241270a","modified":1666443493094},{"_id":"public/2020/20200404/index.html","hash":"d7ee03a1e8b42b12b2fa20714fcbd45d9083a0e8","modified":1666443493094},{"_id":"public/2020/go入门/index.html","hash":"91d1765c5f2cb74d7de14466a20507e0533d9183","modified":1666443493094},{"_id":"public/2020/android手机执行go程序/index.html","hash":"d1e6a7182663a60a632a16aadd2a723c456fd6ba","modified":1666443493094},{"_id":"public/2020/EventBus源码解析(一)/index.html","hash":"60e1a6cbeff4ad3fd9dccf4a286864e4255e4fca","modified":1666443493094},{"_id":"public/2020/发票的半自动填写/index.html","hash":"a105d05001c8e404dc9b43cb36c0648aee98f58d","modified":1666443493094},{"_id":"public/2020/shell学习: 提取文本，升级版本号/index.html","hash":"7f0d99d5f8e0ab531a875d5a80e066badeec3a0d","modified":1666443493094},{"_id":"public/2020/机会来的时候，你准备好了吗/index.html","hash":"e5ecd457cee5f6cbf5f46bf1aea20ddcb04bf9ae","modified":1666443493094},{"_id":"public/2020/git服务器搭建/index.html","hash":"0c823b1689c2ca7e4b32ca8416a3b0f134de2ee0","modified":1666443493094},{"_id":"public/2020/mac下解压报22错误/index.html","hash":"8aff201e9377f242cfc45fc905aad3ec2b610035","modified":1666443493094},{"_id":"public/2021/软件设计的哲学-ch2/index.html","hash":"326770c79c66d83cc40750e4b94ebeb417f49c2a","modified":1666443493094},{"_id":"public/2020/nginx/index.html","hash":"811750c5fc4312f9da272269ce305d38d2d6a55e","modified":1666443493094},{"_id":"public/2020/我的扛疫/index.html","hash":"8e6460dac08da4a54d1f8ef8aead2904b10cddd4","modified":1666443493094},{"_id":"public/2020/shell学习/index.html","hash":"665622dbe475e806b328e2883e0f09c48258480a","modified":1666443493094},{"_id":"public/2020/公式相声之浅见/index.html","hash":"596df31e992209596179a042d0008042823423cf","modified":1666443493094},{"_id":"public/2017/管理学效应/index.html","hash":"bd2a7dbef0d376f8308f8dccc994cc656616f7f4","modified":1666443493094},{"_id":"public/2017/养娃日志1/index.html","hash":"93a850ee75e3f41ebd2c1bb51145bec0ceece02f","modified":1666443493094},{"_id":"public/2017/如何选择一个看起来更松快的车厢/index.html","hash":"8758f43d45edac4bcfa9cc49279e58e98b8b0a7e","modified":1666443493094},{"_id":"public/2017/常见的心理学效应/index.html","hash":"a0bcd8834aa13af7342565a016d848a84db87fad","modified":1666443493094},{"_id":"public/2017/周报/index.html","hash":"ec12ff732b2f060be4cecaca3ec13ade3afefe95","modified":1666443493094},{"_id":"public/2017/技术demo/index.html","hash":"2d49d901aa46c3960e31077f071c48086feeccf3","modified":1666443493094},{"_id":"public/2015/北漂的日子（十四）杂说/index.html","hash":"940be5f2229fabd9c70fe22228ed27be56e69ac2","modified":1666443493094},{"_id":"public/2015/北漂的日子（十三）致敬2014/index.html","hash":"fff3931b2b1ccc6dfb8ebec7add112d3c1f6eddc","modified":1666443493094},{"_id":"public/2014/北漂的日子（十一）阴雨天北戴河水鸟/index.html","hash":"fa5810920203dbe6ce78523869ba5ea705dc876c","modified":1666443493094},{"_id":"public/2014/北漂的日子（十二）《一句顶一万句》读后感-/index.html","hash":"4196b3d7a95d94892da4406003943baac8e93a23","modified":1666443493094},{"_id":"public/2014/北漂的日子（九）平凡的一年终于过去了/index.html","hash":"fb0c72bda82268fc0277b5b373147cccc1698e4f","modified":1666443493094},{"_id":"public/2013/北漂的日子（八）/index.html","hash":"99aa27d177e467a1163cb2cd85c769d674f8d0c9","modified":1666443493094},{"_id":"public/2012/北漂的日子（六）/index.html","hash":"9038fca04b260ea822eef72a45044d7349c9d2c9","modified":1666443493094},{"_id":"public/2012/北漂的日子（五）/index.html","hash":"26c446285de5224f2768098e792c6741d8166430","modified":1666443493094},{"_id":"public/2012/北漂的日子（四）/index.html","hash":"40b9d73f524c669a3469347be2d4637a4a444355","modified":1666443493094},{"_id":"public/2013/北漂的日子（七）/index.html","hash":"b801fb2fc0a310c399413ac8082d47e9340e5784","modified":1666443493094},{"_id":"public/2012/北漂的日志（三）/index.html","hash":"c17374ba550ea8df1d613828bd4383b37adc6de7","modified":1666443493094},{"_id":"public/2012/北漂的日子（二）/index.html","hash":"5e1a67454988265b0752949bddc01cec8b9b7ef7","modified":1666443493094},{"_id":"public/2012/北漂的日子（一）/index.html","hash":"51a0807ea34eef277fc910d86f211d5cbbae3544","modified":1666443493094},{"_id":"public/2017/活在当下/index.html","hash":"637a89ab306d76687fa9c453c1445f1435852886","modified":1666443493094},{"_id":"public/2014/北漂的日子（十）致我们终将逝去的童贞/index.html","hash":"6d3a9a7c89389cbc2c472a2b74eb4e02e9dcc1c8","modified":1666443493094},{"_id":"source/_posts/2022清明组诗.md","hash":"334d12703c95b002aa7c7edfaae85b4cc4ebc782","modified":1649166542475},{"_id":"public/2022/2022清明组诗/index.html","hash":"026b8d8c7b3555acbc96f63138cdb44e4319dd70","modified":1666443493094},{"_id":"public/archives/2022/04/index.html","hash":"dce1a30485694bc5ea2e720e70a2e3f725ea7985","modified":1666443493094},{"_id":"source/_posts/重读《赢在中国》.md","hash":"4e33090b77d4152f71359a7339b263de8da8682a","modified":1665893707628},{"_id":"public/2022/重读《赢在中国》/index.html","hash":"39c35723e9d62c7ad56cb8dbeba8376b822de0f3","modified":1666443493094},{"_id":"public/archives/2022/10/index.html","hash":"b73a12ca37b16f011c9479e876c9ec1ce192e245","modified":1666443493094},{"_id":"public/tags/学习笔记-思考总结/index.html","hash":"f2b4b8f8e0c42f58092771ee2f55af5b5330071b","modified":1666443493094},{"_id":"source/_posts/立场.md","hash":"b1752f6b7cb17bec6d7408599b26bec1b6a16985","modified":1665935280411},{"_id":"public/2022/立场/index.html","hash":"ce11b49be739e7be63d1f578ead52a6ef3d6e0a1","modified":1666443493094},{"_id":"public/tags/思考-感悟/index.html","hash":"d5e85650573a62c0220de9174d8b727f3546fc5f","modified":1666443493094},{"_id":"source/_posts/常见javascript解析器.md","hash":"655b813539237b02579e657ffd1bf32c1cbf8c28","modified":1666440601733},{"_id":"public/2022/常见javascript解析器/index.html","hash":"8f5413f766e91ffcf7d36c01a5fe3d4939dfaa44","modified":1666443493094},{"_id":"public/archives/page/8/index.html","hash":"264e151f3628b88cfcbf450bbb7dc434c2ccce2a","modified":1666443493094},{"_id":"public/page/8/index.html","hash":"1cf5b3844ef2549c87578ea7c436c1a9ea8396e7","modified":1666443493094},{"_id":"public/tags/技术汇总/index.html","hash":"cf71e62ceef42a65779dbeb688a3f9ab3e09e956","modified":1666443493094}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"如何选择一个看起来更松快的车厢","date":"2017-09-26T16:00:00.000Z","_content":"晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。\n<!-- more -->\n晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。\n\n\n4号线的地铁是6节车厢，如果你注意观察，不同的车厢的拥挤程度不同，一般的，靠近楼梯的车厢更拥挤些，边上的车厢稍稍松快些，每站的停车时间大概是90s，如果你在车站的中间位置，你如何选择去一个看起来更松快的车厢呢？\n\n注意，北京4号线地铁的车厢标准\n是B型车,车长19米，车宽2.8面, 面积53.2平方米，如果按照每人占0.2平方米，定员230~245人；拥挤时，平均每人大概0.1平方米，每节车厢人数在500人左右。\n\n设想一下可能的方案：\n\n每个车站可能会有自己的人流乘车特点，这个拿不到数据，不好判断。\n根据每节车厢进站时，人流进出的图像，识别出车厢的拥挤程度，使车厢上的灯显示不同的颜色，此时为未进车的人可以根据此判断自己要去那个车厢。\n专属车厢，最近广州地铁推出女性车厢，算是一个办法。\n每个车厢走一遍，看哪个松快，这个需要使用2分法。站在中间，看哪边人少，那边人少，就冲哪边。不过这要计算好你的步行速度\n\b选择合适的时间，在合适的\b时间，列表是刚过始发站，或不是上班高峰\n选择排队候车人数最少的车厢\n选择离楼梯最远的车厢\n根据自己的经验判断的车厢\n随机\b选择一个车厢\n\b选择最好出站的车厢\n选择美女或者帅哥少的的车厢\n选择根据乘客下一站上车少，下车多，比如下一站北京南站，就选择\b行李箱多的\b的那个车厢，（根据未来的预期，选择现在的占位）\n….\n其实通过AI和图像识别技术，可以\b计算和预估车厢的拥挤程度，避免有些车厢拥挤，而有些车险零星几个乘客的情况。这个有木有充满想象力？我想未来一定可以实现，立此博以证。","source":"_posts/如何选择一个看起来更松快的车厢.md","raw":"---\ntitle: 如何选择一个看起来更松快的车厢\ndate: 2017-09-27\n---\n晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。\n<!-- more -->\n晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。\n\n\n4号线的地铁是6节车厢，如果你注意观察，不同的车厢的拥挤程度不同，一般的，靠近楼梯的车厢更拥挤些，边上的车厢稍稍松快些，每站的停车时间大概是90s，如果你在车站的中间位置，你如何选择去一个看起来更松快的车厢呢？\n\n注意，北京4号线地铁的车厢标准\n是B型车,车长19米，车宽2.8面, 面积53.2平方米，如果按照每人占0.2平方米，定员230~245人；拥挤时，平均每人大概0.1平方米，每节车厢人数在500人左右。\n\n设想一下可能的方案：\n\n每个车站可能会有自己的人流乘车特点，这个拿不到数据，不好判断。\n根据每节车厢进站时，人流进出的图像，识别出车厢的拥挤程度，使车厢上的灯显示不同的颜色，此时为未进车的人可以根据此判断自己要去那个车厢。\n专属车厢，最近广州地铁推出女性车厢，算是一个办法。\n每个车厢走一遍，看哪个松快，这个需要使用2分法。站在中间，看哪边人少，那边人少，就冲哪边。不过这要计算好你的步行速度\n\b选择合适的时间，在合适的\b时间，列表是刚过始发站，或不是上班高峰\n选择排队候车人数最少的车厢\n选择离楼梯最远的车厢\n根据自己的经验判断的车厢\n随机\b选择一个车厢\n\b选择最好出站的车厢\n选择美女或者帅哥少的的车厢\n选择根据乘客下一站上车少，下车多，比如下一站北京南站，就选择\b行李箱多的\b的那个车厢，（根据未来的预期，选择现在的占位）\n….\n其实通过AI和图像识别技术，可以\b计算和预估车厢的拥挤程度，避免有些车厢拥挤，而有些车险零星几个乘客的情况。这个有木有充满想象力？我想未来一定可以实现，立此博以证。","slug":"如何选择一个看起来更松快的车厢","published":1,"updated":"2020-01-29T06:52:45.539Z","_id":"ck5xwo6wk0000m7iyaq3e64ie","comments":1,"layout":"post","photos":[],"link":"","content":"<p>晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。</p>\n<a id=\"more\"></a>\n<p>晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。</p>\n<p>4号线的地铁是6节车厢，如果你注意观察，不同的车厢的拥挤程度不同，一般的，靠近楼梯的车厢更拥挤些，边上的车厢稍稍松快些，每站的停车时间大概是90s，如果你在车站的中间位置，你如何选择去一个看起来更松快的车厢呢？</p>\n<p>注意，北京4号线地铁的车厢标准<br>是B型车,车长19米，车宽2.8面, 面积53.2平方米，如果按照每人占0.2平方米，定员230~245人；拥挤时，平均每人大概0.1平方米，每节车厢人数在500人左右。</p>\n<p>设想一下可能的方案：</p>\n<p>每个车站可能会有自己的人流乘车特点，这个拿不到数据，不好判断。<br>根据每节车厢进站时，人流进出的图像，识别出车厢的拥挤程度，使车厢上的灯显示不同的颜色，此时为未进车的人可以根据此判断自己要去那个车厢。<br>专属车厢，最近广州地铁推出女性车厢，算是一个办法。<br>每个车厢走一遍，看哪个松快，这个需要使用2分法。站在中间，看哪边人少，那边人少，就冲哪边。不过这要计算好你的步行速度<br>\b选择合适的时间，在合适的\b时间，列表是刚过始发站，或不是上班高峰<br>选择排队候车人数最少的车厢<br>选择离楼梯最远的车厢<br>根据自己的经验判断的车厢<br>随机\b选择一个车厢<br>\b选择最好出站的车厢<br>选择美女或者帅哥少的的车厢<br>选择根据乘客下一站上车少，下车多，比如下一站北京南站，就选择\b行李箱多的\b的那个车厢，（根据未来的预期，选择现在的占位）<br>….<br>其实通过AI和图像识别技术，可以\b计算和预估车厢的拥挤程度，避免有些车厢拥挤，而有些车险零星几个乘客的情况。这个有木有充满想象力？我想未来一定可以实现，立此博以证。</p>\n","site":{"data":{}},"excerpt":"<p>晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。</p>","more":"<p>晚上10点半，从宣武门到角门西的地铁里仍然拥挤不堪，这个点的4号线车到天宫院的是隔次列车，拥挤些也不奇怪。城区内的房租年年都要涨，越来越多的人选择子在丰台南部、大兴，燕郊那边租房居住，城内上班城外住，似乎已经成为工薪阶层的潮流。</p>\n<p>4号线的地铁是6节车厢，如果你注意观察，不同的车厢的拥挤程度不同，一般的，靠近楼梯的车厢更拥挤些，边上的车厢稍稍松快些，每站的停车时间大概是90s，如果你在车站的中间位置，你如何选择去一个看起来更松快的车厢呢？</p>\n<p>注意，北京4号线地铁的车厢标准<br>是B型车,车长19米，车宽2.8面, 面积53.2平方米，如果按照每人占0.2平方米，定员230~245人；拥挤时，平均每人大概0.1平方米，每节车厢人数在500人左右。</p>\n<p>设想一下可能的方案：</p>\n<p>每个车站可能会有自己的人流乘车特点，这个拿不到数据，不好判断。<br>根据每节车厢进站时，人流进出的图像，识别出车厢的拥挤程度，使车厢上的灯显示不同的颜色，此时为未进车的人可以根据此判断自己要去那个车厢。<br>专属车厢，最近广州地铁推出女性车厢，算是一个办法。<br>每个车厢走一遍，看哪个松快，这个需要使用2分法。站在中间，看哪边人少，那边人少，就冲哪边。不过这要计算好你的步行速度<br>\b选择合适的时间，在合适的\b时间，列表是刚过始发站，或不是上班高峰<br>选择排队候车人数最少的车厢<br>选择离楼梯最远的车厢<br>根据自己的经验判断的车厢<br>随机\b选择一个车厢<br>\b选择最好出站的车厢<br>选择美女或者帅哥少的的车厢<br>选择根据乘客下一站上车少，下车多，比如下一站北京南站，就选择\b行李箱多的\b的那个车厢，（根据未来的预期，选择现在的占位）<br>….<br>其实通过AI和图像识别技术，可以\b计算和预估车厢的拥挤程度，避免有些车厢拥挤，而有些车险零星几个乘客的情况。这个有木有充满想象力？我想未来一定可以实现，立此博以证。</p>"},{"title":"常见的心理学效应","date":"2017-09-26T16:00:00.000Z","_content":"常见的心理学效应，每天学习一下，站在更高一点的位置看人的行为，会让我们活的更通透一些。\n<!-- more -->\n\n# 承诺定律\n承诺未必可以保证一定做到，但是如果你没有做出承诺，就算你做到了也没有价值。​\n\n# 苹果定律\n如果有一堆苹果，有好有坏，你就应该先吃好的，把坏的令人扔掉，如果你先吃坏的，好的也会变坏，你将永远吃不到好的苹果，人生亦如此。\n\n# 价值定律\n当你拥有一项东西的时候，你就会发现这种东西并不像你原来所想的那样有价值。\n\n# 酝酿效应\n在古希腊，国王让人做了一顶纯金的王冠，但他又怀疑工匠在王冠中掺了银子。可问题是这顶王冠与当初交给金匠的一样重，谁也不知道金匠到底有没有捣鬼。国王把这个难题交给了阿基米德。阿基米德为了解决这个问题冥思苦想,他起初尝试了很多想法，但都失败了。有一天他去洗澡，一边他一边坐进澡盆，以便看到水往外溢，同时感觉身体被轻轻地托起，他突然恍然大悟，运用浮力原理解决了问题。不管是科学家还是一般人，在解决问题的过程中，我们都可以发现“把难题放在一边，放上一段时间，才能得到满意的答案”这一现象。心理学家将其称为“酝酿效应”。阿基米德发现浮力定律就是酝酿效应的经典故事。日常生活中，我们常常会对一个难题束手无策，不知从何入手，这时思维就进入了“酝酿阶段”。直到有一天，当我们抛开面前的问题去做其他的事情时，百思不得其解的答案却突然出现在我们面前，令我们忍不住发出类似阿基米德的惊叹，这时，“酝酿效应”就绽开了“思维之花”，结出了“答案之果”。古代诗词说“山重水复疑无路，柳暗花明又一村”正是这一心理的写照。 心理学家认为，酝酿过程中，存在潜在的意识层面推理，储存在记忆里的相关信息在潜意识里组合，人们之所以在休息的时候突然找到答案，是因为个体消除了前期的心理紧张，忘记了个体前面不正确的、导致僵局的思路，具有了创造性的思维状态。因此，如果你面临一个难题，不妨先把它放在一边，去和朋友散步、喝茶，或许答案真的会“踏破铁鞋无觅处，得来全不费功夫”。\n\n# 阿伦森效应\n是指人们最喜欢那些对自己的喜欢、奖励、赞扬不断增加的人或物，最不喜欢那些显得不断减少的人或物。心理学家做过一个实验,分4组人对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒。结果此实验对数十人进行过后，发现绝大部分人对第四组最具好感，而对第三组最为反感。阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。同样，它也提醒我们在形成对别人的印象过程中，要避免受它的影响而形成错误的态度。有个案例说道: 在宿舍楼的后面，停放着一部烂汽车，大院里的孩子们每当晚上7点时，便攀上车厢蹦跳，嘭嘭之声震耳欲聋，大人们越管，众孩童蹦得越欢，见者无奈。这天，一个人对孩子们说：“小朋友们，今晚你们比赛，蹦得最响的奖玩具手枪一支。”众童呜呼雀跃，争相蹦跳，优者果然得奖。次日，这位朋友又来到车前，说：“今天继续比赛，奖品为两粒奶糖。”众童见奖品直线下跌，纷纷不悦，无人卖力蹦跳，声音疏稀而弱小。第三天，朋友又对孩子们言：“今日奖品为花生米二粒。”众童纷纷跳下汽车，皆说：“不蹦了，不蹦了，真没意思，回家看电视了。” 在“正面难攻”的情况下，采用“奖励递减法”可起到奇妙心理效应。\n又有个案例说道: 小刚大学毕业后分到一个单位工作，刚一进单位，他决心好好地积极表现一番，以给领导和同事们留下非常好的第一印象。于是，他每天提前到单位打水扫地，节假日主动要求加班，领导布置的任务有些他明明有很大的困难，也硬着头皮一概承揽下来。本来，刚刚走上工作岗位的青年人积极表现一下自我是无可厚议的。但问题是小刚的此时表现与其真正的思想觉悟、为人处世的一贯态度和行为模式相差甚远，夹杂着“过分表演”的成分。因而就难以有长久的坚持性。没过多久，小刚水也不打了，地也不拖了，还经常迟到，对领导布置的任务更是挑肥拣瘦。结果，领导和同事们对他的印象由好转坏，甚至比那些刚开始来的时候表现不佳的青年所持的印象还不好。因为大家对他已有了一个“高期待、高标准”，另外，大家认为他刚开始的积极表现是“装假”，而“诚实”是我们社会评定一个人所运用的“核心品质”。\n\n# 巴霖效应\n源自于马戏团经理巴霖先生的一句名言：每分钟都有一名笨蛋诞生。”巴霖效应” 多少解释了为什么有些星座或生肖书刊能够”准确的”指出某人的性格。原因在此,那些用来描述性格的词句,其实根本属”人之常情”或基本上适用于大部分人身上的。换言之,那些词句的适用范围是如此的空泛，以至往往”说了等于没说。例如:水瓶座理性而爱好自由，巨蟹座感性而富爱心；然而巨蟹座的人就永远没理性，水瓶座的人就缺乏爱心吗？我们不去否定星座存在的价值，毕竟它存有统计的基础在。但如果你想成为一个聪明人，不去迷信星座，我又得告诉你，你又错了！知道什么叫做”天醉人亦醉”吗?既然身旁有超过半数的人相信星座，你又何苦试着去推翻那根植于心的观念(实际上也不太可能)? 如果一对情侣在星座学中是不甚相配的，即使两人都不迷信，但他们的心理必然会承受一股不小的压力，在往后交往的时间中，若有了冲突磨擦，心中既存的那种”原来真的不合适”的预设就会被强迫成立，最终难逃分手命运!巴霖效应与巴纳姆效应相同, 巴纳姆效应是由心理学家伯特伦·福勒于1948年通过试验证明的一种心理学现象，它主要表现为：每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，他仍然认为反映了自己的人格面貌。而要避免巴纳姆效应，就应客观真实地认识自己。\n\n# 半途效应\n半途效应是指在激励过程中达到半途时，由于心理因素及环境因素的交互作用而导致的对于目标行为的一种负面影响。大量的事实表明，人的目标行为的中止期多发生在”半途”附近，在人的目标行为过程的中点附近是一个极其敏感和极其脆弱的活跃区域。导致半途效应的原因主要有两个，一是目标选择的合理性，目标选择的越不合理越容易出现半途效应；二是个人的意志力，意志力越弱的人越容易出现半途效应。这就要求班主任在平时教育学生时多注意学习各方面的知识，培养多方面的能力，同时多注意进行意志力的磨练。行为学家提出了”大目标、小步子”的方法，对于防止半途效应的发生具有积极的意义。\n\n# 比马龙效应\n评价主体低估被评价者能力，认定被评价者是不求上进的、行为差劲的，以致被评价者将这种观念内化，促使被评价者表现不良行为。你有过这样的经历吗？本来穿了一件自认为是很漂亮的衣服去上班，结果好几个同事都说不好看，当第一个同事说的时候，你可能还觉得只是她的个人看法，但是说的人多了，你就慢慢开始怀疑自己的判断力和审美眼光了，于是到了下班后，你回家做的第一件事情就是把衣服换下来，并且决定再也不穿它去上班了。又比如, 如果家长们一直对自己的孩子说你为什么这么笨啊, 久而久之, 这个孩子就会潜移默化地以为自己很笨. 其实，这只是心理暗示在起作用。暗示作用往往会使别人不自觉地按照一定的方式行动，或者不加批判地接受一定的意见或信念。可见，暗示在本质上，是人的情感和观念，会不同程度地受到别人下意识的影响。\n\n# 边际效应\n有时也称为边际贡献，是指消费者在逐次增加1个单位消费品的时候，带来的单位效用是逐渐递减的（虽然带来的总效用仍然是增加的）。\n\n举一个通俗的例子，当你肚子很饿的时候，有人给你拿来一笼包子，那你一定感觉吃第一个包子的感觉是最好的，吃的越多，单个包子给你带来的满足感就越小，直到你吃撑了，那其它的包子已经起不到任何效用了。边际效应的应用非常广泛，例如经济学上的需求法则就是以此为依据，即：用户购买或使用商品数量越多，则其愿为单位商品支付的成本越低（因为后购买的商品对其带来的效用降低了）。当然也有少数例外情况，例如嗜酒如命的人，是越喝越高兴，或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。了解边际效应的概念，你就可以尝试去在实际生活中运用它，例如：你是公司管理层，要给员工涨工资，给 3K 月薪的人增加 1K 带来的效应一般来说是比 6K 月薪增加 1K 大的，可能和 6K 月薪的人增加 2K 的相当，所以似乎给低收入的人增加月薪更对公司有利；另外，经常靠增加薪水来维持员工的工作热情看来也是不行的，第一次涨薪 1K 后，员工非常激动，大大增加了工作热情；第二次涨薪 1K，很激动，增加了一些工作热情；第三次涨薪 2K ，有点激动，可能增加工作热情；第四次 … … ，直至涨薪已经带来不了任何效果。如果想避免这种情况，每次涨薪都想达到和第一次涨薪 1K 相同的效果，则第二次涨薪可能需要 2K ，第三次需要 3K … … ，或者使用其它激励措施，例如第二次可以安排其参加职业发展培训，第三次可以对其在职位上进行提升，虽然花费可能想当，但由于手段不同，达到了更好的效果。研究经济学其实也很有意思，只是对很多人来说，与 IT 这个行业不可完全兼得。\n\n1). 边际效应递减:边际效益递减是经济学的一个基本概念，它说的是在一个以资源作为投入的企业，单位资源投入对产品产出的效用是不断递减的，换句话，就是虽然其产出总量是递增的，但是其二阶倒数为负，使得其增长速度不断变慢，使得其最终趋于峰值，并有可能衰退。最明显的诠释，就是非线性函数，例如二次曲线。在生活中，我们可以看到许多例子：给你一个可爱多，你高兴的乱跳以为赚了，接下来是第二个……可是一直给你，你会觉得开始恶心了。这有两个原因：一，你吃饱 了，生理不需要了，二，你吃腻了，刺激受够了。你希望有个机会表白自己“老大，给个哈根啊好啊？”\n\n所谓的新官上任三把火，讲的也是这个道理：刚来了要混个脸熟，所以拼尽全力在所不辞。日子一久，也就澹了。一般的教材会这样解释：神秘莫测的心理学和社会 学。我们可以想想，边际效用递减式一个无处不在的规律，你想过四级，于是找了本宝书，从A背起，不错，一会儿就背完 呢（当然，本来A就不太多，我就是这种人），然后是B，然后是……B part2，然后是B part 2 1/2…级数的概念有了应用。当然你可以选择从Z开始背回头（当然，我也是这种人）。 可见，投入和产出是相同的概念，由于投入了就要求有产出，所以边际效益递减的逆仍然适用。 我们可以拓展到离开效用这个概念。让我们看一个实际中的问题： 昨天打扫房间卫生，发现刚刚擦过的桌子一层灰又上去了，和旁边的一个小支架看上去没什么区别。实际上，后者上次被美容的时候我还没在南京…… 一个东西从干净到涨很快，可是从脏到很脏是一个多么漫长的过程阿，指望考古队？（尽管也有评价的因素） 大家还可以想到很多很多，比如，人文一点，“失去的才是真”。\n\n我们如何利用这个规律呢？经济学的解释是资源的最优配置。因为投入的太多使得 最终的收益摊的太薄。再好的东西也有个限度。理工科的更加清楚，所谓的各种高级操作都是某种程度上的吃力不讨好，最有效的往往是那些基本操作。更高深的是 当然一些数学上的游戏。 然而我觉得，这个现象的起源绝对是一个哲学问题，那就是我们为什么进步和发展。 想想，如果边际效益递增，我们还需要创新吗？我们还需要坚持吗？同志们，可爱多足够了，不，凉水就行！魅力这个词，永远的就失去了意义。\n\n2). 边际效应递增: 有时候边际效应有时候也是递增的。当然也有少数例外情况，例如嗜酒如命的人，越喝越高兴，或者吸毒的人，越吸越想吸。或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。​\n\n# 超限效应\n美国着名幽默作家马克·吐温有一次在教堂听牧师演讲。最初，他觉得牧师讲得很好，使人感动，准备捐款。过了10分钟，牧师还没有讲完，他有些不耐烦了，决定只捐一些零钱。又过了10分钟，牧师还没有讲完，于是他决定，1分钱也不捐。到牧师终于结束了冗长的演讲，开始募捐时，马克·吐温由于气愤，不仅未捐钱，还从盘子里偷了2元钱。 这种刺激过多、过强和作用时间过久而引起心理极不耐烦或反抗的心理现象，称之为“超限效应”。 超限效应在家庭教育中时常发生。如：当孩子不用心而没考好时，父母会一次、两次、三次，甚至四次、五次重复对一件事作同样的批评，使孩子从内疚不安到不耐烦最后反感讨厌。被“逼急”了，就会出现“我偏要这样”的反抗心理和行为。 因为孩子一旦受到批评，总需要一段时间才能恢复心理平衡，受到重复批评时，他心里会嘀咕：“怎么老这样对我？”孩子挨批评的心情就无法复归平静，反抗心理就高亢起来。 可见，家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果非要再次批评，那也不应简单地重复，要换个角度，换种说法。这样，孩子才不会觉得同样的错误被“揪住不放”，厌烦心理、逆反心理也会随之减低。\n\n# 拆屋效应\n鲁迅先生曾于1927年在《无声的中国》一文中写下了这样一段文字：”中国人的性情总是喜欢调和、折中的，譬如你说，这屋子太暗，说在这里开一个天窗，大家一定是不允许的，但如果你主张拆掉屋顶，他们就会来调和，愿意开天窗了。”这种先提出很大的要求，接着提出较小较少的要求，在心理学上被称为”拆屋效应”。虽然这一效应在XXXXX生活中多见，但也有不少学生学会了这些。如有的学生犯了错误后离家出走，班主任很着急，过了几天学生安全回来后，班主任反倒不再过多地去追究学生的错误了。实际上在这里，离家出走相当于”拆屋”，犯了错误相当于”开天窗”，用的就是拆屋效应。因此，班主任在教育学生的过程中，教育方法一定要恰当，能被学生所接受，同时，对学生的不合理要求或不良的行为绝不能迁就，特别要注意不能让学生在这些方面养成与班主任讨价还价的习惯。\n\n# 刺猬法则\n刺猬法则可以用这样一个有趣的现象来形象地说明：两只困倦的刺猬由于寒冷而拥在一起，可怎么也睡不舒服，因为各自身上都长着刺，紧挨在一块，反而无法睡得安宁。几经折腾，两只刺猬拉开距离，尽管外面寒风呼呼，可它们却睡得甜乎乎的。刺猬法则就是人际交往中的“心理距离效应”。管理心理学专家的研究认为：领导者要搞好工作应该与下属保持亲密关系，但这是“亲密有间”的关系。特别要提醒的是，领导者与下属亲密无间地相处，还容易导致彼此称兄道弟、吃喝不分，并在工作中丧失原则。\n\n# 从众效应\n有一个成语叫做三人成虎，意思是说，有三个人谎报市上有老虎，听者就信以为真。这种人在社会群体中容易不加分析地接受大多数人认同的观点或行为的心理倾向被称为从众效应。这一效应的启示是：班主任要善于发挥从众效应的积极作用，首先要有意识地通过班会、黑板报等舆论阵地大张旗鼓地进行宣传；其次，要抓好班团干部和积极分子等基本队伍的建设，组成坚强的堡垒，要及时发现班上的不良倾向，对症下药，将其遏制在萌芽状态，以防止产生从众效应的负作用。 从众效应是指在群体活动中，当个人与多数人的意见和行为不一致时，个人放弃自己的意见和行为，表现出与群体中多数人相一致的意见和行为方式的现象。从众也就是我们日常俗语中所说的“随大流”。 促使一个人在合作中产生从众行为的因素有多种，一般认为主要有：小组里有较优势的学生存在；个性特质如智力的低、胆小、顾虑多、意志不坚定、自信心差、过于重视他人并依赖他人者等；小组人数的规模等因素。 毋庸质疑，从众有利于形成统一的小组意见，合理的小组环境可以促进或潜移默化地使落后的小组成员形成正确的思想与行为。同时，应该指出，在不合理的小组环境里，由于从众效应表现为趋向学习结论一致，而不一定是学习结论正确；部分学生容易与自信或学习优秀的小组成员的观点、思维方法形成一致，而忽视自己地观点、思维方法正确与否，小组合作的结果可能是以虚假的多数形成错误的小组结论。可见，从众效应容易压制正确思想的形成，窒息小组成员的独创精神；合作学习有时有弱化独立思考的趋势，个体在群体中容易丧失了对自我的控制，失去了个体感，使人“人云亦云”。我们需要的\n\n# 淬火效应\n金属工件加热到一定温度后，浸入冷却剂(油、水等)中，经过冷却处理，工件的性能更好、更稳定。长期受表扬头脑有些发热的学生，不妨设置一点小小的障碍，施以“挫折教育”，几经锻炼，其心理会更趋成熟，心理承受能力会更强；对于麻烦事或者已经激化的矛盾，不妨采用“冷处理”，放一段时间，思考得会更周全，办法会更稳妥。\n\n# 得寸进尺效应\n美国社会心理学家弗里得曼做了一个有趣的实验：他让助手去访问一些家庭主妇，请求被访问者答应将一个小招牌挂在窗户上，她们答应了。过了半个月，实验者再次登门，要求将一个大招牌放在庭院内，这个牌子不仅大，而且很不美观。同时，实验者也向以前没有放过小招牌的家庭主妇提出同样的要求。结果前者有55%的人同意，而后者只有不到17%的人同意，前者比后者高3倍。后来人们把这种心理现象叫作“得寸进尺效应”。心理学认为，人的每个意志行动都有行动的最初目标，在许多场合下，由于人的动机是复杂的，人常常面临各种不同目标的比较、权衡和选择，在相同情况下，那些简单容易的目标容易让人接受。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会继续下去。上述心理效应告诉我们，要让他人接受一个很大的、甚至是很难的要求时，最好先让他接受一个小要求，一旦他接受了这个小要求，他就比较容易接受更高的要求。差生作为一个特殊群体，其身心素质和学习基础等方面都低于一般水平。转化差生，也要像弗里得曼一样善于引导，善于“搭梯子”，使之逐渐转化；应贯彻“小步子、低台阶、勤帮助、多照应”的原则，注意“梯子”依靠的地方要正确、间距不宜太大、太陡，做到扶一扶“梯子”，托一托人。\n\n# 定势效应\n有一个农夫丢失了一把斧头，怀疑是邻居的儿子偷盗，于是观察他走路的样子，脸上的表情，感到言行举止就像偷斧头的贼。后来农夫找到了丢失的斧头，他再看邻居的儿子，竟觉得言行举止中没有一点偷斧头的模样了。这则故事描述了农夫在心理定势作用下的心理活动过程。所谓心理定势是指人们在认知活动中用“老眼光”——已有的知识经验来看待当前的问题的一种心理反应倾向，也叫思维定势或心向。在人际交往中，定势效应表现在人们用一种固定化了的人物形象去认知他人。例如：我们与老年人交往中，我们会认为他们思想僵化，墨守成规，跟不上时代；而他们则会认为我们年纪轻轻，缺乏经验，“嘴巴无毛，办事不牢”。与同学相处时，我们会认为诚实的人始终不会说谎；而一旦我们认为某个人老奸巨猾，既使他对你表示好感，你也会认为这是“黄鼠狼给鸡拜年没安好心”。 心理定势效应常常会导致偏见和成见，阻碍我们正确地认知他人。所以我们要“士别三日，当刮目相看”他人呀！不要一味地用老眼光来看人处事。\n\n# 多看效应\n转在许多人眼中，喜新厌旧是人的天性。然而,事实果真是如此吗?20世纪60年代,心理学家查荣茨做过试验:先向被试出示一些照片,有的出现了20多次,有的出现了10多次,有的只出现一两次,然后请别试评价对照片的喜爱程度,结果发现,被试更喜欢那些只看过几次的新鲜照片,既看的次数增加了喜欢的程度.这种对越熟悉的东西就越喜欢的现象,心理学上称为多看效应.在人际交往中,如果你细心观察就会发现,那些人缘很好的人,往往将多看效应发挥的淋漓尽致:他们善于制造双方接触的机会,已提高彼此间的熟悉度,然后互相产生更强的吸引力.人际吸引难道真的是如此的简单?有社会心理学的实验做佐证:在一所大学的女生宿舍楼里,心理学家随机找了几个寝室,发给她们不同口味的饮料,然后要求这几个寝室的女生,可以以品尝饮料为理由,在这些寝室间互相走动,但见面时不得交谈.一段时间后,心理学家评估她们之间的熟悉和喜欢的程度,结果发现:见面的次数越多,互相喜欢的程度越大:见面的次数越少或根本没有,相互喜欢的程度也较低.\n\n可见,若想增强人际吸引,就要留心提高自己在别人面前的熟悉度,这样可以增加别人喜欢你的程度.因此,一个自我封闭的人,或是一个面对他人就逃避和退缩的人，由于不易让人亲近而另人费解,也就是太讨人喜欢.\n\n当然,多看效应发挥作用的前提,是首因效应要好,若给人的第一印象不很差,则见面越多就越讨人厌,多看效应反而起了副用.\n\n# 首因效应\n首因效应，是人与人第一次交往中给人留下的印象，在对方的头脑中形成并占据着主导地位的效应。首因效应也叫首次效应、优先效应或第一印象效应。它是指当人们第一次与某物或某人相接触时会留下深刻印象，个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。 第一印象作用最强，持续的时间也长，比以后得到的信息对于事物整个印象产生的作用更强。首因，是指首次认知客体而在脑中留下的第一印象。首因效应，是指个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。\n\n# 近因效应\n所谓近因效应：与首因效应相反. 最近、最后的印象，往往是最强烈的，可以冲澹在此之前产生的各种因素，这就是近因效应。有这样一个例子：面试过程中，主考官告诉考生可以走了，可当考生要离开考场时，主考官又叫住他，对他说，你已回答了我们所提出的问题，评委觉得不怎么样，你对此怎么看？其实，考官做出这么一种设置，是对毕业生的最后一考，想借此考察一下应聘者的心理素质和临场应变能力。如果这一道题回答得精彩，大可弥补此前面试中的缺憾；如果回答得不好，可能会由于这最后的关键性试题而使应聘者前功尽弃\n\n# 凡勃伦效应\n一些商品价格定得越高，就越能受到消费者的青睐。我们经常在生活中看到这样的情景：款式、皮质差不多的一双皮鞋，在普通的鞋店卖80元，进入大商场的柜台，就要卖到几百元，却总有人愿意买。1.66万元的眼镜架、6.88万元的纪念表、168万元的顶级钢琴，这些近乎“天价”的商品流通，往往也能在市场上走俏。其实，消费者购买这类商品的目的并不仅仅是为了获得直接的物质满足和享受，更大程度上是为了获得心理上的满足。这就出现了一种奇特的经济现象，即一些商品价格定得越高，就越能受到消费者的青睐。由于这一现象最早由美国经济学家凡勃伦注意到，因此被命名为“凡勃伦效应”。随着社会经济的发展，人们的消费会随着收入的增加，而逐步由追求数量和质量过渡到追求品位格调。了解了“凡勃伦效应”，我们也可以利用它来探索新的经营策略。比如凭借媒体的宣传，将自己的形象转化为商品或服务上的声誉，使商品附带上一种高层次的形象，给人以“名贵”和“超凡脱俗”的印象，从而加强消费者对商品的好感。这种价值的转换在消费者从数量，质量购买阶段过渡到感性购买阶段时，就成为可能。实际上，在东南沿海的一些发达地区，感性消费已经逐渐成为一种时尚，而只要消费者有能力进行这种感性购买时，“凡勃伦效应”就可以被有效地转化为提高市场份额营销策略。\n\n# 共生效应\n植物界中相互影响、相互促进的现象,称之为:共生效应 在自然界，一株植物单独生长时，往往长势不旺，没有生机，甚至枯萎衰败，而当众多植物一起生长时，却能郁郁葱葱，挺拔茂盛，人们把这种植物中这种相互影响、相互促进的现象称之为“共生效应”。 共生就是两者相互利用（虽然这个词是贬义词，但实际就是这样），同时有利于双方发展的现象，这种情况应不仅限于自然界，人类社会也会有。\n\n# 黑暗效应\n在光线比较暗的场所，约会双方彼此看不清对方表情，就很容易减少戒备感而产生安全感。在这种情况下，彼此产生亲近的可能性就会远远高于光线比较亮的场所。心理学家将这种现象称之为“黑暗效应”。有个这样的案例：有一位男子钟情于一位女子，但每次约会，他总觉得双方谈话不投机。有一天晚上，他约那位女子到一家光线比较暗的酒吧，结果这次谈话融洽投机。从此以后，这位男子将约会的地点都选择在光线比较暗的酒吧。几次约会之后，他俩终于决定结下百年之好。 社会心理学家研究后的结论是，在正常情况下，一般的人都能根据对方和外界条件来决定自己应该掏出多少心里话，特别是对还不十分了解但又愿意继续交往的人，既有一种戒备感，又会自然而然地把自己好的方面尽量展示出来，把自己弱点和缺点尽量隐藏起来。因此，这时双方就相对难以沟通。\n\n# 棘轮效应\n商朝时，纣王登位之初，天下人都认为这位精明的国君的治理下，商朝的江山一定会坚如磐石。有一天，纣王命人用象牙做了一双筷子，十分高兴地使用这双象牙筷子就餐。他的叔父箕子见了，劝他收藏起来，而纣王却满不在乎，满朝文武大臣也不以为然，认为这本来是一件很平常的小事。箕子为此忧心忡忡，有的大臣莫名其妙地问他原因，箕子回答说：“纣王用象牙做筷子，必定再不会用土制的瓦罐盛汤装饭，肯定要改用犀牛角做成的杯子和美玉制成的饭碗；有了象牙筷、犀牛角杯和美玉碗，难道还会用它来吃粗茶澹饭和豆子煮的汤吗？大王的餐桌从此顿顿都要摆上美酒佳肴了；吃的是美酒佳肴，穿的自然要绫罗绸缎，住的就要求富丽堂皇，还要大兴土木筑起楼台亭阁以便取乐了。对这样的后果我觉得不寒而栗。”仅仅5年时间，箕子的预言果然应验了，商纣王瓷意骄奢，便断送了商汤绵延500年的江山。在上面的故事中，箕子对纣王使用象牙筷子的评价，运用了现代经济学一种消费效应――棘轮效应。所谓棘轮效应，又称制轮作用，是指人的消费习惯形成之后有不可逆性，即易于向上调整，而难于向下调整。尤其是在短期内消费是不可逆的，其习惯效应较大。这种习惯效应，使消费取决于相对收入，即相对于自己过去的高峰收入。这一效应是经济学家杜森贝提出的。古典经济学家凯恩斯主张消费是可逆的，即绝对收入水平变动必然立即引起消费水平的变化。针对这一观点，杜森贝认为这实际上是不可能的，因为消费决策不可能是一种理想的计划，它还取决于消费习惯。这种消费习惯受许多因素影响，如生理和社会需要、个人的经历、个人经历的后果等。特别是个人在收入最高期所达到的\n\n从个人的角度来说，我们对于欲望既不能禁止，也不能放纵，对于过度的及至贪得无厌的奢求，必须加以节制。如果对自己的欲望不加限制的话，过度地放纵奢侈，没能培养俭仆的生活习惯，必然会使自古“富不过三代”之说就成了必然，就必然出现“君子多欲，则贪慕富贵，枉道速祸；小人多欲，则多求妄用，败家丧身。是以居官必贿，居乡必盗”的情况。西方一些成功企业家虽家境富裕，但依然对子女要求极严，从不给孩子更多的零花钱，甚至寒暑假还让孩子四处打工。这些成功企业家并不是苛求子女能为自己多赚一点钱，而是希望子女懂得每一分钱的来之不易，懂得俭仆和自立。\n\n# 奖惩效应\n奖励和惩罚是对学生行为的外部强化或弱化的手段，它通过影响学生的自身评价，能对学生的心理产生重大影响，由奖惩所带来的行为的强化或弱化就叫做奖惩效应。心理学实验证明，表扬、鼓励和信任，往往能激发一个人的自尊心和上进心。但奖励学生的原则应是精神奖励重于物质奖励，否则易造成”为钱而学”、”为班主任而学”的心态。同时奖励要抓住时机，掌握分寸，不断升化。当然”没有惩罚就没有教育”，必要的惩罚是控制学生行为的有效信号。惩罚时用语要得体、适度、就事论事，使学生明白为什么受罚和怎样改过。同时还应注意的是奖惩的频率，从心理学的研究结果看，当奖惩的比例为5：1时往往效果最好。\n\n# 结伴效应\n是指两个人或几个人结伴从事相同的一项活动时（并不进行竞赛）相互之间会产生刺激作用，提高活动效率。例如：学生在一起作作业比独立完成作业的效率高。 可以相应组成学习小组。教师应注意课上的效率，注意时间分配。…\n\n# 空白效应\n心理实验表明，在演讲的过程中，适当地留一些空白，会取得良好的演讲效果，这就是空白效应。它给我们的启示是，班主任要善于留白，如在表达方面留白，针对某些问题，班主任不妨先不说出自己的观点，让学生去想、去说，让学生有表达自己意见的机会。在实践方面留白，给学生一个锻炼和实践的机会，提高学生的动手能力。在思考方面留白，班主任应给学生思考分析的机会，让学生独立地思考、判断和面对，学生的分析能力就会逐渐提高。在批评方面留白，批评之后，留有学生自己去思考、自己去责备的时间。这样学生就不会有一种被”穷追不舍”之感，反抗心理就会锐减。\n\n# 青蛙现象\n青蛙现象：把一只青蛙直接放进热水锅里，由于它对不良环境的反应十分敏感，就会迅速跳出锅外。如果把一个青蛙放进冷水锅里，慢 慢地加温，青蛙并不会立即跳出锅外，水温逐渐提高的最终结局是青蛙被煮死了，因为等水温高到青蛙无法忍受时，它已经来不及、或者说是没有能力跳出锅外了。青蛙现象告诉我们，一些突变事件，往往容易引起人们的警觉，而易致人于死地的却是在自我感觉良好的情况下，对实际情况的逐渐恶化，没有清醒的察觉。启示之一是：我们的组织和社会生存的主要威胁，并非来自突如其来的事件，而是由缓慢渐进而无法察觉的过程形成。人们目光短浅，只看到局部，而无法纵观全局，对于突如其来的变化，可以从容面对，对于悄悄发生的大的变化，而无法察觉，最终会带给我们更加严重的危害！~启示之二是：青蛙，就好象是我们生活中的芸芸众生，我们要着眼未来，勤于思考新的问题，勤于学习新的知识，不能过“今日有酒，今日醉”和“当一天和尚，撞一天钟”的醉生梦死的生活，到头来将是非常可悲的！\n\n启示之三是：当今的社会，是一个知识爆炸、日新月异的时代，知识也需要不断更新，所以我们不要一味的沉迷于现状、安于现状，不思进取，这样下去的话，肯定会被时代所淘汰，也会有面临失业的危险！\n\n启示之四是：我们不要单纯的，只能面对突如其来的危险，而忽视那种缓慢而又微小甚微的危险，因为，那种缓慢而又微小甚微的危险，才是最可怕的！\n\n# 21天效应\n在行为心理学中，人们把一个人的新习惯或理念的形成并得以巩固至少需要21天的现象，称之为21天效应。也就是说，一个人的动作、或想法，如果重复21天就会变成一个习惯性的动作或想法。\n\n根据我国成功学专家易发久研究，习惯的形成大致分为三个阶段：\n\n第一阶段：1-7天左右。此阶段表现为“刻意，不自然”，需要十分刻意地提醒自己。\n\n第二阶段：7-21天左右。此阶段表现为“刻意，自然”，但还需要意识控制。\n\n第三阶段：21-90天左右，此阶段表现为“不经意，自然”，无需意识控制。\n\n# 本杰明富兰克林效应\n让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。—— 本杰明·富兰克林效应,\n\n本杰明 富兰克林效应的现象启示我们，如果你对一个人行善举，那么往往会得到好的结果。当然这绝非是种“果报”理论\n本杰明 富兰克林曾表示，通过向一个不喜爱他的议员借书，他们俩最终成为了要好的朋友。认知失调理论的解释为，如果我们去帮助一个不喜欢的人，结果说不定就会喜欢上他—— 当我们给予不喜欢的人帮助时，其实是经历了一种失调，我们的行为和对此人的态度之间发生了矛盾。为了缓解这种失调，我们会尽力说服自己这个人是好的、值得帮助的，从而注意并强调了其优点，而澹化了自己本来不喜爱他的事实。这个故事倒是给了我们一点启示：如果想追求一个本来不怎么喜欢你的姑娘，或许也可以通过求得她帮忙的方式来逐步制造她对你的好感呢？\n\n# 史密斯原则\n如果你不能战胜他们，你就加入到他们之中去。竞争使人进步最快，合作让人得到最多。\n\n# 鸟笼逻辑\n挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里。这就是鸟笼逻辑。过程很 简单，设想你是这房间的主人，只要有人走进房间，看到鸟笼，就会忍不住问你：“鸟呢？是不是死了？”当你回答：“我从来都没有养过鸟。”人们会问：“那么，你要一个鸟笼干什么？”最后你不得不在两个选择中二选一，因为这比无休止的解释要容易得多。鸟笼逻辑的原因很简单：人们绝大部分的时候是采取惯性思维。所以可见在生活和工作中培养逻辑思维是多么重要\n\n# 责任分散效应\n1964年3月13日夜3时20分，在美国纽约郊外某公寓前，一位叫朱诺比白的年轻女子在结束酒巴间工作回家的路上遇刺。当她绝望地喊叫：“有人要杀人 啦!救命!救命!”听到喊叫声，附近住户亮起了灯，打开了窗户，凶手吓跑了。当一切恢复平静后，凶手又返回作案。当她又叫喊时，附近的住户又打开了电灯， 凶手又逃跑了。当她认为已经无事，回到自己家上楼时，凶手又一次出现在她面前，将她杀死在楼梯上。在这个过程中，尽管她大声呼救，她的邻居中至少有38位 到窗前观看，但无一人来救她，甚至无一人打电话报警。这件事引起纽约社会的轰动，也引起了社会心理学工作者的重视和思考。人们把这种众多的旁观者见死不救 的现象称为责任分散效应。对于责任分散效应形成的原因，心理学家进行了大量的实验和调查，结果发现：这种现象不能仅仅说是众人的冷酷无 情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己 的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担， 造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的 局面。如何打破这种局面，这是心理学家正在研究的一个重要课题。\n\n# 虚假同感偏差\n我们通常都会相信，我们的爱好与大多数人是一样的。如果你喜欢玩电脑游戏，那么就有可能高估喜欢电脑游戏的人数。你也通常会 高估给自己喜欢的同学投票的人数，高估自己在群体中的威信与领导能力等等。你的这种高估与你的行为及态度有相同特点的人数的倾向性就叫做“虚假同感偏 差”。有些因素会影响你的这种虚假同感偏差强度：\n\n当外部的归因强于内部归因时；\n当前的行为或事件对某人非常重要时；\n当你对自己的观点非常确定或坚信时；\n当你的地位或正常生活和学习受到某种威胁时；\n当涉及到某种积极的品质或个性时；\n当你将其他人看成与自己是相似时。\n美人效应\n罗马一家自助餐厅的老板想出一个赚小费的妙计。他请来一位非常漂亮的姑娘，坐在柜台边收钱，以便使男客们神魂颠倒，慷慨解囊。谁知那位姑娘上班后没过几天，就对老板说：“我想，我不如以前漂亮了。”老板忙问：“这是怎么回事呢？”“现在，所有的男客都在柜台边反复地数找给他们的零钱。”美人效应在这里发挥的作用正是挖掘潜在消费和增加客人满意程度，增强餐厅的竞争优势，从而留住客人。\n\n# 潘多拉效应\n古希腊有个神话，说宙斯给一个名叫潘多拉的女孩一个盒子，告诉她绝对不能打开。“为什么不能打开？还要‘绝对’？里面该不是稀世珍宝吧？”潘多拉越想越好 奇，越想揭开真相。憋了一段时间后，她终于把盒子打开了。谁知盒子里装的是人类的全部罪恶，结果让它们都跑到人间了。心理学把这种“不禁不为、愈禁愈为” 的现象，叫“潘多拉效应”或“禁果效应”。潘多拉效应的心理实质是好奇心和逆反心理在起作用。\n\n# 光环效应\n也叫晕轮效应, 晕轮原指月亮被光环笼罩时产生的模煳不清的现象。晕轮效应是一种普通存在的心理现象，即对一个人进行评价时，往往会因对他的某一品质特征的强烈、清晰的感知，而掩盖了其他方面的品质。毕业生在求职应聘中，如果能够巧妙地运用这种晕轮效应，把自身的优势充分地展现出来，一定会给招聘考官留下深刻的印象，赢得对方的赏识，取得面试的成功。比如，当招聘者问及你的英语水平时，你便用英语熟练地与其交谈，必然会引起招聘者的极大兴趣，很可能当场便与你拍板“成交”。但在运用这一效应时一定要注意，不能刻意制造“光环”效果，那种虚妄做出的行为，往往适得其反。\n\n# 冷热水效应\n一杯温水，保持温度不变，另有一杯冷水，一杯热水。当先将手放在冷水中，再放到温水中，会感到温水热；当先将手放在热水中，再放到温水中，会到温水凉。同一杯温水，出现了两种不同的感觉，这就是冷热水效应。这种现象的出现，是因为人人心里都有一杆秤，只不过是秤砣并不一致，也不固定。随着心理的变化，秤砣也在变化。当秤砣变小时，它所称出的物体重量就大，当秤砣变大时，它所称出的物体重量就小。人们对事物的感知，就是受这秤砣的影响。人际交往中，要善于运用这种冷热水效应。 运用冷热水效应，可以获得对方的好评。 人处世上，难免有事业上滑坡的时候，难免有不小心伤害他人的时候，难免有需要对他人进行批评指责的时候，在这些时候，假若处理不当，就会降低自己在他人心目中的形象。如果巧妙运用冷热水效应，就不但不会降低自己的形象，反而会获得他人一个好的评价。当事业上滑坡的时候，不妨预先把最糟糕的事态委婉地告诉别人，以后即使失败也可立于不败之地；当不小心伤害他人的时候，道歉不妨超过应有的限度，这样不但可以显示出你的诚意，而且会收到化干戈为玉帛的效果；当要说令人不快的话语时，不妨事先声明，这样就不会引起他人的反感，使他人体会到你的用心良苦。这些运用冷热水效应的举动，实质上就是先通过一二处“伏笔”，使对方心中的“秤砣”变小，如此一来，它“称出的物体重量”也就大了。某汽车销售公司的老李，每月都能卖出30辆以上汽车，深得公司经理的赏识。由于种种原因，老李预计到这个月只能卖出10辆车。深懂人性奥妙的老李对经理说：“由于银根紧缩，市场萧条，我估计这个月顶多卖出5辆车。”经理点了点头，对他的看法表示赞成。没想到一个月过后，老李竟然卖了12辆汽车，公司经理对他大大夸奖一番。假若老李说本月可以卖15辆或者事先对此不说，结果只卖了12辆，公司经理会怎么认为呢？他会强烈地感受到老李失败了，不但不会夸奖，反而可能指责。在这个事例中，老李把最糟糕情况――顶多卖5辆车，报告给经理，使得经理心中的“秤砣”变小，因此当月绩出来以后，对老李的评价不但不会降低，反而提高了。 蔡女士很少演讲，一次迫不得已，她对一群学者、评论家进行演说。她的开场白是：“我是一个普普通通的家庭妇女，自然不会说出精彩绝伦的话语，因此恳请各位专家对我的发言不要笑话……”经她这么一说，听众心中的“秤砣”变小了，许多开始对她怀疑的人，也在专心听讲了。她的简单朴实演说完成后，台下的学者、评论家们感到好极了，他们认为她的演说达到了极高的水平。对于蔡女士的成功演讲，他们抱以热烈的掌声。当一个人不能直接端给他人一盆“热水”时，不妨先端给他人一盆“冷水”，再端给他人一盆“温水”，这样的话，这人的这盆“温水”同样会获得他人的一个良好评价。\n\n# 临近效应\n两个人能否成为朋友，这与俩人住处的远近有很大关系。这被称为邻近效应。那么为什么邻近性会引发好感呢？\n\n(增强亲近感) - 邻近性一般都会增强亲近感。住得近的人自然碰面的机会也相对频繁，重复的接触就会引发、增强相互间的好感。\n(强烈的相似性) - 人们大多选择社会地位、经济实力与自己相近的人为邻，而地理位置上的邻近性进一步增强了人们的相似性。\n(越是邻近的人，其可利用度也越高) - 邻居之间不用花费太多的时间和费用便可成为好朋友，而且有很多事可以相互嘱托，有快乐可以共同分享。比如可以请邻居照看孩子或房子，家里不管发生什么大事小事都可以相互照应。\n(认知的一贯性) - 与讨厌的人比邻而居，在心理上是难以忍受的。人们在交往中大多愿意接近与自己合得来、住所比较近的人。\n\n# 名人效应\n美国心理学家曾做过一个有趣的实验，在给大学心理系学生讲课时，向学生介绍说聘请到举世闻名的化学家。然后这位化学家说，他发现了一种新的化学物质，这种物质具有强烈的气味，但对人体无害。在这里只是想测一下大家的嗅觉。接着打开瓶盖，过了一会儿，他要求闻到气味的同学举手，不少同学举了手，其实这只瓶子里只不过是蒸馏水，”化学家”是从外校请来的德语教师。这种由于接受名人的暗示所产生的信服和盲从现象被称为名人效应。名人效应的产生依赖于名人的权威和知名度，名人之所以成为名人，在他们那一领域必然有其过人之处。名人知名度高，为世人所熟悉、喜爱，所以名人更能引起人们的好感、关注、议论和记忆。由于青少年的认识特点及心理发展，他们所希望的名人多为形式化、表面性的形象所吸，他们喜欢的名人多为歌星、影星一类，出现追星现象。这就要求班主任要为学生选择好”名人”，以促进学生的健康成长。\n\n# 墨菲定律\n(Murphy’s Law)缘于美国一位名叫墨菲的上尉。他认为他的某位同事是个倒霉蛋，不经意说了句笑话：“如果一件事情有可能被弄糟，让他去做就一定会弄糟。”这句话迅速流传。经过多年，这一“定律”逐渐进入习语范畴，其内涵被赋予无穷的创意，出现了众多的变体，“如果坏事有可能发生，不管这种可能性多么小，它总会发生，并引起最大可能的损失”、“If anything can go wrong, it will.(会出错的，终将会出错)”、“笑一笑，明天未必比今天好。”“东西越好，越不中用”、“别试图教猪唱歌，这样不但不会有结果，还会惹猪不高兴!”墨菲定律的原话是这样说的：If there are two or more ways to do something, and one of those ways can result in a catastrophe, then someone will do it.(如果有两种选择，其中一种将导致灾难，则必定有人会作出这种选择。)\n\n根据“墨菲定律”，一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四，如果你担心某种情况发生，那么它就更有可能发生。我们都有这样的体会，如果在街上准备拦一辆车去赴一个时间紧迫的约会，你会发现街上所有的出租车不是有客就是根本不搭理你，而当你不需要租车的时候，却发现有很多空车在你周围游弋，只待你的一扬手，车随时就停在你的面前。如果一个月前在浴室打碎镜子，尽管仔细检查和冲刷，也不敢光着脚走路，等过了一段时间确定没有危险了，不幸的事还是照样发生，你还是被碎玻璃扎了脚。如果你把一片干面包掉在你的新地毯上，它两面都可能着地。但你把一片一面涂有果酱的面包掉在新地毯上，常常是有果酱的那面朝下。\n\n墨菲定律告诉我们，容易犯错误是人类与生俱来的弱点，不论科技多发达，事故都会发生。而且我们解决问题的手段越高明，面临的麻烦就越严重。所以，我们在事前应该是尽可能想得周到、全面一些，如果真的发生不幸或者损失，就笑着应对吧，关键在于总结所犯的错误，而不是企图掩盖它。\n\n2003年美国“哥伦比亚”号航天飞机即将返回地面时，在美国得克萨斯州中部地区上空解体，机上6名美国宇航员以及首位进入太空的以色列宇航员拉蒙全部遇难。“哥伦比亚”号航天飞机失事也印证了墨菲定律。如此复杂的系统是一定要出事的，不是今天，就是明天，合情合理。一次事故之后，人们总是要积极寻找事故原因，以防止下一次事故，这是人的一般理性都能够理解的，否则，或者从此放弃航天事业，或者听任下一次事故再次发生，这都不是一个国家能够接受的结果\n\n人永远也不可能成为上帝，当你妄自尊大时，“墨菲定律”会叫你知道厉害；相反，如果你承认自己的无知，“墨菲定律”会帮助你做得更严密些。\n\n这其实是概率在起作用，人算不如天算，如老话说的“上的山多终遇虎”。还有“祸不单行”。如彩票，连着几期没大奖，最后必定滚出一个千万大奖来，灾祸发生的概率虽然也很小，但累积到一定程度，也会从最薄弱环节爆发。所以关键是要平时清扫死角，消除不安全隐患，降低事故概率。\n\n# 破窗效应\n美国心理学家詹巴斗曾经做过一个”偷车实验”，将两辆一模一样的轿车分别放在一个环境很好的中产阶级社区和环境比较脏乱的贫民区，结果发现贫民区的车很快被偷走了，而另一辆几天后仍然完好无损；如果将中产阶级社区的那辆车的天窗玻璃打破，几个小时后，那辆车也被偷了。后来，在此实验基础上，美国政治学家威尔逊和犯罪学家凯林提出了有名的”破窗理论”：如果有人打坏了一栋建筑上的一块玻璃，又没有及时修好，别人就可能受到某些暗示性的纵容，去打碎更多的玻璃。 “破窗理论”体现的是细节对人的暗示效果，以及细节对事件结果不容小视的重要作用。事实证明，”破窗理论”也确实能够指导我们的生活。 18世纪的纽约以脏乱差闻名，环境恶劣，同时犯罪猖獗，地铁的情况尤为严重，是罪恶的延伸地，平均每7个逃票的人中就有一个通缉犯，每20个逃票的人中有一个携带武器者。1994年，新任警察局长布拉顿开始治理纽约。他从地铁的车箱开始治理：车箱干净了，站台跟着也变干净了，站台干净了，阶梯也随之整洁了，随后街道也干净了，然后旁边的街道也干净了，后来整个社区干净了，最后整个纽约变了样，变整洁漂亮了。现在纽约是全美国治理最出色的都市之一，这件事也被称为”纽约引爆点”。 还有一个被称为校园里的”破窗现象”：班里新来了一个留级生，由于他的勤奋努力，使得原本想混日子的同学受到震动，学习气氛开始转好，有时老师反复强调的重点，有的人或许不以为然，但是他的一句话–这个内容要考试–便会立即引起同学们的高度重视，留级生的话比老师的话还有效！这说明及时修好第一扇被打破的玻璃，能有效阻止”破窗现象”于萌芽状态。 将”破窗理论”中的玻璃\n\n在公共场合大声说话，暗示一个人喜欢表现自己；\n\n穿什么样的袜子，暗示一个人的品位如何；\n\n在背后说别人坏话的人，在暗示他不可信任；\n\n对任何事都怀疑的人，暗示他是一个悲观主义者；\n\n对任何事都不满的人，暗示他是一个愤世嫉俗者；\n\n不贪小便宜的人，暗示他很正直……\n\n每件大事都由无数小事–也就是细节构成，将细节尽量做到完美，将来的结果才有可能完美。人的一生也由无数细节组成，将小事做好，给他人留下美好印象，将来才会更美好。\n\n# 热手效应\n如果篮球队员投篮连续命中，球迷一般都相信球员“手感好”，下次投篮还会得分。在轮盘游戏中，赌徒往往认定其中的红黑两色会交替出现，如果之前红色出现过多，下次更可能出现黑色。可是，直觉未必是靠得住的。事实上，第一次投篮和第二次投篮是否命中没有任何联系，转动一回轮盘，红色和黑色出现的机会也总是0.5。就像受“热手效应”误导的球迷或受“赌徒谬误”左右的赌徒，投资者预测股价也容易受到之前价格信息的影响，用直觉代替理性分析，产生所谓的“启发式心理”。举个例子，一家制药公司的股价长期上扬，在初期，投资者可能表现为“热手效应”，认为股价的走势会持续，“买涨不买跌”；可一旦股价一直高位上扬，投资者又担心上涨空间越来越小，价格走势会“反转”，所以卖出的倾向增强，产生“赌徒谬误”。“‘热手效应’与‘赌徒谬误’都来自人们心理学上的认知偏差－即认为一系列事件的结果都在某种程度上隐含了自相关的关系”。由南京大学商学院的林树、复旦大学管理学院和清华大学公共管理学院的俞乔、汤震宇、周建四位学者组成的团队，利用心理学实验的方法研究了中国的个体投资者在面对过去股价信息时的交易行为与心理预期。林树、俞乔等发表在《经济研究》8月号、题为《投资者“热手效应”与“赌徒谬误”的心理实验研究》的文章发现，“在中国资本市场上具有较高教育程度的个人投资者或潜在个人投资者中，‘赌徒谬误’效应对股价序列变化的作用均要强于‘热手效应’，占据支配地位”，也就是说，无论股价连续上涨还是下跌，投资者更愿意相信价格走势会逆向反转。根据这一发现，研究认为“在中国股票市场处于中长期‘熊市\n\n# 睡眠效应\n使坏印象随时间的流逝而消失邮递销售或上门销售中有这样一项保护消费者的制度，即使是已签定的买卖合同，只要超过了一定期限就会被自动失效。这个制度被称为“冷却制”（coolingoff）。这里的“cooling”是指从一开始认为“很好”到后来可能认为不怎么样的这段冷却期。反过来，起初认为“没有什么好处”的坏印象也可能由于时间的流逝而消失，继而产生好印象。心理学称这种现象为睡眠效应。比如谈判陷入僵局即将破裂时，提出“先吃午饭，等吃完后再做决定吧”，让双方有一段冷静思考的时间。等重开谈判时，进展会异常顺利。谈判到达高潮时或刚刚进行劝说后，给予对方一段思考的时间，会收到良好的效果。因为劝说者与劝说内容的暂时分离会增加信息的可信度，使对方作出冷静的判断。\n\n# 羊群效应\n是指管理学上一些企业的市场行为的一种常见现象。例如一个羊群（集体）是一个很散乱的组织，平时大家在一起盲目地左冲右撞。如果一头羊发现了一片肥沃的绿草地，并在那里吃到了新鲜的青草，后来的羊群就会一哄而上，争抢那里的青草，全然不顾旁边虎视眈眈的狼，或者看不到其它还有更好的青草。 羊群效应的出现一般在一个竞争非常激烈的行业上，而且这个行业上有一个领先者（领头羊）占据了主要的注意力，那么整个羊群就会不断摹仿这个领头羊的一举一动，领头羊到哪里去吃草，其它的羊也去哪里淘金。搜索引擎这个市场上的竞争加剧的情况下，搜索引擎的巨头之间对对手之间的动作非常的注意，一旦一个搜索引擎出现某一个新的功能，或者进入一个新的领域，众多的搜索引擎都会去尝试这个新的“水草地”是否真的肥美，是否真得有利可图。\n\n# 异性效应\n在人际关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对人的活动和学习通常起积极的影响。这种现象称为“异性效应”. 心理学家曾在一次测试中发现，男性在男、女同桌就餐地要比单纯男性. 就餐时要文明许多，这是由于大多数人在异性面前更注意自己的言行。\n\n# 马斯洛需求层次理论\nMaslow’s hierarchy of needs, 该理论将需求分为五种，像阶梯一样从低到高，按层次逐级递升，分别为：生理上的需求，安全上的需求，情感和归属的需求，尊重的需求，自我实现的需求。\n\n需求层次理论有两个基本出发点，一是人人都有需要，某层需要获得满足后，另一层需要才出现；二是在多种需要未获满足前，首先满足迫切需要；该需要满足后，后面的需要才显示出其激励作用。一般来说，某一层次的需要相对满足了，就会向高一层次发展，追求更高一层次的需要就成为驱使行为的动力。相应的，获得基本满足的需要就不再是一股激励力量。五种需要可以分为两级，其中生理上的需要、安全上的需要和感情上的需要都属于低一级的需要，这些需要通过外部条件就可以满足；而尊重的需要和自我实现的需要是高级需要，他们是通过内部因素才能满足的，而且一个人对尊重和自我实现的需要是无止境的。同一时期，一个人可能有几种需要，但每一时期总有一种需要占支配地位，对行为起决定作用。任何一种需要都不会因为更高层次需要的发展而消失。各层次的需要相互依赖和重叠，高层次的需要发展后，低层次的需要仍然存在，只是对行为影响的程度大大减小\n\n另外两种需要：求知需要和审美需要。这两种需要未被列入到他的需求层次排列中，他认为这二者应居于尊重需求与自我实现需求之间。\n\n# 卢维斯定理\n谦虚不是把自己想得很糟，而是完全不想自己。如果把自己想得太好，就很容易将别人想得很糟。\n\n# 托利得定理\n测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。","source":"_posts/常见的心理学效应.md","raw":"---\ntitle: 常见的心理学效应\ndate: 2017-09-27\n---\n常见的心理学效应，每天学习一下，站在更高一点的位置看人的行为，会让我们活的更通透一些。\n<!-- more -->\n\n# 承诺定律\n承诺未必可以保证一定做到，但是如果你没有做出承诺，就算你做到了也没有价值。​\n\n# 苹果定律\n如果有一堆苹果，有好有坏，你就应该先吃好的，把坏的令人扔掉，如果你先吃坏的，好的也会变坏，你将永远吃不到好的苹果，人生亦如此。\n\n# 价值定律\n当你拥有一项东西的时候，你就会发现这种东西并不像你原来所想的那样有价值。\n\n# 酝酿效应\n在古希腊，国王让人做了一顶纯金的王冠，但他又怀疑工匠在王冠中掺了银子。可问题是这顶王冠与当初交给金匠的一样重，谁也不知道金匠到底有没有捣鬼。国王把这个难题交给了阿基米德。阿基米德为了解决这个问题冥思苦想,他起初尝试了很多想法，但都失败了。有一天他去洗澡，一边他一边坐进澡盆，以便看到水往外溢，同时感觉身体被轻轻地托起，他突然恍然大悟，运用浮力原理解决了问题。不管是科学家还是一般人，在解决问题的过程中，我们都可以发现“把难题放在一边，放上一段时间，才能得到满意的答案”这一现象。心理学家将其称为“酝酿效应”。阿基米德发现浮力定律就是酝酿效应的经典故事。日常生活中，我们常常会对一个难题束手无策，不知从何入手，这时思维就进入了“酝酿阶段”。直到有一天，当我们抛开面前的问题去做其他的事情时，百思不得其解的答案却突然出现在我们面前，令我们忍不住发出类似阿基米德的惊叹，这时，“酝酿效应”就绽开了“思维之花”，结出了“答案之果”。古代诗词说“山重水复疑无路，柳暗花明又一村”正是这一心理的写照。 心理学家认为，酝酿过程中，存在潜在的意识层面推理，储存在记忆里的相关信息在潜意识里组合，人们之所以在休息的时候突然找到答案，是因为个体消除了前期的心理紧张，忘记了个体前面不正确的、导致僵局的思路，具有了创造性的思维状态。因此，如果你面临一个难题，不妨先把它放在一边，去和朋友散步、喝茶，或许答案真的会“踏破铁鞋无觅处，得来全不费功夫”。\n\n# 阿伦森效应\n是指人们最喜欢那些对自己的喜欢、奖励、赞扬不断增加的人或物，最不喜欢那些显得不断减少的人或物。心理学家做过一个实验,分4组人对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒。结果此实验对数十人进行过后，发现绝大部分人对第四组最具好感，而对第三组最为反感。阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。同样，它也提醒我们在形成对别人的印象过程中，要避免受它的影响而形成错误的态度。有个案例说道: 在宿舍楼的后面，停放着一部烂汽车，大院里的孩子们每当晚上7点时，便攀上车厢蹦跳，嘭嘭之声震耳欲聋，大人们越管，众孩童蹦得越欢，见者无奈。这天，一个人对孩子们说：“小朋友们，今晚你们比赛，蹦得最响的奖玩具手枪一支。”众童呜呼雀跃，争相蹦跳，优者果然得奖。次日，这位朋友又来到车前，说：“今天继续比赛，奖品为两粒奶糖。”众童见奖品直线下跌，纷纷不悦，无人卖力蹦跳，声音疏稀而弱小。第三天，朋友又对孩子们言：“今日奖品为花生米二粒。”众童纷纷跳下汽车，皆说：“不蹦了，不蹦了，真没意思，回家看电视了。” 在“正面难攻”的情况下，采用“奖励递减法”可起到奇妙心理效应。\n又有个案例说道: 小刚大学毕业后分到一个单位工作，刚一进单位，他决心好好地积极表现一番，以给领导和同事们留下非常好的第一印象。于是，他每天提前到单位打水扫地，节假日主动要求加班，领导布置的任务有些他明明有很大的困难，也硬着头皮一概承揽下来。本来，刚刚走上工作岗位的青年人积极表现一下自我是无可厚议的。但问题是小刚的此时表现与其真正的思想觉悟、为人处世的一贯态度和行为模式相差甚远，夹杂着“过分表演”的成分。因而就难以有长久的坚持性。没过多久，小刚水也不打了，地也不拖了，还经常迟到，对领导布置的任务更是挑肥拣瘦。结果，领导和同事们对他的印象由好转坏，甚至比那些刚开始来的时候表现不佳的青年所持的印象还不好。因为大家对他已有了一个“高期待、高标准”，另外，大家认为他刚开始的积极表现是“装假”，而“诚实”是我们社会评定一个人所运用的“核心品质”。\n\n# 巴霖效应\n源自于马戏团经理巴霖先生的一句名言：每分钟都有一名笨蛋诞生。”巴霖效应” 多少解释了为什么有些星座或生肖书刊能够”准确的”指出某人的性格。原因在此,那些用来描述性格的词句,其实根本属”人之常情”或基本上适用于大部分人身上的。换言之,那些词句的适用范围是如此的空泛，以至往往”说了等于没说。例如:水瓶座理性而爱好自由，巨蟹座感性而富爱心；然而巨蟹座的人就永远没理性，水瓶座的人就缺乏爱心吗？我们不去否定星座存在的价值，毕竟它存有统计的基础在。但如果你想成为一个聪明人，不去迷信星座，我又得告诉你，你又错了！知道什么叫做”天醉人亦醉”吗?既然身旁有超过半数的人相信星座，你又何苦试着去推翻那根植于心的观念(实际上也不太可能)? 如果一对情侣在星座学中是不甚相配的，即使两人都不迷信，但他们的心理必然会承受一股不小的压力，在往后交往的时间中，若有了冲突磨擦，心中既存的那种”原来真的不合适”的预设就会被强迫成立，最终难逃分手命运!巴霖效应与巴纳姆效应相同, 巴纳姆效应是由心理学家伯特伦·福勒于1948年通过试验证明的一种心理学现象，它主要表现为：每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，他仍然认为反映了自己的人格面貌。而要避免巴纳姆效应，就应客观真实地认识自己。\n\n# 半途效应\n半途效应是指在激励过程中达到半途时，由于心理因素及环境因素的交互作用而导致的对于目标行为的一种负面影响。大量的事实表明，人的目标行为的中止期多发生在”半途”附近，在人的目标行为过程的中点附近是一个极其敏感和极其脆弱的活跃区域。导致半途效应的原因主要有两个，一是目标选择的合理性，目标选择的越不合理越容易出现半途效应；二是个人的意志力，意志力越弱的人越容易出现半途效应。这就要求班主任在平时教育学生时多注意学习各方面的知识，培养多方面的能力，同时多注意进行意志力的磨练。行为学家提出了”大目标、小步子”的方法，对于防止半途效应的发生具有积极的意义。\n\n# 比马龙效应\n评价主体低估被评价者能力，认定被评价者是不求上进的、行为差劲的，以致被评价者将这种观念内化，促使被评价者表现不良行为。你有过这样的经历吗？本来穿了一件自认为是很漂亮的衣服去上班，结果好几个同事都说不好看，当第一个同事说的时候，你可能还觉得只是她的个人看法，但是说的人多了，你就慢慢开始怀疑自己的判断力和审美眼光了，于是到了下班后，你回家做的第一件事情就是把衣服换下来，并且决定再也不穿它去上班了。又比如, 如果家长们一直对自己的孩子说你为什么这么笨啊, 久而久之, 这个孩子就会潜移默化地以为自己很笨. 其实，这只是心理暗示在起作用。暗示作用往往会使别人不自觉地按照一定的方式行动，或者不加批判地接受一定的意见或信念。可见，暗示在本质上，是人的情感和观念，会不同程度地受到别人下意识的影响。\n\n# 边际效应\n有时也称为边际贡献，是指消费者在逐次增加1个单位消费品的时候，带来的单位效用是逐渐递减的（虽然带来的总效用仍然是增加的）。\n\n举一个通俗的例子，当你肚子很饿的时候，有人给你拿来一笼包子，那你一定感觉吃第一个包子的感觉是最好的，吃的越多，单个包子给你带来的满足感就越小，直到你吃撑了，那其它的包子已经起不到任何效用了。边际效应的应用非常广泛，例如经济学上的需求法则就是以此为依据，即：用户购买或使用商品数量越多，则其愿为单位商品支付的成本越低（因为后购买的商品对其带来的效用降低了）。当然也有少数例外情况，例如嗜酒如命的人，是越喝越高兴，或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。了解边际效应的概念，你就可以尝试去在实际生活中运用它，例如：你是公司管理层，要给员工涨工资，给 3K 月薪的人增加 1K 带来的效应一般来说是比 6K 月薪增加 1K 大的，可能和 6K 月薪的人增加 2K 的相当，所以似乎给低收入的人增加月薪更对公司有利；另外，经常靠增加薪水来维持员工的工作热情看来也是不行的，第一次涨薪 1K 后，员工非常激动，大大增加了工作热情；第二次涨薪 1K，很激动，增加了一些工作热情；第三次涨薪 2K ，有点激动，可能增加工作热情；第四次 … … ，直至涨薪已经带来不了任何效果。如果想避免这种情况，每次涨薪都想达到和第一次涨薪 1K 相同的效果，则第二次涨薪可能需要 2K ，第三次需要 3K … … ，或者使用其它激励措施，例如第二次可以安排其参加职业发展培训，第三次可以对其在职位上进行提升，虽然花费可能想当，但由于手段不同，达到了更好的效果。研究经济学其实也很有意思，只是对很多人来说，与 IT 这个行业不可完全兼得。\n\n1). 边际效应递减:边际效益递减是经济学的一个基本概念，它说的是在一个以资源作为投入的企业，单位资源投入对产品产出的效用是不断递减的，换句话，就是虽然其产出总量是递增的，但是其二阶倒数为负，使得其增长速度不断变慢，使得其最终趋于峰值，并有可能衰退。最明显的诠释，就是非线性函数，例如二次曲线。在生活中，我们可以看到许多例子：给你一个可爱多，你高兴的乱跳以为赚了，接下来是第二个……可是一直给你，你会觉得开始恶心了。这有两个原因：一，你吃饱 了，生理不需要了，二，你吃腻了，刺激受够了。你希望有个机会表白自己“老大，给个哈根啊好啊？”\n\n所谓的新官上任三把火，讲的也是这个道理：刚来了要混个脸熟，所以拼尽全力在所不辞。日子一久，也就澹了。一般的教材会这样解释：神秘莫测的心理学和社会 学。我们可以想想，边际效用递减式一个无处不在的规律，你想过四级，于是找了本宝书，从A背起，不错，一会儿就背完 呢（当然，本来A就不太多，我就是这种人），然后是B，然后是……B part2，然后是B part 2 1/2…级数的概念有了应用。当然你可以选择从Z开始背回头（当然，我也是这种人）。 可见，投入和产出是相同的概念，由于投入了就要求有产出，所以边际效益递减的逆仍然适用。 我们可以拓展到离开效用这个概念。让我们看一个实际中的问题： 昨天打扫房间卫生，发现刚刚擦过的桌子一层灰又上去了，和旁边的一个小支架看上去没什么区别。实际上，后者上次被美容的时候我还没在南京…… 一个东西从干净到涨很快，可是从脏到很脏是一个多么漫长的过程阿，指望考古队？（尽管也有评价的因素） 大家还可以想到很多很多，比如，人文一点，“失去的才是真”。\n\n我们如何利用这个规律呢？经济学的解释是资源的最优配置。因为投入的太多使得 最终的收益摊的太薄。再好的东西也有个限度。理工科的更加清楚，所谓的各种高级操作都是某种程度上的吃力不讨好，最有效的往往是那些基本操作。更高深的是 当然一些数学上的游戏。 然而我觉得，这个现象的起源绝对是一个哲学问题，那就是我们为什么进步和发展。 想想，如果边际效益递增，我们还需要创新吗？我们还需要坚持吗？同志们，可爱多足够了，不，凉水就行！魅力这个词，永远的就失去了意义。\n\n2). 边际效应递增: 有时候边际效应有时候也是递增的。当然也有少数例外情况，例如嗜酒如命的人，越喝越高兴，或者吸毒的人，越吸越想吸。或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。​\n\n# 超限效应\n美国着名幽默作家马克·吐温有一次在教堂听牧师演讲。最初，他觉得牧师讲得很好，使人感动，准备捐款。过了10分钟，牧师还没有讲完，他有些不耐烦了，决定只捐一些零钱。又过了10分钟，牧师还没有讲完，于是他决定，1分钱也不捐。到牧师终于结束了冗长的演讲，开始募捐时，马克·吐温由于气愤，不仅未捐钱，还从盘子里偷了2元钱。 这种刺激过多、过强和作用时间过久而引起心理极不耐烦或反抗的心理现象，称之为“超限效应”。 超限效应在家庭教育中时常发生。如：当孩子不用心而没考好时，父母会一次、两次、三次，甚至四次、五次重复对一件事作同样的批评，使孩子从内疚不安到不耐烦最后反感讨厌。被“逼急”了，就会出现“我偏要这样”的反抗心理和行为。 因为孩子一旦受到批评，总需要一段时间才能恢复心理平衡，受到重复批评时，他心里会嘀咕：“怎么老这样对我？”孩子挨批评的心情就无法复归平静，反抗心理就高亢起来。 可见，家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果非要再次批评，那也不应简单地重复，要换个角度，换种说法。这样，孩子才不会觉得同样的错误被“揪住不放”，厌烦心理、逆反心理也会随之减低。\n\n# 拆屋效应\n鲁迅先生曾于1927年在《无声的中国》一文中写下了这样一段文字：”中国人的性情总是喜欢调和、折中的，譬如你说，这屋子太暗，说在这里开一个天窗，大家一定是不允许的，但如果你主张拆掉屋顶，他们就会来调和，愿意开天窗了。”这种先提出很大的要求，接着提出较小较少的要求，在心理学上被称为”拆屋效应”。虽然这一效应在XXXXX生活中多见，但也有不少学生学会了这些。如有的学生犯了错误后离家出走，班主任很着急，过了几天学生安全回来后，班主任反倒不再过多地去追究学生的错误了。实际上在这里，离家出走相当于”拆屋”，犯了错误相当于”开天窗”，用的就是拆屋效应。因此，班主任在教育学生的过程中，教育方法一定要恰当，能被学生所接受，同时，对学生的不合理要求或不良的行为绝不能迁就，特别要注意不能让学生在这些方面养成与班主任讨价还价的习惯。\n\n# 刺猬法则\n刺猬法则可以用这样一个有趣的现象来形象地说明：两只困倦的刺猬由于寒冷而拥在一起，可怎么也睡不舒服，因为各自身上都长着刺，紧挨在一块，反而无法睡得安宁。几经折腾，两只刺猬拉开距离，尽管外面寒风呼呼，可它们却睡得甜乎乎的。刺猬法则就是人际交往中的“心理距离效应”。管理心理学专家的研究认为：领导者要搞好工作应该与下属保持亲密关系，但这是“亲密有间”的关系。特别要提醒的是，领导者与下属亲密无间地相处，还容易导致彼此称兄道弟、吃喝不分，并在工作中丧失原则。\n\n# 从众效应\n有一个成语叫做三人成虎，意思是说，有三个人谎报市上有老虎，听者就信以为真。这种人在社会群体中容易不加分析地接受大多数人认同的观点或行为的心理倾向被称为从众效应。这一效应的启示是：班主任要善于发挥从众效应的积极作用，首先要有意识地通过班会、黑板报等舆论阵地大张旗鼓地进行宣传；其次，要抓好班团干部和积极分子等基本队伍的建设，组成坚强的堡垒，要及时发现班上的不良倾向，对症下药，将其遏制在萌芽状态，以防止产生从众效应的负作用。 从众效应是指在群体活动中，当个人与多数人的意见和行为不一致时，个人放弃自己的意见和行为，表现出与群体中多数人相一致的意见和行为方式的现象。从众也就是我们日常俗语中所说的“随大流”。 促使一个人在合作中产生从众行为的因素有多种，一般认为主要有：小组里有较优势的学生存在；个性特质如智力的低、胆小、顾虑多、意志不坚定、自信心差、过于重视他人并依赖他人者等；小组人数的规模等因素。 毋庸质疑，从众有利于形成统一的小组意见，合理的小组环境可以促进或潜移默化地使落后的小组成员形成正确的思想与行为。同时，应该指出，在不合理的小组环境里，由于从众效应表现为趋向学习结论一致，而不一定是学习结论正确；部分学生容易与自信或学习优秀的小组成员的观点、思维方法形成一致，而忽视自己地观点、思维方法正确与否，小组合作的结果可能是以虚假的多数形成错误的小组结论。可见，从众效应容易压制正确思想的形成，窒息小组成员的独创精神；合作学习有时有弱化独立思考的趋势，个体在群体中容易丧失了对自我的控制，失去了个体感，使人“人云亦云”。我们需要的\n\n# 淬火效应\n金属工件加热到一定温度后，浸入冷却剂(油、水等)中，经过冷却处理，工件的性能更好、更稳定。长期受表扬头脑有些发热的学生，不妨设置一点小小的障碍，施以“挫折教育”，几经锻炼，其心理会更趋成熟，心理承受能力会更强；对于麻烦事或者已经激化的矛盾，不妨采用“冷处理”，放一段时间，思考得会更周全，办法会更稳妥。\n\n# 得寸进尺效应\n美国社会心理学家弗里得曼做了一个有趣的实验：他让助手去访问一些家庭主妇，请求被访问者答应将一个小招牌挂在窗户上，她们答应了。过了半个月，实验者再次登门，要求将一个大招牌放在庭院内，这个牌子不仅大，而且很不美观。同时，实验者也向以前没有放过小招牌的家庭主妇提出同样的要求。结果前者有55%的人同意，而后者只有不到17%的人同意，前者比后者高3倍。后来人们把这种心理现象叫作“得寸进尺效应”。心理学认为，人的每个意志行动都有行动的最初目标，在许多场合下，由于人的动机是复杂的，人常常面临各种不同目标的比较、权衡和选择，在相同情况下，那些简单容易的目标容易让人接受。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会继续下去。上述心理效应告诉我们，要让他人接受一个很大的、甚至是很难的要求时，最好先让他接受一个小要求，一旦他接受了这个小要求，他就比较容易接受更高的要求。差生作为一个特殊群体，其身心素质和学习基础等方面都低于一般水平。转化差生，也要像弗里得曼一样善于引导，善于“搭梯子”，使之逐渐转化；应贯彻“小步子、低台阶、勤帮助、多照应”的原则，注意“梯子”依靠的地方要正确、间距不宜太大、太陡，做到扶一扶“梯子”，托一托人。\n\n# 定势效应\n有一个农夫丢失了一把斧头，怀疑是邻居的儿子偷盗，于是观察他走路的样子，脸上的表情，感到言行举止就像偷斧头的贼。后来农夫找到了丢失的斧头，他再看邻居的儿子，竟觉得言行举止中没有一点偷斧头的模样了。这则故事描述了农夫在心理定势作用下的心理活动过程。所谓心理定势是指人们在认知活动中用“老眼光”——已有的知识经验来看待当前的问题的一种心理反应倾向，也叫思维定势或心向。在人际交往中，定势效应表现在人们用一种固定化了的人物形象去认知他人。例如：我们与老年人交往中，我们会认为他们思想僵化，墨守成规，跟不上时代；而他们则会认为我们年纪轻轻，缺乏经验，“嘴巴无毛，办事不牢”。与同学相处时，我们会认为诚实的人始终不会说谎；而一旦我们认为某个人老奸巨猾，既使他对你表示好感，你也会认为这是“黄鼠狼给鸡拜年没安好心”。 心理定势效应常常会导致偏见和成见，阻碍我们正确地认知他人。所以我们要“士别三日，当刮目相看”他人呀！不要一味地用老眼光来看人处事。\n\n# 多看效应\n转在许多人眼中，喜新厌旧是人的天性。然而,事实果真是如此吗?20世纪60年代,心理学家查荣茨做过试验:先向被试出示一些照片,有的出现了20多次,有的出现了10多次,有的只出现一两次,然后请别试评价对照片的喜爱程度,结果发现,被试更喜欢那些只看过几次的新鲜照片,既看的次数增加了喜欢的程度.这种对越熟悉的东西就越喜欢的现象,心理学上称为多看效应.在人际交往中,如果你细心观察就会发现,那些人缘很好的人,往往将多看效应发挥的淋漓尽致:他们善于制造双方接触的机会,已提高彼此间的熟悉度,然后互相产生更强的吸引力.人际吸引难道真的是如此的简单?有社会心理学的实验做佐证:在一所大学的女生宿舍楼里,心理学家随机找了几个寝室,发给她们不同口味的饮料,然后要求这几个寝室的女生,可以以品尝饮料为理由,在这些寝室间互相走动,但见面时不得交谈.一段时间后,心理学家评估她们之间的熟悉和喜欢的程度,结果发现:见面的次数越多,互相喜欢的程度越大:见面的次数越少或根本没有,相互喜欢的程度也较低.\n\n可见,若想增强人际吸引,就要留心提高自己在别人面前的熟悉度,这样可以增加别人喜欢你的程度.因此,一个自我封闭的人,或是一个面对他人就逃避和退缩的人，由于不易让人亲近而另人费解,也就是太讨人喜欢.\n\n当然,多看效应发挥作用的前提,是首因效应要好,若给人的第一印象不很差,则见面越多就越讨人厌,多看效应反而起了副用.\n\n# 首因效应\n首因效应，是人与人第一次交往中给人留下的印象，在对方的头脑中形成并占据着主导地位的效应。首因效应也叫首次效应、优先效应或第一印象效应。它是指当人们第一次与某物或某人相接触时会留下深刻印象，个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。 第一印象作用最强，持续的时间也长，比以后得到的信息对于事物整个印象产生的作用更强。首因，是指首次认知客体而在脑中留下的第一印象。首因效应，是指个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。\n\n# 近因效应\n所谓近因效应：与首因效应相反. 最近、最后的印象，往往是最强烈的，可以冲澹在此之前产生的各种因素，这就是近因效应。有这样一个例子：面试过程中，主考官告诉考生可以走了，可当考生要离开考场时，主考官又叫住他，对他说，你已回答了我们所提出的问题，评委觉得不怎么样，你对此怎么看？其实，考官做出这么一种设置，是对毕业生的最后一考，想借此考察一下应聘者的心理素质和临场应变能力。如果这一道题回答得精彩，大可弥补此前面试中的缺憾；如果回答得不好，可能会由于这最后的关键性试题而使应聘者前功尽弃\n\n# 凡勃伦效应\n一些商品价格定得越高，就越能受到消费者的青睐。我们经常在生活中看到这样的情景：款式、皮质差不多的一双皮鞋，在普通的鞋店卖80元，进入大商场的柜台，就要卖到几百元，却总有人愿意买。1.66万元的眼镜架、6.88万元的纪念表、168万元的顶级钢琴，这些近乎“天价”的商品流通，往往也能在市场上走俏。其实，消费者购买这类商品的目的并不仅仅是为了获得直接的物质满足和享受，更大程度上是为了获得心理上的满足。这就出现了一种奇特的经济现象，即一些商品价格定得越高，就越能受到消费者的青睐。由于这一现象最早由美国经济学家凡勃伦注意到，因此被命名为“凡勃伦效应”。随着社会经济的发展，人们的消费会随着收入的增加，而逐步由追求数量和质量过渡到追求品位格调。了解了“凡勃伦效应”，我们也可以利用它来探索新的经营策略。比如凭借媒体的宣传，将自己的形象转化为商品或服务上的声誉，使商品附带上一种高层次的形象，给人以“名贵”和“超凡脱俗”的印象，从而加强消费者对商品的好感。这种价值的转换在消费者从数量，质量购买阶段过渡到感性购买阶段时，就成为可能。实际上，在东南沿海的一些发达地区，感性消费已经逐渐成为一种时尚，而只要消费者有能力进行这种感性购买时，“凡勃伦效应”就可以被有效地转化为提高市场份额营销策略。\n\n# 共生效应\n植物界中相互影响、相互促进的现象,称之为:共生效应 在自然界，一株植物单独生长时，往往长势不旺，没有生机，甚至枯萎衰败，而当众多植物一起生长时，却能郁郁葱葱，挺拔茂盛，人们把这种植物中这种相互影响、相互促进的现象称之为“共生效应”。 共生就是两者相互利用（虽然这个词是贬义词，但实际就是这样），同时有利于双方发展的现象，这种情况应不仅限于自然界，人类社会也会有。\n\n# 黑暗效应\n在光线比较暗的场所，约会双方彼此看不清对方表情，就很容易减少戒备感而产生安全感。在这种情况下，彼此产生亲近的可能性就会远远高于光线比较亮的场所。心理学家将这种现象称之为“黑暗效应”。有个这样的案例：有一位男子钟情于一位女子，但每次约会，他总觉得双方谈话不投机。有一天晚上，他约那位女子到一家光线比较暗的酒吧，结果这次谈话融洽投机。从此以后，这位男子将约会的地点都选择在光线比较暗的酒吧。几次约会之后，他俩终于决定结下百年之好。 社会心理学家研究后的结论是，在正常情况下，一般的人都能根据对方和外界条件来决定自己应该掏出多少心里话，特别是对还不十分了解但又愿意继续交往的人，既有一种戒备感，又会自然而然地把自己好的方面尽量展示出来，把自己弱点和缺点尽量隐藏起来。因此，这时双方就相对难以沟通。\n\n# 棘轮效应\n商朝时，纣王登位之初，天下人都认为这位精明的国君的治理下，商朝的江山一定会坚如磐石。有一天，纣王命人用象牙做了一双筷子，十分高兴地使用这双象牙筷子就餐。他的叔父箕子见了，劝他收藏起来，而纣王却满不在乎，满朝文武大臣也不以为然，认为这本来是一件很平常的小事。箕子为此忧心忡忡，有的大臣莫名其妙地问他原因，箕子回答说：“纣王用象牙做筷子，必定再不会用土制的瓦罐盛汤装饭，肯定要改用犀牛角做成的杯子和美玉制成的饭碗；有了象牙筷、犀牛角杯和美玉碗，难道还会用它来吃粗茶澹饭和豆子煮的汤吗？大王的餐桌从此顿顿都要摆上美酒佳肴了；吃的是美酒佳肴，穿的自然要绫罗绸缎，住的就要求富丽堂皇，还要大兴土木筑起楼台亭阁以便取乐了。对这样的后果我觉得不寒而栗。”仅仅5年时间，箕子的预言果然应验了，商纣王瓷意骄奢，便断送了商汤绵延500年的江山。在上面的故事中，箕子对纣王使用象牙筷子的评价，运用了现代经济学一种消费效应――棘轮效应。所谓棘轮效应，又称制轮作用，是指人的消费习惯形成之后有不可逆性，即易于向上调整，而难于向下调整。尤其是在短期内消费是不可逆的，其习惯效应较大。这种习惯效应，使消费取决于相对收入，即相对于自己过去的高峰收入。这一效应是经济学家杜森贝提出的。古典经济学家凯恩斯主张消费是可逆的，即绝对收入水平变动必然立即引起消费水平的变化。针对这一观点，杜森贝认为这实际上是不可能的，因为消费决策不可能是一种理想的计划，它还取决于消费习惯。这种消费习惯受许多因素影响，如生理和社会需要、个人的经历、个人经历的后果等。特别是个人在收入最高期所达到的\n\n从个人的角度来说，我们对于欲望既不能禁止，也不能放纵，对于过度的及至贪得无厌的奢求，必须加以节制。如果对自己的欲望不加限制的话，过度地放纵奢侈，没能培养俭仆的生活习惯，必然会使自古“富不过三代”之说就成了必然，就必然出现“君子多欲，则贪慕富贵，枉道速祸；小人多欲，则多求妄用，败家丧身。是以居官必贿，居乡必盗”的情况。西方一些成功企业家虽家境富裕，但依然对子女要求极严，从不给孩子更多的零花钱，甚至寒暑假还让孩子四处打工。这些成功企业家并不是苛求子女能为自己多赚一点钱，而是希望子女懂得每一分钱的来之不易，懂得俭仆和自立。\n\n# 奖惩效应\n奖励和惩罚是对学生行为的外部强化或弱化的手段，它通过影响学生的自身评价，能对学生的心理产生重大影响，由奖惩所带来的行为的强化或弱化就叫做奖惩效应。心理学实验证明，表扬、鼓励和信任，往往能激发一个人的自尊心和上进心。但奖励学生的原则应是精神奖励重于物质奖励，否则易造成”为钱而学”、”为班主任而学”的心态。同时奖励要抓住时机，掌握分寸，不断升化。当然”没有惩罚就没有教育”，必要的惩罚是控制学生行为的有效信号。惩罚时用语要得体、适度、就事论事，使学生明白为什么受罚和怎样改过。同时还应注意的是奖惩的频率，从心理学的研究结果看，当奖惩的比例为5：1时往往效果最好。\n\n# 结伴效应\n是指两个人或几个人结伴从事相同的一项活动时（并不进行竞赛）相互之间会产生刺激作用，提高活动效率。例如：学生在一起作作业比独立完成作业的效率高。 可以相应组成学习小组。教师应注意课上的效率，注意时间分配。…\n\n# 空白效应\n心理实验表明，在演讲的过程中，适当地留一些空白，会取得良好的演讲效果，这就是空白效应。它给我们的启示是，班主任要善于留白，如在表达方面留白，针对某些问题，班主任不妨先不说出自己的观点，让学生去想、去说，让学生有表达自己意见的机会。在实践方面留白，给学生一个锻炼和实践的机会，提高学生的动手能力。在思考方面留白，班主任应给学生思考分析的机会，让学生独立地思考、判断和面对，学生的分析能力就会逐渐提高。在批评方面留白，批评之后，留有学生自己去思考、自己去责备的时间。这样学生就不会有一种被”穷追不舍”之感，反抗心理就会锐减。\n\n# 青蛙现象\n青蛙现象：把一只青蛙直接放进热水锅里，由于它对不良环境的反应十分敏感，就会迅速跳出锅外。如果把一个青蛙放进冷水锅里，慢 慢地加温，青蛙并不会立即跳出锅外，水温逐渐提高的最终结局是青蛙被煮死了，因为等水温高到青蛙无法忍受时，它已经来不及、或者说是没有能力跳出锅外了。青蛙现象告诉我们，一些突变事件，往往容易引起人们的警觉，而易致人于死地的却是在自我感觉良好的情况下，对实际情况的逐渐恶化，没有清醒的察觉。启示之一是：我们的组织和社会生存的主要威胁，并非来自突如其来的事件，而是由缓慢渐进而无法察觉的过程形成。人们目光短浅，只看到局部，而无法纵观全局，对于突如其来的变化，可以从容面对，对于悄悄发生的大的变化，而无法察觉，最终会带给我们更加严重的危害！~启示之二是：青蛙，就好象是我们生活中的芸芸众生，我们要着眼未来，勤于思考新的问题，勤于学习新的知识，不能过“今日有酒，今日醉”和“当一天和尚，撞一天钟”的醉生梦死的生活，到头来将是非常可悲的！\n\n启示之三是：当今的社会，是一个知识爆炸、日新月异的时代，知识也需要不断更新，所以我们不要一味的沉迷于现状、安于现状，不思进取，这样下去的话，肯定会被时代所淘汰，也会有面临失业的危险！\n\n启示之四是：我们不要单纯的，只能面对突如其来的危险，而忽视那种缓慢而又微小甚微的危险，因为，那种缓慢而又微小甚微的危险，才是最可怕的！\n\n# 21天效应\n在行为心理学中，人们把一个人的新习惯或理念的形成并得以巩固至少需要21天的现象，称之为21天效应。也就是说，一个人的动作、或想法，如果重复21天就会变成一个习惯性的动作或想法。\n\n根据我国成功学专家易发久研究，习惯的形成大致分为三个阶段：\n\n第一阶段：1-7天左右。此阶段表现为“刻意，不自然”，需要十分刻意地提醒自己。\n\n第二阶段：7-21天左右。此阶段表现为“刻意，自然”，但还需要意识控制。\n\n第三阶段：21-90天左右，此阶段表现为“不经意，自然”，无需意识控制。\n\n# 本杰明富兰克林效应\n让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。—— 本杰明·富兰克林效应,\n\n本杰明 富兰克林效应的现象启示我们，如果你对一个人行善举，那么往往会得到好的结果。当然这绝非是种“果报”理论\n本杰明 富兰克林曾表示，通过向一个不喜爱他的议员借书，他们俩最终成为了要好的朋友。认知失调理论的解释为，如果我们去帮助一个不喜欢的人，结果说不定就会喜欢上他—— 当我们给予不喜欢的人帮助时，其实是经历了一种失调，我们的行为和对此人的态度之间发生了矛盾。为了缓解这种失调，我们会尽力说服自己这个人是好的、值得帮助的，从而注意并强调了其优点，而澹化了自己本来不喜爱他的事实。这个故事倒是给了我们一点启示：如果想追求一个本来不怎么喜欢你的姑娘，或许也可以通过求得她帮忙的方式来逐步制造她对你的好感呢？\n\n# 史密斯原则\n如果你不能战胜他们，你就加入到他们之中去。竞争使人进步最快，合作让人得到最多。\n\n# 鸟笼逻辑\n挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里。这就是鸟笼逻辑。过程很 简单，设想你是这房间的主人，只要有人走进房间，看到鸟笼，就会忍不住问你：“鸟呢？是不是死了？”当你回答：“我从来都没有养过鸟。”人们会问：“那么，你要一个鸟笼干什么？”最后你不得不在两个选择中二选一，因为这比无休止的解释要容易得多。鸟笼逻辑的原因很简单：人们绝大部分的时候是采取惯性思维。所以可见在生活和工作中培养逻辑思维是多么重要\n\n# 责任分散效应\n1964年3月13日夜3时20分，在美国纽约郊外某公寓前，一位叫朱诺比白的年轻女子在结束酒巴间工作回家的路上遇刺。当她绝望地喊叫：“有人要杀人 啦!救命!救命!”听到喊叫声，附近住户亮起了灯，打开了窗户，凶手吓跑了。当一切恢复平静后，凶手又返回作案。当她又叫喊时，附近的住户又打开了电灯， 凶手又逃跑了。当她认为已经无事，回到自己家上楼时，凶手又一次出现在她面前，将她杀死在楼梯上。在这个过程中，尽管她大声呼救，她的邻居中至少有38位 到窗前观看，但无一人来救她，甚至无一人打电话报警。这件事引起纽约社会的轰动，也引起了社会心理学工作者的重视和思考。人们把这种众多的旁观者见死不救 的现象称为责任分散效应。对于责任分散效应形成的原因，心理学家进行了大量的实验和调查，结果发现：这种现象不能仅仅说是众人的冷酷无 情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己 的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担， 造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的 局面。如何打破这种局面，这是心理学家正在研究的一个重要课题。\n\n# 虚假同感偏差\n我们通常都会相信，我们的爱好与大多数人是一样的。如果你喜欢玩电脑游戏，那么就有可能高估喜欢电脑游戏的人数。你也通常会 高估给自己喜欢的同学投票的人数，高估自己在群体中的威信与领导能力等等。你的这种高估与你的行为及态度有相同特点的人数的倾向性就叫做“虚假同感偏 差”。有些因素会影响你的这种虚假同感偏差强度：\n\n当外部的归因强于内部归因时；\n当前的行为或事件对某人非常重要时；\n当你对自己的观点非常确定或坚信时；\n当你的地位或正常生活和学习受到某种威胁时；\n当涉及到某种积极的品质或个性时；\n当你将其他人看成与自己是相似时。\n美人效应\n罗马一家自助餐厅的老板想出一个赚小费的妙计。他请来一位非常漂亮的姑娘，坐在柜台边收钱，以便使男客们神魂颠倒，慷慨解囊。谁知那位姑娘上班后没过几天，就对老板说：“我想，我不如以前漂亮了。”老板忙问：“这是怎么回事呢？”“现在，所有的男客都在柜台边反复地数找给他们的零钱。”美人效应在这里发挥的作用正是挖掘潜在消费和增加客人满意程度，增强餐厅的竞争优势，从而留住客人。\n\n# 潘多拉效应\n古希腊有个神话，说宙斯给一个名叫潘多拉的女孩一个盒子，告诉她绝对不能打开。“为什么不能打开？还要‘绝对’？里面该不是稀世珍宝吧？”潘多拉越想越好 奇，越想揭开真相。憋了一段时间后，她终于把盒子打开了。谁知盒子里装的是人类的全部罪恶，结果让它们都跑到人间了。心理学把这种“不禁不为、愈禁愈为” 的现象，叫“潘多拉效应”或“禁果效应”。潘多拉效应的心理实质是好奇心和逆反心理在起作用。\n\n# 光环效应\n也叫晕轮效应, 晕轮原指月亮被光环笼罩时产生的模煳不清的现象。晕轮效应是一种普通存在的心理现象，即对一个人进行评价时，往往会因对他的某一品质特征的强烈、清晰的感知，而掩盖了其他方面的品质。毕业生在求职应聘中，如果能够巧妙地运用这种晕轮效应，把自身的优势充分地展现出来，一定会给招聘考官留下深刻的印象，赢得对方的赏识，取得面试的成功。比如，当招聘者问及你的英语水平时，你便用英语熟练地与其交谈，必然会引起招聘者的极大兴趣，很可能当场便与你拍板“成交”。但在运用这一效应时一定要注意，不能刻意制造“光环”效果，那种虚妄做出的行为，往往适得其反。\n\n# 冷热水效应\n一杯温水，保持温度不变，另有一杯冷水，一杯热水。当先将手放在冷水中，再放到温水中，会感到温水热；当先将手放在热水中，再放到温水中，会到温水凉。同一杯温水，出现了两种不同的感觉，这就是冷热水效应。这种现象的出现，是因为人人心里都有一杆秤，只不过是秤砣并不一致，也不固定。随着心理的变化，秤砣也在变化。当秤砣变小时，它所称出的物体重量就大，当秤砣变大时，它所称出的物体重量就小。人们对事物的感知，就是受这秤砣的影响。人际交往中，要善于运用这种冷热水效应。 运用冷热水效应，可以获得对方的好评。 人处世上，难免有事业上滑坡的时候，难免有不小心伤害他人的时候，难免有需要对他人进行批评指责的时候，在这些时候，假若处理不当，就会降低自己在他人心目中的形象。如果巧妙运用冷热水效应，就不但不会降低自己的形象，反而会获得他人一个好的评价。当事业上滑坡的时候，不妨预先把最糟糕的事态委婉地告诉别人，以后即使失败也可立于不败之地；当不小心伤害他人的时候，道歉不妨超过应有的限度，这样不但可以显示出你的诚意，而且会收到化干戈为玉帛的效果；当要说令人不快的话语时，不妨事先声明，这样就不会引起他人的反感，使他人体会到你的用心良苦。这些运用冷热水效应的举动，实质上就是先通过一二处“伏笔”，使对方心中的“秤砣”变小，如此一来，它“称出的物体重量”也就大了。某汽车销售公司的老李，每月都能卖出30辆以上汽车，深得公司经理的赏识。由于种种原因，老李预计到这个月只能卖出10辆车。深懂人性奥妙的老李对经理说：“由于银根紧缩，市场萧条，我估计这个月顶多卖出5辆车。”经理点了点头，对他的看法表示赞成。没想到一个月过后，老李竟然卖了12辆汽车，公司经理对他大大夸奖一番。假若老李说本月可以卖15辆或者事先对此不说，结果只卖了12辆，公司经理会怎么认为呢？他会强烈地感受到老李失败了，不但不会夸奖，反而可能指责。在这个事例中，老李把最糟糕情况――顶多卖5辆车，报告给经理，使得经理心中的“秤砣”变小，因此当月绩出来以后，对老李的评价不但不会降低，反而提高了。 蔡女士很少演讲，一次迫不得已，她对一群学者、评论家进行演说。她的开场白是：“我是一个普普通通的家庭妇女，自然不会说出精彩绝伦的话语，因此恳请各位专家对我的发言不要笑话……”经她这么一说，听众心中的“秤砣”变小了，许多开始对她怀疑的人，也在专心听讲了。她的简单朴实演说完成后，台下的学者、评论家们感到好极了，他们认为她的演说达到了极高的水平。对于蔡女士的成功演讲，他们抱以热烈的掌声。当一个人不能直接端给他人一盆“热水”时，不妨先端给他人一盆“冷水”，再端给他人一盆“温水”，这样的话，这人的这盆“温水”同样会获得他人的一个良好评价。\n\n# 临近效应\n两个人能否成为朋友，这与俩人住处的远近有很大关系。这被称为邻近效应。那么为什么邻近性会引发好感呢？\n\n(增强亲近感) - 邻近性一般都会增强亲近感。住得近的人自然碰面的机会也相对频繁，重复的接触就会引发、增强相互间的好感。\n(强烈的相似性) - 人们大多选择社会地位、经济实力与自己相近的人为邻，而地理位置上的邻近性进一步增强了人们的相似性。\n(越是邻近的人，其可利用度也越高) - 邻居之间不用花费太多的时间和费用便可成为好朋友，而且有很多事可以相互嘱托，有快乐可以共同分享。比如可以请邻居照看孩子或房子，家里不管发生什么大事小事都可以相互照应。\n(认知的一贯性) - 与讨厌的人比邻而居，在心理上是难以忍受的。人们在交往中大多愿意接近与自己合得来、住所比较近的人。\n\n# 名人效应\n美国心理学家曾做过一个有趣的实验，在给大学心理系学生讲课时，向学生介绍说聘请到举世闻名的化学家。然后这位化学家说，他发现了一种新的化学物质，这种物质具有强烈的气味，但对人体无害。在这里只是想测一下大家的嗅觉。接着打开瓶盖，过了一会儿，他要求闻到气味的同学举手，不少同学举了手，其实这只瓶子里只不过是蒸馏水，”化学家”是从外校请来的德语教师。这种由于接受名人的暗示所产生的信服和盲从现象被称为名人效应。名人效应的产生依赖于名人的权威和知名度，名人之所以成为名人，在他们那一领域必然有其过人之处。名人知名度高，为世人所熟悉、喜爱，所以名人更能引起人们的好感、关注、议论和记忆。由于青少年的认识特点及心理发展，他们所希望的名人多为形式化、表面性的形象所吸，他们喜欢的名人多为歌星、影星一类，出现追星现象。这就要求班主任要为学生选择好”名人”，以促进学生的健康成长。\n\n# 墨菲定律\n(Murphy’s Law)缘于美国一位名叫墨菲的上尉。他认为他的某位同事是个倒霉蛋，不经意说了句笑话：“如果一件事情有可能被弄糟，让他去做就一定会弄糟。”这句话迅速流传。经过多年，这一“定律”逐渐进入习语范畴，其内涵被赋予无穷的创意，出现了众多的变体，“如果坏事有可能发生，不管这种可能性多么小，它总会发生，并引起最大可能的损失”、“If anything can go wrong, it will.(会出错的，终将会出错)”、“笑一笑，明天未必比今天好。”“东西越好，越不中用”、“别试图教猪唱歌，这样不但不会有结果，还会惹猪不高兴!”墨菲定律的原话是这样说的：If there are two or more ways to do something, and one of those ways can result in a catastrophe, then someone will do it.(如果有两种选择，其中一种将导致灾难，则必定有人会作出这种选择。)\n\n根据“墨菲定律”，一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四，如果你担心某种情况发生，那么它就更有可能发生。我们都有这样的体会，如果在街上准备拦一辆车去赴一个时间紧迫的约会，你会发现街上所有的出租车不是有客就是根本不搭理你，而当你不需要租车的时候，却发现有很多空车在你周围游弋，只待你的一扬手，车随时就停在你的面前。如果一个月前在浴室打碎镜子，尽管仔细检查和冲刷，也不敢光着脚走路，等过了一段时间确定没有危险了，不幸的事还是照样发生，你还是被碎玻璃扎了脚。如果你把一片干面包掉在你的新地毯上，它两面都可能着地。但你把一片一面涂有果酱的面包掉在新地毯上，常常是有果酱的那面朝下。\n\n墨菲定律告诉我们，容易犯错误是人类与生俱来的弱点，不论科技多发达，事故都会发生。而且我们解决问题的手段越高明，面临的麻烦就越严重。所以，我们在事前应该是尽可能想得周到、全面一些，如果真的发生不幸或者损失，就笑着应对吧，关键在于总结所犯的错误，而不是企图掩盖它。\n\n2003年美国“哥伦比亚”号航天飞机即将返回地面时，在美国得克萨斯州中部地区上空解体，机上6名美国宇航员以及首位进入太空的以色列宇航员拉蒙全部遇难。“哥伦比亚”号航天飞机失事也印证了墨菲定律。如此复杂的系统是一定要出事的，不是今天，就是明天，合情合理。一次事故之后，人们总是要积极寻找事故原因，以防止下一次事故，这是人的一般理性都能够理解的，否则，或者从此放弃航天事业，或者听任下一次事故再次发生，这都不是一个国家能够接受的结果\n\n人永远也不可能成为上帝，当你妄自尊大时，“墨菲定律”会叫你知道厉害；相反，如果你承认自己的无知，“墨菲定律”会帮助你做得更严密些。\n\n这其实是概率在起作用，人算不如天算，如老话说的“上的山多终遇虎”。还有“祸不单行”。如彩票，连着几期没大奖，最后必定滚出一个千万大奖来，灾祸发生的概率虽然也很小，但累积到一定程度，也会从最薄弱环节爆发。所以关键是要平时清扫死角，消除不安全隐患，降低事故概率。\n\n# 破窗效应\n美国心理学家詹巴斗曾经做过一个”偷车实验”，将两辆一模一样的轿车分别放在一个环境很好的中产阶级社区和环境比较脏乱的贫民区，结果发现贫民区的车很快被偷走了，而另一辆几天后仍然完好无损；如果将中产阶级社区的那辆车的天窗玻璃打破，几个小时后，那辆车也被偷了。后来，在此实验基础上，美国政治学家威尔逊和犯罪学家凯林提出了有名的”破窗理论”：如果有人打坏了一栋建筑上的一块玻璃，又没有及时修好，别人就可能受到某些暗示性的纵容，去打碎更多的玻璃。 “破窗理论”体现的是细节对人的暗示效果，以及细节对事件结果不容小视的重要作用。事实证明，”破窗理论”也确实能够指导我们的生活。 18世纪的纽约以脏乱差闻名，环境恶劣，同时犯罪猖獗，地铁的情况尤为严重，是罪恶的延伸地，平均每7个逃票的人中就有一个通缉犯，每20个逃票的人中有一个携带武器者。1994年，新任警察局长布拉顿开始治理纽约。他从地铁的车箱开始治理：车箱干净了，站台跟着也变干净了，站台干净了，阶梯也随之整洁了，随后街道也干净了，然后旁边的街道也干净了，后来整个社区干净了，最后整个纽约变了样，变整洁漂亮了。现在纽约是全美国治理最出色的都市之一，这件事也被称为”纽约引爆点”。 还有一个被称为校园里的”破窗现象”：班里新来了一个留级生，由于他的勤奋努力，使得原本想混日子的同学受到震动，学习气氛开始转好，有时老师反复强调的重点，有的人或许不以为然，但是他的一句话–这个内容要考试–便会立即引起同学们的高度重视，留级生的话比老师的话还有效！这说明及时修好第一扇被打破的玻璃，能有效阻止”破窗现象”于萌芽状态。 将”破窗理论”中的玻璃\n\n在公共场合大声说话，暗示一个人喜欢表现自己；\n\n穿什么样的袜子，暗示一个人的品位如何；\n\n在背后说别人坏话的人，在暗示他不可信任；\n\n对任何事都怀疑的人，暗示他是一个悲观主义者；\n\n对任何事都不满的人，暗示他是一个愤世嫉俗者；\n\n不贪小便宜的人，暗示他很正直……\n\n每件大事都由无数小事–也就是细节构成，将细节尽量做到完美，将来的结果才有可能完美。人的一生也由无数细节组成，将小事做好，给他人留下美好印象，将来才会更美好。\n\n# 热手效应\n如果篮球队员投篮连续命中，球迷一般都相信球员“手感好”，下次投篮还会得分。在轮盘游戏中，赌徒往往认定其中的红黑两色会交替出现，如果之前红色出现过多，下次更可能出现黑色。可是，直觉未必是靠得住的。事实上，第一次投篮和第二次投篮是否命中没有任何联系，转动一回轮盘，红色和黑色出现的机会也总是0.5。就像受“热手效应”误导的球迷或受“赌徒谬误”左右的赌徒，投资者预测股价也容易受到之前价格信息的影响，用直觉代替理性分析，产生所谓的“启发式心理”。举个例子，一家制药公司的股价长期上扬，在初期，投资者可能表现为“热手效应”，认为股价的走势会持续，“买涨不买跌”；可一旦股价一直高位上扬，投资者又担心上涨空间越来越小，价格走势会“反转”，所以卖出的倾向增强，产生“赌徒谬误”。“‘热手效应’与‘赌徒谬误’都来自人们心理学上的认知偏差－即认为一系列事件的结果都在某种程度上隐含了自相关的关系”。由南京大学商学院的林树、复旦大学管理学院和清华大学公共管理学院的俞乔、汤震宇、周建四位学者组成的团队，利用心理学实验的方法研究了中国的个体投资者在面对过去股价信息时的交易行为与心理预期。林树、俞乔等发表在《经济研究》8月号、题为《投资者“热手效应”与“赌徒谬误”的心理实验研究》的文章发现，“在中国资本市场上具有较高教育程度的个人投资者或潜在个人投资者中，‘赌徒谬误’效应对股价序列变化的作用均要强于‘热手效应’，占据支配地位”，也就是说，无论股价连续上涨还是下跌，投资者更愿意相信价格走势会逆向反转。根据这一发现，研究认为“在中国股票市场处于中长期‘熊市\n\n# 睡眠效应\n使坏印象随时间的流逝而消失邮递销售或上门销售中有这样一项保护消费者的制度，即使是已签定的买卖合同，只要超过了一定期限就会被自动失效。这个制度被称为“冷却制”（coolingoff）。这里的“cooling”是指从一开始认为“很好”到后来可能认为不怎么样的这段冷却期。反过来，起初认为“没有什么好处”的坏印象也可能由于时间的流逝而消失，继而产生好印象。心理学称这种现象为睡眠效应。比如谈判陷入僵局即将破裂时，提出“先吃午饭，等吃完后再做决定吧”，让双方有一段冷静思考的时间。等重开谈判时，进展会异常顺利。谈判到达高潮时或刚刚进行劝说后，给予对方一段思考的时间，会收到良好的效果。因为劝说者与劝说内容的暂时分离会增加信息的可信度，使对方作出冷静的判断。\n\n# 羊群效应\n是指管理学上一些企业的市场行为的一种常见现象。例如一个羊群（集体）是一个很散乱的组织，平时大家在一起盲目地左冲右撞。如果一头羊发现了一片肥沃的绿草地，并在那里吃到了新鲜的青草，后来的羊群就会一哄而上，争抢那里的青草，全然不顾旁边虎视眈眈的狼，或者看不到其它还有更好的青草。 羊群效应的出现一般在一个竞争非常激烈的行业上，而且这个行业上有一个领先者（领头羊）占据了主要的注意力，那么整个羊群就会不断摹仿这个领头羊的一举一动，领头羊到哪里去吃草，其它的羊也去哪里淘金。搜索引擎这个市场上的竞争加剧的情况下，搜索引擎的巨头之间对对手之间的动作非常的注意，一旦一个搜索引擎出现某一个新的功能，或者进入一个新的领域，众多的搜索引擎都会去尝试这个新的“水草地”是否真的肥美，是否真得有利可图。\n\n# 异性效应\n在人际关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对人的活动和学习通常起积极的影响。这种现象称为“异性效应”. 心理学家曾在一次测试中发现，男性在男、女同桌就餐地要比单纯男性. 就餐时要文明许多，这是由于大多数人在异性面前更注意自己的言行。\n\n# 马斯洛需求层次理论\nMaslow’s hierarchy of needs, 该理论将需求分为五种，像阶梯一样从低到高，按层次逐级递升，分别为：生理上的需求，安全上的需求，情感和归属的需求，尊重的需求，自我实现的需求。\n\n需求层次理论有两个基本出发点，一是人人都有需要，某层需要获得满足后，另一层需要才出现；二是在多种需要未获满足前，首先满足迫切需要；该需要满足后，后面的需要才显示出其激励作用。一般来说，某一层次的需要相对满足了，就会向高一层次发展，追求更高一层次的需要就成为驱使行为的动力。相应的，获得基本满足的需要就不再是一股激励力量。五种需要可以分为两级，其中生理上的需要、安全上的需要和感情上的需要都属于低一级的需要，这些需要通过外部条件就可以满足；而尊重的需要和自我实现的需要是高级需要，他们是通过内部因素才能满足的，而且一个人对尊重和自我实现的需要是无止境的。同一时期，一个人可能有几种需要，但每一时期总有一种需要占支配地位，对行为起决定作用。任何一种需要都不会因为更高层次需要的发展而消失。各层次的需要相互依赖和重叠，高层次的需要发展后，低层次的需要仍然存在，只是对行为影响的程度大大减小\n\n另外两种需要：求知需要和审美需要。这两种需要未被列入到他的需求层次排列中，他认为这二者应居于尊重需求与自我实现需求之间。\n\n# 卢维斯定理\n谦虚不是把自己想得很糟，而是完全不想自己。如果把自己想得太好，就很容易将别人想得很糟。\n\n# 托利得定理\n测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。","slug":"常见的心理学效应","published":1,"updated":"2020-01-29T02:55:54.012Z","_id":"ck5xwo6wv0001m7iy62xubcsy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>常见的心理学效应，每天学习一下，站在更高一点的位置看人的行为，会让我们活的更通透一些。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"承诺定律\"><a href=\"#承诺定律\" class=\"headerlink\" title=\"承诺定律\"></a>承诺定律</h1><p>承诺未必可以保证一定做到，但是如果你没有做出承诺，就算你做到了也没有价值。​</p>\n<h1 id=\"苹果定律\"><a href=\"#苹果定律\" class=\"headerlink\" title=\"苹果定律\"></a>苹果定律</h1><p>如果有一堆苹果，有好有坏，你就应该先吃好的，把坏的令人扔掉，如果你先吃坏的，好的也会变坏，你将永远吃不到好的苹果，人生亦如此。</p>\n<h1 id=\"价值定律\"><a href=\"#价值定律\" class=\"headerlink\" title=\"价值定律\"></a>价值定律</h1><p>当你拥有一项东西的时候，你就会发现这种东西并不像你原来所想的那样有价值。</p>\n<h1 id=\"酝酿效应\"><a href=\"#酝酿效应\" class=\"headerlink\" title=\"酝酿效应\"></a>酝酿效应</h1><p>在古希腊，国王让人做了一顶纯金的王冠，但他又怀疑工匠在王冠中掺了银子。可问题是这顶王冠与当初交给金匠的一样重，谁也不知道金匠到底有没有捣鬼。国王把这个难题交给了阿基米德。阿基米德为了解决这个问题冥思苦想,他起初尝试了很多想法，但都失败了。有一天他去洗澡，一边他一边坐进澡盆，以便看到水往外溢，同时感觉身体被轻轻地托起，他突然恍然大悟，运用浮力原理解决了问题。不管是科学家还是一般人，在解决问题的过程中，我们都可以发现“把难题放在一边，放上一段时间，才能得到满意的答案”这一现象。心理学家将其称为“酝酿效应”。阿基米德发现浮力定律就是酝酿效应的经典故事。日常生活中，我们常常会对一个难题束手无策，不知从何入手，这时思维就进入了“酝酿阶段”。直到有一天，当我们抛开面前的问题去做其他的事情时，百思不得其解的答案却突然出现在我们面前，令我们忍不住发出类似阿基米德的惊叹，这时，“酝酿效应”就绽开了“思维之花”，结出了“答案之果”。古代诗词说“山重水复疑无路，柳暗花明又一村”正是这一心理的写照。 心理学家认为，酝酿过程中，存在潜在的意识层面推理，储存在记忆里的相关信息在潜意识里组合，人们之所以在休息的时候突然找到答案，是因为个体消除了前期的心理紧张，忘记了个体前面不正确的、导致僵局的思路，具有了创造性的思维状态。因此，如果你面临一个难题，不妨先把它放在一边，去和朋友散步、喝茶，或许答案真的会“踏破铁鞋无觅处，得来全不费功夫”。</p>\n<h1 id=\"阿伦森效应\"><a href=\"#阿伦森效应\" class=\"headerlink\" title=\"阿伦森效应\"></a>阿伦森效应</h1><p>是指人们最喜欢那些对自己的喜欢、奖励、赞扬不断增加的人或物，最不喜欢那些显得不断减少的人或物。心理学家做过一个实验,分4组人对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒。结果此实验对数十人进行过后，发现绝大部分人对第四组最具好感，而对第三组最为反感。阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。同样，它也提醒我们在形成对别人的印象过程中，要避免受它的影响而形成错误的态度。有个案例说道: 在宿舍楼的后面，停放着一部烂汽车，大院里的孩子们每当晚上7点时，便攀上车厢蹦跳，嘭嘭之声震耳欲聋，大人们越管，众孩童蹦得越欢，见者无奈。这天，一个人对孩子们说：“小朋友们，今晚你们比赛，蹦得最响的奖玩具手枪一支。”众童呜呼雀跃，争相蹦跳，优者果然得奖。次日，这位朋友又来到车前，说：“今天继续比赛，奖品为两粒奶糖。”众童见奖品直线下跌，纷纷不悦，无人卖力蹦跳，声音疏稀而弱小。第三天，朋友又对孩子们言：“今日奖品为花生米二粒。”众童纷纷跳下汽车，皆说：“不蹦了，不蹦了，真没意思，回家看电视了。” 在“正面难攻”的情况下，采用“奖励递减法”可起到奇妙心理效应。<br>又有个案例说道: 小刚大学毕业后分到一个单位工作，刚一进单位，他决心好好地积极表现一番，以给领导和同事们留下非常好的第一印象。于是，他每天提前到单位打水扫地，节假日主动要求加班，领导布置的任务有些他明明有很大的困难，也硬着头皮一概承揽下来。本来，刚刚走上工作岗位的青年人积极表现一下自我是无可厚议的。但问题是小刚的此时表现与其真正的思想觉悟、为人处世的一贯态度和行为模式相差甚远，夹杂着“过分表演”的成分。因而就难以有长久的坚持性。没过多久，小刚水也不打了，地也不拖了，还经常迟到，对领导布置的任务更是挑肥拣瘦。结果，领导和同事们对他的印象由好转坏，甚至比那些刚开始来的时候表现不佳的青年所持的印象还不好。因为大家对他已有了一个“高期待、高标准”，另外，大家认为他刚开始的积极表现是“装假”，而“诚实”是我们社会评定一个人所运用的“核心品质”。</p>\n<h1 id=\"巴霖效应\"><a href=\"#巴霖效应\" class=\"headerlink\" title=\"巴霖效应\"></a>巴霖效应</h1><p>源自于马戏团经理巴霖先生的一句名言：每分钟都有一名笨蛋诞生。”巴霖效应” 多少解释了为什么有些星座或生肖书刊能够”准确的”指出某人的性格。原因在此,那些用来描述性格的词句,其实根本属”人之常情”或基本上适用于大部分人身上的。换言之,那些词句的适用范围是如此的空泛，以至往往”说了等于没说。例如:水瓶座理性而爱好自由，巨蟹座感性而富爱心；然而巨蟹座的人就永远没理性，水瓶座的人就缺乏爱心吗？我们不去否定星座存在的价值，毕竟它存有统计的基础在。但如果你想成为一个聪明人，不去迷信星座，我又得告诉你，你又错了！知道什么叫做”天醉人亦醉”吗?既然身旁有超过半数的人相信星座，你又何苦试着去推翻那根植于心的观念(实际上也不太可能)? 如果一对情侣在星座学中是不甚相配的，即使两人都不迷信，但他们的心理必然会承受一股不小的压力，在往后交往的时间中，若有了冲突磨擦，心中既存的那种”原来真的不合适”的预设就会被强迫成立，最终难逃分手命运!巴霖效应与巴纳姆效应相同, 巴纳姆效应是由心理学家伯特伦·福勒于1948年通过试验证明的一种心理学现象，它主要表现为：每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，他仍然认为反映了自己的人格面貌。而要避免巴纳姆效应，就应客观真实地认识自己。</p>\n<h1 id=\"半途效应\"><a href=\"#半途效应\" class=\"headerlink\" title=\"半途效应\"></a>半途效应</h1><p>半途效应是指在激励过程中达到半途时，由于心理因素及环境因素的交互作用而导致的对于目标行为的一种负面影响。大量的事实表明，人的目标行为的中止期多发生在”半途”附近，在人的目标行为过程的中点附近是一个极其敏感和极其脆弱的活跃区域。导致半途效应的原因主要有两个，一是目标选择的合理性，目标选择的越不合理越容易出现半途效应；二是个人的意志力，意志力越弱的人越容易出现半途效应。这就要求班主任在平时教育学生时多注意学习各方面的知识，培养多方面的能力，同时多注意进行意志力的磨练。行为学家提出了”大目标、小步子”的方法，对于防止半途效应的发生具有积极的意义。</p>\n<h1 id=\"比马龙效应\"><a href=\"#比马龙效应\" class=\"headerlink\" title=\"比马龙效应\"></a>比马龙效应</h1><p>评价主体低估被评价者能力，认定被评价者是不求上进的、行为差劲的，以致被评价者将这种观念内化，促使被评价者表现不良行为。你有过这样的经历吗？本来穿了一件自认为是很漂亮的衣服去上班，结果好几个同事都说不好看，当第一个同事说的时候，你可能还觉得只是她的个人看法，但是说的人多了，你就慢慢开始怀疑自己的判断力和审美眼光了，于是到了下班后，你回家做的第一件事情就是把衣服换下来，并且决定再也不穿它去上班了。又比如, 如果家长们一直对自己的孩子说你为什么这么笨啊, 久而久之, 这个孩子就会潜移默化地以为自己很笨. 其实，这只是心理暗示在起作用。暗示作用往往会使别人不自觉地按照一定的方式行动，或者不加批判地接受一定的意见或信念。可见，暗示在本质上，是人的情感和观念，会不同程度地受到别人下意识的影响。</p>\n<h1 id=\"边际效应\"><a href=\"#边际效应\" class=\"headerlink\" title=\"边际效应\"></a>边际效应</h1><p>有时也称为边际贡献，是指消费者在逐次增加1个单位消费品的时候，带来的单位效用是逐渐递减的（虽然带来的总效用仍然是增加的）。</p>\n<p>举一个通俗的例子，当你肚子很饿的时候，有人给你拿来一笼包子，那你一定感觉吃第一个包子的感觉是最好的，吃的越多，单个包子给你带来的满足感就越小，直到你吃撑了，那其它的包子已经起不到任何效用了。边际效应的应用非常广泛，例如经济学上的需求法则就是以此为依据，即：用户购买或使用商品数量越多，则其愿为单位商品支付的成本越低（因为后购买的商品对其带来的效用降低了）。当然也有少数例外情况，例如嗜酒如命的人，是越喝越高兴，或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。了解边际效应的概念，你就可以尝试去在实际生活中运用它，例如：你是公司管理层，要给员工涨工资，给 3K 月薪的人增加 1K 带来的效应一般来说是比 6K 月薪增加 1K 大的，可能和 6K 月薪的人增加 2K 的相当，所以似乎给低收入的人增加月薪更对公司有利；另外，经常靠增加薪水来维持员工的工作热情看来也是不行的，第一次涨薪 1K 后，员工非常激动，大大增加了工作热情；第二次涨薪 1K，很激动，增加了一些工作热情；第三次涨薪 2K ，有点激动，可能增加工作热情；第四次 … … ，直至涨薪已经带来不了任何效果。如果想避免这种情况，每次涨薪都想达到和第一次涨薪 1K 相同的效果，则第二次涨薪可能需要 2K ，第三次需要 3K … … ，或者使用其它激励措施，例如第二次可以安排其参加职业发展培训，第三次可以对其在职位上进行提升，虽然花费可能想当，但由于手段不同，达到了更好的效果。研究经济学其实也很有意思，只是对很多人来说，与 IT 这个行业不可完全兼得。</p>\n<p>1). 边际效应递减:边际效益递减是经济学的一个基本概念，它说的是在一个以资源作为投入的企业，单位资源投入对产品产出的效用是不断递减的，换句话，就是虽然其产出总量是递增的，但是其二阶倒数为负，使得其增长速度不断变慢，使得其最终趋于峰值，并有可能衰退。最明显的诠释，就是非线性函数，例如二次曲线。在生活中，我们可以看到许多例子：给你一个可爱多，你高兴的乱跳以为赚了，接下来是第二个……可是一直给你，你会觉得开始恶心了。这有两个原因：一，你吃饱 了，生理不需要了，二，你吃腻了，刺激受够了。你希望有个机会表白自己“老大，给个哈根啊好啊？”</p>\n<p>所谓的新官上任三把火，讲的也是这个道理：刚来了要混个脸熟，所以拼尽全力在所不辞。日子一久，也就澹了。一般的教材会这样解释：神秘莫测的心理学和社会 学。我们可以想想，边际效用递减式一个无处不在的规律，你想过四级，于是找了本宝书，从A背起，不错，一会儿就背完 呢（当然，本来A就不太多，我就是这种人），然后是B，然后是……B part2，然后是B part 2 1/2…级数的概念有了应用。当然你可以选择从Z开始背回头（当然，我也是这种人）。 可见，投入和产出是相同的概念，由于投入了就要求有产出，所以边际效益递减的逆仍然适用。 我们可以拓展到离开效用这个概念。让我们看一个实际中的问题： 昨天打扫房间卫生，发现刚刚擦过的桌子一层灰又上去了，和旁边的一个小支架看上去没什么区别。实际上，后者上次被美容的时候我还没在南京…… 一个东西从干净到涨很快，可是从脏到很脏是一个多么漫长的过程阿，指望考古队？（尽管也有评价的因素） 大家还可以想到很多很多，比如，人文一点，“失去的才是真”。</p>\n<p>我们如何利用这个规律呢？经济学的解释是资源的最优配置。因为投入的太多使得 最终的收益摊的太薄。再好的东西也有个限度。理工科的更加清楚，所谓的各种高级操作都是某种程度上的吃力不讨好，最有效的往往是那些基本操作。更高深的是 当然一些数学上的游戏。 然而我觉得，这个现象的起源绝对是一个哲学问题，那就是我们为什么进步和发展。 想想，如果边际效益递增，我们还需要创新吗？我们还需要坚持吗？同志们，可爱多足够了，不，凉水就行！魅力这个词，永远的就失去了意义。</p>\n<p>2). 边际效应递增: 有时候边际效应有时候也是递增的。当然也有少数例外情况，例如嗜酒如命的人，越喝越高兴，或者吸毒的人，越吸越想吸。或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。​</p>\n<h1 id=\"超限效应\"><a href=\"#超限效应\" class=\"headerlink\" title=\"超限效应\"></a>超限效应</h1><p>美国着名幽默作家马克·吐温有一次在教堂听牧师演讲。最初，他觉得牧师讲得很好，使人感动，准备捐款。过了10分钟，牧师还没有讲完，他有些不耐烦了，决定只捐一些零钱。又过了10分钟，牧师还没有讲完，于是他决定，1分钱也不捐。到牧师终于结束了冗长的演讲，开始募捐时，马克·吐温由于气愤，不仅未捐钱，还从盘子里偷了2元钱。 这种刺激过多、过强和作用时间过久而引起心理极不耐烦或反抗的心理现象，称之为“超限效应”。 超限效应在家庭教育中时常发生。如：当孩子不用心而没考好时，父母会一次、两次、三次，甚至四次、五次重复对一件事作同样的批评，使孩子从内疚不安到不耐烦最后反感讨厌。被“逼急”了，就会出现“我偏要这样”的反抗心理和行为。 因为孩子一旦受到批评，总需要一段时间才能恢复心理平衡，受到重复批评时，他心里会嘀咕：“怎么老这样对我？”孩子挨批评的心情就无法复归平静，反抗心理就高亢起来。 可见，家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果非要再次批评，那也不应简单地重复，要换个角度，换种说法。这样，孩子才不会觉得同样的错误被“揪住不放”，厌烦心理、逆反心理也会随之减低。</p>\n<h1 id=\"拆屋效应\"><a href=\"#拆屋效应\" class=\"headerlink\" title=\"拆屋效应\"></a>拆屋效应</h1><p>鲁迅先生曾于1927年在《无声的中国》一文中写下了这样一段文字：”中国人的性情总是喜欢调和、折中的，譬如你说，这屋子太暗，说在这里开一个天窗，大家一定是不允许的，但如果你主张拆掉屋顶，他们就会来调和，愿意开天窗了。”这种先提出很大的要求，接着提出较小较少的要求，在心理学上被称为”拆屋效应”。虽然这一效应在XXXXX生活中多见，但也有不少学生学会了这些。如有的学生犯了错误后离家出走，班主任很着急，过了几天学生安全回来后，班主任反倒不再过多地去追究学生的错误了。实际上在这里，离家出走相当于”拆屋”，犯了错误相当于”开天窗”，用的就是拆屋效应。因此，班主任在教育学生的过程中，教育方法一定要恰当，能被学生所接受，同时，对学生的不合理要求或不良的行为绝不能迁就，特别要注意不能让学生在这些方面养成与班主任讨价还价的习惯。</p>\n<h1 id=\"刺猬法则\"><a href=\"#刺猬法则\" class=\"headerlink\" title=\"刺猬法则\"></a>刺猬法则</h1><p>刺猬法则可以用这样一个有趣的现象来形象地说明：两只困倦的刺猬由于寒冷而拥在一起，可怎么也睡不舒服，因为各自身上都长着刺，紧挨在一块，反而无法睡得安宁。几经折腾，两只刺猬拉开距离，尽管外面寒风呼呼，可它们却睡得甜乎乎的。刺猬法则就是人际交往中的“心理距离效应”。管理心理学专家的研究认为：领导者要搞好工作应该与下属保持亲密关系，但这是“亲密有间”的关系。特别要提醒的是，领导者与下属亲密无间地相处，还容易导致彼此称兄道弟、吃喝不分，并在工作中丧失原则。</p>\n<h1 id=\"从众效应\"><a href=\"#从众效应\" class=\"headerlink\" title=\"从众效应\"></a>从众效应</h1><p>有一个成语叫做三人成虎，意思是说，有三个人谎报市上有老虎，听者就信以为真。这种人在社会群体中容易不加分析地接受大多数人认同的观点或行为的心理倾向被称为从众效应。这一效应的启示是：班主任要善于发挥从众效应的积极作用，首先要有意识地通过班会、黑板报等舆论阵地大张旗鼓地进行宣传；其次，要抓好班团干部和积极分子等基本队伍的建设，组成坚强的堡垒，要及时发现班上的不良倾向，对症下药，将其遏制在萌芽状态，以防止产生从众效应的负作用。 从众效应是指在群体活动中，当个人与多数人的意见和行为不一致时，个人放弃自己的意见和行为，表现出与群体中多数人相一致的意见和行为方式的现象。从众也就是我们日常俗语中所说的“随大流”。 促使一个人在合作中产生从众行为的因素有多种，一般认为主要有：小组里有较优势的学生存在；个性特质如智力的低、胆小、顾虑多、意志不坚定、自信心差、过于重视他人并依赖他人者等；小组人数的规模等因素。 毋庸质疑，从众有利于形成统一的小组意见，合理的小组环境可以促进或潜移默化地使落后的小组成员形成正确的思想与行为。同时，应该指出，在不合理的小组环境里，由于从众效应表现为趋向学习结论一致，而不一定是学习结论正确；部分学生容易与自信或学习优秀的小组成员的观点、思维方法形成一致，而忽视自己地观点、思维方法正确与否，小组合作的结果可能是以虚假的多数形成错误的小组结论。可见，从众效应容易压制正确思想的形成，窒息小组成员的独创精神；合作学习有时有弱化独立思考的趋势，个体在群体中容易丧失了对自我的控制，失去了个体感，使人“人云亦云”。我们需要的</p>\n<h1 id=\"淬火效应\"><a href=\"#淬火效应\" class=\"headerlink\" title=\"淬火效应\"></a>淬火效应</h1><p>金属工件加热到一定温度后，浸入冷却剂(油、水等)中，经过冷却处理，工件的性能更好、更稳定。长期受表扬头脑有些发热的学生，不妨设置一点小小的障碍，施以“挫折教育”，几经锻炼，其心理会更趋成熟，心理承受能力会更强；对于麻烦事或者已经激化的矛盾，不妨采用“冷处理”，放一段时间，思考得会更周全，办法会更稳妥。</p>\n<h1 id=\"得寸进尺效应\"><a href=\"#得寸进尺效应\" class=\"headerlink\" title=\"得寸进尺效应\"></a>得寸进尺效应</h1><p>美国社会心理学家弗里得曼做了一个有趣的实验：他让助手去访问一些家庭主妇，请求被访问者答应将一个小招牌挂在窗户上，她们答应了。过了半个月，实验者再次登门，要求将一个大招牌放在庭院内，这个牌子不仅大，而且很不美观。同时，实验者也向以前没有放过小招牌的家庭主妇提出同样的要求。结果前者有55%的人同意，而后者只有不到17%的人同意，前者比后者高3倍。后来人们把这种心理现象叫作“得寸进尺效应”。心理学认为，人的每个意志行动都有行动的最初目标，在许多场合下，由于人的动机是复杂的，人常常面临各种不同目标的比较、权衡和选择，在相同情况下，那些简单容易的目标容易让人接受。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会继续下去。上述心理效应告诉我们，要让他人接受一个很大的、甚至是很难的要求时，最好先让他接受一个小要求，一旦他接受了这个小要求，他就比较容易接受更高的要求。差生作为一个特殊群体，其身心素质和学习基础等方面都低于一般水平。转化差生，也要像弗里得曼一样善于引导，善于“搭梯子”，使之逐渐转化；应贯彻“小步子、低台阶、勤帮助、多照应”的原则，注意“梯子”依靠的地方要正确、间距不宜太大、太陡，做到扶一扶“梯子”，托一托人。</p>\n<h1 id=\"定势效应\"><a href=\"#定势效应\" class=\"headerlink\" title=\"定势效应\"></a>定势效应</h1><p>有一个农夫丢失了一把斧头，怀疑是邻居的儿子偷盗，于是观察他走路的样子，脸上的表情，感到言行举止就像偷斧头的贼。后来农夫找到了丢失的斧头，他再看邻居的儿子，竟觉得言行举止中没有一点偷斧头的模样了。这则故事描述了农夫在心理定势作用下的心理活动过程。所谓心理定势是指人们在认知活动中用“老眼光”——已有的知识经验来看待当前的问题的一种心理反应倾向，也叫思维定势或心向。在人际交往中，定势效应表现在人们用一种固定化了的人物形象去认知他人。例如：我们与老年人交往中，我们会认为他们思想僵化，墨守成规，跟不上时代；而他们则会认为我们年纪轻轻，缺乏经验，“嘴巴无毛，办事不牢”。与同学相处时，我们会认为诚实的人始终不会说谎；而一旦我们认为某个人老奸巨猾，既使他对你表示好感，你也会认为这是“黄鼠狼给鸡拜年没安好心”。 心理定势效应常常会导致偏见和成见，阻碍我们正确地认知他人。所以我们要“士别三日，当刮目相看”他人呀！不要一味地用老眼光来看人处事。</p>\n<h1 id=\"多看效应\"><a href=\"#多看效应\" class=\"headerlink\" title=\"多看效应\"></a>多看效应</h1><p>转在许多人眼中，喜新厌旧是人的天性。然而,事实果真是如此吗?20世纪60年代,心理学家查荣茨做过试验:先向被试出示一些照片,有的出现了20多次,有的出现了10多次,有的只出现一两次,然后请别试评价对照片的喜爱程度,结果发现,被试更喜欢那些只看过几次的新鲜照片,既看的次数增加了喜欢的程度.这种对越熟悉的东西就越喜欢的现象,心理学上称为多看效应.在人际交往中,如果你细心观察就会发现,那些人缘很好的人,往往将多看效应发挥的淋漓尽致:他们善于制造双方接触的机会,已提高彼此间的熟悉度,然后互相产生更强的吸引力.人际吸引难道真的是如此的简单?有社会心理学的实验做佐证:在一所大学的女生宿舍楼里,心理学家随机找了几个寝室,发给她们不同口味的饮料,然后要求这几个寝室的女生,可以以品尝饮料为理由,在这些寝室间互相走动,但见面时不得交谈.一段时间后,心理学家评估她们之间的熟悉和喜欢的程度,结果发现:见面的次数越多,互相喜欢的程度越大:见面的次数越少或根本没有,相互喜欢的程度也较低.</p>\n<p>可见,若想增强人际吸引,就要留心提高自己在别人面前的熟悉度,这样可以增加别人喜欢你的程度.因此,一个自我封闭的人,或是一个面对他人就逃避和退缩的人，由于不易让人亲近而另人费解,也就是太讨人喜欢.</p>\n<p>当然,多看效应发挥作用的前提,是首因效应要好,若给人的第一印象不很差,则见面越多就越讨人厌,多看效应反而起了副用.</p>\n<h1 id=\"首因效应\"><a href=\"#首因效应\" class=\"headerlink\" title=\"首因效应\"></a>首因效应</h1><p>首因效应，是人与人第一次交往中给人留下的印象，在对方的头脑中形成并占据着主导地位的效应。首因效应也叫首次效应、优先效应或第一印象效应。它是指当人们第一次与某物或某人相接触时会留下深刻印象，个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。 第一印象作用最强，持续的时间也长，比以后得到的信息对于事物整个印象产生的作用更强。首因，是指首次认知客体而在脑中留下的第一印象。首因效应，是指个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。</p>\n<h1 id=\"近因效应\"><a href=\"#近因效应\" class=\"headerlink\" title=\"近因效应\"></a>近因效应</h1><p>所谓近因效应：与首因效应相反. 最近、最后的印象，往往是最强烈的，可以冲澹在此之前产生的各种因素，这就是近因效应。有这样一个例子：面试过程中，主考官告诉考生可以走了，可当考生要离开考场时，主考官又叫住他，对他说，你已回答了我们所提出的问题，评委觉得不怎么样，你对此怎么看？其实，考官做出这么一种设置，是对毕业生的最后一考，想借此考察一下应聘者的心理素质和临场应变能力。如果这一道题回答得精彩，大可弥补此前面试中的缺憾；如果回答得不好，可能会由于这最后的关键性试题而使应聘者前功尽弃</p>\n<h1 id=\"凡勃伦效应\"><a href=\"#凡勃伦效应\" class=\"headerlink\" title=\"凡勃伦效应\"></a>凡勃伦效应</h1><p>一些商品价格定得越高，就越能受到消费者的青睐。我们经常在生活中看到这样的情景：款式、皮质差不多的一双皮鞋，在普通的鞋店卖80元，进入大商场的柜台，就要卖到几百元，却总有人愿意买。1.66万元的眼镜架、6.88万元的纪念表、168万元的顶级钢琴，这些近乎“天价”的商品流通，往往也能在市场上走俏。其实，消费者购买这类商品的目的并不仅仅是为了获得直接的物质满足和享受，更大程度上是为了获得心理上的满足。这就出现了一种奇特的经济现象，即一些商品价格定得越高，就越能受到消费者的青睐。由于这一现象最早由美国经济学家凡勃伦注意到，因此被命名为“凡勃伦效应”。随着社会经济的发展，人们的消费会随着收入的增加，而逐步由追求数量和质量过渡到追求品位格调。了解了“凡勃伦效应”，我们也可以利用它来探索新的经营策略。比如凭借媒体的宣传，将自己的形象转化为商品或服务上的声誉，使商品附带上一种高层次的形象，给人以“名贵”和“超凡脱俗”的印象，从而加强消费者对商品的好感。这种价值的转换在消费者从数量，质量购买阶段过渡到感性购买阶段时，就成为可能。实际上，在东南沿海的一些发达地区，感性消费已经逐渐成为一种时尚，而只要消费者有能力进行这种感性购买时，“凡勃伦效应”就可以被有效地转化为提高市场份额营销策略。</p>\n<h1 id=\"共生效应\"><a href=\"#共生效应\" class=\"headerlink\" title=\"共生效应\"></a>共生效应</h1><p>植物界中相互影响、相互促进的现象,称之为:共生效应 在自然界，一株植物单独生长时，往往长势不旺，没有生机，甚至枯萎衰败，而当众多植物一起生长时，却能郁郁葱葱，挺拔茂盛，人们把这种植物中这种相互影响、相互促进的现象称之为“共生效应”。 共生就是两者相互利用（虽然这个词是贬义词，但实际就是这样），同时有利于双方发展的现象，这种情况应不仅限于自然界，人类社会也会有。</p>\n<h1 id=\"黑暗效应\"><a href=\"#黑暗效应\" class=\"headerlink\" title=\"黑暗效应\"></a>黑暗效应</h1><p>在光线比较暗的场所，约会双方彼此看不清对方表情，就很容易减少戒备感而产生安全感。在这种情况下，彼此产生亲近的可能性就会远远高于光线比较亮的场所。心理学家将这种现象称之为“黑暗效应”。有个这样的案例：有一位男子钟情于一位女子，但每次约会，他总觉得双方谈话不投机。有一天晚上，他约那位女子到一家光线比较暗的酒吧，结果这次谈话融洽投机。从此以后，这位男子将约会的地点都选择在光线比较暗的酒吧。几次约会之后，他俩终于决定结下百年之好。 社会心理学家研究后的结论是，在正常情况下，一般的人都能根据对方和外界条件来决定自己应该掏出多少心里话，特别是对还不十分了解但又愿意继续交往的人，既有一种戒备感，又会自然而然地把自己好的方面尽量展示出来，把自己弱点和缺点尽量隐藏起来。因此，这时双方就相对难以沟通。</p>\n<h1 id=\"棘轮效应\"><a href=\"#棘轮效应\" class=\"headerlink\" title=\"棘轮效应\"></a>棘轮效应</h1><p>商朝时，纣王登位之初，天下人都认为这位精明的国君的治理下，商朝的江山一定会坚如磐石。有一天，纣王命人用象牙做了一双筷子，十分高兴地使用这双象牙筷子就餐。他的叔父箕子见了，劝他收藏起来，而纣王却满不在乎，满朝文武大臣也不以为然，认为这本来是一件很平常的小事。箕子为此忧心忡忡，有的大臣莫名其妙地问他原因，箕子回答说：“纣王用象牙做筷子，必定再不会用土制的瓦罐盛汤装饭，肯定要改用犀牛角做成的杯子和美玉制成的饭碗；有了象牙筷、犀牛角杯和美玉碗，难道还会用它来吃粗茶澹饭和豆子煮的汤吗？大王的餐桌从此顿顿都要摆上美酒佳肴了；吃的是美酒佳肴，穿的自然要绫罗绸缎，住的就要求富丽堂皇，还要大兴土木筑起楼台亭阁以便取乐了。对这样的后果我觉得不寒而栗。”仅仅5年时间，箕子的预言果然应验了，商纣王瓷意骄奢，便断送了商汤绵延500年的江山。在上面的故事中，箕子对纣王使用象牙筷子的评价，运用了现代经济学一种消费效应――棘轮效应。所谓棘轮效应，又称制轮作用，是指人的消费习惯形成之后有不可逆性，即易于向上调整，而难于向下调整。尤其是在短期内消费是不可逆的，其习惯效应较大。这种习惯效应，使消费取决于相对收入，即相对于自己过去的高峰收入。这一效应是经济学家杜森贝提出的。古典经济学家凯恩斯主张消费是可逆的，即绝对收入水平变动必然立即引起消费水平的变化。针对这一观点，杜森贝认为这实际上是不可能的，因为消费决策不可能是一种理想的计划，它还取决于消费习惯。这种消费习惯受许多因素影响，如生理和社会需要、个人的经历、个人经历的后果等。特别是个人在收入最高期所达到的</p>\n<p>从个人的角度来说，我们对于欲望既不能禁止，也不能放纵，对于过度的及至贪得无厌的奢求，必须加以节制。如果对自己的欲望不加限制的话，过度地放纵奢侈，没能培养俭仆的生活习惯，必然会使自古“富不过三代”之说就成了必然，就必然出现“君子多欲，则贪慕富贵，枉道速祸；小人多欲，则多求妄用，败家丧身。是以居官必贿，居乡必盗”的情况。西方一些成功企业家虽家境富裕，但依然对子女要求极严，从不给孩子更多的零花钱，甚至寒暑假还让孩子四处打工。这些成功企业家并不是苛求子女能为自己多赚一点钱，而是希望子女懂得每一分钱的来之不易，懂得俭仆和自立。</p>\n<h1 id=\"奖惩效应\"><a href=\"#奖惩效应\" class=\"headerlink\" title=\"奖惩效应\"></a>奖惩效应</h1><p>奖励和惩罚是对学生行为的外部强化或弱化的手段，它通过影响学生的自身评价，能对学生的心理产生重大影响，由奖惩所带来的行为的强化或弱化就叫做奖惩效应。心理学实验证明，表扬、鼓励和信任，往往能激发一个人的自尊心和上进心。但奖励学生的原则应是精神奖励重于物质奖励，否则易造成”为钱而学”、”为班主任而学”的心态。同时奖励要抓住时机，掌握分寸，不断升化。当然”没有惩罚就没有教育”，必要的惩罚是控制学生行为的有效信号。惩罚时用语要得体、适度、就事论事，使学生明白为什么受罚和怎样改过。同时还应注意的是奖惩的频率，从心理学的研究结果看，当奖惩的比例为5：1时往往效果最好。</p>\n<h1 id=\"结伴效应\"><a href=\"#结伴效应\" class=\"headerlink\" title=\"结伴效应\"></a>结伴效应</h1><p>是指两个人或几个人结伴从事相同的一项活动时（并不进行竞赛）相互之间会产生刺激作用，提高活动效率。例如：学生在一起作作业比独立完成作业的效率高。 可以相应组成学习小组。教师应注意课上的效率，注意时间分配。…</p>\n<h1 id=\"空白效应\"><a href=\"#空白效应\" class=\"headerlink\" title=\"空白效应\"></a>空白效应</h1><p>心理实验表明，在演讲的过程中，适当地留一些空白，会取得良好的演讲效果，这就是空白效应。它给我们的启示是，班主任要善于留白，如在表达方面留白，针对某些问题，班主任不妨先不说出自己的观点，让学生去想、去说，让学生有表达自己意见的机会。在实践方面留白，给学生一个锻炼和实践的机会，提高学生的动手能力。在思考方面留白，班主任应给学生思考分析的机会，让学生独立地思考、判断和面对，学生的分析能力就会逐渐提高。在批评方面留白，批评之后，留有学生自己去思考、自己去责备的时间。这样学生就不会有一种被”穷追不舍”之感，反抗心理就会锐减。</p>\n<h1 id=\"青蛙现象\"><a href=\"#青蛙现象\" class=\"headerlink\" title=\"青蛙现象\"></a>青蛙现象</h1><p>青蛙现象：把一只青蛙直接放进热水锅里，由于它对不良环境的反应十分敏感，就会迅速跳出锅外。如果把一个青蛙放进冷水锅里，慢 慢地加温，青蛙并不会立即跳出锅外，水温逐渐提高的最终结局是青蛙被煮死了，因为等水温高到青蛙无法忍受时，它已经来不及、或者说是没有能力跳出锅外了。青蛙现象告诉我们，一些突变事件，往往容易引起人们的警觉，而易致人于死地的却是在自我感觉良好的情况下，对实际情况的逐渐恶化，没有清醒的察觉。启示之一是：我们的组织和社会生存的主要威胁，并非来自突如其来的事件，而是由缓慢渐进而无法察觉的过程形成。人们目光短浅，只看到局部，而无法纵观全局，对于突如其来的变化，可以从容面对，对于悄悄发生的大的变化，而无法察觉，最终会带给我们更加严重的危害！~启示之二是：青蛙，就好象是我们生活中的芸芸众生，我们要着眼未来，勤于思考新的问题，勤于学习新的知识，不能过“今日有酒，今日醉”和“当一天和尚，撞一天钟”的醉生梦死的生活，到头来将是非常可悲的！</p>\n<p>启示之三是：当今的社会，是一个知识爆炸、日新月异的时代，知识也需要不断更新，所以我们不要一味的沉迷于现状、安于现状，不思进取，这样下去的话，肯定会被时代所淘汰，也会有面临失业的危险！</p>\n<p>启示之四是：我们不要单纯的，只能面对突如其来的危险，而忽视那种缓慢而又微小甚微的危险，因为，那种缓慢而又微小甚微的危险，才是最可怕的！</p>\n<h1 id=\"21天效应\"><a href=\"#21天效应\" class=\"headerlink\" title=\"21天效应\"></a>21天效应</h1><p>在行为心理学中，人们把一个人的新习惯或理念的形成并得以巩固至少需要21天的现象，称之为21天效应。也就是说，一个人的动作、或想法，如果重复21天就会变成一个习惯性的动作或想法。</p>\n<p>根据我国成功学专家易发久研究，习惯的形成大致分为三个阶段：</p>\n<p>第一阶段：1-7天左右。此阶段表现为“刻意，不自然”，需要十分刻意地提醒自己。</p>\n<p>第二阶段：7-21天左右。此阶段表现为“刻意，自然”，但还需要意识控制。</p>\n<p>第三阶段：21-90天左右，此阶段表现为“不经意，自然”，无需意识控制。</p>\n<h1 id=\"本杰明富兰克林效应\"><a href=\"#本杰明富兰克林效应\" class=\"headerlink\" title=\"本杰明富兰克林效应\"></a>本杰明富兰克林效应</h1><p>让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。—— 本杰明·富兰克林效应,</p>\n<p>本杰明 富兰克林效应的现象启示我们，如果你对一个人行善举，那么往往会得到好的结果。当然这绝非是种“果报”理论<br>本杰明 富兰克林曾表示，通过向一个不喜爱他的议员借书，他们俩最终成为了要好的朋友。认知失调理论的解释为，如果我们去帮助一个不喜欢的人，结果说不定就会喜欢上他—— 当我们给予不喜欢的人帮助时，其实是经历了一种失调，我们的行为和对此人的态度之间发生了矛盾。为了缓解这种失调，我们会尽力说服自己这个人是好的、值得帮助的，从而注意并强调了其优点，而澹化了自己本来不喜爱他的事实。这个故事倒是给了我们一点启示：如果想追求一个本来不怎么喜欢你的姑娘，或许也可以通过求得她帮忙的方式来逐步制造她对你的好感呢？</p>\n<h1 id=\"史密斯原则\"><a href=\"#史密斯原则\" class=\"headerlink\" title=\"史密斯原则\"></a>史密斯原则</h1><p>如果你不能战胜他们，你就加入到他们之中去。竞争使人进步最快，合作让人得到最多。</p>\n<h1 id=\"鸟笼逻辑\"><a href=\"#鸟笼逻辑\" class=\"headerlink\" title=\"鸟笼逻辑\"></a>鸟笼逻辑</h1><p>挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里。这就是鸟笼逻辑。过程很 简单，设想你是这房间的主人，只要有人走进房间，看到鸟笼，就会忍不住问你：“鸟呢？是不是死了？”当你回答：“我从来都没有养过鸟。”人们会问：“那么，你要一个鸟笼干什么？”最后你不得不在两个选择中二选一，因为这比无休止的解释要容易得多。鸟笼逻辑的原因很简单：人们绝大部分的时候是采取惯性思维。所以可见在生活和工作中培养逻辑思维是多么重要</p>\n<h1 id=\"责任分散效应\"><a href=\"#责任分散效应\" class=\"headerlink\" title=\"责任分散效应\"></a>责任分散效应</h1><p>1964年3月13日夜3时20分，在美国纽约郊外某公寓前，一位叫朱诺比白的年轻女子在结束酒巴间工作回家的路上遇刺。当她绝望地喊叫：“有人要杀人 啦!救命!救命!”听到喊叫声，附近住户亮起了灯，打开了窗户，凶手吓跑了。当一切恢复平静后，凶手又返回作案。当她又叫喊时，附近的住户又打开了电灯， 凶手又逃跑了。当她认为已经无事，回到自己家上楼时，凶手又一次出现在她面前，将她杀死在楼梯上。在这个过程中，尽管她大声呼救，她的邻居中至少有38位 到窗前观看，但无一人来救她，甚至无一人打电话报警。这件事引起纽约社会的轰动，也引起了社会心理学工作者的重视和思考。人们把这种众多的旁观者见死不救 的现象称为责任分散效应。对于责任分散效应形成的原因，心理学家进行了大量的实验和调查，结果发现：这种现象不能仅仅说是众人的冷酷无 情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己 的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担， 造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的 局面。如何打破这种局面，这是心理学家正在研究的一个重要课题。</p>\n<h1 id=\"虚假同感偏差\"><a href=\"#虚假同感偏差\" class=\"headerlink\" title=\"虚假同感偏差\"></a>虚假同感偏差</h1><p>我们通常都会相信，我们的爱好与大多数人是一样的。如果你喜欢玩电脑游戏，那么就有可能高估喜欢电脑游戏的人数。你也通常会 高估给自己喜欢的同学投票的人数，高估自己在群体中的威信与领导能力等等。你的这种高估与你的行为及态度有相同特点的人数的倾向性就叫做“虚假同感偏 差”。有些因素会影响你的这种虚假同感偏差强度：</p>\n<p>当外部的归因强于内部归因时；<br>当前的行为或事件对某人非常重要时；<br>当你对自己的观点非常确定或坚信时；<br>当你的地位或正常生活和学习受到某种威胁时；<br>当涉及到某种积极的品质或个性时；<br>当你将其他人看成与自己是相似时。<br>美人效应<br>罗马一家自助餐厅的老板想出一个赚小费的妙计。他请来一位非常漂亮的姑娘，坐在柜台边收钱，以便使男客们神魂颠倒，慷慨解囊。谁知那位姑娘上班后没过几天，就对老板说：“我想，我不如以前漂亮了。”老板忙问：“这是怎么回事呢？”“现在，所有的男客都在柜台边反复地数找给他们的零钱。”美人效应在这里发挥的作用正是挖掘潜在消费和增加客人满意程度，增强餐厅的竞争优势，从而留住客人。</p>\n<h1 id=\"潘多拉效应\"><a href=\"#潘多拉效应\" class=\"headerlink\" title=\"潘多拉效应\"></a>潘多拉效应</h1><p>古希腊有个神话，说宙斯给一个名叫潘多拉的女孩一个盒子，告诉她绝对不能打开。“为什么不能打开？还要‘绝对’？里面该不是稀世珍宝吧？”潘多拉越想越好 奇，越想揭开真相。憋了一段时间后，她终于把盒子打开了。谁知盒子里装的是人类的全部罪恶，结果让它们都跑到人间了。心理学把这种“不禁不为、愈禁愈为” 的现象，叫“潘多拉效应”或“禁果效应”。潘多拉效应的心理实质是好奇心和逆反心理在起作用。</p>\n<h1 id=\"光环效应\"><a href=\"#光环效应\" class=\"headerlink\" title=\"光环效应\"></a>光环效应</h1><p>也叫晕轮效应, 晕轮原指月亮被光环笼罩时产生的模煳不清的现象。晕轮效应是一种普通存在的心理现象，即对一个人进行评价时，往往会因对他的某一品质特征的强烈、清晰的感知，而掩盖了其他方面的品质。毕业生在求职应聘中，如果能够巧妙地运用这种晕轮效应，把自身的优势充分地展现出来，一定会给招聘考官留下深刻的印象，赢得对方的赏识，取得面试的成功。比如，当招聘者问及你的英语水平时，你便用英语熟练地与其交谈，必然会引起招聘者的极大兴趣，很可能当场便与你拍板“成交”。但在运用这一效应时一定要注意，不能刻意制造“光环”效果，那种虚妄做出的行为，往往适得其反。</p>\n<h1 id=\"冷热水效应\"><a href=\"#冷热水效应\" class=\"headerlink\" title=\"冷热水效应\"></a>冷热水效应</h1><p>一杯温水，保持温度不变，另有一杯冷水，一杯热水。当先将手放在冷水中，再放到温水中，会感到温水热；当先将手放在热水中，再放到温水中，会到温水凉。同一杯温水，出现了两种不同的感觉，这就是冷热水效应。这种现象的出现，是因为人人心里都有一杆秤，只不过是秤砣并不一致，也不固定。随着心理的变化，秤砣也在变化。当秤砣变小时，它所称出的物体重量就大，当秤砣变大时，它所称出的物体重量就小。人们对事物的感知，就是受这秤砣的影响。人际交往中，要善于运用这种冷热水效应。 运用冷热水效应，可以获得对方的好评。 人处世上，难免有事业上滑坡的时候，难免有不小心伤害他人的时候，难免有需要对他人进行批评指责的时候，在这些时候，假若处理不当，就会降低自己在他人心目中的形象。如果巧妙运用冷热水效应，就不但不会降低自己的形象，反而会获得他人一个好的评价。当事业上滑坡的时候，不妨预先把最糟糕的事态委婉地告诉别人，以后即使失败也可立于不败之地；当不小心伤害他人的时候，道歉不妨超过应有的限度，这样不但可以显示出你的诚意，而且会收到化干戈为玉帛的效果；当要说令人不快的话语时，不妨事先声明，这样就不会引起他人的反感，使他人体会到你的用心良苦。这些运用冷热水效应的举动，实质上就是先通过一二处“伏笔”，使对方心中的“秤砣”变小，如此一来，它“称出的物体重量”也就大了。某汽车销售公司的老李，每月都能卖出30辆以上汽车，深得公司经理的赏识。由于种种原因，老李预计到这个月只能卖出10辆车。深懂人性奥妙的老李对经理说：“由于银根紧缩，市场萧条，我估计这个月顶多卖出5辆车。”经理点了点头，对他的看法表示赞成。没想到一个月过后，老李竟然卖了12辆汽车，公司经理对他大大夸奖一番。假若老李说本月可以卖15辆或者事先对此不说，结果只卖了12辆，公司经理会怎么认为呢？他会强烈地感受到老李失败了，不但不会夸奖，反而可能指责。在这个事例中，老李把最糟糕情况――顶多卖5辆车，报告给经理，使得经理心中的“秤砣”变小，因此当月绩出来以后，对老李的评价不但不会降低，反而提高了。 蔡女士很少演讲，一次迫不得已，她对一群学者、评论家进行演说。她的开场白是：“我是一个普普通通的家庭妇女，自然不会说出精彩绝伦的话语，因此恳请各位专家对我的发言不要笑话……”经她这么一说，听众心中的“秤砣”变小了，许多开始对她怀疑的人，也在专心听讲了。她的简单朴实演说完成后，台下的学者、评论家们感到好极了，他们认为她的演说达到了极高的水平。对于蔡女士的成功演讲，他们抱以热烈的掌声。当一个人不能直接端给他人一盆“热水”时，不妨先端给他人一盆“冷水”，再端给他人一盆“温水”，这样的话，这人的这盆“温水”同样会获得他人的一个良好评价。</p>\n<h1 id=\"临近效应\"><a href=\"#临近效应\" class=\"headerlink\" title=\"临近效应\"></a>临近效应</h1><p>两个人能否成为朋友，这与俩人住处的远近有很大关系。这被称为邻近效应。那么为什么邻近性会引发好感呢？</p>\n<p>(增强亲近感) - 邻近性一般都会增强亲近感。住得近的人自然碰面的机会也相对频繁，重复的接触就会引发、增强相互间的好感。<br>(强烈的相似性) - 人们大多选择社会地位、经济实力与自己相近的人为邻，而地理位置上的邻近性进一步增强了人们的相似性。<br>(越是邻近的人，其可利用度也越高) - 邻居之间不用花费太多的时间和费用便可成为好朋友，而且有很多事可以相互嘱托，有快乐可以共同分享。比如可以请邻居照看孩子或房子，家里不管发生什么大事小事都可以相互照应。<br>(认知的一贯性) - 与讨厌的人比邻而居，在心理上是难以忍受的。人们在交往中大多愿意接近与自己合得来、住所比较近的人。</p>\n<h1 id=\"名人效应\"><a href=\"#名人效应\" class=\"headerlink\" title=\"名人效应\"></a>名人效应</h1><p>美国心理学家曾做过一个有趣的实验，在给大学心理系学生讲课时，向学生介绍说聘请到举世闻名的化学家。然后这位化学家说，他发现了一种新的化学物质，这种物质具有强烈的气味，但对人体无害。在这里只是想测一下大家的嗅觉。接着打开瓶盖，过了一会儿，他要求闻到气味的同学举手，不少同学举了手，其实这只瓶子里只不过是蒸馏水，”化学家”是从外校请来的德语教师。这种由于接受名人的暗示所产生的信服和盲从现象被称为名人效应。名人效应的产生依赖于名人的权威和知名度，名人之所以成为名人，在他们那一领域必然有其过人之处。名人知名度高，为世人所熟悉、喜爱，所以名人更能引起人们的好感、关注、议论和记忆。由于青少年的认识特点及心理发展，他们所希望的名人多为形式化、表面性的形象所吸，他们喜欢的名人多为歌星、影星一类，出现追星现象。这就要求班主任要为学生选择好”名人”，以促进学生的健康成长。</p>\n<h1 id=\"墨菲定律\"><a href=\"#墨菲定律\" class=\"headerlink\" title=\"墨菲定律\"></a>墨菲定律</h1><p>(Murphy’s Law)缘于美国一位名叫墨菲的上尉。他认为他的某位同事是个倒霉蛋，不经意说了句笑话：“如果一件事情有可能被弄糟，让他去做就一定会弄糟。”这句话迅速流传。经过多年，这一“定律”逐渐进入习语范畴，其内涵被赋予无穷的创意，出现了众多的变体，“如果坏事有可能发生，不管这种可能性多么小，它总会发生，并引起最大可能的损失”、“If anything can go wrong, it will.(会出错的，终将会出错)”、“笑一笑，明天未必比今天好。”“东西越好，越不中用”、“别试图教猪唱歌，这样不但不会有结果，还会惹猪不高兴!”墨菲定律的原话是这样说的：If there are two or more ways to do something, and one of those ways can result in a catastrophe, then someone will do it.(如果有两种选择，其中一种将导致灾难，则必定有人会作出这种选择。)</p>\n<p>根据“墨菲定律”，一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四，如果你担心某种情况发生，那么它就更有可能发生。我们都有这样的体会，如果在街上准备拦一辆车去赴一个时间紧迫的约会，你会发现街上所有的出租车不是有客就是根本不搭理你，而当你不需要租车的时候，却发现有很多空车在你周围游弋，只待你的一扬手，车随时就停在你的面前。如果一个月前在浴室打碎镜子，尽管仔细检查和冲刷，也不敢光着脚走路，等过了一段时间确定没有危险了，不幸的事还是照样发生，你还是被碎玻璃扎了脚。如果你把一片干面包掉在你的新地毯上，它两面都可能着地。但你把一片一面涂有果酱的面包掉在新地毯上，常常是有果酱的那面朝下。</p>\n<p>墨菲定律告诉我们，容易犯错误是人类与生俱来的弱点，不论科技多发达，事故都会发生。而且我们解决问题的手段越高明，面临的麻烦就越严重。所以，我们在事前应该是尽可能想得周到、全面一些，如果真的发生不幸或者损失，就笑着应对吧，关键在于总结所犯的错误，而不是企图掩盖它。</p>\n<p>2003年美国“哥伦比亚”号航天飞机即将返回地面时，在美国得克萨斯州中部地区上空解体，机上6名美国宇航员以及首位进入太空的以色列宇航员拉蒙全部遇难。“哥伦比亚”号航天飞机失事也印证了墨菲定律。如此复杂的系统是一定要出事的，不是今天，就是明天，合情合理。一次事故之后，人们总是要积极寻找事故原因，以防止下一次事故，这是人的一般理性都能够理解的，否则，或者从此放弃航天事业，或者听任下一次事故再次发生，这都不是一个国家能够接受的结果</p>\n<p>人永远也不可能成为上帝，当你妄自尊大时，“墨菲定律”会叫你知道厉害；相反，如果你承认自己的无知，“墨菲定律”会帮助你做得更严密些。</p>\n<p>这其实是概率在起作用，人算不如天算，如老话说的“上的山多终遇虎”。还有“祸不单行”。如彩票，连着几期没大奖，最后必定滚出一个千万大奖来，灾祸发生的概率虽然也很小，但累积到一定程度，也会从最薄弱环节爆发。所以关键是要平时清扫死角，消除不安全隐患，降低事故概率。</p>\n<h1 id=\"破窗效应\"><a href=\"#破窗效应\" class=\"headerlink\" title=\"破窗效应\"></a>破窗效应</h1><p>美国心理学家詹巴斗曾经做过一个”偷车实验”，将两辆一模一样的轿车分别放在一个环境很好的中产阶级社区和环境比较脏乱的贫民区，结果发现贫民区的车很快被偷走了，而另一辆几天后仍然完好无损；如果将中产阶级社区的那辆车的天窗玻璃打破，几个小时后，那辆车也被偷了。后来，在此实验基础上，美国政治学家威尔逊和犯罪学家凯林提出了有名的”破窗理论”：如果有人打坏了一栋建筑上的一块玻璃，又没有及时修好，别人就可能受到某些暗示性的纵容，去打碎更多的玻璃。 “破窗理论”体现的是细节对人的暗示效果，以及细节对事件结果不容小视的重要作用。事实证明，”破窗理论”也确实能够指导我们的生活。 18世纪的纽约以脏乱差闻名，环境恶劣，同时犯罪猖獗，地铁的情况尤为严重，是罪恶的延伸地，平均每7个逃票的人中就有一个通缉犯，每20个逃票的人中有一个携带武器者。1994年，新任警察局长布拉顿开始治理纽约。他从地铁的车箱开始治理：车箱干净了，站台跟着也变干净了，站台干净了，阶梯也随之整洁了，随后街道也干净了，然后旁边的街道也干净了，后来整个社区干净了，最后整个纽约变了样，变整洁漂亮了。现在纽约是全美国治理最出色的都市之一，这件事也被称为”纽约引爆点”。 还有一个被称为校园里的”破窗现象”：班里新来了一个留级生，由于他的勤奋努力，使得原本想混日子的同学受到震动，学习气氛开始转好，有时老师反复强调的重点，有的人或许不以为然，但是他的一句话–这个内容要考试–便会立即引起同学们的高度重视，留级生的话比老师的话还有效！这说明及时修好第一扇被打破的玻璃，能有效阻止”破窗现象”于萌芽状态。 将”破窗理论”中的玻璃</p>\n<p>在公共场合大声说话，暗示一个人喜欢表现自己；</p>\n<p>穿什么样的袜子，暗示一个人的品位如何；</p>\n<p>在背后说别人坏话的人，在暗示他不可信任；</p>\n<p>对任何事都怀疑的人，暗示他是一个悲观主义者；</p>\n<p>对任何事都不满的人，暗示他是一个愤世嫉俗者；</p>\n<p>不贪小便宜的人，暗示他很正直……</p>\n<p>每件大事都由无数小事–也就是细节构成，将细节尽量做到完美，将来的结果才有可能完美。人的一生也由无数细节组成，将小事做好，给他人留下美好印象，将来才会更美好。</p>\n<h1 id=\"热手效应\"><a href=\"#热手效应\" class=\"headerlink\" title=\"热手效应\"></a>热手效应</h1><p>如果篮球队员投篮连续命中，球迷一般都相信球员“手感好”，下次投篮还会得分。在轮盘游戏中，赌徒往往认定其中的红黑两色会交替出现，如果之前红色出现过多，下次更可能出现黑色。可是，直觉未必是靠得住的。事实上，第一次投篮和第二次投篮是否命中没有任何联系，转动一回轮盘，红色和黑色出现的机会也总是0.5。就像受“热手效应”误导的球迷或受“赌徒谬误”左右的赌徒，投资者预测股价也容易受到之前价格信息的影响，用直觉代替理性分析，产生所谓的“启发式心理”。举个例子，一家制药公司的股价长期上扬，在初期，投资者可能表现为“热手效应”，认为股价的走势会持续，“买涨不买跌”；可一旦股价一直高位上扬，投资者又担心上涨空间越来越小，价格走势会“反转”，所以卖出的倾向增强，产生“赌徒谬误”。“‘热手效应’与‘赌徒谬误’都来自人们心理学上的认知偏差－即认为一系列事件的结果都在某种程度上隐含了自相关的关系”。由南京大学商学院的林树、复旦大学管理学院和清华大学公共管理学院的俞乔、汤震宇、周建四位学者组成的团队，利用心理学实验的方法研究了中国的个体投资者在面对过去股价信息时的交易行为与心理预期。林树、俞乔等发表在《经济研究》8月号、题为《投资者“热手效应”与“赌徒谬误”的心理实验研究》的文章发现，“在中国资本市场上具有较高教育程度的个人投资者或潜在个人投资者中，‘赌徒谬误’效应对股价序列变化的作用均要强于‘热手效应’，占据支配地位”，也就是说，无论股价连续上涨还是下跌，投资者更愿意相信价格走势会逆向反转。根据这一发现，研究认为“在中国股票市场处于中长期‘熊市</p>\n<h1 id=\"睡眠效应\"><a href=\"#睡眠效应\" class=\"headerlink\" title=\"睡眠效应\"></a>睡眠效应</h1><p>使坏印象随时间的流逝而消失邮递销售或上门销售中有这样一项保护消费者的制度，即使是已签定的买卖合同，只要超过了一定期限就会被自动失效。这个制度被称为“冷却制”（coolingoff）。这里的“cooling”是指从一开始认为“很好”到后来可能认为不怎么样的这段冷却期。反过来，起初认为“没有什么好处”的坏印象也可能由于时间的流逝而消失，继而产生好印象。心理学称这种现象为睡眠效应。比如谈判陷入僵局即将破裂时，提出“先吃午饭，等吃完后再做决定吧”，让双方有一段冷静思考的时间。等重开谈判时，进展会异常顺利。谈判到达高潮时或刚刚进行劝说后，给予对方一段思考的时间，会收到良好的效果。因为劝说者与劝说内容的暂时分离会增加信息的可信度，使对方作出冷静的判断。</p>\n<h1 id=\"羊群效应\"><a href=\"#羊群效应\" class=\"headerlink\" title=\"羊群效应\"></a>羊群效应</h1><p>是指管理学上一些企业的市场行为的一种常见现象。例如一个羊群（集体）是一个很散乱的组织，平时大家在一起盲目地左冲右撞。如果一头羊发现了一片肥沃的绿草地，并在那里吃到了新鲜的青草，后来的羊群就会一哄而上，争抢那里的青草，全然不顾旁边虎视眈眈的狼，或者看不到其它还有更好的青草。 羊群效应的出现一般在一个竞争非常激烈的行业上，而且这个行业上有一个领先者（领头羊）占据了主要的注意力，那么整个羊群就会不断摹仿这个领头羊的一举一动，领头羊到哪里去吃草，其它的羊也去哪里淘金。搜索引擎这个市场上的竞争加剧的情况下，搜索引擎的巨头之间对对手之间的动作非常的注意，一旦一个搜索引擎出现某一个新的功能，或者进入一个新的领域，众多的搜索引擎都会去尝试这个新的“水草地”是否真的肥美，是否真得有利可图。</p>\n<h1 id=\"异性效应\"><a href=\"#异性效应\" class=\"headerlink\" title=\"异性效应\"></a>异性效应</h1><p>在人际关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对人的活动和学习通常起积极的影响。这种现象称为“异性效应”. 心理学家曾在一次测试中发现，男性在男、女同桌就餐地要比单纯男性. 就餐时要文明许多，这是由于大多数人在异性面前更注意自己的言行。</p>\n<h1 id=\"马斯洛需求层次理论\"><a href=\"#马斯洛需求层次理论\" class=\"headerlink\" title=\"马斯洛需求层次理论\"></a>马斯洛需求层次理论</h1><p>Maslow’s hierarchy of needs, 该理论将需求分为五种，像阶梯一样从低到高，按层次逐级递升，分别为：生理上的需求，安全上的需求，情感和归属的需求，尊重的需求，自我实现的需求。</p>\n<p>需求层次理论有两个基本出发点，一是人人都有需要，某层需要获得满足后，另一层需要才出现；二是在多种需要未获满足前，首先满足迫切需要；该需要满足后，后面的需要才显示出其激励作用。一般来说，某一层次的需要相对满足了，就会向高一层次发展，追求更高一层次的需要就成为驱使行为的动力。相应的，获得基本满足的需要就不再是一股激励力量。五种需要可以分为两级，其中生理上的需要、安全上的需要和感情上的需要都属于低一级的需要，这些需要通过外部条件就可以满足；而尊重的需要和自我实现的需要是高级需要，他们是通过内部因素才能满足的，而且一个人对尊重和自我实现的需要是无止境的。同一时期，一个人可能有几种需要，但每一时期总有一种需要占支配地位，对行为起决定作用。任何一种需要都不会因为更高层次需要的发展而消失。各层次的需要相互依赖和重叠，高层次的需要发展后，低层次的需要仍然存在，只是对行为影响的程度大大减小</p>\n<p>另外两种需要：求知需要和审美需要。这两种需要未被列入到他的需求层次排列中，他认为这二者应居于尊重需求与自我实现需求之间。</p>\n<h1 id=\"卢维斯定理\"><a href=\"#卢维斯定理\" class=\"headerlink\" title=\"卢维斯定理\"></a>卢维斯定理</h1><p>谦虚不是把自己想得很糟，而是完全不想自己。如果把自己想得太好，就很容易将别人想得很糟。</p>\n<h1 id=\"托利得定理\"><a href=\"#托利得定理\" class=\"headerlink\" title=\"托利得定理\"></a>托利得定理</h1><p>测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。</p>\n","site":{"data":{}},"excerpt":"<p>常见的心理学效应，每天学习一下，站在更高一点的位置看人的行为，会让我们活的更通透一些。</p>","more":"<h1 id=\"承诺定律\"><a href=\"#承诺定律\" class=\"headerlink\" title=\"承诺定律\"></a>承诺定律</h1><p>承诺未必可以保证一定做到，但是如果你没有做出承诺，就算你做到了也没有价值。​</p>\n<h1 id=\"苹果定律\"><a href=\"#苹果定律\" class=\"headerlink\" title=\"苹果定律\"></a>苹果定律</h1><p>如果有一堆苹果，有好有坏，你就应该先吃好的，把坏的令人扔掉，如果你先吃坏的，好的也会变坏，你将永远吃不到好的苹果，人生亦如此。</p>\n<h1 id=\"价值定律\"><a href=\"#价值定律\" class=\"headerlink\" title=\"价值定律\"></a>价值定律</h1><p>当你拥有一项东西的时候，你就会发现这种东西并不像你原来所想的那样有价值。</p>\n<h1 id=\"酝酿效应\"><a href=\"#酝酿效应\" class=\"headerlink\" title=\"酝酿效应\"></a>酝酿效应</h1><p>在古希腊，国王让人做了一顶纯金的王冠，但他又怀疑工匠在王冠中掺了银子。可问题是这顶王冠与当初交给金匠的一样重，谁也不知道金匠到底有没有捣鬼。国王把这个难题交给了阿基米德。阿基米德为了解决这个问题冥思苦想,他起初尝试了很多想法，但都失败了。有一天他去洗澡，一边他一边坐进澡盆，以便看到水往外溢，同时感觉身体被轻轻地托起，他突然恍然大悟，运用浮力原理解决了问题。不管是科学家还是一般人，在解决问题的过程中，我们都可以发现“把难题放在一边，放上一段时间，才能得到满意的答案”这一现象。心理学家将其称为“酝酿效应”。阿基米德发现浮力定律就是酝酿效应的经典故事。日常生活中，我们常常会对一个难题束手无策，不知从何入手，这时思维就进入了“酝酿阶段”。直到有一天，当我们抛开面前的问题去做其他的事情时，百思不得其解的答案却突然出现在我们面前，令我们忍不住发出类似阿基米德的惊叹，这时，“酝酿效应”就绽开了“思维之花”，结出了“答案之果”。古代诗词说“山重水复疑无路，柳暗花明又一村”正是这一心理的写照。 心理学家认为，酝酿过程中，存在潜在的意识层面推理，储存在记忆里的相关信息在潜意识里组合，人们之所以在休息的时候突然找到答案，是因为个体消除了前期的心理紧张，忘记了个体前面不正确的、导致僵局的思路，具有了创造性的思维状态。因此，如果你面临一个难题，不妨先把它放在一边，去和朋友散步、喝茶，或许答案真的会“踏破铁鞋无觅处，得来全不费功夫”。</p>\n<h1 id=\"阿伦森效应\"><a href=\"#阿伦森效应\" class=\"headerlink\" title=\"阿伦森效应\"></a>阿伦森效应</h1><p>是指人们最喜欢那些对自己的喜欢、奖励、赞扬不断增加的人或物，最不喜欢那些显得不断减少的人或物。心理学家做过一个实验,分4组人对某一人给予不同的评价，借以观察某人对哪一组最具好感。第一组始终对之褒扬有加，第二组始终对之贬损否定，第三组先褒后贬，第四组先贬后褒。结果此实验对数十人进行过后，发现绝大部分人对第四组最具好感，而对第三组最为反感。阿伦森效应提醒人们，在日常工作与生活中，应该尽力避免由于自己的表现不当所造成的他人对自己印象不良方向的逆转。同样，它也提醒我们在形成对别人的印象过程中，要避免受它的影响而形成错误的态度。有个案例说道: 在宿舍楼的后面，停放着一部烂汽车，大院里的孩子们每当晚上7点时，便攀上车厢蹦跳，嘭嘭之声震耳欲聋，大人们越管，众孩童蹦得越欢，见者无奈。这天，一个人对孩子们说：“小朋友们，今晚你们比赛，蹦得最响的奖玩具手枪一支。”众童呜呼雀跃，争相蹦跳，优者果然得奖。次日，这位朋友又来到车前，说：“今天继续比赛，奖品为两粒奶糖。”众童见奖品直线下跌，纷纷不悦，无人卖力蹦跳，声音疏稀而弱小。第三天，朋友又对孩子们言：“今日奖品为花生米二粒。”众童纷纷跳下汽车，皆说：“不蹦了，不蹦了，真没意思，回家看电视了。” 在“正面难攻”的情况下，采用“奖励递减法”可起到奇妙心理效应。<br>又有个案例说道: 小刚大学毕业后分到一个单位工作，刚一进单位，他决心好好地积极表现一番，以给领导和同事们留下非常好的第一印象。于是，他每天提前到单位打水扫地，节假日主动要求加班，领导布置的任务有些他明明有很大的困难，也硬着头皮一概承揽下来。本来，刚刚走上工作岗位的青年人积极表现一下自我是无可厚议的。但问题是小刚的此时表现与其真正的思想觉悟、为人处世的一贯态度和行为模式相差甚远，夹杂着“过分表演”的成分。因而就难以有长久的坚持性。没过多久，小刚水也不打了，地也不拖了，还经常迟到，对领导布置的任务更是挑肥拣瘦。结果，领导和同事们对他的印象由好转坏，甚至比那些刚开始来的时候表现不佳的青年所持的印象还不好。因为大家对他已有了一个“高期待、高标准”，另外，大家认为他刚开始的积极表现是“装假”，而“诚实”是我们社会评定一个人所运用的“核心品质”。</p>\n<h1 id=\"巴霖效应\"><a href=\"#巴霖效应\" class=\"headerlink\" title=\"巴霖效应\"></a>巴霖效应</h1><p>源自于马戏团经理巴霖先生的一句名言：每分钟都有一名笨蛋诞生。”巴霖效应” 多少解释了为什么有些星座或生肖书刊能够”准确的”指出某人的性格。原因在此,那些用来描述性格的词句,其实根本属”人之常情”或基本上适用于大部分人身上的。换言之,那些词句的适用范围是如此的空泛，以至往往”说了等于没说。例如:水瓶座理性而爱好自由，巨蟹座感性而富爱心；然而巨蟹座的人就永远没理性，水瓶座的人就缺乏爱心吗？我们不去否定星座存在的价值，毕竟它存有统计的基础在。但如果你想成为一个聪明人，不去迷信星座，我又得告诉你，你又错了！知道什么叫做”天醉人亦醉”吗?既然身旁有超过半数的人相信星座，你又何苦试着去推翻那根植于心的观念(实际上也不太可能)? 如果一对情侣在星座学中是不甚相配的，即使两人都不迷信，但他们的心理必然会承受一股不小的压力，在往后交往的时间中，若有了冲突磨擦，心中既存的那种”原来真的不合适”的预设就会被强迫成立，最终难逃分手命运!巴霖效应与巴纳姆效应相同, 巴纳姆效应是由心理学家伯特伦·福勒于1948年通过试验证明的一种心理学现象，它主要表现为：每个人都会很容易相信一个笼统的、一般性的人格描述特别适合他。即使这种描述十分空洞，他仍然认为反映了自己的人格面貌。而要避免巴纳姆效应，就应客观真实地认识自己。</p>\n<h1 id=\"半途效应\"><a href=\"#半途效应\" class=\"headerlink\" title=\"半途效应\"></a>半途效应</h1><p>半途效应是指在激励过程中达到半途时，由于心理因素及环境因素的交互作用而导致的对于目标行为的一种负面影响。大量的事实表明，人的目标行为的中止期多发生在”半途”附近，在人的目标行为过程的中点附近是一个极其敏感和极其脆弱的活跃区域。导致半途效应的原因主要有两个，一是目标选择的合理性，目标选择的越不合理越容易出现半途效应；二是个人的意志力，意志力越弱的人越容易出现半途效应。这就要求班主任在平时教育学生时多注意学习各方面的知识，培养多方面的能力，同时多注意进行意志力的磨练。行为学家提出了”大目标、小步子”的方法，对于防止半途效应的发生具有积极的意义。</p>\n<h1 id=\"比马龙效应\"><a href=\"#比马龙效应\" class=\"headerlink\" title=\"比马龙效应\"></a>比马龙效应</h1><p>评价主体低估被评价者能力，认定被评价者是不求上进的、行为差劲的，以致被评价者将这种观念内化，促使被评价者表现不良行为。你有过这样的经历吗？本来穿了一件自认为是很漂亮的衣服去上班，结果好几个同事都说不好看，当第一个同事说的时候，你可能还觉得只是她的个人看法，但是说的人多了，你就慢慢开始怀疑自己的判断力和审美眼光了，于是到了下班后，你回家做的第一件事情就是把衣服换下来，并且决定再也不穿它去上班了。又比如, 如果家长们一直对自己的孩子说你为什么这么笨啊, 久而久之, 这个孩子就会潜移默化地以为自己很笨. 其实，这只是心理暗示在起作用。暗示作用往往会使别人不自觉地按照一定的方式行动，或者不加批判地接受一定的意见或信念。可见，暗示在本质上，是人的情感和观念，会不同程度地受到别人下意识的影响。</p>\n<h1 id=\"边际效应\"><a href=\"#边际效应\" class=\"headerlink\" title=\"边际效应\"></a>边际效应</h1><p>有时也称为边际贡献，是指消费者在逐次增加1个单位消费品的时候，带来的单位效用是逐渐递减的（虽然带来的总效用仍然是增加的）。</p>\n<p>举一个通俗的例子，当你肚子很饿的时候，有人给你拿来一笼包子，那你一定感觉吃第一个包子的感觉是最好的，吃的越多，单个包子给你带来的满足感就越小，直到你吃撑了，那其它的包子已经起不到任何效用了。边际效应的应用非常广泛，例如经济学上的需求法则就是以此为依据，即：用户购买或使用商品数量越多，则其愿为单位商品支付的成本越低（因为后购买的商品对其带来的效用降低了）。当然也有少数例外情况，例如嗜酒如命的人，是越喝越高兴，或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。了解边际效应的概念，你就可以尝试去在实际生活中运用它，例如：你是公司管理层，要给员工涨工资，给 3K 月薪的人增加 1K 带来的效应一般来说是比 6K 月薪增加 1K 大的，可能和 6K 月薪的人增加 2K 的相当，所以似乎给低收入的人增加月薪更对公司有利；另外，经常靠增加薪水来维持员工的工作热情看来也是不行的，第一次涨薪 1K 后，员工非常激动，大大增加了工作热情；第二次涨薪 1K，很激动，增加了一些工作热情；第三次涨薪 2K ，有点激动，可能增加工作热情；第四次 … … ，直至涨薪已经带来不了任何效果。如果想避免这种情况，每次涨薪都想达到和第一次涨薪 1K 相同的效果，则第二次涨薪可能需要 2K ，第三次需要 3K … … ，或者使用其它激励措施，例如第二次可以安排其参加职业发展培训，第三次可以对其在职位上进行提升，虽然花费可能想当，但由于手段不同，达到了更好的效果。研究经济学其实也很有意思，只是对很多人来说，与 IT 这个行业不可完全兼得。</p>\n<p>1). 边际效应递减:边际效益递减是经济学的一个基本概念，它说的是在一个以资源作为投入的企业，单位资源投入对产品产出的效用是不断递减的，换句话，就是虽然其产出总量是递增的，但是其二阶倒数为负，使得其增长速度不断变慢，使得其最终趋于峰值，并有可能衰退。最明显的诠释，就是非线性函数，例如二次曲线。在生活中，我们可以看到许多例子：给你一个可爱多，你高兴的乱跳以为赚了，接下来是第二个……可是一直给你，你会觉得开始恶心了。这有两个原因：一，你吃饱 了，生理不需要了，二，你吃腻了，刺激受够了。你希望有个机会表白自己“老大，给个哈根啊好啊？”</p>\n<p>所谓的新官上任三把火，讲的也是这个道理：刚来了要混个脸熟，所以拼尽全力在所不辞。日子一久，也就澹了。一般的教材会这样解释：神秘莫测的心理学和社会 学。我们可以想想，边际效用递减式一个无处不在的规律，你想过四级，于是找了本宝书，从A背起，不错，一会儿就背完 呢（当然，本来A就不太多，我就是这种人），然后是B，然后是……B part2，然后是B part 2 1/2…级数的概念有了应用。当然你可以选择从Z开始背回头（当然，我也是这种人）。 可见，投入和产出是相同的概念，由于投入了就要求有产出，所以边际效益递减的逆仍然适用。 我们可以拓展到离开效用这个概念。让我们看一个实际中的问题： 昨天打扫房间卫生，发现刚刚擦过的桌子一层灰又上去了，和旁边的一个小支架看上去没什么区别。实际上，后者上次被美容的时候我还没在南京…… 一个东西从干净到涨很快，可是从脏到很脏是一个多么漫长的过程阿，指望考古队？（尽管也有评价的因素） 大家还可以想到很多很多，比如，人文一点，“失去的才是真”。</p>\n<p>我们如何利用这个规律呢？经济学的解释是资源的最优配置。因为投入的太多使得 最终的收益摊的太薄。再好的东西也有个限度。理工科的更加清楚，所谓的各种高级操作都是某种程度上的吃力不讨好，最有效的往往是那些基本操作。更高深的是 当然一些数学上的游戏。 然而我觉得，这个现象的起源绝对是一个哲学问题，那就是我们为什么进步和发展。 想想，如果边际效益递增，我们还需要创新吗？我们还需要坚持吗？同志们，可爱多足够了，不，凉水就行！魅力这个词，永远的就失去了意义。</p>\n<p>2). 边际效应递增: 有时候边际效应有时候也是递增的。当然也有少数例外情况，例如嗜酒如命的人，越喝越高兴，或者吸毒的人，越吸越想吸。或者集邮爱好者收藏一套文革邮票，那么这一套邮票中最后收集到的那张邮票的边际效应是最大的。​</p>\n<h1 id=\"超限效应\"><a href=\"#超限效应\" class=\"headerlink\" title=\"超限效应\"></a>超限效应</h1><p>美国着名幽默作家马克·吐温有一次在教堂听牧师演讲。最初，他觉得牧师讲得很好，使人感动，准备捐款。过了10分钟，牧师还没有讲完，他有些不耐烦了，决定只捐一些零钱。又过了10分钟，牧师还没有讲完，于是他决定，1分钱也不捐。到牧师终于结束了冗长的演讲，开始募捐时，马克·吐温由于气愤，不仅未捐钱，还从盘子里偷了2元钱。 这种刺激过多、过强和作用时间过久而引起心理极不耐烦或反抗的心理现象，称之为“超限效应”。 超限效应在家庭教育中时常发生。如：当孩子不用心而没考好时，父母会一次、两次、三次，甚至四次、五次重复对一件事作同样的批评，使孩子从内疚不安到不耐烦最后反感讨厌。被“逼急”了，就会出现“我偏要这样”的反抗心理和行为。 因为孩子一旦受到批评，总需要一段时间才能恢复心理平衡，受到重复批评时，他心里会嘀咕：“怎么老这样对我？”孩子挨批评的心情就无法复归平静，反抗心理就高亢起来。 可见，家长对孩子的批评不能超过限度，应对孩子“犯一次错，只批评一次”。如果非要再次批评，那也不应简单地重复，要换个角度，换种说法。这样，孩子才不会觉得同样的错误被“揪住不放”，厌烦心理、逆反心理也会随之减低。</p>\n<h1 id=\"拆屋效应\"><a href=\"#拆屋效应\" class=\"headerlink\" title=\"拆屋效应\"></a>拆屋效应</h1><p>鲁迅先生曾于1927年在《无声的中国》一文中写下了这样一段文字：”中国人的性情总是喜欢调和、折中的，譬如你说，这屋子太暗，说在这里开一个天窗，大家一定是不允许的，但如果你主张拆掉屋顶，他们就会来调和，愿意开天窗了。”这种先提出很大的要求，接着提出较小较少的要求，在心理学上被称为”拆屋效应”。虽然这一效应在XXXXX生活中多见，但也有不少学生学会了这些。如有的学生犯了错误后离家出走，班主任很着急，过了几天学生安全回来后，班主任反倒不再过多地去追究学生的错误了。实际上在这里，离家出走相当于”拆屋”，犯了错误相当于”开天窗”，用的就是拆屋效应。因此，班主任在教育学生的过程中，教育方法一定要恰当，能被学生所接受，同时，对学生的不合理要求或不良的行为绝不能迁就，特别要注意不能让学生在这些方面养成与班主任讨价还价的习惯。</p>\n<h1 id=\"刺猬法则\"><a href=\"#刺猬法则\" class=\"headerlink\" title=\"刺猬法则\"></a>刺猬法则</h1><p>刺猬法则可以用这样一个有趣的现象来形象地说明：两只困倦的刺猬由于寒冷而拥在一起，可怎么也睡不舒服，因为各自身上都长着刺，紧挨在一块，反而无法睡得安宁。几经折腾，两只刺猬拉开距离，尽管外面寒风呼呼，可它们却睡得甜乎乎的。刺猬法则就是人际交往中的“心理距离效应”。管理心理学专家的研究认为：领导者要搞好工作应该与下属保持亲密关系，但这是“亲密有间”的关系。特别要提醒的是，领导者与下属亲密无间地相处，还容易导致彼此称兄道弟、吃喝不分，并在工作中丧失原则。</p>\n<h1 id=\"从众效应\"><a href=\"#从众效应\" class=\"headerlink\" title=\"从众效应\"></a>从众效应</h1><p>有一个成语叫做三人成虎，意思是说，有三个人谎报市上有老虎，听者就信以为真。这种人在社会群体中容易不加分析地接受大多数人认同的观点或行为的心理倾向被称为从众效应。这一效应的启示是：班主任要善于发挥从众效应的积极作用，首先要有意识地通过班会、黑板报等舆论阵地大张旗鼓地进行宣传；其次，要抓好班团干部和积极分子等基本队伍的建设，组成坚强的堡垒，要及时发现班上的不良倾向，对症下药，将其遏制在萌芽状态，以防止产生从众效应的负作用。 从众效应是指在群体活动中，当个人与多数人的意见和行为不一致时，个人放弃自己的意见和行为，表现出与群体中多数人相一致的意见和行为方式的现象。从众也就是我们日常俗语中所说的“随大流”。 促使一个人在合作中产生从众行为的因素有多种，一般认为主要有：小组里有较优势的学生存在；个性特质如智力的低、胆小、顾虑多、意志不坚定、自信心差、过于重视他人并依赖他人者等；小组人数的规模等因素。 毋庸质疑，从众有利于形成统一的小组意见，合理的小组环境可以促进或潜移默化地使落后的小组成员形成正确的思想与行为。同时，应该指出，在不合理的小组环境里，由于从众效应表现为趋向学习结论一致，而不一定是学习结论正确；部分学生容易与自信或学习优秀的小组成员的观点、思维方法形成一致，而忽视自己地观点、思维方法正确与否，小组合作的结果可能是以虚假的多数形成错误的小组结论。可见，从众效应容易压制正确思想的形成，窒息小组成员的独创精神；合作学习有时有弱化独立思考的趋势，个体在群体中容易丧失了对自我的控制，失去了个体感，使人“人云亦云”。我们需要的</p>\n<h1 id=\"淬火效应\"><a href=\"#淬火效应\" class=\"headerlink\" title=\"淬火效应\"></a>淬火效应</h1><p>金属工件加热到一定温度后，浸入冷却剂(油、水等)中，经过冷却处理，工件的性能更好、更稳定。长期受表扬头脑有些发热的学生，不妨设置一点小小的障碍，施以“挫折教育”，几经锻炼，其心理会更趋成熟，心理承受能力会更强；对于麻烦事或者已经激化的矛盾，不妨采用“冷处理”，放一段时间，思考得会更周全，办法会更稳妥。</p>\n<h1 id=\"得寸进尺效应\"><a href=\"#得寸进尺效应\" class=\"headerlink\" title=\"得寸进尺效应\"></a>得寸进尺效应</h1><p>美国社会心理学家弗里得曼做了一个有趣的实验：他让助手去访问一些家庭主妇，请求被访问者答应将一个小招牌挂在窗户上，她们答应了。过了半个月，实验者再次登门，要求将一个大招牌放在庭院内，这个牌子不仅大，而且很不美观。同时，实验者也向以前没有放过小招牌的家庭主妇提出同样的要求。结果前者有55%的人同意，而后者只有不到17%的人同意，前者比后者高3倍。后来人们把这种心理现象叫作“得寸进尺效应”。心理学认为，人的每个意志行动都有行动的最初目标，在许多场合下，由于人的动机是复杂的，人常常面临各种不同目标的比较、权衡和选择，在相同情况下，那些简单容易的目标容易让人接受。另外，人们总愿意把自己调整成前后一贯、首尾一致的形象，即使别人的要求有些过分，但为了维护印象的一贯性，人们也会继续下去。上述心理效应告诉我们，要让他人接受一个很大的、甚至是很难的要求时，最好先让他接受一个小要求，一旦他接受了这个小要求，他就比较容易接受更高的要求。差生作为一个特殊群体，其身心素质和学习基础等方面都低于一般水平。转化差生，也要像弗里得曼一样善于引导，善于“搭梯子”，使之逐渐转化；应贯彻“小步子、低台阶、勤帮助、多照应”的原则，注意“梯子”依靠的地方要正确、间距不宜太大、太陡，做到扶一扶“梯子”，托一托人。</p>\n<h1 id=\"定势效应\"><a href=\"#定势效应\" class=\"headerlink\" title=\"定势效应\"></a>定势效应</h1><p>有一个农夫丢失了一把斧头，怀疑是邻居的儿子偷盗，于是观察他走路的样子，脸上的表情，感到言行举止就像偷斧头的贼。后来农夫找到了丢失的斧头，他再看邻居的儿子，竟觉得言行举止中没有一点偷斧头的模样了。这则故事描述了农夫在心理定势作用下的心理活动过程。所谓心理定势是指人们在认知活动中用“老眼光”——已有的知识经验来看待当前的问题的一种心理反应倾向，也叫思维定势或心向。在人际交往中，定势效应表现在人们用一种固定化了的人物形象去认知他人。例如：我们与老年人交往中，我们会认为他们思想僵化，墨守成规，跟不上时代；而他们则会认为我们年纪轻轻，缺乏经验，“嘴巴无毛，办事不牢”。与同学相处时，我们会认为诚实的人始终不会说谎；而一旦我们认为某个人老奸巨猾，既使他对你表示好感，你也会认为这是“黄鼠狼给鸡拜年没安好心”。 心理定势效应常常会导致偏见和成见，阻碍我们正确地认知他人。所以我们要“士别三日，当刮目相看”他人呀！不要一味地用老眼光来看人处事。</p>\n<h1 id=\"多看效应\"><a href=\"#多看效应\" class=\"headerlink\" title=\"多看效应\"></a>多看效应</h1><p>转在许多人眼中，喜新厌旧是人的天性。然而,事实果真是如此吗?20世纪60年代,心理学家查荣茨做过试验:先向被试出示一些照片,有的出现了20多次,有的出现了10多次,有的只出现一两次,然后请别试评价对照片的喜爱程度,结果发现,被试更喜欢那些只看过几次的新鲜照片,既看的次数增加了喜欢的程度.这种对越熟悉的东西就越喜欢的现象,心理学上称为多看效应.在人际交往中,如果你细心观察就会发现,那些人缘很好的人,往往将多看效应发挥的淋漓尽致:他们善于制造双方接触的机会,已提高彼此间的熟悉度,然后互相产生更强的吸引力.人际吸引难道真的是如此的简单?有社会心理学的实验做佐证:在一所大学的女生宿舍楼里,心理学家随机找了几个寝室,发给她们不同口味的饮料,然后要求这几个寝室的女生,可以以品尝饮料为理由,在这些寝室间互相走动,但见面时不得交谈.一段时间后,心理学家评估她们之间的熟悉和喜欢的程度,结果发现:见面的次数越多,互相喜欢的程度越大:见面的次数越少或根本没有,相互喜欢的程度也较低.</p>\n<p>可见,若想增强人际吸引,就要留心提高自己在别人面前的熟悉度,这样可以增加别人喜欢你的程度.因此,一个自我封闭的人,或是一个面对他人就逃避和退缩的人，由于不易让人亲近而另人费解,也就是太讨人喜欢.</p>\n<p>当然,多看效应发挥作用的前提,是首因效应要好,若给人的第一印象不很差,则见面越多就越讨人厌,多看效应反而起了副用.</p>\n<h1 id=\"首因效应\"><a href=\"#首因效应\" class=\"headerlink\" title=\"首因效应\"></a>首因效应</h1><p>首因效应，是人与人第一次交往中给人留下的印象，在对方的头脑中形成并占据着主导地位的效应。首因效应也叫首次效应、优先效应或第一印象效应。它是指当人们第一次与某物或某人相接触时会留下深刻印象，个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。 第一印象作用最强，持续的时间也长，比以后得到的信息对于事物整个印象产生的作用更强。首因，是指首次认知客体而在脑中留下的第一印象。首因效应，是指个体在社会认知过程中，通过“第一印象”最先输入的信息对客体以后的认知产生的影响作用。</p>\n<h1 id=\"近因效应\"><a href=\"#近因效应\" class=\"headerlink\" title=\"近因效应\"></a>近因效应</h1><p>所谓近因效应：与首因效应相反. 最近、最后的印象，往往是最强烈的，可以冲澹在此之前产生的各种因素，这就是近因效应。有这样一个例子：面试过程中，主考官告诉考生可以走了，可当考生要离开考场时，主考官又叫住他，对他说，你已回答了我们所提出的问题，评委觉得不怎么样，你对此怎么看？其实，考官做出这么一种设置，是对毕业生的最后一考，想借此考察一下应聘者的心理素质和临场应变能力。如果这一道题回答得精彩，大可弥补此前面试中的缺憾；如果回答得不好，可能会由于这最后的关键性试题而使应聘者前功尽弃</p>\n<h1 id=\"凡勃伦效应\"><a href=\"#凡勃伦效应\" class=\"headerlink\" title=\"凡勃伦效应\"></a>凡勃伦效应</h1><p>一些商品价格定得越高，就越能受到消费者的青睐。我们经常在生活中看到这样的情景：款式、皮质差不多的一双皮鞋，在普通的鞋店卖80元，进入大商场的柜台，就要卖到几百元，却总有人愿意买。1.66万元的眼镜架、6.88万元的纪念表、168万元的顶级钢琴，这些近乎“天价”的商品流通，往往也能在市场上走俏。其实，消费者购买这类商品的目的并不仅仅是为了获得直接的物质满足和享受，更大程度上是为了获得心理上的满足。这就出现了一种奇特的经济现象，即一些商品价格定得越高，就越能受到消费者的青睐。由于这一现象最早由美国经济学家凡勃伦注意到，因此被命名为“凡勃伦效应”。随着社会经济的发展，人们的消费会随着收入的增加，而逐步由追求数量和质量过渡到追求品位格调。了解了“凡勃伦效应”，我们也可以利用它来探索新的经营策略。比如凭借媒体的宣传，将自己的形象转化为商品或服务上的声誉，使商品附带上一种高层次的形象，给人以“名贵”和“超凡脱俗”的印象，从而加强消费者对商品的好感。这种价值的转换在消费者从数量，质量购买阶段过渡到感性购买阶段时，就成为可能。实际上，在东南沿海的一些发达地区，感性消费已经逐渐成为一种时尚，而只要消费者有能力进行这种感性购买时，“凡勃伦效应”就可以被有效地转化为提高市场份额营销策略。</p>\n<h1 id=\"共生效应\"><a href=\"#共生效应\" class=\"headerlink\" title=\"共生效应\"></a>共生效应</h1><p>植物界中相互影响、相互促进的现象,称之为:共生效应 在自然界，一株植物单独生长时，往往长势不旺，没有生机，甚至枯萎衰败，而当众多植物一起生长时，却能郁郁葱葱，挺拔茂盛，人们把这种植物中这种相互影响、相互促进的现象称之为“共生效应”。 共生就是两者相互利用（虽然这个词是贬义词，但实际就是这样），同时有利于双方发展的现象，这种情况应不仅限于自然界，人类社会也会有。</p>\n<h1 id=\"黑暗效应\"><a href=\"#黑暗效应\" class=\"headerlink\" title=\"黑暗效应\"></a>黑暗效应</h1><p>在光线比较暗的场所，约会双方彼此看不清对方表情，就很容易减少戒备感而产生安全感。在这种情况下，彼此产生亲近的可能性就会远远高于光线比较亮的场所。心理学家将这种现象称之为“黑暗效应”。有个这样的案例：有一位男子钟情于一位女子，但每次约会，他总觉得双方谈话不投机。有一天晚上，他约那位女子到一家光线比较暗的酒吧，结果这次谈话融洽投机。从此以后，这位男子将约会的地点都选择在光线比较暗的酒吧。几次约会之后，他俩终于决定结下百年之好。 社会心理学家研究后的结论是，在正常情况下，一般的人都能根据对方和外界条件来决定自己应该掏出多少心里话，特别是对还不十分了解但又愿意继续交往的人，既有一种戒备感，又会自然而然地把自己好的方面尽量展示出来，把自己弱点和缺点尽量隐藏起来。因此，这时双方就相对难以沟通。</p>\n<h1 id=\"棘轮效应\"><a href=\"#棘轮效应\" class=\"headerlink\" title=\"棘轮效应\"></a>棘轮效应</h1><p>商朝时，纣王登位之初，天下人都认为这位精明的国君的治理下，商朝的江山一定会坚如磐石。有一天，纣王命人用象牙做了一双筷子，十分高兴地使用这双象牙筷子就餐。他的叔父箕子见了，劝他收藏起来，而纣王却满不在乎，满朝文武大臣也不以为然，认为这本来是一件很平常的小事。箕子为此忧心忡忡，有的大臣莫名其妙地问他原因，箕子回答说：“纣王用象牙做筷子，必定再不会用土制的瓦罐盛汤装饭，肯定要改用犀牛角做成的杯子和美玉制成的饭碗；有了象牙筷、犀牛角杯和美玉碗，难道还会用它来吃粗茶澹饭和豆子煮的汤吗？大王的餐桌从此顿顿都要摆上美酒佳肴了；吃的是美酒佳肴，穿的自然要绫罗绸缎，住的就要求富丽堂皇，还要大兴土木筑起楼台亭阁以便取乐了。对这样的后果我觉得不寒而栗。”仅仅5年时间，箕子的预言果然应验了，商纣王瓷意骄奢，便断送了商汤绵延500年的江山。在上面的故事中，箕子对纣王使用象牙筷子的评价，运用了现代经济学一种消费效应――棘轮效应。所谓棘轮效应，又称制轮作用，是指人的消费习惯形成之后有不可逆性，即易于向上调整，而难于向下调整。尤其是在短期内消费是不可逆的，其习惯效应较大。这种习惯效应，使消费取决于相对收入，即相对于自己过去的高峰收入。这一效应是经济学家杜森贝提出的。古典经济学家凯恩斯主张消费是可逆的，即绝对收入水平变动必然立即引起消费水平的变化。针对这一观点，杜森贝认为这实际上是不可能的，因为消费决策不可能是一种理想的计划，它还取决于消费习惯。这种消费习惯受许多因素影响，如生理和社会需要、个人的经历、个人经历的后果等。特别是个人在收入最高期所达到的</p>\n<p>从个人的角度来说，我们对于欲望既不能禁止，也不能放纵，对于过度的及至贪得无厌的奢求，必须加以节制。如果对自己的欲望不加限制的话，过度地放纵奢侈，没能培养俭仆的生活习惯，必然会使自古“富不过三代”之说就成了必然，就必然出现“君子多欲，则贪慕富贵，枉道速祸；小人多欲，则多求妄用，败家丧身。是以居官必贿，居乡必盗”的情况。西方一些成功企业家虽家境富裕，但依然对子女要求极严，从不给孩子更多的零花钱，甚至寒暑假还让孩子四处打工。这些成功企业家并不是苛求子女能为自己多赚一点钱，而是希望子女懂得每一分钱的来之不易，懂得俭仆和自立。</p>\n<h1 id=\"奖惩效应\"><a href=\"#奖惩效应\" class=\"headerlink\" title=\"奖惩效应\"></a>奖惩效应</h1><p>奖励和惩罚是对学生行为的外部强化或弱化的手段，它通过影响学生的自身评价，能对学生的心理产生重大影响，由奖惩所带来的行为的强化或弱化就叫做奖惩效应。心理学实验证明，表扬、鼓励和信任，往往能激发一个人的自尊心和上进心。但奖励学生的原则应是精神奖励重于物质奖励，否则易造成”为钱而学”、”为班主任而学”的心态。同时奖励要抓住时机，掌握分寸，不断升化。当然”没有惩罚就没有教育”，必要的惩罚是控制学生行为的有效信号。惩罚时用语要得体、适度、就事论事，使学生明白为什么受罚和怎样改过。同时还应注意的是奖惩的频率，从心理学的研究结果看，当奖惩的比例为5：1时往往效果最好。</p>\n<h1 id=\"结伴效应\"><a href=\"#结伴效应\" class=\"headerlink\" title=\"结伴效应\"></a>结伴效应</h1><p>是指两个人或几个人结伴从事相同的一项活动时（并不进行竞赛）相互之间会产生刺激作用，提高活动效率。例如：学生在一起作作业比独立完成作业的效率高。 可以相应组成学习小组。教师应注意课上的效率，注意时间分配。…</p>\n<h1 id=\"空白效应\"><a href=\"#空白效应\" class=\"headerlink\" title=\"空白效应\"></a>空白效应</h1><p>心理实验表明，在演讲的过程中，适当地留一些空白，会取得良好的演讲效果，这就是空白效应。它给我们的启示是，班主任要善于留白，如在表达方面留白，针对某些问题，班主任不妨先不说出自己的观点，让学生去想、去说，让学生有表达自己意见的机会。在实践方面留白，给学生一个锻炼和实践的机会，提高学生的动手能力。在思考方面留白，班主任应给学生思考分析的机会，让学生独立地思考、判断和面对，学生的分析能力就会逐渐提高。在批评方面留白，批评之后，留有学生自己去思考、自己去责备的时间。这样学生就不会有一种被”穷追不舍”之感，反抗心理就会锐减。</p>\n<h1 id=\"青蛙现象\"><a href=\"#青蛙现象\" class=\"headerlink\" title=\"青蛙现象\"></a>青蛙现象</h1><p>青蛙现象：把一只青蛙直接放进热水锅里，由于它对不良环境的反应十分敏感，就会迅速跳出锅外。如果把一个青蛙放进冷水锅里，慢 慢地加温，青蛙并不会立即跳出锅外，水温逐渐提高的最终结局是青蛙被煮死了，因为等水温高到青蛙无法忍受时，它已经来不及、或者说是没有能力跳出锅外了。青蛙现象告诉我们，一些突变事件，往往容易引起人们的警觉，而易致人于死地的却是在自我感觉良好的情况下，对实际情况的逐渐恶化，没有清醒的察觉。启示之一是：我们的组织和社会生存的主要威胁，并非来自突如其来的事件，而是由缓慢渐进而无法察觉的过程形成。人们目光短浅，只看到局部，而无法纵观全局，对于突如其来的变化，可以从容面对，对于悄悄发生的大的变化，而无法察觉，最终会带给我们更加严重的危害！~启示之二是：青蛙，就好象是我们生活中的芸芸众生，我们要着眼未来，勤于思考新的问题，勤于学习新的知识，不能过“今日有酒，今日醉”和“当一天和尚，撞一天钟”的醉生梦死的生活，到头来将是非常可悲的！</p>\n<p>启示之三是：当今的社会，是一个知识爆炸、日新月异的时代，知识也需要不断更新，所以我们不要一味的沉迷于现状、安于现状，不思进取，这样下去的话，肯定会被时代所淘汰，也会有面临失业的危险！</p>\n<p>启示之四是：我们不要单纯的，只能面对突如其来的危险，而忽视那种缓慢而又微小甚微的危险，因为，那种缓慢而又微小甚微的危险，才是最可怕的！</p>\n<h1 id=\"21天效应\"><a href=\"#21天效应\" class=\"headerlink\" title=\"21天效应\"></a>21天效应</h1><p>在行为心理学中，人们把一个人的新习惯或理念的形成并得以巩固至少需要21天的现象，称之为21天效应。也就是说，一个人的动作、或想法，如果重复21天就会变成一个习惯性的动作或想法。</p>\n<p>根据我国成功学专家易发久研究，习惯的形成大致分为三个阶段：</p>\n<p>第一阶段：1-7天左右。此阶段表现为“刻意，不自然”，需要十分刻意地提醒自己。</p>\n<p>第二阶段：7-21天左右。此阶段表现为“刻意，自然”，但还需要意识控制。</p>\n<p>第三阶段：21-90天左右，此阶段表现为“不经意，自然”，无需意识控制。</p>\n<h1 id=\"本杰明富兰克林效应\"><a href=\"#本杰明富兰克林效应\" class=\"headerlink\" title=\"本杰明富兰克林效应\"></a>本杰明富兰克林效应</h1><p>让别人喜欢你的最好方法不是去帮助他们，而是让他们来帮助你。—— 本杰明·富兰克林效应,</p>\n<p>本杰明 富兰克林效应的现象启示我们，如果你对一个人行善举，那么往往会得到好的结果。当然这绝非是种“果报”理论<br>本杰明 富兰克林曾表示，通过向一个不喜爱他的议员借书，他们俩最终成为了要好的朋友。认知失调理论的解释为，如果我们去帮助一个不喜欢的人，结果说不定就会喜欢上他—— 当我们给予不喜欢的人帮助时，其实是经历了一种失调，我们的行为和对此人的态度之间发生了矛盾。为了缓解这种失调，我们会尽力说服自己这个人是好的、值得帮助的，从而注意并强调了其优点，而澹化了自己本来不喜爱他的事实。这个故事倒是给了我们一点启示：如果想追求一个本来不怎么喜欢你的姑娘，或许也可以通过求得她帮忙的方式来逐步制造她对你的好感呢？</p>\n<h1 id=\"史密斯原则\"><a href=\"#史密斯原则\" class=\"headerlink\" title=\"史密斯原则\"></a>史密斯原则</h1><p>如果你不能战胜他们，你就加入到他们之中去。竞争使人进步最快，合作让人得到最多。</p>\n<h1 id=\"鸟笼逻辑\"><a href=\"#鸟笼逻辑\" class=\"headerlink\" title=\"鸟笼逻辑\"></a>鸟笼逻辑</h1><p>挂一个漂亮的鸟笼在房间里最显眼的地方，过不了几天，主人一定会做出下面两个选择之一：把鸟笼扔掉，或者买一只鸟回来放在鸟笼里。这就是鸟笼逻辑。过程很 简单，设想你是这房间的主人，只要有人走进房间，看到鸟笼，就会忍不住问你：“鸟呢？是不是死了？”当你回答：“我从来都没有养过鸟。”人们会问：“那么，你要一个鸟笼干什么？”最后你不得不在两个选择中二选一，因为这比无休止的解释要容易得多。鸟笼逻辑的原因很简单：人们绝大部分的时候是采取惯性思维。所以可见在生活和工作中培养逻辑思维是多么重要</p>\n<h1 id=\"责任分散效应\"><a href=\"#责任分散效应\" class=\"headerlink\" title=\"责任分散效应\"></a>责任分散效应</h1><p>1964年3月13日夜3时20分，在美国纽约郊外某公寓前，一位叫朱诺比白的年轻女子在结束酒巴间工作回家的路上遇刺。当她绝望地喊叫：“有人要杀人 啦!救命!救命!”听到喊叫声，附近住户亮起了灯，打开了窗户，凶手吓跑了。当一切恢复平静后，凶手又返回作案。当她又叫喊时，附近的住户又打开了电灯， 凶手又逃跑了。当她认为已经无事，回到自己家上楼时，凶手又一次出现在她面前，将她杀死在楼梯上。在这个过程中，尽管她大声呼救，她的邻居中至少有38位 到窗前观看，但无一人来救她，甚至无一人打电话报警。这件事引起纽约社会的轰动，也引起了社会心理学工作者的重视和思考。人们把这种众多的旁观者见死不救 的现象称为责任分散效应。对于责任分散效应形成的原因，心理学家进行了大量的实验和调查，结果发现：这种现象不能仅仅说是众人的冷酷无 情，或道德日益沦丧的表现。因为在不同的场合，人们的援助行为确实是不同的。当一个人遇到紧急情境时，如果只有他一个人能提供帮助，他会清醒地意识到自己 的责任，对受难者给予帮助。如果他见死不救会产生罪恶感、内疚感，这需要付出很高的心理代价。而如果有许多人在场的话，帮助求助者的责任就由大家来分担， 造成责任分散，每个人分担的责任很少，旁观者甚至可能连他自己的那一份责任也意识不到，从而产生一种“我不去救，由别人去救”的心理，造成“集体冷漠”的 局面。如何打破这种局面，这是心理学家正在研究的一个重要课题。</p>\n<h1 id=\"虚假同感偏差\"><a href=\"#虚假同感偏差\" class=\"headerlink\" title=\"虚假同感偏差\"></a>虚假同感偏差</h1><p>我们通常都会相信，我们的爱好与大多数人是一样的。如果你喜欢玩电脑游戏，那么就有可能高估喜欢电脑游戏的人数。你也通常会 高估给自己喜欢的同学投票的人数，高估自己在群体中的威信与领导能力等等。你的这种高估与你的行为及态度有相同特点的人数的倾向性就叫做“虚假同感偏 差”。有些因素会影响你的这种虚假同感偏差强度：</p>\n<p>当外部的归因强于内部归因时；<br>当前的行为或事件对某人非常重要时；<br>当你对自己的观点非常确定或坚信时；<br>当你的地位或正常生活和学习受到某种威胁时；<br>当涉及到某种积极的品质或个性时；<br>当你将其他人看成与自己是相似时。<br>美人效应<br>罗马一家自助餐厅的老板想出一个赚小费的妙计。他请来一位非常漂亮的姑娘，坐在柜台边收钱，以便使男客们神魂颠倒，慷慨解囊。谁知那位姑娘上班后没过几天，就对老板说：“我想，我不如以前漂亮了。”老板忙问：“这是怎么回事呢？”“现在，所有的男客都在柜台边反复地数找给他们的零钱。”美人效应在这里发挥的作用正是挖掘潜在消费和增加客人满意程度，增强餐厅的竞争优势，从而留住客人。</p>\n<h1 id=\"潘多拉效应\"><a href=\"#潘多拉效应\" class=\"headerlink\" title=\"潘多拉效应\"></a>潘多拉效应</h1><p>古希腊有个神话，说宙斯给一个名叫潘多拉的女孩一个盒子，告诉她绝对不能打开。“为什么不能打开？还要‘绝对’？里面该不是稀世珍宝吧？”潘多拉越想越好 奇，越想揭开真相。憋了一段时间后，她终于把盒子打开了。谁知盒子里装的是人类的全部罪恶，结果让它们都跑到人间了。心理学把这种“不禁不为、愈禁愈为” 的现象，叫“潘多拉效应”或“禁果效应”。潘多拉效应的心理实质是好奇心和逆反心理在起作用。</p>\n<h1 id=\"光环效应\"><a href=\"#光环效应\" class=\"headerlink\" title=\"光环效应\"></a>光环效应</h1><p>也叫晕轮效应, 晕轮原指月亮被光环笼罩时产生的模煳不清的现象。晕轮效应是一种普通存在的心理现象，即对一个人进行评价时，往往会因对他的某一品质特征的强烈、清晰的感知，而掩盖了其他方面的品质。毕业生在求职应聘中，如果能够巧妙地运用这种晕轮效应，把自身的优势充分地展现出来，一定会给招聘考官留下深刻的印象，赢得对方的赏识，取得面试的成功。比如，当招聘者问及你的英语水平时，你便用英语熟练地与其交谈，必然会引起招聘者的极大兴趣，很可能当场便与你拍板“成交”。但在运用这一效应时一定要注意，不能刻意制造“光环”效果，那种虚妄做出的行为，往往适得其反。</p>\n<h1 id=\"冷热水效应\"><a href=\"#冷热水效应\" class=\"headerlink\" title=\"冷热水效应\"></a>冷热水效应</h1><p>一杯温水，保持温度不变，另有一杯冷水，一杯热水。当先将手放在冷水中，再放到温水中，会感到温水热；当先将手放在热水中，再放到温水中，会到温水凉。同一杯温水，出现了两种不同的感觉，这就是冷热水效应。这种现象的出现，是因为人人心里都有一杆秤，只不过是秤砣并不一致，也不固定。随着心理的变化，秤砣也在变化。当秤砣变小时，它所称出的物体重量就大，当秤砣变大时，它所称出的物体重量就小。人们对事物的感知，就是受这秤砣的影响。人际交往中，要善于运用这种冷热水效应。 运用冷热水效应，可以获得对方的好评。 人处世上，难免有事业上滑坡的时候，难免有不小心伤害他人的时候，难免有需要对他人进行批评指责的时候，在这些时候，假若处理不当，就会降低自己在他人心目中的形象。如果巧妙运用冷热水效应，就不但不会降低自己的形象，反而会获得他人一个好的评价。当事业上滑坡的时候，不妨预先把最糟糕的事态委婉地告诉别人，以后即使失败也可立于不败之地；当不小心伤害他人的时候，道歉不妨超过应有的限度，这样不但可以显示出你的诚意，而且会收到化干戈为玉帛的效果；当要说令人不快的话语时，不妨事先声明，这样就不会引起他人的反感，使他人体会到你的用心良苦。这些运用冷热水效应的举动，实质上就是先通过一二处“伏笔”，使对方心中的“秤砣”变小，如此一来，它“称出的物体重量”也就大了。某汽车销售公司的老李，每月都能卖出30辆以上汽车，深得公司经理的赏识。由于种种原因，老李预计到这个月只能卖出10辆车。深懂人性奥妙的老李对经理说：“由于银根紧缩，市场萧条，我估计这个月顶多卖出5辆车。”经理点了点头，对他的看法表示赞成。没想到一个月过后，老李竟然卖了12辆汽车，公司经理对他大大夸奖一番。假若老李说本月可以卖15辆或者事先对此不说，结果只卖了12辆，公司经理会怎么认为呢？他会强烈地感受到老李失败了，不但不会夸奖，反而可能指责。在这个事例中，老李把最糟糕情况――顶多卖5辆车，报告给经理，使得经理心中的“秤砣”变小，因此当月绩出来以后，对老李的评价不但不会降低，反而提高了。 蔡女士很少演讲，一次迫不得已，她对一群学者、评论家进行演说。她的开场白是：“我是一个普普通通的家庭妇女，自然不会说出精彩绝伦的话语，因此恳请各位专家对我的发言不要笑话……”经她这么一说，听众心中的“秤砣”变小了，许多开始对她怀疑的人，也在专心听讲了。她的简单朴实演说完成后，台下的学者、评论家们感到好极了，他们认为她的演说达到了极高的水平。对于蔡女士的成功演讲，他们抱以热烈的掌声。当一个人不能直接端给他人一盆“热水”时，不妨先端给他人一盆“冷水”，再端给他人一盆“温水”，这样的话，这人的这盆“温水”同样会获得他人的一个良好评价。</p>\n<h1 id=\"临近效应\"><a href=\"#临近效应\" class=\"headerlink\" title=\"临近效应\"></a>临近效应</h1><p>两个人能否成为朋友，这与俩人住处的远近有很大关系。这被称为邻近效应。那么为什么邻近性会引发好感呢？</p>\n<p>(增强亲近感) - 邻近性一般都会增强亲近感。住得近的人自然碰面的机会也相对频繁，重复的接触就会引发、增强相互间的好感。<br>(强烈的相似性) - 人们大多选择社会地位、经济实力与自己相近的人为邻，而地理位置上的邻近性进一步增强了人们的相似性。<br>(越是邻近的人，其可利用度也越高) - 邻居之间不用花费太多的时间和费用便可成为好朋友，而且有很多事可以相互嘱托，有快乐可以共同分享。比如可以请邻居照看孩子或房子，家里不管发生什么大事小事都可以相互照应。<br>(认知的一贯性) - 与讨厌的人比邻而居，在心理上是难以忍受的。人们在交往中大多愿意接近与自己合得来、住所比较近的人。</p>\n<h1 id=\"名人效应\"><a href=\"#名人效应\" class=\"headerlink\" title=\"名人效应\"></a>名人效应</h1><p>美国心理学家曾做过一个有趣的实验，在给大学心理系学生讲课时，向学生介绍说聘请到举世闻名的化学家。然后这位化学家说，他发现了一种新的化学物质，这种物质具有强烈的气味，但对人体无害。在这里只是想测一下大家的嗅觉。接着打开瓶盖，过了一会儿，他要求闻到气味的同学举手，不少同学举了手，其实这只瓶子里只不过是蒸馏水，”化学家”是从外校请来的德语教师。这种由于接受名人的暗示所产生的信服和盲从现象被称为名人效应。名人效应的产生依赖于名人的权威和知名度，名人之所以成为名人，在他们那一领域必然有其过人之处。名人知名度高，为世人所熟悉、喜爱，所以名人更能引起人们的好感、关注、议论和记忆。由于青少年的认识特点及心理发展，他们所希望的名人多为形式化、表面性的形象所吸，他们喜欢的名人多为歌星、影星一类，出现追星现象。这就要求班主任要为学生选择好”名人”，以促进学生的健康成长。</p>\n<h1 id=\"墨菲定律\"><a href=\"#墨菲定律\" class=\"headerlink\" title=\"墨菲定律\"></a>墨菲定律</h1><p>(Murphy’s Law)缘于美国一位名叫墨菲的上尉。他认为他的某位同事是个倒霉蛋，不经意说了句笑话：“如果一件事情有可能被弄糟，让他去做就一定会弄糟。”这句话迅速流传。经过多年，这一“定律”逐渐进入习语范畴，其内涵被赋予无穷的创意，出现了众多的变体，“如果坏事有可能发生，不管这种可能性多么小，它总会发生，并引起最大可能的损失”、“If anything can go wrong, it will.(会出错的，终将会出错)”、“笑一笑，明天未必比今天好。”“东西越好，越不中用”、“别试图教猪唱歌，这样不但不会有结果，还会惹猪不高兴!”墨菲定律的原话是这样说的：If there are two or more ways to do something, and one of those ways can result in a catastrophe, then someone will do it.(如果有两种选择，其中一种将导致灾难，则必定有人会作出这种选择。)</p>\n<p>根据“墨菲定律”，一、任何事都没有表面看起来那么简单；二、所有的事都会比你预计的时间长；三、会出错的事总会出错；四，如果你担心某种情况发生，那么它就更有可能发生。我们都有这样的体会，如果在街上准备拦一辆车去赴一个时间紧迫的约会，你会发现街上所有的出租车不是有客就是根本不搭理你，而当你不需要租车的时候，却发现有很多空车在你周围游弋，只待你的一扬手，车随时就停在你的面前。如果一个月前在浴室打碎镜子，尽管仔细检查和冲刷，也不敢光着脚走路，等过了一段时间确定没有危险了，不幸的事还是照样发生，你还是被碎玻璃扎了脚。如果你把一片干面包掉在你的新地毯上，它两面都可能着地。但你把一片一面涂有果酱的面包掉在新地毯上，常常是有果酱的那面朝下。</p>\n<p>墨菲定律告诉我们，容易犯错误是人类与生俱来的弱点，不论科技多发达，事故都会发生。而且我们解决问题的手段越高明，面临的麻烦就越严重。所以，我们在事前应该是尽可能想得周到、全面一些，如果真的发生不幸或者损失，就笑着应对吧，关键在于总结所犯的错误，而不是企图掩盖它。</p>\n<p>2003年美国“哥伦比亚”号航天飞机即将返回地面时，在美国得克萨斯州中部地区上空解体，机上6名美国宇航员以及首位进入太空的以色列宇航员拉蒙全部遇难。“哥伦比亚”号航天飞机失事也印证了墨菲定律。如此复杂的系统是一定要出事的，不是今天，就是明天，合情合理。一次事故之后，人们总是要积极寻找事故原因，以防止下一次事故，这是人的一般理性都能够理解的，否则，或者从此放弃航天事业，或者听任下一次事故再次发生，这都不是一个国家能够接受的结果</p>\n<p>人永远也不可能成为上帝，当你妄自尊大时，“墨菲定律”会叫你知道厉害；相反，如果你承认自己的无知，“墨菲定律”会帮助你做得更严密些。</p>\n<p>这其实是概率在起作用，人算不如天算，如老话说的“上的山多终遇虎”。还有“祸不单行”。如彩票，连着几期没大奖，最后必定滚出一个千万大奖来，灾祸发生的概率虽然也很小，但累积到一定程度，也会从最薄弱环节爆发。所以关键是要平时清扫死角，消除不安全隐患，降低事故概率。</p>\n<h1 id=\"破窗效应\"><a href=\"#破窗效应\" class=\"headerlink\" title=\"破窗效应\"></a>破窗效应</h1><p>美国心理学家詹巴斗曾经做过一个”偷车实验”，将两辆一模一样的轿车分别放在一个环境很好的中产阶级社区和环境比较脏乱的贫民区，结果发现贫民区的车很快被偷走了，而另一辆几天后仍然完好无损；如果将中产阶级社区的那辆车的天窗玻璃打破，几个小时后，那辆车也被偷了。后来，在此实验基础上，美国政治学家威尔逊和犯罪学家凯林提出了有名的”破窗理论”：如果有人打坏了一栋建筑上的一块玻璃，又没有及时修好，别人就可能受到某些暗示性的纵容，去打碎更多的玻璃。 “破窗理论”体现的是细节对人的暗示效果，以及细节对事件结果不容小视的重要作用。事实证明，”破窗理论”也确实能够指导我们的生活。 18世纪的纽约以脏乱差闻名，环境恶劣，同时犯罪猖獗，地铁的情况尤为严重，是罪恶的延伸地，平均每7个逃票的人中就有一个通缉犯，每20个逃票的人中有一个携带武器者。1994年，新任警察局长布拉顿开始治理纽约。他从地铁的车箱开始治理：车箱干净了，站台跟着也变干净了，站台干净了，阶梯也随之整洁了，随后街道也干净了，然后旁边的街道也干净了，后来整个社区干净了，最后整个纽约变了样，变整洁漂亮了。现在纽约是全美国治理最出色的都市之一，这件事也被称为”纽约引爆点”。 还有一个被称为校园里的”破窗现象”：班里新来了一个留级生，由于他的勤奋努力，使得原本想混日子的同学受到震动，学习气氛开始转好，有时老师反复强调的重点，有的人或许不以为然，但是他的一句话–这个内容要考试–便会立即引起同学们的高度重视，留级生的话比老师的话还有效！这说明及时修好第一扇被打破的玻璃，能有效阻止”破窗现象”于萌芽状态。 将”破窗理论”中的玻璃</p>\n<p>在公共场合大声说话，暗示一个人喜欢表现自己；</p>\n<p>穿什么样的袜子，暗示一个人的品位如何；</p>\n<p>在背后说别人坏话的人，在暗示他不可信任；</p>\n<p>对任何事都怀疑的人，暗示他是一个悲观主义者；</p>\n<p>对任何事都不满的人，暗示他是一个愤世嫉俗者；</p>\n<p>不贪小便宜的人，暗示他很正直……</p>\n<p>每件大事都由无数小事–也就是细节构成，将细节尽量做到完美，将来的结果才有可能完美。人的一生也由无数细节组成，将小事做好，给他人留下美好印象，将来才会更美好。</p>\n<h1 id=\"热手效应\"><a href=\"#热手效应\" class=\"headerlink\" title=\"热手效应\"></a>热手效应</h1><p>如果篮球队员投篮连续命中，球迷一般都相信球员“手感好”，下次投篮还会得分。在轮盘游戏中，赌徒往往认定其中的红黑两色会交替出现，如果之前红色出现过多，下次更可能出现黑色。可是，直觉未必是靠得住的。事实上，第一次投篮和第二次投篮是否命中没有任何联系，转动一回轮盘，红色和黑色出现的机会也总是0.5。就像受“热手效应”误导的球迷或受“赌徒谬误”左右的赌徒，投资者预测股价也容易受到之前价格信息的影响，用直觉代替理性分析，产生所谓的“启发式心理”。举个例子，一家制药公司的股价长期上扬，在初期，投资者可能表现为“热手效应”，认为股价的走势会持续，“买涨不买跌”；可一旦股价一直高位上扬，投资者又担心上涨空间越来越小，价格走势会“反转”，所以卖出的倾向增强，产生“赌徒谬误”。“‘热手效应’与‘赌徒谬误’都来自人们心理学上的认知偏差－即认为一系列事件的结果都在某种程度上隐含了自相关的关系”。由南京大学商学院的林树、复旦大学管理学院和清华大学公共管理学院的俞乔、汤震宇、周建四位学者组成的团队，利用心理学实验的方法研究了中国的个体投资者在面对过去股价信息时的交易行为与心理预期。林树、俞乔等发表在《经济研究》8月号、题为《投资者“热手效应”与“赌徒谬误”的心理实验研究》的文章发现，“在中国资本市场上具有较高教育程度的个人投资者或潜在个人投资者中，‘赌徒谬误’效应对股价序列变化的作用均要强于‘热手效应’，占据支配地位”，也就是说，无论股价连续上涨还是下跌，投资者更愿意相信价格走势会逆向反转。根据这一发现，研究认为“在中国股票市场处于中长期‘熊市</p>\n<h1 id=\"睡眠效应\"><a href=\"#睡眠效应\" class=\"headerlink\" title=\"睡眠效应\"></a>睡眠效应</h1><p>使坏印象随时间的流逝而消失邮递销售或上门销售中有这样一项保护消费者的制度，即使是已签定的买卖合同，只要超过了一定期限就会被自动失效。这个制度被称为“冷却制”（coolingoff）。这里的“cooling”是指从一开始认为“很好”到后来可能认为不怎么样的这段冷却期。反过来，起初认为“没有什么好处”的坏印象也可能由于时间的流逝而消失，继而产生好印象。心理学称这种现象为睡眠效应。比如谈判陷入僵局即将破裂时，提出“先吃午饭，等吃完后再做决定吧”，让双方有一段冷静思考的时间。等重开谈判时，进展会异常顺利。谈判到达高潮时或刚刚进行劝说后，给予对方一段思考的时间，会收到良好的效果。因为劝说者与劝说内容的暂时分离会增加信息的可信度，使对方作出冷静的判断。</p>\n<h1 id=\"羊群效应\"><a href=\"#羊群效应\" class=\"headerlink\" title=\"羊群效应\"></a>羊群效应</h1><p>是指管理学上一些企业的市场行为的一种常见现象。例如一个羊群（集体）是一个很散乱的组织，平时大家在一起盲目地左冲右撞。如果一头羊发现了一片肥沃的绿草地，并在那里吃到了新鲜的青草，后来的羊群就会一哄而上，争抢那里的青草，全然不顾旁边虎视眈眈的狼，或者看不到其它还有更好的青草。 羊群效应的出现一般在一个竞争非常激烈的行业上，而且这个行业上有一个领先者（领头羊）占据了主要的注意力，那么整个羊群就会不断摹仿这个领头羊的一举一动，领头羊到哪里去吃草，其它的羊也去哪里淘金。搜索引擎这个市场上的竞争加剧的情况下，搜索引擎的巨头之间对对手之间的动作非常的注意，一旦一个搜索引擎出现某一个新的功能，或者进入一个新的领域，众多的搜索引擎都会去尝试这个新的“水草地”是否真的肥美，是否真得有利可图。</p>\n<h1 id=\"异性效应\"><a href=\"#异性效应\" class=\"headerlink\" title=\"异性效应\"></a>异性效应</h1><p>在人际关系中，异性接触会产生一种特殊的相互吸引力和激发力，并能从中体验到难以言传的感情追求，对人的活动和学习通常起积极的影响。这种现象称为“异性效应”. 心理学家曾在一次测试中发现，男性在男、女同桌就餐地要比单纯男性. 就餐时要文明许多，这是由于大多数人在异性面前更注意自己的言行。</p>\n<h1 id=\"马斯洛需求层次理论\"><a href=\"#马斯洛需求层次理论\" class=\"headerlink\" title=\"马斯洛需求层次理论\"></a>马斯洛需求层次理论</h1><p>Maslow’s hierarchy of needs, 该理论将需求分为五种，像阶梯一样从低到高，按层次逐级递升，分别为：生理上的需求，安全上的需求，情感和归属的需求，尊重的需求，自我实现的需求。</p>\n<p>需求层次理论有两个基本出发点，一是人人都有需要，某层需要获得满足后，另一层需要才出现；二是在多种需要未获满足前，首先满足迫切需要；该需要满足后，后面的需要才显示出其激励作用。一般来说，某一层次的需要相对满足了，就会向高一层次发展，追求更高一层次的需要就成为驱使行为的动力。相应的，获得基本满足的需要就不再是一股激励力量。五种需要可以分为两级，其中生理上的需要、安全上的需要和感情上的需要都属于低一级的需要，这些需要通过外部条件就可以满足；而尊重的需要和自我实现的需要是高级需要，他们是通过内部因素才能满足的，而且一个人对尊重和自我实现的需要是无止境的。同一时期，一个人可能有几种需要，但每一时期总有一种需要占支配地位，对行为起决定作用。任何一种需要都不会因为更高层次需要的发展而消失。各层次的需要相互依赖和重叠，高层次的需要发展后，低层次的需要仍然存在，只是对行为影响的程度大大减小</p>\n<p>另外两种需要：求知需要和审美需要。这两种需要未被列入到他的需求层次排列中，他认为这二者应居于尊重需求与自我实现需求之间。</p>\n<h1 id=\"卢维斯定理\"><a href=\"#卢维斯定理\" class=\"headerlink\" title=\"卢维斯定理\"></a>卢维斯定理</h1><p>谦虚不是把自己想得很糟，而是完全不想自己。如果把自己想得太好，就很容易将别人想得很糟。</p>\n<h1 id=\"托利得定理\"><a href=\"#托利得定理\" class=\"headerlink\" title=\"托利得定理\"></a>托利得定理</h1><p>测验一个人的智力是否属于上乘，只看脑子里能否同时容纳两种相反的思想，而无碍于其处世行事。</p>"},{"title":"周报","date":"2017-09-26T16:00:00.000Z","_content":"周报，周报，周报！...\n<!-- more -->\n# 我认知里的周报\n对开发团队来说，写日报一般是实习或者试用期阶段的同学，日报每天都写，容易写成流水账，日报写的出类拔萃，还是比较少见。\n\n前阵子团队里确定每周写过总结，总结每周发现的问题，心得体会，经验教训，一连三周我这忙于开发加上自己房子网签的事停滞了周报的事，于是开会时大家吐槽了这件事。这件事还真让我认真思考了一下这么多年写的总结，月报，周报，日报。\n\n让我们用马克斯的\b‘第一性原理’来理解下周报，’报‘，就是一种\b传达告知的意思，‘周’，这里应该是一个周期性的时间段，就是\b我们所理解的一个星期。所谓\b‘周报’ 就是一个\b星期里的传达告知。不是我矫情，抠字眼，按照这个理解，你能想到几个问题？\n\n- 一个星期怎么算？\n- 一个星期是个时间段，在哪个点\b我去传达告知？\n- 我为什么要传达告知？\n- 传到告知什么事？\n- 如何算是传达告知？\n- \b我怎么确认我传达告知了\n- 我通过什么方式传达告知\n- 谁传达\b告知给谁？\n- 传达和告知是一回事\b吗？\n- 传达告知的本质是啥？\n- 传达告知花费我时间啊？\n- 值不值得我去传达告知？\n- 值不值得我去看那些传达告知给我的？\n如果你比较另类，你还会想：\n\n- \b我为\b什么非要传达告知？\n- 为什么是一周，一天？一个月？\n- \b我为什么传达告知给xx呢？\n- ...\n看到这些问题，你在脑海里有木有答案？有木有针对这些问题，形成一个体系？\n\n本质上说，”传到告知“是一种沟通，如果前面加个时间也就是说是周期性的沟通。于是“周报”也是适用于“沟通”的各种性质属性，经验，法则。\b作为不怎么看管理\b知识的开发人员，真的有必要看一下这个“沟通“，沟通不仅仅是对话！\n\n很多人不愿意写周报，很大的一个原因是”周报“是一个失败的沟通，是一种单向沟通，得不到\b反馈。\n\n看完以上的问题，我认为你已经基本了解我说的周报了。\n\n# 为什么写周报\n在我的认识里，周报是对一周工作的纵览，总结，\b回顾，反思，展望，\b规划汇总等，总之就是对这周工作的一种思考的呈现。这种呈现就是传达告知，为什么要传达告知这个思考的呈现呢？有四个原因：\n\n1.能力养成\n2.知识提升\n3.丰富经验\n4.展现价值\n展现价值，是给你传达告知的人的一种价值，他通过你的周报了解到什么，学习到了什么，对你造成正向作用了，也就是说你的周报是有用的 ，这就意味你\b展现了你的价值。\n\n有同学说，我周一开发那个机器人对话，发现\b一个坑，老是不能正确识别“沙茶面”，因为坑极具个别性，可能只有你遇到，可能只有你爱吃沙茶面，不是具有普遍性的知识，你需要把它提炼的\b更具通用性，才能\b放到周报里，比如你试了下“用心做鸡”，“\b牛鼻子” 也不能识别，那你可以推论一下，带有\b脏话谐音的可能都不行，由此得出的结论，才能算为经验，\b才是对别人真正有价值的。\n\n能力养成，比较难理解，通俗点说，因为一件事，或者\b在此之前的一周里\b你对某件事从不会到玩转，就说明你有了\b做这件事的能力。能力养成的传达告知不\b是了炫耀，是为了团队其他\b成员了解你能做什么了。\n\n# 要写什么呢？\n一周我做了很多事，我都要写在周报里吗？不需要。不过很好，你记录下很多事，不过你要细心，善于发现问题，善于扩展延伸问题\n\n把这些发现的问题，扩展的问题思考总结成一个由头有尾，\b\b有原因有结果，有现状，\b有\b预计，有方案，能落地的小段落就可以了。\n\n# 怎么写呢？\n周报的内容要：\n\n1. \b简洁\n2. 丰富\n3. 有内容\n尼玛！这不矛盾吗？好，听\b哥\b解释：\n简洁是\b指书面周报\b排版整齐，字体颜色朴实美观（要求高了😊），\b逻辑条理清晰明白，不啰嗦，不扯淡。\n\n丰富指你写的事情是在这一周里最能代表你的状态和态度的事，\b要把这个事的前因后果，前情后设都要概要的说明清楚，把你在其中的作用要刻画的丰富，有血有肉（😄\b，写小说的节奏，你懂的），哪怕失败的事迹也要轰轰烈烈（千万不能虚构\b\b🈲️）\n\n有内容指你要有素材，平时注意积累，写周报时才能做到信手拈来，这就要求你平时善于思考，积累思考的成果。\n\n# 还有啥\b注意到点没？\n周报一般是书面，邮件形式最为常见。如果是one to one，face to face的周报，那兄弟我祝贺你，你要么有喜事，要么有坏事，反正你是摊上大事儿了。😊\n\n## 邮件\n邮件这个怎么写，有啥需要注意的哥就不说，这不知道，就网上学习吧，懒得上网啊，那就找身边的老江湖，\b哪怕老油条也能给你几句金玉良言。\n\n## 但是要注意几个点：\n\n格式要中庸，不能用特大号字体，不能全篇各种重点，叹号，红色，蓝色的\n中性用词，客观论说\n不说没有结论的问题，除非你这个不是周报，是\b\b申请批示，如果真有这种问题，单独发邮件吧\n不要涉及\b\b太扯淡，太虚的问题，所说事情要务实\n\b## 口头\n使用这种方式，不管你是汇报人还是被汇报人，我都建议您带着可以记录的东西，笔记本，手机都可以\n\n## 要注意几个点：\n\n谈话内容紧抓主题\n弄明白对方说的内容的背后的东西\n不要妄下结论，不要急于\b承诺\n从容淡定\n\bthat’s all，good\b lucky！","source":"_posts/周报.md","raw":"---\ntitle: 周报\ndate: 2017-09-27\n---\n周报，周报，周报！...\n<!-- more -->\n# 我认知里的周报\n对开发团队来说，写日报一般是实习或者试用期阶段的同学，日报每天都写，容易写成流水账，日报写的出类拔萃，还是比较少见。\n\n前阵子团队里确定每周写过总结，总结每周发现的问题，心得体会，经验教训，一连三周我这忙于开发加上自己房子网签的事停滞了周报的事，于是开会时大家吐槽了这件事。这件事还真让我认真思考了一下这么多年写的总结，月报，周报，日报。\n\n让我们用马克斯的\b‘第一性原理’来理解下周报，’报‘，就是一种\b传达告知的意思，‘周’，这里应该是一个周期性的时间段，就是\b我们所理解的一个星期。所谓\b‘周报’ 就是一个\b星期里的传达告知。不是我矫情，抠字眼，按照这个理解，你能想到几个问题？\n\n- 一个星期怎么算？\n- 一个星期是个时间段，在哪个点\b我去传达告知？\n- 我为什么要传达告知？\n- 传到告知什么事？\n- 如何算是传达告知？\n- \b我怎么确认我传达告知了\n- 我通过什么方式传达告知\n- 谁传达\b告知给谁？\n- 传达和告知是一回事\b吗？\n- 传达告知的本质是啥？\n- 传达告知花费我时间啊？\n- 值不值得我去传达告知？\n- 值不值得我去看那些传达告知给我的？\n如果你比较另类，你还会想：\n\n- \b我为\b什么非要传达告知？\n- 为什么是一周，一天？一个月？\n- \b我为什么传达告知给xx呢？\n- ...\n看到这些问题，你在脑海里有木有答案？有木有针对这些问题，形成一个体系？\n\n本质上说，”传到告知“是一种沟通，如果前面加个时间也就是说是周期性的沟通。于是“周报”也是适用于“沟通”的各种性质属性，经验，法则。\b作为不怎么看管理\b知识的开发人员，真的有必要看一下这个“沟通“，沟通不仅仅是对话！\n\n很多人不愿意写周报，很大的一个原因是”周报“是一个失败的沟通，是一种单向沟通，得不到\b反馈。\n\n看完以上的问题，我认为你已经基本了解我说的周报了。\n\n# 为什么写周报\n在我的认识里，周报是对一周工作的纵览，总结，\b回顾，反思，展望，\b规划汇总等，总之就是对这周工作的一种思考的呈现。这种呈现就是传达告知，为什么要传达告知这个思考的呈现呢？有四个原因：\n\n1.能力养成\n2.知识提升\n3.丰富经验\n4.展现价值\n展现价值，是给你传达告知的人的一种价值，他通过你的周报了解到什么，学习到了什么，对你造成正向作用了，也就是说你的周报是有用的 ，这就意味你\b展现了你的价值。\n\n有同学说，我周一开发那个机器人对话，发现\b一个坑，老是不能正确识别“沙茶面”，因为坑极具个别性，可能只有你遇到，可能只有你爱吃沙茶面，不是具有普遍性的知识，你需要把它提炼的\b更具通用性，才能\b放到周报里，比如你试了下“用心做鸡”，“\b牛鼻子” 也不能识别，那你可以推论一下，带有\b脏话谐音的可能都不行，由此得出的结论，才能算为经验，\b才是对别人真正有价值的。\n\n能力养成，比较难理解，通俗点说，因为一件事，或者\b在此之前的一周里\b你对某件事从不会到玩转，就说明你有了\b做这件事的能力。能力养成的传达告知不\b是了炫耀，是为了团队其他\b成员了解你能做什么了。\n\n# 要写什么呢？\n一周我做了很多事，我都要写在周报里吗？不需要。不过很好，你记录下很多事，不过你要细心，善于发现问题，善于扩展延伸问题\n\n把这些发现的问题，扩展的问题思考总结成一个由头有尾，\b\b有原因有结果，有现状，\b有\b预计，有方案，能落地的小段落就可以了。\n\n# 怎么写呢？\n周报的内容要：\n\n1. \b简洁\n2. 丰富\n3. 有内容\n尼玛！这不矛盾吗？好，听\b哥\b解释：\n简洁是\b指书面周报\b排版整齐，字体颜色朴实美观（要求高了😊），\b逻辑条理清晰明白，不啰嗦，不扯淡。\n\n丰富指你写的事情是在这一周里最能代表你的状态和态度的事，\b要把这个事的前因后果，前情后设都要概要的说明清楚，把你在其中的作用要刻画的丰富，有血有肉（😄\b，写小说的节奏，你懂的），哪怕失败的事迹也要轰轰烈烈（千万不能虚构\b\b🈲️）\n\n有内容指你要有素材，平时注意积累，写周报时才能做到信手拈来，这就要求你平时善于思考，积累思考的成果。\n\n# 还有啥\b注意到点没？\n周报一般是书面，邮件形式最为常见。如果是one to one，face to face的周报，那兄弟我祝贺你，你要么有喜事，要么有坏事，反正你是摊上大事儿了。😊\n\n## 邮件\n邮件这个怎么写，有啥需要注意的哥就不说，这不知道，就网上学习吧，懒得上网啊，那就找身边的老江湖，\b哪怕老油条也能给你几句金玉良言。\n\n## 但是要注意几个点：\n\n格式要中庸，不能用特大号字体，不能全篇各种重点，叹号，红色，蓝色的\n中性用词，客观论说\n不说没有结论的问题，除非你这个不是周报，是\b\b申请批示，如果真有这种问题，单独发邮件吧\n不要涉及\b\b太扯淡，太虚的问题，所说事情要务实\n\b## 口头\n使用这种方式，不管你是汇报人还是被汇报人，我都建议您带着可以记录的东西，笔记本，手机都可以\n\n## 要注意几个点：\n\n谈话内容紧抓主题\n弄明白对方说的内容的背后的东西\n不要妄下结论，不要急于\b承诺\n从容淡定\n\bthat’s all，good\b lucky！","slug":"周报","published":1,"updated":"2020-01-29T04:28:49.070Z","_id":"ck5xwo6ww0002m7iy7cxebtge","comments":1,"layout":"post","photos":[],"link":"","content":"<p>周报，周报，周报！…</p>\n<a id=\"more\"></a>\n<h1 id=\"我认知里的周报\"><a href=\"#我认知里的周报\" class=\"headerlink\" title=\"我认知里的周报\"></a>我认知里的周报</h1><p>对开发团队来说，写日报一般是实习或者试用期阶段的同学，日报每天都写，容易写成流水账，日报写的出类拔萃，还是比较少见。</p>\n<p>前阵子团队里确定每周写过总结，总结每周发现的问题，心得体会，经验教训，一连三周我这忙于开发加上自己房子网签的事停滞了周报的事，于是开会时大家吐槽了这件事。这件事还真让我认真思考了一下这么多年写的总结，月报，周报，日报。</p>\n<p>让我们用马克斯的\b‘第一性原理’来理解下周报，’报‘，就是一种\b传达告知的意思，‘周’，这里应该是一个周期性的时间段，就是\b我们所理解的一个星期。所谓\b‘周报’ 就是一个\b星期里的传达告知。不是我矫情，抠字眼，按照这个理解，你能想到几个问题？</p>\n<ul>\n<li><p>一个星期怎么算？</p>\n</li>\n<li><p>一个星期是个时间段，在哪个点\b我去传达告知？</p>\n</li>\n<li><p>我为什么要传达告知？</p>\n</li>\n<li><p>传到告知什么事？</p>\n</li>\n<li><p>如何算是传达告知？</p>\n</li>\n<li><p>\b我怎么确认我传达告知了</p>\n</li>\n<li><p>我通过什么方式传达告知</p>\n</li>\n<li><p>谁传达\b告知给谁？</p>\n</li>\n<li><p>传达和告知是一回事\b吗？</p>\n</li>\n<li><p>传达告知的本质是啥？</p>\n</li>\n<li><p>传达告知花费我时间啊？</p>\n</li>\n<li><p>值不值得我去传达告知？</p>\n</li>\n<li><p>值不值得我去看那些传达告知给我的？<br>如果你比较另类，你还会想：</p>\n</li>\n<li><p>\b我为\b什么非要传达告知？</p>\n</li>\n<li><p>为什么是一周，一天？一个月？</p>\n</li>\n<li><p>\b我为什么传达告知给xx呢？</p>\n</li>\n<li><p>…<br>看到这些问题，你在脑海里有木有答案？有木有针对这些问题，形成一个体系？</p>\n</li>\n</ul>\n<p>本质上说，”传到告知“是一种沟通，如果前面加个时间也就是说是周期性的沟通。于是“周报”也是适用于“沟通”的各种性质属性，经验，法则。\b作为不怎么看管理\b知识的开发人员，真的有必要看一下这个“沟通“，沟通不仅仅是对话！</p>\n<p>很多人不愿意写周报，很大的一个原因是”周报“是一个失败的沟通，是一种单向沟通，得不到\b反馈。</p>\n<p>看完以上的问题，我认为你已经基本了解我说的周报了。</p>\n<h1 id=\"为什么写周报\"><a href=\"#为什么写周报\" class=\"headerlink\" title=\"为什么写周报\"></a>为什么写周报</h1><p>在我的认识里，周报是对一周工作的纵览，总结，\b回顾，反思，展望，\b规划汇总等，总之就是对这周工作的一种思考的呈现。这种呈现就是传达告知，为什么要传达告知这个思考的呈现呢？有四个原因：</p>\n<p>1.能力养成<br>2.知识提升<br>3.丰富经验<br>4.展现价值<br>展现价值，是给你传达告知的人的一种价值，他通过你的周报了解到什么，学习到了什么，对你造成正向作用了，也就是说你的周报是有用的 ，这就意味你\b展现了你的价值。</p>\n<p>有同学说，我周一开发那个机器人对话，发现\b一个坑，老是不能正确识别“沙茶面”，因为坑极具个别性，可能只有你遇到，可能只有你爱吃沙茶面，不是具有普遍性的知识，你需要把它提炼的\b更具通用性，才能\b放到周报里，比如你试了下“用心做鸡”，“\b牛鼻子” 也不能识别，那你可以推论一下，带有\b脏话谐音的可能都不行，由此得出的结论，才能算为经验，\b才是对别人真正有价值的。</p>\n<p>能力养成，比较难理解，通俗点说，因为一件事，或者\b在此之前的一周里\b你对某件事从不会到玩转，就说明你有了\b做这件事的能力。能力养成的传达告知不\b是了炫耀，是为了团队其他\b成员了解你能做什么了。</p>\n<h1 id=\"要写什么呢？\"><a href=\"#要写什么呢？\" class=\"headerlink\" title=\"要写什么呢？\"></a>要写什么呢？</h1><p>一周我做了很多事，我都要写在周报里吗？不需要。不过很好，你记录下很多事，不过你要细心，善于发现问题，善于扩展延伸问题</p>\n<p>把这些发现的问题，扩展的问题思考总结成一个由头有尾，\b\b有原因有结果，有现状，\b有\b预计，有方案，能落地的小段落就可以了。</p>\n<h1 id=\"怎么写呢？\"><a href=\"#怎么写呢？\" class=\"headerlink\" title=\"怎么写呢？\"></a>怎么写呢？</h1><p>周报的内容要：</p>\n<ol>\n<li>\b简洁</li>\n<li>丰富</li>\n<li>有内容<br>尼玛！这不矛盾吗？好，听\b哥\b解释：<br>简洁是\b指书面周报\b排版整齐，字体颜色朴实美观（要求高了😊），\b逻辑条理清晰明白，不啰嗦，不扯淡。</li>\n</ol>\n<p>丰富指你写的事情是在这一周里最能代表你的状态和态度的事，\b要把这个事的前因后果，前情后设都要概要的说明清楚，把你在其中的作用要刻画的丰富，有血有肉（😄\b，写小说的节奏，你懂的），哪怕失败的事迹也要轰轰烈烈（千万不能虚构\b\b🈲️）</p>\n<p>有内容指你要有素材，平时注意积累，写周报时才能做到信手拈来，这就要求你平时善于思考，积累思考的成果。</p>\n<h1 id=\"还有啥注意到点没？\"><a href=\"#还有啥注意到点没？\" class=\"headerlink\" title=\"还有啥\b注意到点没？\"></a>还有啥\b注意到点没？</h1><p>周报一般是书面，邮件形式最为常见。如果是one to one，face to face的周报，那兄弟我祝贺你，你要么有喜事，要么有坏事，反正你是摊上大事儿了。😊</p>\n<h2 id=\"邮件\"><a href=\"#邮件\" class=\"headerlink\" title=\"邮件\"></a>邮件</h2><p>邮件这个怎么写，有啥需要注意的哥就不说，这不知道，就网上学习吧，懒得上网啊，那就找身边的老江湖，\b哪怕老油条也能给你几句金玉良言。</p>\n<h2 id=\"但是要注意几个点：\"><a href=\"#但是要注意几个点：\" class=\"headerlink\" title=\"但是要注意几个点：\"></a>但是要注意几个点：</h2><p>格式要中庸，不能用特大号字体，不能全篇各种重点，叹号，红色，蓝色的<br>中性用词，客观论说<br>不说没有结论的问题，除非你这个不是周报，是\b\b申请批示，如果真有这种问题，单独发邮件吧<br>不要涉及\b\b太扯淡，太虚的问题，所说事情要务实<br>\b## 口头<br>使用这种方式，不管你是汇报人还是被汇报人，我都建议您带着可以记录的东西，笔记本，手机都可以</p>\n<h2 id=\"要注意几个点：\"><a href=\"#要注意几个点：\" class=\"headerlink\" title=\"要注意几个点：\"></a>要注意几个点：</h2><p>谈话内容紧抓主题<br>弄明白对方说的内容的背后的东西<br>不要妄下结论，不要急于\b承诺<br>从容淡定<br>\bthat’s all，good\b lucky！</p>\n","site":{"data":{}},"excerpt":"<p>周报，周报，周报！…</p>","more":"<h1 id=\"我认知里的周报\"><a href=\"#我认知里的周报\" class=\"headerlink\" title=\"我认知里的周报\"></a>我认知里的周报</h1><p>对开发团队来说，写日报一般是实习或者试用期阶段的同学，日报每天都写，容易写成流水账，日报写的出类拔萃，还是比较少见。</p>\n<p>前阵子团队里确定每周写过总结，总结每周发现的问题，心得体会，经验教训，一连三周我这忙于开发加上自己房子网签的事停滞了周报的事，于是开会时大家吐槽了这件事。这件事还真让我认真思考了一下这么多年写的总结，月报，周报，日报。</p>\n<p>让我们用马克斯的\b‘第一性原理’来理解下周报，’报‘，就是一种\b传达告知的意思，‘周’，这里应该是一个周期性的时间段，就是\b我们所理解的一个星期。所谓\b‘周报’ 就是一个\b星期里的传达告知。不是我矫情，抠字眼，按照这个理解，你能想到几个问题？</p>\n<ul>\n<li><p>一个星期怎么算？</p>\n</li>\n<li><p>一个星期是个时间段，在哪个点\b我去传达告知？</p>\n</li>\n<li><p>我为什么要传达告知？</p>\n</li>\n<li><p>传到告知什么事？</p>\n</li>\n<li><p>如何算是传达告知？</p>\n</li>\n<li><p>\b我怎么确认我传达告知了</p>\n</li>\n<li><p>我通过什么方式传达告知</p>\n</li>\n<li><p>谁传达\b告知给谁？</p>\n</li>\n<li><p>传达和告知是一回事\b吗？</p>\n</li>\n<li><p>传达告知的本质是啥？</p>\n</li>\n<li><p>传达告知花费我时间啊？</p>\n</li>\n<li><p>值不值得我去传达告知？</p>\n</li>\n<li><p>值不值得我去看那些传达告知给我的？<br>如果你比较另类，你还会想：</p>\n</li>\n<li><p>\b我为\b什么非要传达告知？</p>\n</li>\n<li><p>为什么是一周，一天？一个月？</p>\n</li>\n<li><p>\b我为什么传达告知给xx呢？</p>\n</li>\n<li><p>…<br>看到这些问题，你在脑海里有木有答案？有木有针对这些问题，形成一个体系？</p>\n</li>\n</ul>\n<p>本质上说，”传到告知“是一种沟通，如果前面加个时间也就是说是周期性的沟通。于是“周报”也是适用于“沟通”的各种性质属性，经验，法则。\b作为不怎么看管理\b知识的开发人员，真的有必要看一下这个“沟通“，沟通不仅仅是对话！</p>\n<p>很多人不愿意写周报，很大的一个原因是”周报“是一个失败的沟通，是一种单向沟通，得不到\b反馈。</p>\n<p>看完以上的问题，我认为你已经基本了解我说的周报了。</p>\n<h1 id=\"为什么写周报\"><a href=\"#为什么写周报\" class=\"headerlink\" title=\"为什么写周报\"></a>为什么写周报</h1><p>在我的认识里，周报是对一周工作的纵览，总结，\b回顾，反思，展望，\b规划汇总等，总之就是对这周工作的一种思考的呈现。这种呈现就是传达告知，为什么要传达告知这个思考的呈现呢？有四个原因：</p>\n<p>1.能力养成<br>2.知识提升<br>3.丰富经验<br>4.展现价值<br>展现价值，是给你传达告知的人的一种价值，他通过你的周报了解到什么，学习到了什么，对你造成正向作用了，也就是说你的周报是有用的 ，这就意味你\b展现了你的价值。</p>\n<p>有同学说，我周一开发那个机器人对话，发现\b一个坑，老是不能正确识别“沙茶面”，因为坑极具个别性，可能只有你遇到，可能只有你爱吃沙茶面，不是具有普遍性的知识，你需要把它提炼的\b更具通用性，才能\b放到周报里，比如你试了下“用心做鸡”，“\b牛鼻子” 也不能识别，那你可以推论一下，带有\b脏话谐音的可能都不行，由此得出的结论，才能算为经验，\b才是对别人真正有价值的。</p>\n<p>能力养成，比较难理解，通俗点说，因为一件事，或者\b在此之前的一周里\b你对某件事从不会到玩转，就说明你有了\b做这件事的能力。能力养成的传达告知不\b是了炫耀，是为了团队其他\b成员了解你能做什么了。</p>\n<h1 id=\"要写什么呢？\"><a href=\"#要写什么呢？\" class=\"headerlink\" title=\"要写什么呢？\"></a>要写什么呢？</h1><p>一周我做了很多事，我都要写在周报里吗？不需要。不过很好，你记录下很多事，不过你要细心，善于发现问题，善于扩展延伸问题</p>\n<p>把这些发现的问题，扩展的问题思考总结成一个由头有尾，\b\b有原因有结果，有现状，\b有\b预计，有方案，能落地的小段落就可以了。</p>\n<h1 id=\"怎么写呢？\"><a href=\"#怎么写呢？\" class=\"headerlink\" title=\"怎么写呢？\"></a>怎么写呢？</h1><p>周报的内容要：</p>\n<ol>\n<li>\b简洁</li>\n<li>丰富</li>\n<li>有内容<br>尼玛！这不矛盾吗？好，听\b哥\b解释：<br>简洁是\b指书面周报\b排版整齐，字体颜色朴实美观（要求高了😊），\b逻辑条理清晰明白，不啰嗦，不扯淡。</li>\n</ol>\n<p>丰富指你写的事情是在这一周里最能代表你的状态和态度的事，\b要把这个事的前因后果，前情后设都要概要的说明清楚，把你在其中的作用要刻画的丰富，有血有肉（😄\b，写小说的节奏，你懂的），哪怕失败的事迹也要轰轰烈烈（千万不能虚构\b\b🈲️）</p>\n<p>有内容指你要有素材，平时注意积累，写周报时才能做到信手拈来，这就要求你平时善于思考，积累思考的成果。</p>\n<h1 id=\"还有啥注意到点没？\"><a href=\"#还有啥注意到点没？\" class=\"headerlink\" title=\"还有啥\b注意到点没？\"></a>还有啥\b注意到点没？</h1><p>周报一般是书面，邮件形式最为常见。如果是one to one，face to face的周报，那兄弟我祝贺你，你要么有喜事，要么有坏事，反正你是摊上大事儿了。😊</p>\n<h2 id=\"邮件\"><a href=\"#邮件\" class=\"headerlink\" title=\"邮件\"></a>邮件</h2><p>邮件这个怎么写，有啥需要注意的哥就不说，这不知道，就网上学习吧，懒得上网啊，那就找身边的老江湖，\b哪怕老油条也能给你几句金玉良言。</p>\n<h2 id=\"但是要注意几个点：\"><a href=\"#但是要注意几个点：\" class=\"headerlink\" title=\"但是要注意几个点：\"></a>但是要注意几个点：</h2><p>格式要中庸，不能用特大号字体，不能全篇各种重点，叹号，红色，蓝色的<br>中性用词，客观论说<br>不说没有结论的问题，除非你这个不是周报，是\b\b申请批示，如果真有这种问题，单独发邮件吧<br>不要涉及\b\b太扯淡，太虚的问题，所说事情要务实<br>\b## 口头<br>使用这种方式，不管你是汇报人还是被汇报人，我都建议您带着可以记录的东西，笔记本，手机都可以</p>\n<h2 id=\"要注意几个点：\"><a href=\"#要注意几个点：\" class=\"headerlink\" title=\"要注意几个点：\"></a>要注意几个点：</h2><p>谈话内容紧抓主题<br>弄明白对方说的内容的背后的东西<br>不要妄下结论，不要急于\b承诺<br>从容淡定<br>\bthat’s all，good\b lucky！</p>"},{"title":"活在当下","date":"2017-09-26T16:00:00.000Z","_content":"最近在读《沉思录》，里面有一段文字，直击内心！\n<!-- more -->\n\n纵使你的生命可以延续到三千年，甚至三万年，要知道一个人只能死一次，也只能活一回；所以，顶长的寿命和顶短的都一个样。因为所谓的“现在”，对大家是一样长的，我们所丧失的根本便不是我们的，所以我们所放弃的显然只是很短暂的一段时间而已。所以，有两件事要记取：第一，自亘古以来一切事物都是在同一个模型里铸造出来的，然后一遍一遍的重复翻演，所以一个人在100年间或永恒不变的看同样的事物演来演去，实在是没有差别的。再一件事便是：长寿的与夭折的人所放弃的一样多；因为一个人所能被剥夺的只有“现今”，事实上只有这个是他所有的，而他所没有的东西，他当然也不会失去。\n\n人唯一能被夺走的只有现在！\n\n用现在的话来说就是，活在当下。\n\n活在当下，有不同诠释：人生苦短，尽早享受；珍惜时间，完善自我。不管哪一种诠释，都是此时此刻，做真实的自我。\n\n活在当下，就不要瞻前顾后，错失良机，果断决策；\n\n活在当下，就不要辜负年华，在当前做到最好，做到问心无愧。\n\n活在当下，就不要后悔过去的，把握现在，成就未来；\n\n活在当下，就要珍惜身边的人；\n\n活在当下，才是真实的自己。\n\n还有一句，当下的行动，决定未来的你！","source":"_posts/活在当下.md","raw":"---\ntitle: 活在当下\ndate: 2017-09-27\n---\n最近在读《沉思录》，里面有一段文字，直击内心！\n<!-- more -->\n\n纵使你的生命可以延续到三千年，甚至三万年，要知道一个人只能死一次，也只能活一回；所以，顶长的寿命和顶短的都一个样。因为所谓的“现在”，对大家是一样长的，我们所丧失的根本便不是我们的，所以我们所放弃的显然只是很短暂的一段时间而已。所以，有两件事要记取：第一，自亘古以来一切事物都是在同一个模型里铸造出来的，然后一遍一遍的重复翻演，所以一个人在100年间或永恒不变的看同样的事物演来演去，实在是没有差别的。再一件事便是：长寿的与夭折的人所放弃的一样多；因为一个人所能被剥夺的只有“现今”，事实上只有这个是他所有的，而他所没有的东西，他当然也不会失去。\n\n人唯一能被夺走的只有现在！\n\n用现在的话来说就是，活在当下。\n\n活在当下，有不同诠释：人生苦短，尽早享受；珍惜时间，完善自我。不管哪一种诠释，都是此时此刻，做真实的自我。\n\n活在当下，就不要瞻前顾后，错失良机，果断决策；\n\n活在当下，就不要辜负年华，在当前做到最好，做到问心无愧。\n\n活在当下，就不要后悔过去的，把握现在，成就未来；\n\n活在当下，就要珍惜身边的人；\n\n活在当下，才是真实的自己。\n\n还有一句，当下的行动，决定未来的你！","slug":"活在当下","published":1,"updated":"2020-03-03T02:25:26.284Z","_id":"ck5xwo6wx0003m7iyhyblgmyk","comments":1,"layout":"post","photos":[],"link":"","content":"<p>最近在读《沉思录》，里面有一段文字，直击内心！</p>\n<a id=\"more\"></a>\n\n<p>纵使你的生命可以延续到三千年，甚至三万年，要知道一个人只能死一次，也只能活一回；所以，顶长的寿命和顶短的都一个样。因为所谓的“现在”，对大家是一样长的，我们所丧失的根本便不是我们的，所以我们所放弃的显然只是很短暂的一段时间而已。所以，有两件事要记取：第一，自亘古以来一切事物都是在同一个模型里铸造出来的，然后一遍一遍的重复翻演，所以一个人在100年间或永恒不变的看同样的事物演来演去，实在是没有差别的。再一件事便是：长寿的与夭折的人所放弃的一样多；因为一个人所能被剥夺的只有“现今”，事实上只有这个是他所有的，而他所没有的东西，他当然也不会失去。</p>\n<p>人唯一能被夺走的只有现在！</p>\n<p>用现在的话来说就是，活在当下。</p>\n<p>活在当下，有不同诠释：人生苦短，尽早享受；珍惜时间，完善自我。不管哪一种诠释，都是此时此刻，做真实的自我。</p>\n<p>活在当下，就不要瞻前顾后，错失良机，果断决策；</p>\n<p>活在当下，就不要辜负年华，在当前做到最好，做到问心无愧。</p>\n<p>活在当下，就不要后悔过去的，把握现在，成就未来；</p>\n<p>活在当下，就要珍惜身边的人；</p>\n<p>活在当下，才是真实的自己。</p>\n<p>还有一句，当下的行动，决定未来的你！</p>\n","site":{"data":{}},"excerpt":"<p>最近在读《沉思录》，里面有一段文字，直击内心！</p>","more":"<p>纵使你的生命可以延续到三千年，甚至三万年，要知道一个人只能死一次，也只能活一回；所以，顶长的寿命和顶短的都一个样。因为所谓的“现在”，对大家是一样长的，我们所丧失的根本便不是我们的，所以我们所放弃的显然只是很短暂的一段时间而已。所以，有两件事要记取：第一，自亘古以来一切事物都是在同一个模型里铸造出来的，然后一遍一遍的重复翻演，所以一个人在100年间或永恒不变的看同样的事物演来演去，实在是没有差别的。再一件事便是：长寿的与夭折的人所放弃的一样多；因为一个人所能被剥夺的只有“现今”，事实上只有这个是他所有的，而他所没有的东西，他当然也不会失去。</p>\n<p>人唯一能被夺走的只有现在！</p>\n<p>用现在的话来说就是，活在当下。</p>\n<p>活在当下，有不同诠释：人生苦短，尽早享受；珍惜时间，完善自我。不管哪一种诠释，都是此时此刻，做真实的自我。</p>\n<p>活在当下，就不要瞻前顾后，错失良机，果断决策；</p>\n<p>活在当下，就不要辜负年华，在当前做到最好，做到问心无愧。</p>\n<p>活在当下，就不要后悔过去的，把握现在，成就未来；</p>\n<p>活在当下，就要珍惜身边的人；</p>\n<p>活在当下，才是真实的自己。</p>\n<p>还有一句，当下的行动，决定未来的你！</p>"},{"title":"demo","date":"2017-09-26T16:00:00.000Z","_content":"<p><a href=\"http://www.fleven.com/demo/drink_responsability/index.html\">基于three.js + canvas的动画实例</a></p>\n<p><a href=\"http://www.fleven.com/demo/equation/\">数学公式输入示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/mathquill/\">Latex 解析器使用</a></p>\n<p><a href=\"http://www.fleven.com/demo/font.html\">日文字体示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/h5-camera.html\">h5调起摄像头示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/face/index.html\">umu活动示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/img-table/\">使用table拼图片的示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/neve/\">圣诞节背景的动画效果+物理引擎+音效</a></p>\n<p><a href=\"http://www.fleven.com/demo/ps2css.html\">ps阴影转css3</a></p>\n<p><a href=\"http://www.fleven.com/demo/t-rex-runner/public/\">基于手机端控制的chrome断网游戏</a></p>","source":"_posts/技术demo.md","raw":"---\ntitle: demo\ndate: 2017-09-27\n---\n<p><a href=\"http://www.fleven.com/demo/drink_responsability/index.html\">基于three.js + canvas的动画实例</a></p>\n<p><a href=\"http://www.fleven.com/demo/equation/\">数学公式输入示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/mathquill/\">Latex 解析器使用</a></p>\n<p><a href=\"http://www.fleven.com/demo/font.html\">日文字体示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/h5-camera.html\">h5调起摄像头示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/face/index.html\">umu活动示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/img-table/\">使用table拼图片的示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/neve/\">圣诞节背景的动画效果+物理引擎+音效</a></p>\n<p><a href=\"http://www.fleven.com/demo/ps2css.html\">ps阴影转css3</a></p>\n<p><a href=\"http://www.fleven.com/demo/t-rex-runner/public/\">基于手机端控制的chrome断网游戏</a></p>","slug":"技术demo","published":1,"updated":"2020-01-29T06:52:45.534Z","_id":"ck5xwo6wy0004m7iyesla6l2r","comments":1,"layout":"post","photos":[],"link":"","content":"<p><a href=\"http://www.fleven.com/demo/drink_responsability/index.html\">基于three.js + canvas的动画实例</a></p>\n<p><a href=\"http://www.fleven.com/demo/equation/\">数学公式输入示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/mathquill/\">Latex 解析器使用</a></p>\n<p><a href=\"http://www.fleven.com/demo/font.html\">日文字体示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/h5-camera.html\">h5调起摄像头示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/face/index.html\">umu活动示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/img-table/\">使用table拼图片的示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/neve/\">圣诞节背景的动画效果+物理引擎+音效</a></p>\n<p><a href=\"http://www.fleven.com/demo/ps2css.html\">ps阴影转css3</a></p>\n<p><a href=\"http://www.fleven.com/demo/t-rex-runner/public/\">基于手机端控制的chrome断网游戏</a></p>","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://www.fleven.com/demo/drink_responsability/index.html\">基于three.js + canvas的动画实例</a></p>\n<p><a href=\"http://www.fleven.com/demo/equation/\">数学公式输入示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/mathquill/\">Latex 解析器使用</a></p>\n<p><a href=\"http://www.fleven.com/demo/font.html\">日文字体示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/h5-camera.html\">h5调起摄像头示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/face/index.html\">umu活动示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/img-table/\">使用table拼图片的示例</a></p>\n<p><a href=\"http://www.fleven.com/demo/neve/\">圣诞节背景的动画效果+物理引擎+音效</a></p>\n<p><a href=\"http://www.fleven.com/demo/ps2css.html\">ps阴影转css3</a></p>\n<p><a href=\"http://www.fleven.com/demo/t-rex-runner/public/\">基于手机端控制的chrome断网游戏</a></p>"},{"title":"管理学效应","date":"2017-09-26T16:00:00.000Z","_content":"管理无处不在，管理就是如何处理人际关系，平衡利益，分配权力的过程。\n<!-- more -->\n\n# 长尾效应\n长尾效应的根本就是要强调”个性化”,”客户力量”和”小利润大市场”,也就是要赚很少的钱,但是要赚很多人的钱.要将市场细分到很细很小的时候,然后就会发现这些细小市场的累计会带来明显的长尾的效应.以图书为例：Barnes & Noble 的平均上架书目为13万种。而Amazon有超过一半的销售量都来自于在它排行榜上位于13万名开外的图书。如果以Amazon的统计数据为依据的话，这就意味着那些不在一般书店里出售的图书要比那些摆在书店书架上的图书形成的市场更大。也就是说，如果我们能够摆脱资源稀缺的限制，潜在的图书市场将至少是目前的两倍大。曾在音乐行业担任过顾问的风险投资家Kevin Laws 是这样总结这一现象的：“最大的财富孕育自最小的销售。\n\n# 达维多定律\n达维多定律是以英特尔公司副总裁达维多的名字命名的。达维多认为，一家企业要在市场中总是占据主导地位，那么它就要永远做到第一个开发出新一代产品，第一个淘汰自己的产品。\n\n这一定律的基点是着眼于市场开发和利益分割的成效。人们在市场竞争中无时无刻不在抢占先机，因为只有先入市场，才能更容易获得较大的份额和高额的利润。英特尔公司在产品开发和推广上奉行达维多定律，始终是微处理器的开发者和倡导者。他们的产品不一定是性能最好的和速度最快的，但他们一定做到是最新的。为此，他们不惜淘汰自己哪怕是市场上正卖得好的产品。\n\n达维多定律揭示了以下取得成功的真谛：不断创造新产品，及时淘汰老产品，使新产品尽快进入市场，并以自己成功的产品形成新的市场和产品标准，进而形成大规模生产，取得高额利润。\n\n# 酒与污水效应\n如果你把一汤匙的酒倒进一桶污水里，你得到到的是一桶污水；如果你把一汤匙的污水倒进一桶酒里，你得到的还是一桶污水。酒·污水效应对学校管理的启示是：在一些学校中难免碰到个别“污水”式的教师，他们人数虽然很少，但破坏力巨大。为此，学校领导要花费精力处理这类“污水”。\n\n员工的技术能力和敬业程度是公司顺利发展的保证.\n员工优劣评比:分ABC(C类即烂苹果员工)三类,表现最差的员工通常都必须走人.\n对待烂苹果员工的做法: 动作要快,越快越好. 任何组织里，都存在几个难管理的人物，他们像苹果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其他苹果也弄烂。“烂苹果”的可怕之处在于它那惊人的破坏力。组织系统往往是脆弱的，它是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化是因为破坏总比建设容易。“烂苹果”定律告诉我们：对于坏的组员或东西，要在其开始破坏之前及时处理掉。\n\n# 零和游戏原理\n当你看到两位对弈者时，你就可以说他们正在玩“零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+(-1)=0。这正是“零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。\n\n零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与“零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从到经济，似乎无不验证了世界正是一个巨大的“零和游戏”场。这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个“邪恶进化论”式的弱肉强食的世界。\n\n但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，“零和游戏”观念正逐渐被“双赢”观念所取代。人们开始认识到“利己”不一定要建立在“损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从“零和游戏”走向“双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则“双赢”的局面就不可能出现，最终吃亏的还是自己\n\n# 马太效应\n《圣经》中”马太福音”一章里有一句名言：”凡是有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来。”美国着名哲学家罗帕特·默顿发现了同样的现象，即荣誉越多的科学家，授予他的荣誉就越多；而对那些默默无闻的科学家，对其作出的成绩往往不予承认。他于1973年把这种现象命名为”马太效应”。在班级管理中，就是好学生好对待，差学生差对待，而好与差的标准主要还是学习成绩。对于一些班主任心目中的好学生来说，爱”过剩”的时候，就会贬值，他们对表扬就会变得麻木不仁，认为一切都是理所当然。这种优越的社会心理环境会使他们在成长中变得非常脆弱，经不起挫折。而对另外一些学生仅仅因为分数不高，就会长期处在被班主任的关爱遗忘的角落，这种人为造成的恶劣的心理环境，将会使他们情绪偏激、行为带有触发性和冲动性，这样必然导致学生个性的畸形发展，引发学生的心理障碍。\n\n马太效应指出学习能力强的学生，发言机会就多，而发言机会愈多能力愈强，学习能力弱者反之，造成优者越优，差者越差，两极分化。在小组合作学习中，我们常碰到这样的情况，能力较高的成员受到尊重，并取得领导地位，甚至抢尽风头或牺牲其它组员的利益来自我获益；而能力较低的成员则完全丧失了合作学习的兴趣。\n\n社会心理学家认为，“马太效应”是既有消极作用又有积极作用的社会心理现象。其积极作用是：“马太效应”使学习能力强的学生会获得越来越多的荣誉和越来越高的评价，这对小组内表现一般的学生有巨大的吸引力，促使他们去努力，从这个意义上讲，“马太效应”将客观上促使组内竞争的产生，而合作学习并不排斥竞争，这是符合合作学习的精神的。其消极作用是：获得高评价的学生，如果没有清醒的自我认识和没有理智态度容易产生居功自傲、遭小组成员非议等不利合作行为的现象。很显然，如果一味放任小组成员的自发无序地竞争只会导致不均衡的加剧。\n\n消除合作学习中 “马太效应” 的消极作用，要求我们努力实现评价的社会公平感。“马太效应”的导致学生参与度不均衡的主要原因是学生的个人职责不明确，以及老师只关注小组的学习结果，不注意学习过程和个人的学习进步。所以，在合作学习的评价中，教师不仅要关注学习结果，更要关注学习过程，教师还需要讲究评价策略，做到指导与激励相结合，对不同发展水平的学生有不同的要求，应关注每一位学生，特别是对小组中能力较差的学生更应注意到他们的点滴进步。\n\n这是一个赢家通吃的时代，在人类资源分配上，出现了极不均匀的状况：富者越富，穷者越穷。圣经里面的《新约.马太福音》\n成功是成功之母：都说失败是成功之母，这句话是有一定的道理，但不是绝对的，它有一定的适用范围，试想一下，如果你屡屡失败，从未品尝过成功的甜头，你还必胜的信心吗？你还相信失败是成败之母吗？成功有倍增效应，你越成功，你就会越自信，越自信就会使你越容易成功。这个角度来说：“成功是成功之母”。成功和失败也有两极分化的“马太效应”，成功会使你自信，也就越能成功，而失败会使人灰心丧气，离成功也就越来越远了。例如拿破仑一生曾打过100多次胜战，胜利使他坚信自己会所向披靡，而且，也使敌人闻风丧胆。\n当然，提倡“成功是成功之母”，并不反对人们从失败中学习。失败是成败之母对于抗挫折能力强的成年人来说，可能是正确的，但对于心智尚未成熟，意志还很脆弱的中小学生来说，未必适用。对于中小学生而言，成功是成功之母可能更适合他们的发展。当一名学生取得成功后，因成功而酿造出的自信心，会促使她取得更好的成绩，随送新成绩的取得，心理因素再次得到优化，从而形成了一个不断发展的良性循环，让他获得不断的成功。通过体验成功，学生将产生积极向上的心态，并提高学习的效率，具有了更大的发展潜力。这就是教育领域的灵活运用。\n决定一个人身份和地位的并不一定是他的才能和价值，有时候是他的背景和他所代表的组织或是代表的群体，若能使用这些隐藏的资源，它将使你的价值增值。\n永远领先半步”，“一步领先，步步领先“是美国甲骨文软件公司为提升企业文化，增强企业核心竞争力而恪守的经营理念。甲骨文软件公司的经营理念包括市场敏感度领先，销售策略领先，服务超前，规模超前等。在开拓新市场时总是领先市场，领先竞争对手半步，而这半步就是人们所说的领先市场和引导消费，一位高层员工透露：“别人软件没有上市计划，甚至还在开发的时候，我们的软件就已经上市了，但我们通常只比别人提前1个月的时间”。\n由于商业活动中以稀为奇，以少为贵的现象越来越突出，所以要想超出众人，领先半步，就得在稀奇，独特上下功夫，打注意，做文章，见人所未见，为人所未为，才能出奇制胜，步步为赢。\n木桶法则\n木桶法则的意思是：一只沿口不齐的木桶，它盛水的多少，不在于木桶上那块最长的木板，而在于木桶上最短的那块木板。要想多盛水——提高木桶的整体效应，不是去增加最长的那块木板的长度，而是要下功夫依次补齐木桶上最短的那块木板。\n木桶法则告诉管理者：在管理过程中要下功夫狠抓薄弱环节，否则，单位的整体工作就会受到影响。人们常说“取长补短”，即取长的目的是为了补短，只取长不补短，就很难提高工作的整体效应。\n\n# 位差效应\n来自领导层的信息只有20%-25%被下级知道并正确理解,而从下到上反馈的信息则不超过10%,平行交流的效率可达到90%以上.(代表:美国沃尔玛公司—平等的沟通精神,让沟通无处不在)\n\n对待员工和蔼,交流时他会竭尽所能让你将话说出来.\n鼓励中级员工之间加强沟通与合作.\n要求所有的员工极为公司的发展提出新的构想.(每周开展讨论会,并颁发相应的奖励)\n人心不是唠叨所能改变的(要知道唠叨不是一种有效的交流手段,相反只会引起员工的发感)\n每个企业的正常运转都依靠严格的等级制度来保障.但不能管理者的姿态对待员工,认员工敢于直面总裁.如果一个管理者只会趾高气扬,执意显示自己的地位与身份,那么,他的管理定是失败的\n只有让每一位员工都感到自己是公司平等的一员,才能让他们的意见的建议毫无保留的表达出来.\n一个不称职的官员,可能有三条出路:第一是申请退职,把位子让给能干的人,第二是让一位能干的人为协助自己的工作,第三是任用两个(两个以上,才能起到互相牵制的作用)水平比自己更低的人当助手,如此必然导致机构人员膨胀而效率低下.\n\n# 帕金森定律\n英国着名历史学家诺斯古德·帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。\n\n高级官员感到无聊乏味,中级人员忙于勾心斗角,低给人员则灰心丧气.\n权力的危机感是产生帕金森效应的直接原因.\n最需要注意的就是,不要将用人权放在一个被招聘者的直接上司手里.\n华盛顿合作定律\n在角色群体的活动效率中，既可能产生增力作用，也可能导致减力作用。 “三个臭皮匠，凑成一个诸葛亮”，这种情况下“1+1+l”大于3。这在群体成员活动的效率角度上，称之为“群体的增力作用”。 “三个和尚没水喝”，这种情况下的“1+1+1”却等于0了。这在群体成员活动的效率角度上，称之为“群体的减力作用”。\n\n人与人的合作,不是人力的简单相加,而远比这复杂和微妙得多.\n在一个集体中,大多数都采取观望态度(旁观都效应),而产生这类现象的根本原因则是责任不明确.\n能力相等的人一起合作,只有合理的分工合作,才会有辉煌的成果,把每一个人放在最为合适的位置.同时要考虑到该人的优点和缺点及员工之间的相互配合.\n人与人之间的合作,经常会出现彼此之间的排斥的妒嫉心理.多个优秀的人同时一起工作，通常不能顺利的完成工作。通常将其中的一些人调离到新的岗位，其表现也将是惊人的。\n员工之间的分工合作是必需的，\n邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。\n责任保证绩效。责任与绩效之间的关系应该是成正比的，但明确责任，是提高工作绩效的前提，一个企业一定要有明确的责任体系，权责不明不仅不会出现责任真空，而且还容易导致员工之间互相推诿，把自己置于责任之外，明确的责任体系，是让每一个人都清楚自己要做什么，应该怎么做。这们团队中的成员对自己的任务就是责无旁贷的。\n\n# 马蝇效应\n再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。\n\n不言面喻，一个企业的发展，需要竞争对手的时时叮咬，方能保持旺盛的势头让自己强大起来。\n企业能够发展壮大，应该感谢对手时时施加的压力，正是这些压力，化为想方设法战胜困难的动力，进而在残酷的市场竞争中，始终保持着一种危机感。\n\n无独有偶，在美国费城西部，有两个敌对的商店，一个A商店，一个中B商店，两个商店是隔壁邻居，店老板是死对手，他们之间经常展开价格竞争。当A商店在窗口挂出床单6.5元时，B商店则会出现5.9元的标价，此外，他们还常走出商店，相互咒骂，甚至大打出手，最终他们中间一个人会在竞争的退出，宣称另一个店老板是疯子，在他那里买东西的人都是疯子。于是人们便纷纷路到竞争获胜的商店买完所有的床单，在这一带由于他们的不断竞争,人们买到了各种自认为物美价谦的商品。说来有趣，有一天，他们中间的一位老板去世了，而几天后，另一位老板就进行了清仓大展销，然后搬了，人们再也没看见他，这是为什么呢？当房子的新主人进行大清理时发现了其中的秘密，原来，两位老板的住房有一个通道，他们的住房就在商店上面，后来经进一步核查，这两位老板竞是同胞兄弟。\n\n原来所有的咒骂、恐吓和其他人身攻击都是在演戏，所有的价格竞争都是骗人的，谁获得胜利，谁就把俩人的商品一起抛出去，就这样他们的骗局维持了30年之久，未被他人发现。直到其中一个死去才真相大白。保持必要的竞争是企业成长和发展的动力，哪怕是一种竞争假象，也会形成一种良好的氛围，这是一种生存的智慧，也是事业保持快速发展的有效之道。\n\n在“刺头”身上放几个“马蝇”。几乎在每一个企业里都有某一些人拥有在某一方面不可替代的资源（如背景）或聪明，好动，上进心强，是某一方面或某几方面的专家，在此他们充满创新精神。对成功以及成相关的东西（金钱，权力，职位等）具有极其浓厚的兴趣，他们不会行规蹈矩，也不会轻易被权威所折服，更让人头痛的是，这些人不但在专业上有一套，往往在组织内的“兴风作浪上也很有一套。仔细分析一下我们就可以发现，这些人有一个共同的特点：那就是他们不会轻易被满足，他们具有强烈的占有欲。由于不会轻易满足，所以他们才会表现得与众不同，因为他们需要给领导留下更深刻的印象，因为他们希望由此而得到更鑫的满足。因为他们身叮着有刺激他们积极进取的“马蝇”，对于那些有优势的员工来说，他们并不畏惧更高的目标，更大的工作范畴，更有难度的任务，他们往往希望通过挑战这些来显示自己超人一等的能力及在公司里无可替代的地位，以便赢得更多的尊重。这就是叮在他们身上的“马蝇”。\n\n因此，谨慎地做好他们的工作是提升管理绩效的关键。以下几个方面的问题值得仔细关注的：\n\n如果你是一个善于辞令，善于捕捉他人心理的管理者，你可以度着找他们谈谈心，做做思想工作。\n行动永远比语言更有说服力，在巧妙运用你的权利资本时，为这些高傲的家伙树立一个曲范，让他们看看一个有权威的人是怎么处理问题，实现团队目标的。\n这些家伙往往好胜自负，进取心强，在委派任务的时候，最好用一句简洁有力，但颇能刺激他神经的话来结束：这个任务对你来说有困难吗？在得到他不服气或略带轻蔑的回答后，便可结束了，如果太多叮嘱和干预，只会引起这种人的反感和烦燥，甚至使他地于任务本身和你这个管理者更加不屑一顾。\n运用你的智慧和鼓动力，在工作时有意的对此类员工进行一些“冷处理”，让他体会到个人的力量与团队的力量相比，是微不足道的，然后，在适当的时候鼓励其发挥专长，保全他的面子和自尊。\n制度面前人人平等，从一开始就不要给这样的员工以任何错觉，不要让他们误以为自己有某些优势，就可以凌驾于制度之上，这点是长期驾驭这类人的关键，一定要坚持下来。\n在对于想跳槽的员工，应注意：1，不要为了留住某些人轻易做出很难实现的承诺。2，如果有过承诺，一定要兑现，如果无法兑现，一定要给他们一个正面的说法，不能在员工面前扮演一个言而无信的管理者角色，那样只会为将来的动荡埋下隐患。\n及时发现员工的情绪波动，特别是那些业务骨干，一定要把安抚民心做在前头，虽说亡羊补牢，为时未晚，但把预警工作做在前头，是不是可以避免一些不必要的损失呢？\n如果员工去意已定，那么你不要太过勉强，应该善始善终，好说好散，在有必要的时候，可心请他们提前离开，重要的在于不要让某些人的“离去”变成有针对性，有目的性的挑衅，造成全公司员工的大面积情绪波动。\n随时检讨公司晋升，薪酬，绩效考核等人力资源管理制度是否合理，避免因制度性原因而造成员工非正常性流\n攻心为上，以理服人，以情动人。方为上策。\n例外原则\n\n为了提高效率和控制大局，上级只保留处理例外和非常规事件的决定权和控制权，例行和常规的权力由部下分享。（一把抓的控制方式是一种错误的模式）\n\n管理的密决在于合理地授权。所谓授权，就是指为帮助下属完成任务，领导者将所属权力的一部分与其相应的责任授予下属。使领导能做领导的事，下属能做下属的事，这就是授权所应达到的目的。合理地授权可以使领导者摆脱能够由下属完成的日常任务，自已专心处理重大决策问题，还有助于培养下属的工作能力，有利于提高士气，授权是否合理是区分领导者才能高低的重要标志。正如韩非子所说的那样“下者尽已之能，中群尽人之力，上君尽人之智”，领导者做为“上君”，负责最高层的决策。就必须对下属进行合理的授权。\n授权可以让未来规模更大的企业仍然保持小企业的活力，同时也可以为公司培养出发展所必需的大批出色的经营管理人才。\n许多管理者都知道授权的重要性，但他们却总埋怨手下没有可以委托的人，须知才干是在实践中增长的，你总是不敢把艰难的工作交给下属，他们就永远没有显示才干或得不到提高的机会。正如你总是不敢孩子下地，他就永远也学不会走路。\n授权与单纯的分派任务是不同的，分派任务是让下属照你的吩咐去做，他是被动的，而授权则是把整个事情委托给他，同时交付足够的权力让他做必要的决定。这有助于增长他的荣誉，使他有成就感。\n适当放权既能给下属留下发展自已的空间，又能使管理者抽出更多的时间去督导员工工作，提高整个团队的工作效率也就顺理成章了。\n授权并非一蹴而成，不能说一句“这件事交给你就以为完成了授权，授权一事需要授权者和被授权者双方密切的合作，彼此态诚恳，相互沟通了解。在授权的时候，授权者必须有心理准备，明确授予下属完成任务所必须的权力和责任。使他完全理解自己的任务，权力和责任。做到这一点后，就要让授任者依他自已的方式处理事情，不要随意干涉，并且随时给予支持，扶助，合理地授权并非对下属放任自流，撒手不管。授权者要保留监督的权利，在受权者出现不可原谅的错误时，随时取消他的受权资格。\n合理的授权，有利于调动下属在工作中的积极性，主动性和创造性。激发下属工作情绪，增长其才干，使上级领导的思想意图为群体成员所接受。\n授权可以发现人才，利用人才，锻炼人才，使企业的工作出现一个朝气蓬勃，生龙活虎的局面。\n如果你想让下属有出色的表现，，你必须学会为他们“搭舞台”，在必要的时候，给他们提供一定的财力，物力，人力，让他们全身心地投入到工作中，而不会因此分散他们的精力，让他们产生顾虑。\n管理学之父泰罗提倡领导者要学会合理的授权，尤其是要学会在遇到自已懂的知识时，，将决策权交给别人\n授权的原则：\n握大权，授小权（将一些繁重的，琐碎的事务性工作交由下属处理，自已保留例外事件和非常事件的决定权和控制权）〕\n因事择人，视德才授权（泰罗授权理论中最为基本的准则就是因事择人，视德才授权，授权不是利益的分配，更不荣誉的照顾，而是为了将工作做得更出色的一种用人策略，所以应考虑用人更佳性。选择最适的人当受权人）。\n先放后收。不要将一种权力无限度地授予下属。而要适时地加以控制或是回收，这可能会导致上下级之间脱节，从而让自已的下属处于“权力真空”的状态。相反，如若能时时监督下属的权力应用。\n不越级授权。在企业中，主要实行的是领导负责制，这种体制具有明显的层次性。所以在授权下属权力时，一定要掌握尺度，不要越级授权，而要逐级进行，否则只会引起各级下属之间不必要的误解和职责的混乱。\n有效的反馈。对于下属的工作表现的评价，不能太主观意断，而要有说服力，这就要求领导者在授权后，要与下属保持畅通的反馈的渠道。当你将一项权力授予下属，而他将一件工作完成的非常糟糕进，或许事情还不至于糟到无法挽回的地步，但更糟糕的是，你没有补救的办法，下属需要及时的反馈工作的进展情况，而你更需要向下属传授工作的改进之处。\n全局性。一位领导要授权下属以不同的权力，在授权后，你要有足够的时间与精力把握一些全局性的工作，高明的领导在全局统筹的时候，善于采用纵向画线与横向划格的管理模式来实现组织控制。纵向画线是指界定各个部门对上，对下的权限，横向划格是指界定下级各部门之间的权限。这样既有利于下级充分利用自已的权力施展自已的才华，又不至于各部门成为有服从指挥的独立王国，从而有助于从整体上进行把握与协调。\n\n# 鲇鱼效应\n一种动物如果没有对手，就会变得死所沉沉，同样一个人如果没有对手，那他就会甘于庸，养成惰性，最终导致庸碌无为。\n招聘应届毕业生做为鲇鱼员工，因为应届毕业生给企业带来了鲶鱼效应，增强了整个团队的竞争意识和危机意识，从而制造出一种紧张气氛，使全休员工更加勤奋地工作，促使企业的竞争力不断的提升。\n一个单位或部门，如果人员长期固定，彼此太熟悉，就容易产生惰性，削弱组织的活力，若从外部引进“鲇鱼”，他们能以崭新的面貌对原有部门产生强烈的冲击。他们能很好的刺激其他员工的竞争意识，克服员工安于现状，不思进取的惰性。\n有意识地引入一些“鲇鱼”，通过他们挑战性的工作来打破昔日的平静，不仅可心激活整个团体，还能有效地解决原有员工知识不足的缺陷。\n给自己找个对手：许多人都把对手视为心腹大患，是异已，是眼中钉，肉中刺，恨不得马上除之而后快，其实，能有一个强而有力的对手，反而是一种福气，一种造化，因为一个强而有力的对手会让你时刻都有危机感，会激发你更加旺盛的精神和斗志。\n利用“鲇鱼效应”时， 要把握好尺度。“引起一个，带动一片”这种鲇鱼效应的应用是有条件的，要经过科学的评估和精心的安排，若不能将“鲇鱼效应”放在整个人力资源开发之中加以全盘考虑，就会适得其反，酿成“鲇鱼负效应”这很有可能会产生窝里斗的情况，不难看出，这种效应发挥作用的前提是出现了员工不思进取的现象。假如你所在的部门已经形成了龙腾上虎跃，锐意进取的气氛了，若仍坚持引进超量的“鲇鱼”，可能就会一些本来可以进取的“沙丁鱼”看不到希望而开熘，也可能会引发内讧，以至效率低下。\n拿破仑曾经说过：狮子率领的兔子军，要远比兔子率领的狮子军做战能力强，这一句话一方面说明了首领的重要性，另一方面还说明这样一个道理：智慧和能力相当的人不能扎堆，能人扎堆对企业发展不利。在人力资源的配置方面，配置恬当，会出现一加一大于二，大于三，可能等于五，配置不当，人员失和，一加一可能等于零，也有可能成负数。\n很多公司在内部出现职位空缺时，往往第一时间会猎头公司是，认为“外来的和尚好念经”却忽视了公司内部的人才，不予挖掘和起用，结果造成了很多企业精英的流失的管理事故。因此，适量引进“外业和尚好念经”，同时也让“庙里和尚会念经”，内外结合，形成有序的人才竞争机制，如此一来，组织就会更加有活力。\n\n# 王安定论\n在信息社会里, 随着全传播渠道的发达,信息传递的速度大大提高,谁能以最快的反应把握商机,谁就能立于不败之地,速度就是效率!\n现代社会是一个信息社会,信息传播的速度大大地提高了,,信息的快速传递缩短了空间距离,把世界各地的市场信息紧紧地联系在一起,信息是机会,就是财富,但是信息所提供的机会是稍纵即逝的,谁能快速拿捏,谁能把握市场供需,谁就能获得财富,也就能成为时代的佼佼者.对此,美藉华裔企业家王安博士提出了有名的”王安论断”,他认为要在信息万变的时代中力争上游,就要在速度上下功夫,惟有速度提高了,效率才能得到提升,王安论断一再被实践验证,具有极大的合理性.\n王安儿时的一个故事：一天小王安遇见一只流浪的猫咪，决定收养它，可他不敢，怕妈妈反对，于是他回家先征求了妈妈的同意，可回到遇到猫咪的地方时，发现小猫已经饿死了。这次的事对小王安的影响非常的大，他知道凡事只要作了决定就得马上行动，效率才是第一的要务。\n善于王安论断的理化内涵，我们会在任何时候都快人一步，人们常说“一步领先，步步领先，一步落后，步步落后”，因此，培养和树立超前意识，具备前瞻眼光，对于提高行事速度就显得极为重要了。\n所谓前瞻眼光和超前意识，体现在三个方面：\n在动态中准确地预见事物的发展趋势。\n在静态中及时预见事的产生的变化。\n在平平常常的工作，生活，学习以及友好往来中善于发现不显眼的契机，并预见到它蕴含的价值和意义，从而牢牢地抓住它，充分发展自己。\n\n# 史密斯法则\n珍惜每一分钟，最大化时间的价值，几乎是每一位成功者必修的一课，学会有机管理时间，才能保证做事的效率，提高生活的质量。\n神奇的三小时，人们早睡早起，这样可以比别人更早展开新的一天，在时间上就能跑在别人的前面，在这三小时（5-8点），你可不受任何人和事干扰做一些自己想做的事，且必须得讲求恒心，判养成早睡早起的习惯，以后你会受益无穷\n疲劳常常只是厌倦的结果，要消除这种疲劳，停止工作是不行，必须变换工作，一个人要是能做一种以上的事，他会活得更有劲，闲暇对于智者来说是思考，对于享受者来说是养尊，对于愚者来说是虚度。\n\n# 吉德拉法则\n任何企业，如果想求生存，求发展，就必须既有效率，又有效益，当效益无法保证时，就要举起改革的斧子。\n20世纪时，在意大利国际市场疲软，在意大利本国工资升高，物价上涨等情况的冲击下，再加上公司内部出现了管理问题，菲亚特汽车公司经历了历史上最不塂回首的日子，公司连年亏损，在世界汽车生产商的排名榜上接连下跌。在此，一个面临倒闭的企业，如果只是寄希望于对原有体制，管理方式进行修修补补，是无济无事的，要从根本上焕发企业的活力，提升企业的效率，增强企业的效率，增强企业的竞争力，就必须进行深刻的改革。正如吉德拉所说的：“凡是没有必要的，就把它摒弃”。\n用人贵精：在管理上，并不是人多就好，有时管理人员越多，工作效率反而越差，只有找到最合适的人数，管理才能收到最好的效果。在一个公司中，吸有每个部门都真正达到了人员的最佳数量，才能最大阴谋的减少无用的工作时间，降低工作成本，从而达到企业利益的最大化。企业的庞杂，人员设置不合理等现象，会使企业官僚之风盛行，人浮于事，从而导致企业工作效率低下，需设法用最少的人做最多的事，极力减少成本，追求效益最大化。\n精简的机构和人员是企业良好运行的根本，与大多数企业不同，沃尔玛在遇到麻烦时，不是采取增加机构和人员的办法来解决问题，相反，而是追本溯源，解聘失职人和精简相关机构。沃尔玛认为，只有这样才能有效的避免机构臃肿。\n企业竞争力的来源在于用最少的人做最多的事。只有机构精简，人员精干，企业才能保持永久的活力，才能在激烈的竞争中立于不败之地。\n要运好吉德拉法则，就需要我们培养一种果断决策的能力，切忌遇事举棋不定，优柔寡断，坚决果断的个性品质，无疑是决策者必备的素质。遇事举棋不定，犹豫不决，经常彷徨，不知所措的人，是那些没有主意，不能决择，依赖别人的人，这种主意不定，自信不坚的人，也难于得到别人的信任。\n多米诺效应\n一荣难俱荣，一损易俱损；在一个相互联系的系统中，一个很小的初始能量就可能产生一连串的连锁反应，人们就把它们称为“多米诺骨牌效应”或“多米诺效应”。\n\n# 手表定理\n手表定理是指一个人有一只表时，可以知道现在是几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人 失去对 准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话： ” 兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。 ”如果每个人都 ” 选择你所爱，爱你所选择 ” ，无论成败都可以心安理得。然而，困扰很多人的是：他们被 ” 两只表 ” 弄得无所，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也 体会不到成功的快乐。\n\n手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目 标。甚至 每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行 为将陷于混乱。\n\n# 彼得原理\n彼得原理是美国学者劳伦斯彼得在对组织中人员晋升的相关现象研究后得出的一个结论；在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为 ” 向上爬 ” 原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。\n\n对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。因此，这就 要求改 变单纯的 ” 根据贡献决定晋升 ” 的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一 位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖 励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。\n\n对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。\n\n鳄鱼法则\n鳄鱼法则：其原意是假定一只鳄鱼咬住你的脚，如果你用手去试图挣脱你的脚，鳄鱼便会同时咬住你的脚与手。你愈挣扎，就被咬住得越多。所以，万一鳄鱼咬住你的脚，你唯一的办法就是牺牲一只脚。\n\n譬如在股市中，鳄鱼法则就是：当你发现自己的交易背离了市场的方向，必须立即止损，不得有任何延误，不得存有任何侥幸。\n\n# 二八定律\n二八定律(巴莱多定律)：19世纪末20世纪初意大利的经济学家巴莱多认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的。 社会约80%的财富集中在20%的人手里，而80%的人只拥有20%的社会财富。这种统计的不平衡性在社会、经济及生活中无处不在，这就是二八法则。\n\n二八法则告诉我们，不要平均地分析、处理和看待问题，企业经营和管理中要抓住关键的少数;要找出那些能给企业带来80%利润、总量却仅占20%的关键客户，加强服务，达到事半功倍的效果;企业领导人要对工作认真分类分析，要把主要精力花在解决主要问题、抓主要项目上。\n\n20%的人成功------------------80%的人不成功\n20%的人用脖子以上赚钱--------80%的人脖子以下赚钱\n20%的人正面思考--------------80%的人负面思考\n20%的人买时间----------------80%的人卖时间\n20%的人找一个好员工----------80%的人找一份好工作\n20%的人支配别人--------------80%的人受人支配\n20%的人做事业----------------80%的人做事情\n20%的人重视经验--------------80%的人重视学历\n20%的人认为行动才有结果------80%的人认为知识就是力量\n20%的人我要怎么做才有钱------80%的人我要有钱我就怎么做\n20%的人计划未来--------------80%的人早上起来才想今天干嘛\n20%的人按成功经验行事--------80%的人按自己的意愿行事\n20%的人做简单的事情----------80%的人不愿意做简单的事情\n20%的人受成功的人影响--------80%的人受失败人的影响\n20%的人状态很好--------------80%的人态度不好\n20%的人相信自己会成功--------------80%的人不愿改变环境\n20%的人永远赞美、鼓励--------------80%的人永远漫骂、批评\n20%的人会坚持--------------80%的人会放弃\n# 蝴蝶效应\n先从美国麻省理工学院气象学家洛伦兹（Lorenz）的发现谈起。为了预报天气，他用计算机求解仿真地球大气的13个方程式。为了更细致地考察结果，他把一个中间解取出，提高精度再送回。而当他喝了杯咖啡以后回来再看时竟大吃一惊：本来很小的差异，结果却偏离了十万八千里！计算机没有毛病，于是，洛伦兹（Lorenz）认定，他发现了新的现象：“对初始值的极端不稳定性”，即：“混沌 ”，又称“蝴蝶效应”，亚洲蝴蝶拍拍翅膀，将使美洲几个月后出现比狂风还厉害的龙卷风！这个发现非同小可，以致科学家都不理解，几家科学杂志也都拒登他的文章，认为“违背常理”：相近的初值代入确定的方程，结果也应相近才对，怎幺能大大远离呢！线性，指量与量之间按比例、成直线的关系，在空间和时间上代表规则和光滑的运动；而非线性则指不按比例、不成直线的关系，代表不规则的运动和突变。如问：两个眼睛的视敏度是一个眼睛的几倍？很容易想到的是两倍，可实际是 6－10倍！这就是非线性：1＋1不等于2。激光的生成就是非线性的！当外加电压较小时，激光器犹如普通电灯，光向四面八方散射；而当外加电压达到某一定值时，会突然出现一种全新现象：受激原子好象听到“向右看齐”的命令，发射出相位和方向都一致的单色光，就是激光。非线性的特点是：横断各个专业，渗透各个领域，几乎可以说是：“无处不在时时有。” 如：天体运动存在混沌；电、光与声波的振荡，会突陷混沌；地磁场在400万年间，方向突变16次，也是由于混沌。甚至人类自己，原来都是非线性的：与传统的想法相反，健康人的脑电图和心脏跳动并不是规则的，而是混沌的，混沌正是生命力的表现，混沌系统对外界的刺激反应，比非混沌系统快。由此可见，非线性就在我们身边，躲也躲不掉了。\n\n1979年12月，洛伦兹（Lorenz）在华盛顿的美国科学促进会的一次讲演中提出：一只蝴蝶在巴西扇动翅膀，有可能会在美国的德克萨斯引起一场龙卷风。他的演讲和结论给人们留下了极其深刻的印象。从此以后，所谓“蝴蝶效应”之说就不胫而走，名声远扬了。 “蝴蝶效应”之所以令人着迷、令人激动、发人深省，不但在于其大胆的想象力和迷人的美学色彩，更在于其深刻的科学内涵和内在的哲学魅力。混沌理论认为在混沌系统中，初始条件的十分微小的变化经过不断放大，对其未来状态会造成极其巨大的差别。\n\n我们可以用在西方流传的一首民谣对此作形象的说明。这首民谣说：丢失一个钉子，坏了一只蹄铁； 坏了一只蹄铁，折了一匹战马；折了一匹战马，伤了一位骑士；伤了一位骑士，输了一场战斗；输了一场战斗，亡了一个帝国。马蹄铁上一个钉子是否会丢失，本是初始条件的十分微小的变化，但其“长期”效应却是一个帝国存与亡的根本差别。这就是军事和政治领域中的所谓“蝴蝶效应”。有点不可思议，但是确实能够造成这样的恶果。一个明智的领导人一定要防微杜渐，看似一些极微小的事情却有可能造成集体内部的分崩离析，那时岂不是悔之晚矣？横过深谷的吊桥，常从一根细线拴个小石头开始。\n\n# 蘑菰管理原理\n蘑菰长在阴暗的角落，得不到阳光，也没有肥料，自生自灭，只有长到足够高的时候才开始被人关注，可此时它自己已经能够接受阳光了。\n\n蘑菰管理是大多数组织对待初入门者、初学者的一种管理方法。从传统的观念上讲，“蘑菰经历”是一件好事，它是人才蜕壳羽化前的一种磨炼，对人的意志和耐力的培养有促进作用。但用发展的眼光来看，蘑菰管理有着先天的不足：一是太慢，还没等它长高长大恐怕疯长的野草就已经把它盖住了，使它没有成长的机会；二是缺乏主动，有些本来基因较好的蘑菰，一钻出土就碰上了石头，因为得不到帮助，结果胎死腹中。\n\n让初入门者当上一段时间的“蘑菰”，可以消除他们不切实际的幻想，从而使他们更加接近现实，更实际、更理性地思考问题和处理问题。领导者应当注意的是，这一过程不可过长，时间太长便会使其消极退化乃至枯萎，须知不给阳光不给关爱不仅是任其自生自灭，而且更是对其成长的抑制。如何让他们成功地走过生命中的这一段，尽快吸取经验、成熟起来，这才是领导者所应当考虑的。","source":"_posts/管理学效应.md","raw":"---\ntitle: 管理学效应\ndate: 2017-09-27\n---\n管理无处不在，管理就是如何处理人际关系，平衡利益，分配权力的过程。\n<!-- more -->\n\n# 长尾效应\n长尾效应的根本就是要强调”个性化”,”客户力量”和”小利润大市场”,也就是要赚很少的钱,但是要赚很多人的钱.要将市场细分到很细很小的时候,然后就会发现这些细小市场的累计会带来明显的长尾的效应.以图书为例：Barnes & Noble 的平均上架书目为13万种。而Amazon有超过一半的销售量都来自于在它排行榜上位于13万名开外的图书。如果以Amazon的统计数据为依据的话，这就意味着那些不在一般书店里出售的图书要比那些摆在书店书架上的图书形成的市场更大。也就是说，如果我们能够摆脱资源稀缺的限制，潜在的图书市场将至少是目前的两倍大。曾在音乐行业担任过顾问的风险投资家Kevin Laws 是这样总结这一现象的：“最大的财富孕育自最小的销售。\n\n# 达维多定律\n达维多定律是以英特尔公司副总裁达维多的名字命名的。达维多认为，一家企业要在市场中总是占据主导地位，那么它就要永远做到第一个开发出新一代产品，第一个淘汰自己的产品。\n\n这一定律的基点是着眼于市场开发和利益分割的成效。人们在市场竞争中无时无刻不在抢占先机，因为只有先入市场，才能更容易获得较大的份额和高额的利润。英特尔公司在产品开发和推广上奉行达维多定律，始终是微处理器的开发者和倡导者。他们的产品不一定是性能最好的和速度最快的，但他们一定做到是最新的。为此，他们不惜淘汰自己哪怕是市场上正卖得好的产品。\n\n达维多定律揭示了以下取得成功的真谛：不断创造新产品，及时淘汰老产品，使新产品尽快进入市场，并以自己成功的产品形成新的市场和产品标准，进而形成大规模生产，取得高额利润。\n\n# 酒与污水效应\n如果你把一汤匙的酒倒进一桶污水里，你得到到的是一桶污水；如果你把一汤匙的污水倒进一桶酒里，你得到的还是一桶污水。酒·污水效应对学校管理的启示是：在一些学校中难免碰到个别“污水”式的教师，他们人数虽然很少，但破坏力巨大。为此，学校领导要花费精力处理这类“污水”。\n\n员工的技术能力和敬业程度是公司顺利发展的保证.\n员工优劣评比:分ABC(C类即烂苹果员工)三类,表现最差的员工通常都必须走人.\n对待烂苹果员工的做法: 动作要快,越快越好. 任何组织里，都存在几个难管理的人物，他们像苹果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其他苹果也弄烂。“烂苹果”的可怕之处在于它那惊人的破坏力。组织系统往往是脆弱的，它是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化是因为破坏总比建设容易。“烂苹果”定律告诉我们：对于坏的组员或东西，要在其开始破坏之前及时处理掉。\n\n# 零和游戏原理\n当你看到两位对弈者时，你就可以说他们正在玩“零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+(-1)=0。这正是“零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。\n\n零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与“零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从到经济，似乎无不验证了世界正是一个巨大的“零和游戏”场。这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个“邪恶进化论”式的弱肉强食的世界。\n\n但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，“零和游戏”观念正逐渐被“双赢”观念所取代。人们开始认识到“利己”不一定要建立在“损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从“零和游戏”走向“双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则“双赢”的局面就不可能出现，最终吃亏的还是自己\n\n# 马太效应\n《圣经》中”马太福音”一章里有一句名言：”凡是有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来。”美国着名哲学家罗帕特·默顿发现了同样的现象，即荣誉越多的科学家，授予他的荣誉就越多；而对那些默默无闻的科学家，对其作出的成绩往往不予承认。他于1973年把这种现象命名为”马太效应”。在班级管理中，就是好学生好对待，差学生差对待，而好与差的标准主要还是学习成绩。对于一些班主任心目中的好学生来说，爱”过剩”的时候，就会贬值，他们对表扬就会变得麻木不仁，认为一切都是理所当然。这种优越的社会心理环境会使他们在成长中变得非常脆弱，经不起挫折。而对另外一些学生仅仅因为分数不高，就会长期处在被班主任的关爱遗忘的角落，这种人为造成的恶劣的心理环境，将会使他们情绪偏激、行为带有触发性和冲动性，这样必然导致学生个性的畸形发展，引发学生的心理障碍。\n\n马太效应指出学习能力强的学生，发言机会就多，而发言机会愈多能力愈强，学习能力弱者反之，造成优者越优，差者越差，两极分化。在小组合作学习中，我们常碰到这样的情况，能力较高的成员受到尊重，并取得领导地位，甚至抢尽风头或牺牲其它组员的利益来自我获益；而能力较低的成员则完全丧失了合作学习的兴趣。\n\n社会心理学家认为，“马太效应”是既有消极作用又有积极作用的社会心理现象。其积极作用是：“马太效应”使学习能力强的学生会获得越来越多的荣誉和越来越高的评价，这对小组内表现一般的学生有巨大的吸引力，促使他们去努力，从这个意义上讲，“马太效应”将客观上促使组内竞争的产生，而合作学习并不排斥竞争，这是符合合作学习的精神的。其消极作用是：获得高评价的学生，如果没有清醒的自我认识和没有理智态度容易产生居功自傲、遭小组成员非议等不利合作行为的现象。很显然，如果一味放任小组成员的自发无序地竞争只会导致不均衡的加剧。\n\n消除合作学习中 “马太效应” 的消极作用，要求我们努力实现评价的社会公平感。“马太效应”的导致学生参与度不均衡的主要原因是学生的个人职责不明确，以及老师只关注小组的学习结果，不注意学习过程和个人的学习进步。所以，在合作学习的评价中，教师不仅要关注学习结果，更要关注学习过程，教师还需要讲究评价策略，做到指导与激励相结合，对不同发展水平的学生有不同的要求，应关注每一位学生，特别是对小组中能力较差的学生更应注意到他们的点滴进步。\n\n这是一个赢家通吃的时代，在人类资源分配上，出现了极不均匀的状况：富者越富，穷者越穷。圣经里面的《新约.马太福音》\n成功是成功之母：都说失败是成功之母，这句话是有一定的道理，但不是绝对的，它有一定的适用范围，试想一下，如果你屡屡失败，从未品尝过成功的甜头，你还必胜的信心吗？你还相信失败是成败之母吗？成功有倍增效应，你越成功，你就会越自信，越自信就会使你越容易成功。这个角度来说：“成功是成功之母”。成功和失败也有两极分化的“马太效应”，成功会使你自信，也就越能成功，而失败会使人灰心丧气，离成功也就越来越远了。例如拿破仑一生曾打过100多次胜战，胜利使他坚信自己会所向披靡，而且，也使敌人闻风丧胆。\n当然，提倡“成功是成功之母”，并不反对人们从失败中学习。失败是成败之母对于抗挫折能力强的成年人来说，可能是正确的，但对于心智尚未成熟，意志还很脆弱的中小学生来说，未必适用。对于中小学生而言，成功是成功之母可能更适合他们的发展。当一名学生取得成功后，因成功而酿造出的自信心，会促使她取得更好的成绩，随送新成绩的取得，心理因素再次得到优化，从而形成了一个不断发展的良性循环，让他获得不断的成功。通过体验成功，学生将产生积极向上的心态，并提高学习的效率，具有了更大的发展潜力。这就是教育领域的灵活运用。\n决定一个人身份和地位的并不一定是他的才能和价值，有时候是他的背景和他所代表的组织或是代表的群体，若能使用这些隐藏的资源，它将使你的价值增值。\n永远领先半步”，“一步领先，步步领先“是美国甲骨文软件公司为提升企业文化，增强企业核心竞争力而恪守的经营理念。甲骨文软件公司的经营理念包括市场敏感度领先，销售策略领先，服务超前，规模超前等。在开拓新市场时总是领先市场，领先竞争对手半步，而这半步就是人们所说的领先市场和引导消费，一位高层员工透露：“别人软件没有上市计划，甚至还在开发的时候，我们的软件就已经上市了，但我们通常只比别人提前1个月的时间”。\n由于商业活动中以稀为奇，以少为贵的现象越来越突出，所以要想超出众人，领先半步，就得在稀奇，独特上下功夫，打注意，做文章，见人所未见，为人所未为，才能出奇制胜，步步为赢。\n木桶法则\n木桶法则的意思是：一只沿口不齐的木桶，它盛水的多少，不在于木桶上那块最长的木板，而在于木桶上最短的那块木板。要想多盛水——提高木桶的整体效应，不是去增加最长的那块木板的长度，而是要下功夫依次补齐木桶上最短的那块木板。\n木桶法则告诉管理者：在管理过程中要下功夫狠抓薄弱环节，否则，单位的整体工作就会受到影响。人们常说“取长补短”，即取长的目的是为了补短，只取长不补短，就很难提高工作的整体效应。\n\n# 位差效应\n来自领导层的信息只有20%-25%被下级知道并正确理解,而从下到上反馈的信息则不超过10%,平行交流的效率可达到90%以上.(代表:美国沃尔玛公司—平等的沟通精神,让沟通无处不在)\n\n对待员工和蔼,交流时他会竭尽所能让你将话说出来.\n鼓励中级员工之间加强沟通与合作.\n要求所有的员工极为公司的发展提出新的构想.(每周开展讨论会,并颁发相应的奖励)\n人心不是唠叨所能改变的(要知道唠叨不是一种有效的交流手段,相反只会引起员工的发感)\n每个企业的正常运转都依靠严格的等级制度来保障.但不能管理者的姿态对待员工,认员工敢于直面总裁.如果一个管理者只会趾高气扬,执意显示自己的地位与身份,那么,他的管理定是失败的\n只有让每一位员工都感到自己是公司平等的一员,才能让他们的意见的建议毫无保留的表达出来.\n一个不称职的官员,可能有三条出路:第一是申请退职,把位子让给能干的人,第二是让一位能干的人为协助自己的工作,第三是任用两个(两个以上,才能起到互相牵制的作用)水平比自己更低的人当助手,如此必然导致机构人员膨胀而效率低下.\n\n# 帕金森定律\n英国着名历史学家诺斯古德·帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。\n\n高级官员感到无聊乏味,中级人员忙于勾心斗角,低给人员则灰心丧气.\n权力的危机感是产生帕金森效应的直接原因.\n最需要注意的就是,不要将用人权放在一个被招聘者的直接上司手里.\n华盛顿合作定律\n在角色群体的活动效率中，既可能产生增力作用，也可能导致减力作用。 “三个臭皮匠，凑成一个诸葛亮”，这种情况下“1+1+l”大于3。这在群体成员活动的效率角度上，称之为“群体的增力作用”。 “三个和尚没水喝”，这种情况下的“1+1+1”却等于0了。这在群体成员活动的效率角度上，称之为“群体的减力作用”。\n\n人与人的合作,不是人力的简单相加,而远比这复杂和微妙得多.\n在一个集体中,大多数都采取观望态度(旁观都效应),而产生这类现象的根本原因则是责任不明确.\n能力相等的人一起合作,只有合理的分工合作,才会有辉煌的成果,把每一个人放在最为合适的位置.同时要考虑到该人的优点和缺点及员工之间的相互配合.\n人与人之间的合作,经常会出现彼此之间的排斥的妒嫉心理.多个优秀的人同时一起工作，通常不能顺利的完成工作。通常将其中的一些人调离到新的岗位，其表现也将是惊人的。\n员工之间的分工合作是必需的，\n邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。\n责任保证绩效。责任与绩效之间的关系应该是成正比的，但明确责任，是提高工作绩效的前提，一个企业一定要有明确的责任体系，权责不明不仅不会出现责任真空，而且还容易导致员工之间互相推诿，把自己置于责任之外，明确的责任体系，是让每一个人都清楚自己要做什么，应该怎么做。这们团队中的成员对自己的任务就是责无旁贷的。\n\n# 马蝇效应\n再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。\n\n不言面喻，一个企业的发展，需要竞争对手的时时叮咬，方能保持旺盛的势头让自己强大起来。\n企业能够发展壮大，应该感谢对手时时施加的压力，正是这些压力，化为想方设法战胜困难的动力，进而在残酷的市场竞争中，始终保持着一种危机感。\n\n无独有偶，在美国费城西部，有两个敌对的商店，一个A商店，一个中B商店，两个商店是隔壁邻居，店老板是死对手，他们之间经常展开价格竞争。当A商店在窗口挂出床单6.5元时，B商店则会出现5.9元的标价，此外，他们还常走出商店，相互咒骂，甚至大打出手，最终他们中间一个人会在竞争的退出，宣称另一个店老板是疯子，在他那里买东西的人都是疯子。于是人们便纷纷路到竞争获胜的商店买完所有的床单，在这一带由于他们的不断竞争,人们买到了各种自认为物美价谦的商品。说来有趣，有一天，他们中间的一位老板去世了，而几天后，另一位老板就进行了清仓大展销，然后搬了，人们再也没看见他，这是为什么呢？当房子的新主人进行大清理时发现了其中的秘密，原来，两位老板的住房有一个通道，他们的住房就在商店上面，后来经进一步核查，这两位老板竞是同胞兄弟。\n\n原来所有的咒骂、恐吓和其他人身攻击都是在演戏，所有的价格竞争都是骗人的，谁获得胜利，谁就把俩人的商品一起抛出去，就这样他们的骗局维持了30年之久，未被他人发现。直到其中一个死去才真相大白。保持必要的竞争是企业成长和发展的动力，哪怕是一种竞争假象，也会形成一种良好的氛围，这是一种生存的智慧，也是事业保持快速发展的有效之道。\n\n在“刺头”身上放几个“马蝇”。几乎在每一个企业里都有某一些人拥有在某一方面不可替代的资源（如背景）或聪明，好动，上进心强，是某一方面或某几方面的专家，在此他们充满创新精神。对成功以及成相关的东西（金钱，权力，职位等）具有极其浓厚的兴趣，他们不会行规蹈矩，也不会轻易被权威所折服，更让人头痛的是，这些人不但在专业上有一套，往往在组织内的“兴风作浪上也很有一套。仔细分析一下我们就可以发现，这些人有一个共同的特点：那就是他们不会轻易被满足，他们具有强烈的占有欲。由于不会轻易满足，所以他们才会表现得与众不同，因为他们需要给领导留下更深刻的印象，因为他们希望由此而得到更鑫的满足。因为他们身叮着有刺激他们积极进取的“马蝇”，对于那些有优势的员工来说，他们并不畏惧更高的目标，更大的工作范畴，更有难度的任务，他们往往希望通过挑战这些来显示自己超人一等的能力及在公司里无可替代的地位，以便赢得更多的尊重。这就是叮在他们身上的“马蝇”。\n\n因此，谨慎地做好他们的工作是提升管理绩效的关键。以下几个方面的问题值得仔细关注的：\n\n如果你是一个善于辞令，善于捕捉他人心理的管理者，你可以度着找他们谈谈心，做做思想工作。\n行动永远比语言更有说服力，在巧妙运用你的权利资本时，为这些高傲的家伙树立一个曲范，让他们看看一个有权威的人是怎么处理问题，实现团队目标的。\n这些家伙往往好胜自负，进取心强，在委派任务的时候，最好用一句简洁有力，但颇能刺激他神经的话来结束：这个任务对你来说有困难吗？在得到他不服气或略带轻蔑的回答后，便可结束了，如果太多叮嘱和干预，只会引起这种人的反感和烦燥，甚至使他地于任务本身和你这个管理者更加不屑一顾。\n运用你的智慧和鼓动力，在工作时有意的对此类员工进行一些“冷处理”，让他体会到个人的力量与团队的力量相比，是微不足道的，然后，在适当的时候鼓励其发挥专长，保全他的面子和自尊。\n制度面前人人平等，从一开始就不要给这样的员工以任何错觉，不要让他们误以为自己有某些优势，就可以凌驾于制度之上，这点是长期驾驭这类人的关键，一定要坚持下来。\n在对于想跳槽的员工，应注意：1，不要为了留住某些人轻易做出很难实现的承诺。2，如果有过承诺，一定要兑现，如果无法兑现，一定要给他们一个正面的说法，不能在员工面前扮演一个言而无信的管理者角色，那样只会为将来的动荡埋下隐患。\n及时发现员工的情绪波动，特别是那些业务骨干，一定要把安抚民心做在前头，虽说亡羊补牢，为时未晚，但把预警工作做在前头，是不是可以避免一些不必要的损失呢？\n如果员工去意已定，那么你不要太过勉强，应该善始善终，好说好散，在有必要的时候，可心请他们提前离开，重要的在于不要让某些人的“离去”变成有针对性，有目的性的挑衅，造成全公司员工的大面积情绪波动。\n随时检讨公司晋升，薪酬，绩效考核等人力资源管理制度是否合理，避免因制度性原因而造成员工非正常性流\n攻心为上，以理服人，以情动人。方为上策。\n例外原则\n\n为了提高效率和控制大局，上级只保留处理例外和非常规事件的决定权和控制权，例行和常规的权力由部下分享。（一把抓的控制方式是一种错误的模式）\n\n管理的密决在于合理地授权。所谓授权，就是指为帮助下属完成任务，领导者将所属权力的一部分与其相应的责任授予下属。使领导能做领导的事，下属能做下属的事，这就是授权所应达到的目的。合理地授权可以使领导者摆脱能够由下属完成的日常任务，自已专心处理重大决策问题，还有助于培养下属的工作能力，有利于提高士气，授权是否合理是区分领导者才能高低的重要标志。正如韩非子所说的那样“下者尽已之能，中群尽人之力，上君尽人之智”，领导者做为“上君”，负责最高层的决策。就必须对下属进行合理的授权。\n授权可以让未来规模更大的企业仍然保持小企业的活力，同时也可以为公司培养出发展所必需的大批出色的经营管理人才。\n许多管理者都知道授权的重要性，但他们却总埋怨手下没有可以委托的人，须知才干是在实践中增长的，你总是不敢把艰难的工作交给下属，他们就永远没有显示才干或得不到提高的机会。正如你总是不敢孩子下地，他就永远也学不会走路。\n授权与单纯的分派任务是不同的，分派任务是让下属照你的吩咐去做，他是被动的，而授权则是把整个事情委托给他，同时交付足够的权力让他做必要的决定。这有助于增长他的荣誉，使他有成就感。\n适当放权既能给下属留下发展自已的空间，又能使管理者抽出更多的时间去督导员工工作，提高整个团队的工作效率也就顺理成章了。\n授权并非一蹴而成，不能说一句“这件事交给你就以为完成了授权，授权一事需要授权者和被授权者双方密切的合作，彼此态诚恳，相互沟通了解。在授权的时候，授权者必须有心理准备，明确授予下属完成任务所必须的权力和责任。使他完全理解自己的任务，权力和责任。做到这一点后，就要让授任者依他自已的方式处理事情，不要随意干涉，并且随时给予支持，扶助，合理地授权并非对下属放任自流，撒手不管。授权者要保留监督的权利，在受权者出现不可原谅的错误时，随时取消他的受权资格。\n合理的授权，有利于调动下属在工作中的积极性，主动性和创造性。激发下属工作情绪，增长其才干，使上级领导的思想意图为群体成员所接受。\n授权可以发现人才，利用人才，锻炼人才，使企业的工作出现一个朝气蓬勃，生龙活虎的局面。\n如果你想让下属有出色的表现，，你必须学会为他们“搭舞台”，在必要的时候，给他们提供一定的财力，物力，人力，让他们全身心地投入到工作中，而不会因此分散他们的精力，让他们产生顾虑。\n管理学之父泰罗提倡领导者要学会合理的授权，尤其是要学会在遇到自已懂的知识时，，将决策权交给别人\n授权的原则：\n握大权，授小权（将一些繁重的，琐碎的事务性工作交由下属处理，自已保留例外事件和非常事件的决定权和控制权）〕\n因事择人，视德才授权（泰罗授权理论中最为基本的准则就是因事择人，视德才授权，授权不是利益的分配，更不荣誉的照顾，而是为了将工作做得更出色的一种用人策略，所以应考虑用人更佳性。选择最适的人当受权人）。\n先放后收。不要将一种权力无限度地授予下属。而要适时地加以控制或是回收，这可能会导致上下级之间脱节，从而让自已的下属处于“权力真空”的状态。相反，如若能时时监督下属的权力应用。\n不越级授权。在企业中，主要实行的是领导负责制，这种体制具有明显的层次性。所以在授权下属权力时，一定要掌握尺度，不要越级授权，而要逐级进行，否则只会引起各级下属之间不必要的误解和职责的混乱。\n有效的反馈。对于下属的工作表现的评价，不能太主观意断，而要有说服力，这就要求领导者在授权后，要与下属保持畅通的反馈的渠道。当你将一项权力授予下属，而他将一件工作完成的非常糟糕进，或许事情还不至于糟到无法挽回的地步，但更糟糕的是，你没有补救的办法，下属需要及时的反馈工作的进展情况，而你更需要向下属传授工作的改进之处。\n全局性。一位领导要授权下属以不同的权力，在授权后，你要有足够的时间与精力把握一些全局性的工作，高明的领导在全局统筹的时候，善于采用纵向画线与横向划格的管理模式来实现组织控制。纵向画线是指界定各个部门对上，对下的权限，横向划格是指界定下级各部门之间的权限。这样既有利于下级充分利用自已的权力施展自已的才华，又不至于各部门成为有服从指挥的独立王国，从而有助于从整体上进行把握与协调。\n\n# 鲇鱼效应\n一种动物如果没有对手，就会变得死所沉沉，同样一个人如果没有对手，那他就会甘于庸，养成惰性，最终导致庸碌无为。\n招聘应届毕业生做为鲇鱼员工，因为应届毕业生给企业带来了鲶鱼效应，增强了整个团队的竞争意识和危机意识，从而制造出一种紧张气氛，使全休员工更加勤奋地工作，促使企业的竞争力不断的提升。\n一个单位或部门，如果人员长期固定，彼此太熟悉，就容易产生惰性，削弱组织的活力，若从外部引进“鲇鱼”，他们能以崭新的面貌对原有部门产生强烈的冲击。他们能很好的刺激其他员工的竞争意识，克服员工安于现状，不思进取的惰性。\n有意识地引入一些“鲇鱼”，通过他们挑战性的工作来打破昔日的平静，不仅可心激活整个团体，还能有效地解决原有员工知识不足的缺陷。\n给自己找个对手：许多人都把对手视为心腹大患，是异已，是眼中钉，肉中刺，恨不得马上除之而后快，其实，能有一个强而有力的对手，反而是一种福气，一种造化，因为一个强而有力的对手会让你时刻都有危机感，会激发你更加旺盛的精神和斗志。\n利用“鲇鱼效应”时， 要把握好尺度。“引起一个，带动一片”这种鲇鱼效应的应用是有条件的，要经过科学的评估和精心的安排，若不能将“鲇鱼效应”放在整个人力资源开发之中加以全盘考虑，就会适得其反，酿成“鲇鱼负效应”这很有可能会产生窝里斗的情况，不难看出，这种效应发挥作用的前提是出现了员工不思进取的现象。假如你所在的部门已经形成了龙腾上虎跃，锐意进取的气氛了，若仍坚持引进超量的“鲇鱼”，可能就会一些本来可以进取的“沙丁鱼”看不到希望而开熘，也可能会引发内讧，以至效率低下。\n拿破仑曾经说过：狮子率领的兔子军，要远比兔子率领的狮子军做战能力强，这一句话一方面说明了首领的重要性，另一方面还说明这样一个道理：智慧和能力相当的人不能扎堆，能人扎堆对企业发展不利。在人力资源的配置方面，配置恬当，会出现一加一大于二，大于三，可能等于五，配置不当，人员失和，一加一可能等于零，也有可能成负数。\n很多公司在内部出现职位空缺时，往往第一时间会猎头公司是，认为“外来的和尚好念经”却忽视了公司内部的人才，不予挖掘和起用，结果造成了很多企业精英的流失的管理事故。因此，适量引进“外业和尚好念经”，同时也让“庙里和尚会念经”，内外结合，形成有序的人才竞争机制，如此一来，组织就会更加有活力。\n\n# 王安定论\n在信息社会里, 随着全传播渠道的发达,信息传递的速度大大提高,谁能以最快的反应把握商机,谁就能立于不败之地,速度就是效率!\n现代社会是一个信息社会,信息传播的速度大大地提高了,,信息的快速传递缩短了空间距离,把世界各地的市场信息紧紧地联系在一起,信息是机会,就是财富,但是信息所提供的机会是稍纵即逝的,谁能快速拿捏,谁能把握市场供需,谁就能获得财富,也就能成为时代的佼佼者.对此,美藉华裔企业家王安博士提出了有名的”王安论断”,他认为要在信息万变的时代中力争上游,就要在速度上下功夫,惟有速度提高了,效率才能得到提升,王安论断一再被实践验证,具有极大的合理性.\n王安儿时的一个故事：一天小王安遇见一只流浪的猫咪，决定收养它，可他不敢，怕妈妈反对，于是他回家先征求了妈妈的同意，可回到遇到猫咪的地方时，发现小猫已经饿死了。这次的事对小王安的影响非常的大，他知道凡事只要作了决定就得马上行动，效率才是第一的要务。\n善于王安论断的理化内涵，我们会在任何时候都快人一步，人们常说“一步领先，步步领先，一步落后，步步落后”，因此，培养和树立超前意识，具备前瞻眼光，对于提高行事速度就显得极为重要了。\n所谓前瞻眼光和超前意识，体现在三个方面：\n在动态中准确地预见事物的发展趋势。\n在静态中及时预见事的产生的变化。\n在平平常常的工作，生活，学习以及友好往来中善于发现不显眼的契机，并预见到它蕴含的价值和意义，从而牢牢地抓住它，充分发展自己。\n\n# 史密斯法则\n珍惜每一分钟，最大化时间的价值，几乎是每一位成功者必修的一课，学会有机管理时间，才能保证做事的效率，提高生活的质量。\n神奇的三小时，人们早睡早起，这样可以比别人更早展开新的一天，在时间上就能跑在别人的前面，在这三小时（5-8点），你可不受任何人和事干扰做一些自己想做的事，且必须得讲求恒心，判养成早睡早起的习惯，以后你会受益无穷\n疲劳常常只是厌倦的结果，要消除这种疲劳，停止工作是不行，必须变换工作，一个人要是能做一种以上的事，他会活得更有劲，闲暇对于智者来说是思考，对于享受者来说是养尊，对于愚者来说是虚度。\n\n# 吉德拉法则\n任何企业，如果想求生存，求发展，就必须既有效率，又有效益，当效益无法保证时，就要举起改革的斧子。\n20世纪时，在意大利国际市场疲软，在意大利本国工资升高，物价上涨等情况的冲击下，再加上公司内部出现了管理问题，菲亚特汽车公司经历了历史上最不塂回首的日子，公司连年亏损，在世界汽车生产商的排名榜上接连下跌。在此，一个面临倒闭的企业，如果只是寄希望于对原有体制，管理方式进行修修补补，是无济无事的，要从根本上焕发企业的活力，提升企业的效率，增强企业的效率，增强企业的竞争力，就必须进行深刻的改革。正如吉德拉所说的：“凡是没有必要的，就把它摒弃”。\n用人贵精：在管理上，并不是人多就好，有时管理人员越多，工作效率反而越差，只有找到最合适的人数，管理才能收到最好的效果。在一个公司中，吸有每个部门都真正达到了人员的最佳数量，才能最大阴谋的减少无用的工作时间，降低工作成本，从而达到企业利益的最大化。企业的庞杂，人员设置不合理等现象，会使企业官僚之风盛行，人浮于事，从而导致企业工作效率低下，需设法用最少的人做最多的事，极力减少成本，追求效益最大化。\n精简的机构和人员是企业良好运行的根本，与大多数企业不同，沃尔玛在遇到麻烦时，不是采取增加机构和人员的办法来解决问题，相反，而是追本溯源，解聘失职人和精简相关机构。沃尔玛认为，只有这样才能有效的避免机构臃肿。\n企业竞争力的来源在于用最少的人做最多的事。只有机构精简，人员精干，企业才能保持永久的活力，才能在激烈的竞争中立于不败之地。\n要运好吉德拉法则，就需要我们培养一种果断决策的能力，切忌遇事举棋不定，优柔寡断，坚决果断的个性品质，无疑是决策者必备的素质。遇事举棋不定，犹豫不决，经常彷徨，不知所措的人，是那些没有主意，不能决择，依赖别人的人，这种主意不定，自信不坚的人，也难于得到别人的信任。\n多米诺效应\n一荣难俱荣，一损易俱损；在一个相互联系的系统中，一个很小的初始能量就可能产生一连串的连锁反应，人们就把它们称为“多米诺骨牌效应”或“多米诺效应”。\n\n# 手表定理\n手表定理是指一个人有一只表时，可以知道现在是几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人 失去对 准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话： ” 兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。 ”如果每个人都 ” 选择你所爱，爱你所选择 ” ，无论成败都可以心安理得。然而，困扰很多人的是：他们被 ” 两只表 ” 弄得无所，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也 体会不到成功的快乐。\n\n手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目 标。甚至 每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行 为将陷于混乱。\n\n# 彼得原理\n彼得原理是美国学者劳伦斯彼得在对组织中人员晋升的相关现象研究后得出的一个结论；在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为 ” 向上爬 ” 原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。\n\n对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。因此，这就 要求改 变单纯的 ” 根据贡献决定晋升 ” 的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一 位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖 励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。\n\n对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。\n\n鳄鱼法则\n鳄鱼法则：其原意是假定一只鳄鱼咬住你的脚，如果你用手去试图挣脱你的脚，鳄鱼便会同时咬住你的脚与手。你愈挣扎，就被咬住得越多。所以，万一鳄鱼咬住你的脚，你唯一的办法就是牺牲一只脚。\n\n譬如在股市中，鳄鱼法则就是：当你发现自己的交易背离了市场的方向，必须立即止损，不得有任何延误，不得存有任何侥幸。\n\n# 二八定律\n二八定律(巴莱多定律)：19世纪末20世纪初意大利的经济学家巴莱多认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的。 社会约80%的财富集中在20%的人手里，而80%的人只拥有20%的社会财富。这种统计的不平衡性在社会、经济及生活中无处不在，这就是二八法则。\n\n二八法则告诉我们，不要平均地分析、处理和看待问题，企业经营和管理中要抓住关键的少数;要找出那些能给企业带来80%利润、总量却仅占20%的关键客户，加强服务，达到事半功倍的效果;企业领导人要对工作认真分类分析，要把主要精力花在解决主要问题、抓主要项目上。\n\n20%的人成功------------------80%的人不成功\n20%的人用脖子以上赚钱--------80%的人脖子以下赚钱\n20%的人正面思考--------------80%的人负面思考\n20%的人买时间----------------80%的人卖时间\n20%的人找一个好员工----------80%的人找一份好工作\n20%的人支配别人--------------80%的人受人支配\n20%的人做事业----------------80%的人做事情\n20%的人重视经验--------------80%的人重视学历\n20%的人认为行动才有结果------80%的人认为知识就是力量\n20%的人我要怎么做才有钱------80%的人我要有钱我就怎么做\n20%的人计划未来--------------80%的人早上起来才想今天干嘛\n20%的人按成功经验行事--------80%的人按自己的意愿行事\n20%的人做简单的事情----------80%的人不愿意做简单的事情\n20%的人受成功的人影响--------80%的人受失败人的影响\n20%的人状态很好--------------80%的人态度不好\n20%的人相信自己会成功--------------80%的人不愿改变环境\n20%的人永远赞美、鼓励--------------80%的人永远漫骂、批评\n20%的人会坚持--------------80%的人会放弃\n# 蝴蝶效应\n先从美国麻省理工学院气象学家洛伦兹（Lorenz）的发现谈起。为了预报天气，他用计算机求解仿真地球大气的13个方程式。为了更细致地考察结果，他把一个中间解取出，提高精度再送回。而当他喝了杯咖啡以后回来再看时竟大吃一惊：本来很小的差异，结果却偏离了十万八千里！计算机没有毛病，于是，洛伦兹（Lorenz）认定，他发现了新的现象：“对初始值的极端不稳定性”，即：“混沌 ”，又称“蝴蝶效应”，亚洲蝴蝶拍拍翅膀，将使美洲几个月后出现比狂风还厉害的龙卷风！这个发现非同小可，以致科学家都不理解，几家科学杂志也都拒登他的文章，认为“违背常理”：相近的初值代入确定的方程，结果也应相近才对，怎幺能大大远离呢！线性，指量与量之间按比例、成直线的关系，在空间和时间上代表规则和光滑的运动；而非线性则指不按比例、不成直线的关系，代表不规则的运动和突变。如问：两个眼睛的视敏度是一个眼睛的几倍？很容易想到的是两倍，可实际是 6－10倍！这就是非线性：1＋1不等于2。激光的生成就是非线性的！当外加电压较小时，激光器犹如普通电灯，光向四面八方散射；而当外加电压达到某一定值时，会突然出现一种全新现象：受激原子好象听到“向右看齐”的命令，发射出相位和方向都一致的单色光，就是激光。非线性的特点是：横断各个专业，渗透各个领域，几乎可以说是：“无处不在时时有。” 如：天体运动存在混沌；电、光与声波的振荡，会突陷混沌；地磁场在400万年间，方向突变16次，也是由于混沌。甚至人类自己，原来都是非线性的：与传统的想法相反，健康人的脑电图和心脏跳动并不是规则的，而是混沌的，混沌正是生命力的表现，混沌系统对外界的刺激反应，比非混沌系统快。由此可见，非线性就在我们身边，躲也躲不掉了。\n\n1979年12月，洛伦兹（Lorenz）在华盛顿的美国科学促进会的一次讲演中提出：一只蝴蝶在巴西扇动翅膀，有可能会在美国的德克萨斯引起一场龙卷风。他的演讲和结论给人们留下了极其深刻的印象。从此以后，所谓“蝴蝶效应”之说就不胫而走，名声远扬了。 “蝴蝶效应”之所以令人着迷、令人激动、发人深省，不但在于其大胆的想象力和迷人的美学色彩，更在于其深刻的科学内涵和内在的哲学魅力。混沌理论认为在混沌系统中，初始条件的十分微小的变化经过不断放大，对其未来状态会造成极其巨大的差别。\n\n我们可以用在西方流传的一首民谣对此作形象的说明。这首民谣说：丢失一个钉子，坏了一只蹄铁； 坏了一只蹄铁，折了一匹战马；折了一匹战马，伤了一位骑士；伤了一位骑士，输了一场战斗；输了一场战斗，亡了一个帝国。马蹄铁上一个钉子是否会丢失，本是初始条件的十分微小的变化，但其“长期”效应却是一个帝国存与亡的根本差别。这就是军事和政治领域中的所谓“蝴蝶效应”。有点不可思议，但是确实能够造成这样的恶果。一个明智的领导人一定要防微杜渐，看似一些极微小的事情却有可能造成集体内部的分崩离析，那时岂不是悔之晚矣？横过深谷的吊桥，常从一根细线拴个小石头开始。\n\n# 蘑菰管理原理\n蘑菰长在阴暗的角落，得不到阳光，也没有肥料，自生自灭，只有长到足够高的时候才开始被人关注，可此时它自己已经能够接受阳光了。\n\n蘑菰管理是大多数组织对待初入门者、初学者的一种管理方法。从传统的观念上讲，“蘑菰经历”是一件好事，它是人才蜕壳羽化前的一种磨炼，对人的意志和耐力的培养有促进作用。但用发展的眼光来看，蘑菰管理有着先天的不足：一是太慢，还没等它长高长大恐怕疯长的野草就已经把它盖住了，使它没有成长的机会；二是缺乏主动，有些本来基因较好的蘑菰，一钻出土就碰上了石头，因为得不到帮助，结果胎死腹中。\n\n让初入门者当上一段时间的“蘑菰”，可以消除他们不切实际的幻想，从而使他们更加接近现实，更实际、更理性地思考问题和处理问题。领导者应当注意的是，这一过程不可过长，时间太长便会使其消极退化乃至枯萎，须知不给阳光不给关爱不仅是任其自生自灭，而且更是对其成长的抑制。如何让他们成功地走过生命中的这一段，尽快吸取经验、成熟起来，这才是领导者所应当考虑的。","slug":"管理学效应","published":1,"updated":"2020-01-29T06:52:45.533Z","_id":"ck5xwo6wy0005m7iy43jd4xwo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>管理无处不在，管理就是如何处理人际关系，平衡利益，分配权力的过程。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"长尾效应\"><a href=\"#长尾效应\" class=\"headerlink\" title=\"长尾效应\"></a>长尾效应</h1><p>长尾效应的根本就是要强调”个性化”,”客户力量”和”小利润大市场”,也就是要赚很少的钱,但是要赚很多人的钱.要将市场细分到很细很小的时候,然后就会发现这些细小市场的累计会带来明显的长尾的效应.以图书为例：Barnes &amp; Noble 的平均上架书目为13万种。而Amazon有超过一半的销售量都来自于在它排行榜上位于13万名开外的图书。如果以Amazon的统计数据为依据的话，这就意味着那些不在一般书店里出售的图书要比那些摆在书店书架上的图书形成的市场更大。也就是说，如果我们能够摆脱资源稀缺的限制，潜在的图书市场将至少是目前的两倍大。曾在音乐行业担任过顾问的风险投资家Kevin Laws 是这样总结这一现象的：“最大的财富孕育自最小的销售。</p>\n<h1 id=\"达维多定律\"><a href=\"#达维多定律\" class=\"headerlink\" title=\"达维多定律\"></a>达维多定律</h1><p>达维多定律是以英特尔公司副总裁达维多的名字命名的。达维多认为，一家企业要在市场中总是占据主导地位，那么它就要永远做到第一个开发出新一代产品，第一个淘汰自己的产品。</p>\n<p>这一定律的基点是着眼于市场开发和利益分割的成效。人们在市场竞争中无时无刻不在抢占先机，因为只有先入市场，才能更容易获得较大的份额和高额的利润。英特尔公司在产品开发和推广上奉行达维多定律，始终是微处理器的开发者和倡导者。他们的产品不一定是性能最好的和速度最快的，但他们一定做到是最新的。为此，他们不惜淘汰自己哪怕是市场上正卖得好的产品。</p>\n<p>达维多定律揭示了以下取得成功的真谛：不断创造新产品，及时淘汰老产品，使新产品尽快进入市场，并以自己成功的产品形成新的市场和产品标准，进而形成大规模生产，取得高额利润。</p>\n<h1 id=\"酒与污水效应\"><a href=\"#酒与污水效应\" class=\"headerlink\" title=\"酒与污水效应\"></a>酒与污水效应</h1><p>如果你把一汤匙的酒倒进一桶污水里，你得到到的是一桶污水；如果你把一汤匙的污水倒进一桶酒里，你得到的还是一桶污水。酒·污水效应对学校管理的启示是：在一些学校中难免碰到个别“污水”式的教师，他们人数虽然很少，但破坏力巨大。为此，学校领导要花费精力处理这类“污水”。</p>\n<p>员工的技术能力和敬业程度是公司顺利发展的保证.<br>员工优劣评比:分ABC(C类即烂苹果员工)三类,表现最差的员工通常都必须走人.<br>对待烂苹果员工的做法: 动作要快,越快越好. 任何组织里，都存在几个难管理的人物，他们像苹果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其他苹果也弄烂。“烂苹果”的可怕之处在于它那惊人的破坏力。组织系统往往是脆弱的，它是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化是因为破坏总比建设容易。“烂苹果”定律告诉我们：对于坏的组员或东西，要在其开始破坏之前及时处理掉。</p>\n<h1 id=\"零和游戏原理\"><a href=\"#零和游戏原理\" class=\"headerlink\" title=\"零和游戏原理\"></a>零和游戏原理</h1><p>当你看到两位对弈者时，你就可以说他们正在玩“零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+(-1)=0。这正是“零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。</p>\n<p>零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与“零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从到经济，似乎无不验证了世界正是一个巨大的“零和游戏”场。这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个“邪恶进化论”式的弱肉强食的世界。</p>\n<p>但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，“零和游戏”观念正逐渐被“双赢”观念所取代。人们开始认识到“利己”不一定要建立在“损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从“零和游戏”走向“双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则“双赢”的局面就不可能出现，最终吃亏的还是自己</p>\n<h1 id=\"马太效应\"><a href=\"#马太效应\" class=\"headerlink\" title=\"马太效应\"></a>马太效应</h1><p>《圣经》中”马太福音”一章里有一句名言：”凡是有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来。”美国着名哲学家罗帕特·默顿发现了同样的现象，即荣誉越多的科学家，授予他的荣誉就越多；而对那些默默无闻的科学家，对其作出的成绩往往不予承认。他于1973年把这种现象命名为”马太效应”。在班级管理中，就是好学生好对待，差学生差对待，而好与差的标准主要还是学习成绩。对于一些班主任心目中的好学生来说，爱”过剩”的时候，就会贬值，他们对表扬就会变得麻木不仁，认为一切都是理所当然。这种优越的社会心理环境会使他们在成长中变得非常脆弱，经不起挫折。而对另外一些学生仅仅因为分数不高，就会长期处在被班主任的关爱遗忘的角落，这种人为造成的恶劣的心理环境，将会使他们情绪偏激、行为带有触发性和冲动性，这样必然导致学生个性的畸形发展，引发学生的心理障碍。</p>\n<p>马太效应指出学习能力强的学生，发言机会就多，而发言机会愈多能力愈强，学习能力弱者反之，造成优者越优，差者越差，两极分化。在小组合作学习中，我们常碰到这样的情况，能力较高的成员受到尊重，并取得领导地位，甚至抢尽风头或牺牲其它组员的利益来自我获益；而能力较低的成员则完全丧失了合作学习的兴趣。</p>\n<p>社会心理学家认为，“马太效应”是既有消极作用又有积极作用的社会心理现象。其积极作用是：“马太效应”使学习能力强的学生会获得越来越多的荣誉和越来越高的评价，这对小组内表现一般的学生有巨大的吸引力，促使他们去努力，从这个意义上讲，“马太效应”将客观上促使组内竞争的产生，而合作学习并不排斥竞争，这是符合合作学习的精神的。其消极作用是：获得高评价的学生，如果没有清醒的自我认识和没有理智态度容易产生居功自傲、遭小组成员非议等不利合作行为的现象。很显然，如果一味放任小组成员的自发无序地竞争只会导致不均衡的加剧。</p>\n<p>消除合作学习中 “马太效应” 的消极作用，要求我们努力实现评价的社会公平感。“马太效应”的导致学生参与度不均衡的主要原因是学生的个人职责不明确，以及老师只关注小组的学习结果，不注意学习过程和个人的学习进步。所以，在合作学习的评价中，教师不仅要关注学习结果，更要关注学习过程，教师还需要讲究评价策略，做到指导与激励相结合，对不同发展水平的学生有不同的要求，应关注每一位学生，特别是对小组中能力较差的学生更应注意到他们的点滴进步。</p>\n<p>这是一个赢家通吃的时代，在人类资源分配上，出现了极不均匀的状况：富者越富，穷者越穷。圣经里面的《新约.马太福音》<br>成功是成功之母：都说失败是成功之母，这句话是有一定的道理，但不是绝对的，它有一定的适用范围，试想一下，如果你屡屡失败，从未品尝过成功的甜头，你还必胜的信心吗？你还相信失败是成败之母吗？成功有倍增效应，你越成功，你就会越自信，越自信就会使你越容易成功。这个角度来说：“成功是成功之母”。成功和失败也有两极分化的“马太效应”，成功会使你自信，也就越能成功，而失败会使人灰心丧气，离成功也就越来越远了。例如拿破仑一生曾打过100多次胜战，胜利使他坚信自己会所向披靡，而且，也使敌人闻风丧胆。<br>当然，提倡“成功是成功之母”，并不反对人们从失败中学习。失败是成败之母对于抗挫折能力强的成年人来说，可能是正确的，但对于心智尚未成熟，意志还很脆弱的中小学生来说，未必适用。对于中小学生而言，成功是成功之母可能更适合他们的发展。当一名学生取得成功后，因成功而酿造出的自信心，会促使她取得更好的成绩，随送新成绩的取得，心理因素再次得到优化，从而形成了一个不断发展的良性循环，让他获得不断的成功。通过体验成功，学生将产生积极向上的心态，并提高学习的效率，具有了更大的发展潜力。这就是教育领域的灵活运用。<br>决定一个人身份和地位的并不一定是他的才能和价值，有时候是他的背景和他所代表的组织或是代表的群体，若能使用这些隐藏的资源，它将使你的价值增值。<br>永远领先半步”，“一步领先，步步领先“是美国甲骨文软件公司为提升企业文化，增强企业核心竞争力而恪守的经营理念。甲骨文软件公司的经营理念包括市场敏感度领先，销售策略领先，服务超前，规模超前等。在开拓新市场时总是领先市场，领先竞争对手半步，而这半步就是人们所说的领先市场和引导消费，一位高层员工透露：“别人软件没有上市计划，甚至还在开发的时候，我们的软件就已经上市了，但我们通常只比别人提前1个月的时间”。<br>由于商业活动中以稀为奇，以少为贵的现象越来越突出，所以要想超出众人，领先半步，就得在稀奇，独特上下功夫，打注意，做文章，见人所未见，为人所未为，才能出奇制胜，步步为赢。<br>木桶法则<br>木桶法则的意思是：一只沿口不齐的木桶，它盛水的多少，不在于木桶上那块最长的木板，而在于木桶上最短的那块木板。要想多盛水——提高木桶的整体效应，不是去增加最长的那块木板的长度，而是要下功夫依次补齐木桶上最短的那块木板。<br>木桶法则告诉管理者：在管理过程中要下功夫狠抓薄弱环节，否则，单位的整体工作就会受到影响。人们常说“取长补短”，即取长的目的是为了补短，只取长不补短，就很难提高工作的整体效应。</p>\n<h1 id=\"位差效应\"><a href=\"#位差效应\" class=\"headerlink\" title=\"位差效应\"></a>位差效应</h1><p>来自领导层的信息只有20%-25%被下级知道并正确理解,而从下到上反馈的信息则不超过10%,平行交流的效率可达到90%以上.(代表:美国沃尔玛公司—平等的沟通精神,让沟通无处不在)</p>\n<p>对待员工和蔼,交流时他会竭尽所能让你将话说出来.<br>鼓励中级员工之间加强沟通与合作.<br>要求所有的员工极为公司的发展提出新的构想.(每周开展讨论会,并颁发相应的奖励)<br>人心不是唠叨所能改变的(要知道唠叨不是一种有效的交流手段,相反只会引起员工的发感)<br>每个企业的正常运转都依靠严格的等级制度来保障.但不能管理者的姿态对待员工,认员工敢于直面总裁.如果一个管理者只会趾高气扬,执意显示自己的地位与身份,那么,他的管理定是失败的<br>只有让每一位员工都感到自己是公司平等的一员,才能让他们的意见的建议毫无保留的表达出来.<br>一个不称职的官员,可能有三条出路:第一是申请退职,把位子让给能干的人,第二是让一位能干的人为协助自己的工作,第三是任用两个(两个以上,才能起到互相牵制的作用)水平比自己更低的人当助手,如此必然导致机构人员膨胀而效率低下.</p>\n<h1 id=\"帕金森定律\"><a href=\"#帕金森定律\" class=\"headerlink\" title=\"帕金森定律\"></a>帕金森定律</h1><p>英国着名历史学家诺斯古德·帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。</p>\n<p>高级官员感到无聊乏味,中级人员忙于勾心斗角,低给人员则灰心丧气.<br>权力的危机感是产生帕金森效应的直接原因.<br>最需要注意的就是,不要将用人权放在一个被招聘者的直接上司手里.<br>华盛顿合作定律<br>在角色群体的活动效率中，既可能产生增力作用，也可能导致减力作用。 “三个臭皮匠，凑成一个诸葛亮”，这种情况下“1+1+l”大于3。这在群体成员活动的效率角度上，称之为“群体的增力作用”。 “三个和尚没水喝”，这种情况下的“1+1+1”却等于0了。这在群体成员活动的效率角度上，称之为“群体的减力作用”。</p>\n<p>人与人的合作,不是人力的简单相加,而远比这复杂和微妙得多.<br>在一个集体中,大多数都采取观望态度(旁观都效应),而产生这类现象的根本原因则是责任不明确.<br>能力相等的人一起合作,只有合理的分工合作,才会有辉煌的成果,把每一个人放在最为合适的位置.同时要考虑到该人的优点和缺点及员工之间的相互配合.<br>人与人之间的合作,经常会出现彼此之间的排斥的妒嫉心理.多个优秀的人同时一起工作，通常不能顺利的完成工作。通常将其中的一些人调离到新的岗位，其表现也将是惊人的。<br>员工之间的分工合作是必需的，<br>邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。<br>责任保证绩效。责任与绩效之间的关系应该是成正比的，但明确责任，是提高工作绩效的前提，一个企业一定要有明确的责任体系，权责不明不仅不会出现责任真空，而且还容易导致员工之间互相推诿，把自己置于责任之外，明确的责任体系，是让每一个人都清楚自己要做什么，应该怎么做。这们团队中的成员对自己的任务就是责无旁贷的。</p>\n<h1 id=\"马蝇效应\"><a href=\"#马蝇效应\" class=\"headerlink\" title=\"马蝇效应\"></a>马蝇效应</h1><p>再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。</p>\n<p>不言面喻，一个企业的发展，需要竞争对手的时时叮咬，方能保持旺盛的势头让自己强大起来。<br>企业能够发展壮大，应该感谢对手时时施加的压力，正是这些压力，化为想方设法战胜困难的动力，进而在残酷的市场竞争中，始终保持着一种危机感。</p>\n<p>无独有偶，在美国费城西部，有两个敌对的商店，一个A商店，一个中B商店，两个商店是隔壁邻居，店老板是死对手，他们之间经常展开价格竞争。当A商店在窗口挂出床单6.5元时，B商店则会出现5.9元的标价，此外，他们还常走出商店，相互咒骂，甚至大打出手，最终他们中间一个人会在竞争的退出，宣称另一个店老板是疯子，在他那里买东西的人都是疯子。于是人们便纷纷路到竞争获胜的商店买完所有的床单，在这一带由于他们的不断竞争,人们买到了各种自认为物美价谦的商品。说来有趣，有一天，他们中间的一位老板去世了，而几天后，另一位老板就进行了清仓大展销，然后搬了，人们再也没看见他，这是为什么呢？当房子的新主人进行大清理时发现了其中的秘密，原来，两位老板的住房有一个通道，他们的住房就在商店上面，后来经进一步核查，这两位老板竞是同胞兄弟。</p>\n<p>原来所有的咒骂、恐吓和其他人身攻击都是在演戏，所有的价格竞争都是骗人的，谁获得胜利，谁就把俩人的商品一起抛出去，就这样他们的骗局维持了30年之久，未被他人发现。直到其中一个死去才真相大白。保持必要的竞争是企业成长和发展的动力，哪怕是一种竞争假象，也会形成一种良好的氛围，这是一种生存的智慧，也是事业保持快速发展的有效之道。</p>\n<p>在“刺头”身上放几个“马蝇”。几乎在每一个企业里都有某一些人拥有在某一方面不可替代的资源（如背景）或聪明，好动，上进心强，是某一方面或某几方面的专家，在此他们充满创新精神。对成功以及成相关的东西（金钱，权力，职位等）具有极其浓厚的兴趣，他们不会行规蹈矩，也不会轻易被权威所折服，更让人头痛的是，这些人不但在专业上有一套，往往在组织内的“兴风作浪上也很有一套。仔细分析一下我们就可以发现，这些人有一个共同的特点：那就是他们不会轻易被满足，他们具有强烈的占有欲。由于不会轻易满足，所以他们才会表现得与众不同，因为他们需要给领导留下更深刻的印象，因为他们希望由此而得到更鑫的满足。因为他们身叮着有刺激他们积极进取的“马蝇”，对于那些有优势的员工来说，他们并不畏惧更高的目标，更大的工作范畴，更有难度的任务，他们往往希望通过挑战这些来显示自己超人一等的能力及在公司里无可替代的地位，以便赢得更多的尊重。这就是叮在他们身上的“马蝇”。</p>\n<p>因此，谨慎地做好他们的工作是提升管理绩效的关键。以下几个方面的问题值得仔细关注的：</p>\n<p>如果你是一个善于辞令，善于捕捉他人心理的管理者，你可以度着找他们谈谈心，做做思想工作。<br>行动永远比语言更有说服力，在巧妙运用你的权利资本时，为这些高傲的家伙树立一个曲范，让他们看看一个有权威的人是怎么处理问题，实现团队目标的。<br>这些家伙往往好胜自负，进取心强，在委派任务的时候，最好用一句简洁有力，但颇能刺激他神经的话来结束：这个任务对你来说有困难吗？在得到他不服气或略带轻蔑的回答后，便可结束了，如果太多叮嘱和干预，只会引起这种人的反感和烦燥，甚至使他地于任务本身和你这个管理者更加不屑一顾。<br>运用你的智慧和鼓动力，在工作时有意的对此类员工进行一些“冷处理”，让他体会到个人的力量与团队的力量相比，是微不足道的，然后，在适当的时候鼓励其发挥专长，保全他的面子和自尊。<br>制度面前人人平等，从一开始就不要给这样的员工以任何错觉，不要让他们误以为自己有某些优势，就可以凌驾于制度之上，这点是长期驾驭这类人的关键，一定要坚持下来。<br>在对于想跳槽的员工，应注意：1，不要为了留住某些人轻易做出很难实现的承诺。2，如果有过承诺，一定要兑现，如果无法兑现，一定要给他们一个正面的说法，不能在员工面前扮演一个言而无信的管理者角色，那样只会为将来的动荡埋下隐患。<br>及时发现员工的情绪波动，特别是那些业务骨干，一定要把安抚民心做在前头，虽说亡羊补牢，为时未晚，但把预警工作做在前头，是不是可以避免一些不必要的损失呢？<br>如果员工去意已定，那么你不要太过勉强，应该善始善终，好说好散，在有必要的时候，可心请他们提前离开，重要的在于不要让某些人的“离去”变成有针对性，有目的性的挑衅，造成全公司员工的大面积情绪波动。<br>随时检讨公司晋升，薪酬，绩效考核等人力资源管理制度是否合理，避免因制度性原因而造成员工非正常性流<br>攻心为上，以理服人，以情动人。方为上策。<br>例外原则</p>\n<p>为了提高效率和控制大局，上级只保留处理例外和非常规事件的决定权和控制权，例行和常规的权力由部下分享。（一把抓的控制方式是一种错误的模式）</p>\n<p>管理的密决在于合理地授权。所谓授权，就是指为帮助下属完成任务，领导者将所属权力的一部分与其相应的责任授予下属。使领导能做领导的事，下属能做下属的事，这就是授权所应达到的目的。合理地授权可以使领导者摆脱能够由下属完成的日常任务，自已专心处理重大决策问题，还有助于培养下属的工作能力，有利于提高士气，授权是否合理是区分领导者才能高低的重要标志。正如韩非子所说的那样“下者尽已之能，中群尽人之力，上君尽人之智”，领导者做为“上君”，负责最高层的决策。就必须对下属进行合理的授权。<br>授权可以让未来规模更大的企业仍然保持小企业的活力，同时也可以为公司培养出发展所必需的大批出色的经营管理人才。<br>许多管理者都知道授权的重要性，但他们却总埋怨手下没有可以委托的人，须知才干是在实践中增长的，你总是不敢把艰难的工作交给下属，他们就永远没有显示才干或得不到提高的机会。正如你总是不敢孩子下地，他就永远也学不会走路。<br>授权与单纯的分派任务是不同的，分派任务是让下属照你的吩咐去做，他是被动的，而授权则是把整个事情委托给他，同时交付足够的权力让他做必要的决定。这有助于增长他的荣誉，使他有成就感。<br>适当放权既能给下属留下发展自已的空间，又能使管理者抽出更多的时间去督导员工工作，提高整个团队的工作效率也就顺理成章了。<br>授权并非一蹴而成，不能说一句“这件事交给你就以为完成了授权，授权一事需要授权者和被授权者双方密切的合作，彼此态诚恳，相互沟通了解。在授权的时候，授权者必须有心理准备，明确授予下属完成任务所必须的权力和责任。使他完全理解自己的任务，权力和责任。做到这一点后，就要让授任者依他自已的方式处理事情，不要随意干涉，并且随时给予支持，扶助，合理地授权并非对下属放任自流，撒手不管。授权者要保留监督的权利，在受权者出现不可原谅的错误时，随时取消他的受权资格。<br>合理的授权，有利于调动下属在工作中的积极性，主动性和创造性。激发下属工作情绪，增长其才干，使上级领导的思想意图为群体成员所接受。<br>授权可以发现人才，利用人才，锻炼人才，使企业的工作出现一个朝气蓬勃，生龙活虎的局面。<br>如果你想让下属有出色的表现，，你必须学会为他们“搭舞台”，在必要的时候，给他们提供一定的财力，物力，人力，让他们全身心地投入到工作中，而不会因此分散他们的精力，让他们产生顾虑。<br>管理学之父泰罗提倡领导者要学会合理的授权，尤其是要学会在遇到自已懂的知识时，，将决策权交给别人<br>授权的原则：<br>握大权，授小权（将一些繁重的，琐碎的事务性工作交由下属处理，自已保留例外事件和非常事件的决定权和控制权）〕<br>因事择人，视德才授权（泰罗授权理论中最为基本的准则就是因事择人，视德才授权，授权不是利益的分配，更不荣誉的照顾，而是为了将工作做得更出色的一种用人策略，所以应考虑用人更佳性。选择最适的人当受权人）。<br>先放后收。不要将一种权力无限度地授予下属。而要适时地加以控制或是回收，这可能会导致上下级之间脱节，从而让自已的下属处于“权力真空”的状态。相反，如若能时时监督下属的权力应用。<br>不越级授权。在企业中，主要实行的是领导负责制，这种体制具有明显的层次性。所以在授权下属权力时，一定要掌握尺度，不要越级授权，而要逐级进行，否则只会引起各级下属之间不必要的误解和职责的混乱。<br>有效的反馈。对于下属的工作表现的评价，不能太主观意断，而要有说服力，这就要求领导者在授权后，要与下属保持畅通的反馈的渠道。当你将一项权力授予下属，而他将一件工作完成的非常糟糕进，或许事情还不至于糟到无法挽回的地步，但更糟糕的是，你没有补救的办法，下属需要及时的反馈工作的进展情况，而你更需要向下属传授工作的改进之处。<br>全局性。一位领导要授权下属以不同的权力，在授权后，你要有足够的时间与精力把握一些全局性的工作，高明的领导在全局统筹的时候，善于采用纵向画线与横向划格的管理模式来实现组织控制。纵向画线是指界定各个部门对上，对下的权限，横向划格是指界定下级各部门之间的权限。这样既有利于下级充分利用自已的权力施展自已的才华，又不至于各部门成为有服从指挥的独立王国，从而有助于从整体上进行把握与协调。</p>\n<h1 id=\"鲇鱼效应\"><a href=\"#鲇鱼效应\" class=\"headerlink\" title=\"鲇鱼效应\"></a>鲇鱼效应</h1><p>一种动物如果没有对手，就会变得死所沉沉，同样一个人如果没有对手，那他就会甘于庸，养成惰性，最终导致庸碌无为。<br>招聘应届毕业生做为鲇鱼员工，因为应届毕业生给企业带来了鲶鱼效应，增强了整个团队的竞争意识和危机意识，从而制造出一种紧张气氛，使全休员工更加勤奋地工作，促使企业的竞争力不断的提升。<br>一个单位或部门，如果人员长期固定，彼此太熟悉，就容易产生惰性，削弱组织的活力，若从外部引进“鲇鱼”，他们能以崭新的面貌对原有部门产生强烈的冲击。他们能很好的刺激其他员工的竞争意识，克服员工安于现状，不思进取的惰性。<br>有意识地引入一些“鲇鱼”，通过他们挑战性的工作来打破昔日的平静，不仅可心激活整个团体，还能有效地解决原有员工知识不足的缺陷。<br>给自己找个对手：许多人都把对手视为心腹大患，是异已，是眼中钉，肉中刺，恨不得马上除之而后快，其实，能有一个强而有力的对手，反而是一种福气，一种造化，因为一个强而有力的对手会让你时刻都有危机感，会激发你更加旺盛的精神和斗志。<br>利用“鲇鱼效应”时， 要把握好尺度。“引起一个，带动一片”这种鲇鱼效应的应用是有条件的，要经过科学的评估和精心的安排，若不能将“鲇鱼效应”放在整个人力资源开发之中加以全盘考虑，就会适得其反，酿成“鲇鱼负效应”这很有可能会产生窝里斗的情况，不难看出，这种效应发挥作用的前提是出现了员工不思进取的现象。假如你所在的部门已经形成了龙腾上虎跃，锐意进取的气氛了，若仍坚持引进超量的“鲇鱼”，可能就会一些本来可以进取的“沙丁鱼”看不到希望而开熘，也可能会引发内讧，以至效率低下。<br>拿破仑曾经说过：狮子率领的兔子军，要远比兔子率领的狮子军做战能力强，这一句话一方面说明了首领的重要性，另一方面还说明这样一个道理：智慧和能力相当的人不能扎堆，能人扎堆对企业发展不利。在人力资源的配置方面，配置恬当，会出现一加一大于二，大于三，可能等于五，配置不当，人员失和，一加一可能等于零，也有可能成负数。<br>很多公司在内部出现职位空缺时，往往第一时间会猎头公司是，认为“外来的和尚好念经”却忽视了公司内部的人才，不予挖掘和起用，结果造成了很多企业精英的流失的管理事故。因此，适量引进“外业和尚好念经”，同时也让“庙里和尚会念经”，内外结合，形成有序的人才竞争机制，如此一来，组织就会更加有活力。</p>\n<h1 id=\"王安定论\"><a href=\"#王安定论\" class=\"headerlink\" title=\"王安定论\"></a>王安定论</h1><p>在信息社会里, 随着全传播渠道的发达,信息传递的速度大大提高,谁能以最快的反应把握商机,谁就能立于不败之地,速度就是效率!<br>现代社会是一个信息社会,信息传播的速度大大地提高了,,信息的快速传递缩短了空间距离,把世界各地的市场信息紧紧地联系在一起,信息是机会,就是财富,但是信息所提供的机会是稍纵即逝的,谁能快速拿捏,谁能把握市场供需,谁就能获得财富,也就能成为时代的佼佼者.对此,美藉华裔企业家王安博士提出了有名的”王安论断”,他认为要在信息万变的时代中力争上游,就要在速度上下功夫,惟有速度提高了,效率才能得到提升,王安论断一再被实践验证,具有极大的合理性.<br>王安儿时的一个故事：一天小王安遇见一只流浪的猫咪，决定收养它，可他不敢，怕妈妈反对，于是他回家先征求了妈妈的同意，可回到遇到猫咪的地方时，发现小猫已经饿死了。这次的事对小王安的影响非常的大，他知道凡事只要作了决定就得马上行动，效率才是第一的要务。<br>善于王安论断的理化内涵，我们会在任何时候都快人一步，人们常说“一步领先，步步领先，一步落后，步步落后”，因此，培养和树立超前意识，具备前瞻眼光，对于提高行事速度就显得极为重要了。<br>所谓前瞻眼光和超前意识，体现在三个方面：<br>在动态中准确地预见事物的发展趋势。<br>在静态中及时预见事的产生的变化。<br>在平平常常的工作，生活，学习以及友好往来中善于发现不显眼的契机，并预见到它蕴含的价值和意义，从而牢牢地抓住它，充分发展自己。</p>\n<h1 id=\"史密斯法则\"><a href=\"#史密斯法则\" class=\"headerlink\" title=\"史密斯法则\"></a>史密斯法则</h1><p>珍惜每一分钟，最大化时间的价值，几乎是每一位成功者必修的一课，学会有机管理时间，才能保证做事的效率，提高生活的质量。<br>神奇的三小时，人们早睡早起，这样可以比别人更早展开新的一天，在时间上就能跑在别人的前面，在这三小时（5-8点），你可不受任何人和事干扰做一些自己想做的事，且必须得讲求恒心，判养成早睡早起的习惯，以后你会受益无穷<br>疲劳常常只是厌倦的结果，要消除这种疲劳，停止工作是不行，必须变换工作，一个人要是能做一种以上的事，他会活得更有劲，闲暇对于智者来说是思考，对于享受者来说是养尊，对于愚者来说是虚度。</p>\n<h1 id=\"吉德拉法则\"><a href=\"#吉德拉法则\" class=\"headerlink\" title=\"吉德拉法则\"></a>吉德拉法则</h1><p>任何企业，如果想求生存，求发展，就必须既有效率，又有效益，当效益无法保证时，就要举起改革的斧子。<br>20世纪时，在意大利国际市场疲软，在意大利本国工资升高，物价上涨等情况的冲击下，再加上公司内部出现了管理问题，菲亚特汽车公司经历了历史上最不塂回首的日子，公司连年亏损，在世界汽车生产商的排名榜上接连下跌。在此，一个面临倒闭的企业，如果只是寄希望于对原有体制，管理方式进行修修补补，是无济无事的，要从根本上焕发企业的活力，提升企业的效率，增强企业的效率，增强企业的竞争力，就必须进行深刻的改革。正如吉德拉所说的：“凡是没有必要的，就把它摒弃”。<br>用人贵精：在管理上，并不是人多就好，有时管理人员越多，工作效率反而越差，只有找到最合适的人数，管理才能收到最好的效果。在一个公司中，吸有每个部门都真正达到了人员的最佳数量，才能最大阴谋的减少无用的工作时间，降低工作成本，从而达到企业利益的最大化。企业的庞杂，人员设置不合理等现象，会使企业官僚之风盛行，人浮于事，从而导致企业工作效率低下，需设法用最少的人做最多的事，极力减少成本，追求效益最大化。<br>精简的机构和人员是企业良好运行的根本，与大多数企业不同，沃尔玛在遇到麻烦时，不是采取增加机构和人员的办法来解决问题，相反，而是追本溯源，解聘失职人和精简相关机构。沃尔玛认为，只有这样才能有效的避免机构臃肿。<br>企业竞争力的来源在于用最少的人做最多的事。只有机构精简，人员精干，企业才能保持永久的活力，才能在激烈的竞争中立于不败之地。<br>要运好吉德拉法则，就需要我们培养一种果断决策的能力，切忌遇事举棋不定，优柔寡断，坚决果断的个性品质，无疑是决策者必备的素质。遇事举棋不定，犹豫不决，经常彷徨，不知所措的人，是那些没有主意，不能决择，依赖别人的人，这种主意不定，自信不坚的人，也难于得到别人的信任。<br>多米诺效应<br>一荣难俱荣，一损易俱损；在一个相互联系的系统中，一个很小的初始能量就可能产生一连串的连锁反应，人们就把它们称为“多米诺骨牌效应”或“多米诺效应”。</p>\n<h1 id=\"手表定理\"><a href=\"#手表定理\" class=\"headerlink\" title=\"手表定理\"></a>手表定理</h1><p>手表定理是指一个人有一只表时，可以知道现在是几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人 失去对 准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话： ” 兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。 ”如果每个人都 ” 选择你所爱，爱你所选择 ” ，无论成败都可以心安理得。然而，困扰很多人的是：他们被 ” 两只表 ” 弄得无所，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也 体会不到成功的快乐。</p>\n<p>手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目 标。甚至 每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行 为将陷于混乱。</p>\n<h1 id=\"彼得原理\"><a href=\"#彼得原理\" class=\"headerlink\" title=\"彼得原理\"></a>彼得原理</h1><p>彼得原理是美国学者劳伦斯彼得在对组织中人员晋升的相关现象研究后得出的一个结论；在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为 ” 向上爬 ” 原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。</p>\n<p>对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。因此，这就 要求改 变单纯的 ” 根据贡献决定晋升 ” 的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一 位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖 励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。</p>\n<p>对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。</p>\n<p>鳄鱼法则<br>鳄鱼法则：其原意是假定一只鳄鱼咬住你的脚，如果你用手去试图挣脱你的脚，鳄鱼便会同时咬住你的脚与手。你愈挣扎，就被咬住得越多。所以，万一鳄鱼咬住你的脚，你唯一的办法就是牺牲一只脚。</p>\n<p>譬如在股市中，鳄鱼法则就是：当你发现自己的交易背离了市场的方向，必须立即止损，不得有任何延误，不得存有任何侥幸。</p>\n<h1 id=\"二八定律\"><a href=\"#二八定律\" class=\"headerlink\" title=\"二八定律\"></a>二八定律</h1><p>二八定律(巴莱多定律)：19世纪末20世纪初意大利的经济学家巴莱多认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的。 社会约80%的财富集中在20%的人手里，而80%的人只拥有20%的社会财富。这种统计的不平衡性在社会、经济及生活中无处不在，这就是二八法则。</p>\n<p>二八法则告诉我们，不要平均地分析、处理和看待问题，企业经营和管理中要抓住关键的少数;要找出那些能给企业带来80%利润、总量却仅占20%的关键客户，加强服务，达到事半功倍的效果;企业领导人要对工作认真分类分析，要把主要精力花在解决主要问题、抓主要项目上。</p>\n<p>20%的人成功——————80%的人不成功<br>20%的人用脖子以上赚钱——–80%的人脖子以下赚钱<br>20%的人正面思考————–80%的人负面思考<br>20%的人买时间—————-80%的人卖时间<br>20%的人找一个好员工———-80%的人找一份好工作<br>20%的人支配别人————–80%的人受人支配<br>20%的人做事业—————-80%的人做事情<br>20%的人重视经验————–80%的人重视学历<br>20%的人认为行动才有结果——80%的人认为知识就是力量<br>20%的人我要怎么做才有钱——80%的人我要有钱我就怎么做<br>20%的人计划未来————–80%的人早上起来才想今天干嘛<br>20%的人按成功经验行事——–80%的人按自己的意愿行事<br>20%的人做简单的事情———-80%的人不愿意做简单的事情<br>20%的人受成功的人影响——–80%的人受失败人的影响<br>20%的人状态很好————–80%的人态度不好<br>20%的人相信自己会成功————–80%的人不愿改变环境<br>20%的人永远赞美、鼓励————–80%的人永远漫骂、批评<br>20%的人会坚持————–80%的人会放弃</p>\n<h1 id=\"蝴蝶效应\"><a href=\"#蝴蝶效应\" class=\"headerlink\" title=\"蝴蝶效应\"></a>蝴蝶效应</h1><p>先从美国麻省理工学院气象学家洛伦兹（Lorenz）的发现谈起。为了预报天气，他用计算机求解仿真地球大气的13个方程式。为了更细致地考察结果，他把一个中间解取出，提高精度再送回。而当他喝了杯咖啡以后回来再看时竟大吃一惊：本来很小的差异，结果却偏离了十万八千里！计算机没有毛病，于是，洛伦兹（Lorenz）认定，他发现了新的现象：“对初始值的极端不稳定性”，即：“混沌 ”，又称“蝴蝶效应”，亚洲蝴蝶拍拍翅膀，将使美洲几个月后出现比狂风还厉害的龙卷风！这个发现非同小可，以致科学家都不理解，几家科学杂志也都拒登他的文章，认为“违背常理”：相近的初值代入确定的方程，结果也应相近才对，怎幺能大大远离呢！线性，指量与量之间按比例、成直线的关系，在空间和时间上代表规则和光滑的运动；而非线性则指不按比例、不成直线的关系，代表不规则的运动和突变。如问：两个眼睛的视敏度是一个眼睛的几倍？很容易想到的是两倍，可实际是 6－10倍！这就是非线性：1＋1不等于2。激光的生成就是非线性的！当外加电压较小时，激光器犹如普通电灯，光向四面八方散射；而当外加电压达到某一定值时，会突然出现一种全新现象：受激原子好象听到“向右看齐”的命令，发射出相位和方向都一致的单色光，就是激光。非线性的特点是：横断各个专业，渗透各个领域，几乎可以说是：“无处不在时时有。” 如：天体运动存在混沌；电、光与声波的振荡，会突陷混沌；地磁场在400万年间，方向突变16次，也是由于混沌。甚至人类自己，原来都是非线性的：与传统的想法相反，健康人的脑电图和心脏跳动并不是规则的，而是混沌的，混沌正是生命力的表现，混沌系统对外界的刺激反应，比非混沌系统快。由此可见，非线性就在我们身边，躲也躲不掉了。</p>\n<p>1979年12月，洛伦兹（Lorenz）在华盛顿的美国科学促进会的一次讲演中提出：一只蝴蝶在巴西扇动翅膀，有可能会在美国的德克萨斯引起一场龙卷风。他的演讲和结论给人们留下了极其深刻的印象。从此以后，所谓“蝴蝶效应”之说就不胫而走，名声远扬了。 “蝴蝶效应”之所以令人着迷、令人激动、发人深省，不但在于其大胆的想象力和迷人的美学色彩，更在于其深刻的科学内涵和内在的哲学魅力。混沌理论认为在混沌系统中，初始条件的十分微小的变化经过不断放大，对其未来状态会造成极其巨大的差别。</p>\n<p>我们可以用在西方流传的一首民谣对此作形象的说明。这首民谣说：丢失一个钉子，坏了一只蹄铁； 坏了一只蹄铁，折了一匹战马；折了一匹战马，伤了一位骑士；伤了一位骑士，输了一场战斗；输了一场战斗，亡了一个帝国。马蹄铁上一个钉子是否会丢失，本是初始条件的十分微小的变化，但其“长期”效应却是一个帝国存与亡的根本差别。这就是军事和政治领域中的所谓“蝴蝶效应”。有点不可思议，但是确实能够造成这样的恶果。一个明智的领导人一定要防微杜渐，看似一些极微小的事情却有可能造成集体内部的分崩离析，那时岂不是悔之晚矣？横过深谷的吊桥，常从一根细线拴个小石头开始。</p>\n<h1 id=\"蘑菰管理原理\"><a href=\"#蘑菰管理原理\" class=\"headerlink\" title=\"蘑菰管理原理\"></a>蘑菰管理原理</h1><p>蘑菰长在阴暗的角落，得不到阳光，也没有肥料，自生自灭，只有长到足够高的时候才开始被人关注，可此时它自己已经能够接受阳光了。</p>\n<p>蘑菰管理是大多数组织对待初入门者、初学者的一种管理方法。从传统的观念上讲，“蘑菰经历”是一件好事，它是人才蜕壳羽化前的一种磨炼，对人的意志和耐力的培养有促进作用。但用发展的眼光来看，蘑菰管理有着先天的不足：一是太慢，还没等它长高长大恐怕疯长的野草就已经把它盖住了，使它没有成长的机会；二是缺乏主动，有些本来基因较好的蘑菰，一钻出土就碰上了石头，因为得不到帮助，结果胎死腹中。</p>\n<p>让初入门者当上一段时间的“蘑菰”，可以消除他们不切实际的幻想，从而使他们更加接近现实，更实际、更理性地思考问题和处理问题。领导者应当注意的是，这一过程不可过长，时间太长便会使其消极退化乃至枯萎，须知不给阳光不给关爱不仅是任其自生自灭，而且更是对其成长的抑制。如何让他们成功地走过生命中的这一段，尽快吸取经验、成熟起来，这才是领导者所应当考虑的。</p>\n","site":{"data":{}},"excerpt":"<p>管理无处不在，管理就是如何处理人际关系，平衡利益，分配权力的过程。</p>","more":"<h1 id=\"长尾效应\"><a href=\"#长尾效应\" class=\"headerlink\" title=\"长尾效应\"></a>长尾效应</h1><p>长尾效应的根本就是要强调”个性化”,”客户力量”和”小利润大市场”,也就是要赚很少的钱,但是要赚很多人的钱.要将市场细分到很细很小的时候,然后就会发现这些细小市场的累计会带来明显的长尾的效应.以图书为例：Barnes &amp; Noble 的平均上架书目为13万种。而Amazon有超过一半的销售量都来自于在它排行榜上位于13万名开外的图书。如果以Amazon的统计数据为依据的话，这就意味着那些不在一般书店里出售的图书要比那些摆在书店书架上的图书形成的市场更大。也就是说，如果我们能够摆脱资源稀缺的限制，潜在的图书市场将至少是目前的两倍大。曾在音乐行业担任过顾问的风险投资家Kevin Laws 是这样总结这一现象的：“最大的财富孕育自最小的销售。</p>\n<h1 id=\"达维多定律\"><a href=\"#达维多定律\" class=\"headerlink\" title=\"达维多定律\"></a>达维多定律</h1><p>达维多定律是以英特尔公司副总裁达维多的名字命名的。达维多认为，一家企业要在市场中总是占据主导地位，那么它就要永远做到第一个开发出新一代产品，第一个淘汰自己的产品。</p>\n<p>这一定律的基点是着眼于市场开发和利益分割的成效。人们在市场竞争中无时无刻不在抢占先机，因为只有先入市场，才能更容易获得较大的份额和高额的利润。英特尔公司在产品开发和推广上奉行达维多定律，始终是微处理器的开发者和倡导者。他们的产品不一定是性能最好的和速度最快的，但他们一定做到是最新的。为此，他们不惜淘汰自己哪怕是市场上正卖得好的产品。</p>\n<p>达维多定律揭示了以下取得成功的真谛：不断创造新产品，及时淘汰老产品，使新产品尽快进入市场，并以自己成功的产品形成新的市场和产品标准，进而形成大规模生产，取得高额利润。</p>\n<h1 id=\"酒与污水效应\"><a href=\"#酒与污水效应\" class=\"headerlink\" title=\"酒与污水效应\"></a>酒与污水效应</h1><p>如果你把一汤匙的酒倒进一桶污水里，你得到到的是一桶污水；如果你把一汤匙的污水倒进一桶酒里，你得到的还是一桶污水。酒·污水效应对学校管理的启示是：在一些学校中难免碰到个别“污水”式的教师，他们人数虽然很少，但破坏力巨大。为此，学校领导要花费精力处理这类“污水”。</p>\n<p>员工的技术能力和敬业程度是公司顺利发展的保证.<br>员工优劣评比:分ABC(C类即烂苹果员工)三类,表现最差的员工通常都必须走人.<br>对待烂苹果员工的做法: 动作要快,越快越好. 任何组织里，都存在几个难管理的人物，他们像苹果箱里的烂苹果，如果你不及时处理，它会迅速传染，把果箱里其他苹果也弄烂。“烂苹果”的可怕之处在于它那惊人的破坏力。组织系统往往是脆弱的，它是建立在相互理解、妥协和容忍的基础上的，它很容易被侵害、被毒化是因为破坏总比建设容易。“烂苹果”定律告诉我们：对于坏的组员或东西，要在其开始破坏之前及时处理掉。</p>\n<h1 id=\"零和游戏原理\"><a href=\"#零和游戏原理\" class=\"headerlink\" title=\"零和游戏原理\"></a>零和游戏原理</h1><p>当你看到两位对弈者时，你就可以说他们正在玩“零和游戏”。因为在大多数情况下，总会有一个赢，一个输，如果我们把获胜计算为得1分，而输棋为-1分，那么，这两人得分之和就是：1+(-1)=0。这正是“零和游戏”的基本内容：游戏者有输有赢，一方所赢正是另一方所输，游戏的总成绩永远是零。</p>\n<p>零和游戏原理之所以广受关注，主要是因为人们发现在社会的方方面面都能发现与“零和游戏”类似的局面，胜利者的光荣后面往往隐藏着失败者的辛酸和苦涩。从个人到国家，从到经济，似乎无不验证了世界正是一个巨大的“零和游戏”场。这种理论认为，世界是一个封闭的系统，财富、资源、机遇都是有限的，个别人、个别地区和个别国家财富的增加必然意味着对其他人、其他地区和国家的掠夺，这是一个“邪恶进化论”式的弱肉强食的世界。</p>\n<p>但20世纪人类在经历了两次世界大战，经济的高速增长、科技进步、全球化以及日益严重的环境污染之后，“零和游戏”观念正逐渐被“双赢”观念所取代。人们开始认识到“利己”不一定要建立在“损人”的基础上。通过有效合作，皆大欢喜的结局是可能出现的。但从“零和游戏”走向“双赢”，要求各方要有真诚合作的精神和勇气，在合作中不要耍小聪明，不要总想占别人的小便宜，要遵守游戏规则，否则“双赢”的局面就不可能出现，最终吃亏的还是自己</p>\n<h1 id=\"马太效应\"><a href=\"#马太效应\" class=\"headerlink\" title=\"马太效应\"></a>马太效应</h1><p>《圣经》中”马太福音”一章里有一句名言：”凡是有的，还要加给他，叫他有余；没有的，连他所有的也要夺过来。”美国着名哲学家罗帕特·默顿发现了同样的现象，即荣誉越多的科学家，授予他的荣誉就越多；而对那些默默无闻的科学家，对其作出的成绩往往不予承认。他于1973年把这种现象命名为”马太效应”。在班级管理中，就是好学生好对待，差学生差对待，而好与差的标准主要还是学习成绩。对于一些班主任心目中的好学生来说，爱”过剩”的时候，就会贬值，他们对表扬就会变得麻木不仁，认为一切都是理所当然。这种优越的社会心理环境会使他们在成长中变得非常脆弱，经不起挫折。而对另外一些学生仅仅因为分数不高，就会长期处在被班主任的关爱遗忘的角落，这种人为造成的恶劣的心理环境，将会使他们情绪偏激、行为带有触发性和冲动性，这样必然导致学生个性的畸形发展，引发学生的心理障碍。</p>\n<p>马太效应指出学习能力强的学生，发言机会就多，而发言机会愈多能力愈强，学习能力弱者反之，造成优者越优，差者越差，两极分化。在小组合作学习中，我们常碰到这样的情况，能力较高的成员受到尊重，并取得领导地位，甚至抢尽风头或牺牲其它组员的利益来自我获益；而能力较低的成员则完全丧失了合作学习的兴趣。</p>\n<p>社会心理学家认为，“马太效应”是既有消极作用又有积极作用的社会心理现象。其积极作用是：“马太效应”使学习能力强的学生会获得越来越多的荣誉和越来越高的评价，这对小组内表现一般的学生有巨大的吸引力，促使他们去努力，从这个意义上讲，“马太效应”将客观上促使组内竞争的产生，而合作学习并不排斥竞争，这是符合合作学习的精神的。其消极作用是：获得高评价的学生，如果没有清醒的自我认识和没有理智态度容易产生居功自傲、遭小组成员非议等不利合作行为的现象。很显然，如果一味放任小组成员的自发无序地竞争只会导致不均衡的加剧。</p>\n<p>消除合作学习中 “马太效应” 的消极作用，要求我们努力实现评价的社会公平感。“马太效应”的导致学生参与度不均衡的主要原因是学生的个人职责不明确，以及老师只关注小组的学习结果，不注意学习过程和个人的学习进步。所以，在合作学习的评价中，教师不仅要关注学习结果，更要关注学习过程，教师还需要讲究评价策略，做到指导与激励相结合，对不同发展水平的学生有不同的要求，应关注每一位学生，特别是对小组中能力较差的学生更应注意到他们的点滴进步。</p>\n<p>这是一个赢家通吃的时代，在人类资源分配上，出现了极不均匀的状况：富者越富，穷者越穷。圣经里面的《新约.马太福音》<br>成功是成功之母：都说失败是成功之母，这句话是有一定的道理，但不是绝对的，它有一定的适用范围，试想一下，如果你屡屡失败，从未品尝过成功的甜头，你还必胜的信心吗？你还相信失败是成败之母吗？成功有倍增效应，你越成功，你就会越自信，越自信就会使你越容易成功。这个角度来说：“成功是成功之母”。成功和失败也有两极分化的“马太效应”，成功会使你自信，也就越能成功，而失败会使人灰心丧气，离成功也就越来越远了。例如拿破仑一生曾打过100多次胜战，胜利使他坚信自己会所向披靡，而且，也使敌人闻风丧胆。<br>当然，提倡“成功是成功之母”，并不反对人们从失败中学习。失败是成败之母对于抗挫折能力强的成年人来说，可能是正确的，但对于心智尚未成熟，意志还很脆弱的中小学生来说，未必适用。对于中小学生而言，成功是成功之母可能更适合他们的发展。当一名学生取得成功后，因成功而酿造出的自信心，会促使她取得更好的成绩，随送新成绩的取得，心理因素再次得到优化，从而形成了一个不断发展的良性循环，让他获得不断的成功。通过体验成功，学生将产生积极向上的心态，并提高学习的效率，具有了更大的发展潜力。这就是教育领域的灵活运用。<br>决定一个人身份和地位的并不一定是他的才能和价值，有时候是他的背景和他所代表的组织或是代表的群体，若能使用这些隐藏的资源，它将使你的价值增值。<br>永远领先半步”，“一步领先，步步领先“是美国甲骨文软件公司为提升企业文化，增强企业核心竞争力而恪守的经营理念。甲骨文软件公司的经营理念包括市场敏感度领先，销售策略领先，服务超前，规模超前等。在开拓新市场时总是领先市场，领先竞争对手半步，而这半步就是人们所说的领先市场和引导消费，一位高层员工透露：“别人软件没有上市计划，甚至还在开发的时候，我们的软件就已经上市了，但我们通常只比别人提前1个月的时间”。<br>由于商业活动中以稀为奇，以少为贵的现象越来越突出，所以要想超出众人，领先半步，就得在稀奇，独特上下功夫，打注意，做文章，见人所未见，为人所未为，才能出奇制胜，步步为赢。<br>木桶法则<br>木桶法则的意思是：一只沿口不齐的木桶，它盛水的多少，不在于木桶上那块最长的木板，而在于木桶上最短的那块木板。要想多盛水——提高木桶的整体效应，不是去增加最长的那块木板的长度，而是要下功夫依次补齐木桶上最短的那块木板。<br>木桶法则告诉管理者：在管理过程中要下功夫狠抓薄弱环节，否则，单位的整体工作就会受到影响。人们常说“取长补短”，即取长的目的是为了补短，只取长不补短，就很难提高工作的整体效应。</p>\n<h1 id=\"位差效应\"><a href=\"#位差效应\" class=\"headerlink\" title=\"位差效应\"></a>位差效应</h1><p>来自领导层的信息只有20%-25%被下级知道并正确理解,而从下到上反馈的信息则不超过10%,平行交流的效率可达到90%以上.(代表:美国沃尔玛公司—平等的沟通精神,让沟通无处不在)</p>\n<p>对待员工和蔼,交流时他会竭尽所能让你将话说出来.<br>鼓励中级员工之间加强沟通与合作.<br>要求所有的员工极为公司的发展提出新的构想.(每周开展讨论会,并颁发相应的奖励)<br>人心不是唠叨所能改变的(要知道唠叨不是一种有效的交流手段,相反只会引起员工的发感)<br>每个企业的正常运转都依靠严格的等级制度来保障.但不能管理者的姿态对待员工,认员工敢于直面总裁.如果一个管理者只会趾高气扬,执意显示自己的地位与身份,那么,他的管理定是失败的<br>只有让每一位员工都感到自己是公司平等的一员,才能让他们的意见的建议毫无保留的表达出来.<br>一个不称职的官员,可能有三条出路:第一是申请退职,把位子让给能干的人,第二是让一位能干的人为协助自己的工作,第三是任用两个(两个以上,才能起到互相牵制的作用)水平比自己更低的人当助手,如此必然导致机构人员膨胀而效率低下.</p>\n<h1 id=\"帕金森定律\"><a href=\"#帕金森定律\" class=\"headerlink\" title=\"帕金森定律\"></a>帕金森定律</h1><p>英国着名历史学家诺斯古德·帕金森通过长期调查研究，写出一本名叫《帕金森定律》的书。他在书中阐述了机构人员膨胀的原因及后果：一个不称职的官员，可能有三条出路，第一是申请退职，把位子让给能干的人；第二是让一位能干的人来协助自己工作；第三是任用两个水平比自己更低的人当助手。这第一条路是万万走不得的，因为那样会丧失许多权利；第二条路也不能走，因为那个能干的人会成为自己的对手；看来只有第三条路最适宜。于是，两个平庸的助手分担了他的工作，他自己则高高在上发号施令，他们不会对自己的权利构成威胁。两个助手既然无能，他们就上行下效，再为自己找两个更加无能的助手。如此类推，就形成了一个机构臃肿，人浮于事，相互扯皮，效率低下的领导体系。</p>\n<p>高级官员感到无聊乏味,中级人员忙于勾心斗角,低给人员则灰心丧气.<br>权力的危机感是产生帕金森效应的直接原因.<br>最需要注意的就是,不要将用人权放在一个被招聘者的直接上司手里.<br>华盛顿合作定律<br>在角色群体的活动效率中，既可能产生增力作用，也可能导致减力作用。 “三个臭皮匠，凑成一个诸葛亮”，这种情况下“1+1+l”大于3。这在群体成员活动的效率角度上，称之为“群体的增力作用”。 “三个和尚没水喝”，这种情况下的“1+1+1”却等于0了。这在群体成员活动的效率角度上，称之为“群体的减力作用”。</p>\n<p>人与人的合作,不是人力的简单相加,而远比这复杂和微妙得多.<br>在一个集体中,大多数都采取观望态度(旁观都效应),而产生这类现象的根本原因则是责任不明确.<br>能力相等的人一起合作,只有合理的分工合作,才会有辉煌的成果,把每一个人放在最为合适的位置.同时要考虑到该人的优点和缺点及员工之间的相互配合.<br>人与人之间的合作,经常会出现彼此之间的排斥的妒嫉心理.多个优秀的人同时一起工作，通常不能顺利的完成工作。通常将其中的一些人调离到新的岗位，其表现也将是惊人的。<br>员工之间的分工合作是必需的，<br>邦尼人力定律：一个人一分钟可以挖一个洞，六十个人一秒种却挖不了一个洞。<br>责任保证绩效。责任与绩效之间的关系应该是成正比的，但明确责任，是提高工作绩效的前提，一个企业一定要有明确的责任体系，权责不明不仅不会出现责任真空，而且还容易导致员工之间互相推诿，把自己置于责任之外，明确的责任体系，是让每一个人都清楚自己要做什么，应该怎么做。这们团队中的成员对自己的任务就是责无旁贷的。</p>\n<h1 id=\"马蝇效应\"><a href=\"#马蝇效应\" class=\"headerlink\" title=\"马蝇效应\"></a>马蝇效应</h1><p>再懒惰的马，只要身上有马蝇叮咬，它也会精神抖擞，飞快奔跑。</p>\n<p>不言面喻，一个企业的发展，需要竞争对手的时时叮咬，方能保持旺盛的势头让自己强大起来。<br>企业能够发展壮大，应该感谢对手时时施加的压力，正是这些压力，化为想方设法战胜困难的动力，进而在残酷的市场竞争中，始终保持着一种危机感。</p>\n<p>无独有偶，在美国费城西部，有两个敌对的商店，一个A商店，一个中B商店，两个商店是隔壁邻居，店老板是死对手，他们之间经常展开价格竞争。当A商店在窗口挂出床单6.5元时，B商店则会出现5.9元的标价，此外，他们还常走出商店，相互咒骂，甚至大打出手，最终他们中间一个人会在竞争的退出，宣称另一个店老板是疯子，在他那里买东西的人都是疯子。于是人们便纷纷路到竞争获胜的商店买完所有的床单，在这一带由于他们的不断竞争,人们买到了各种自认为物美价谦的商品。说来有趣，有一天，他们中间的一位老板去世了，而几天后，另一位老板就进行了清仓大展销，然后搬了，人们再也没看见他，这是为什么呢？当房子的新主人进行大清理时发现了其中的秘密，原来，两位老板的住房有一个通道，他们的住房就在商店上面，后来经进一步核查，这两位老板竞是同胞兄弟。</p>\n<p>原来所有的咒骂、恐吓和其他人身攻击都是在演戏，所有的价格竞争都是骗人的，谁获得胜利，谁就把俩人的商品一起抛出去，就这样他们的骗局维持了30年之久，未被他人发现。直到其中一个死去才真相大白。保持必要的竞争是企业成长和发展的动力，哪怕是一种竞争假象，也会形成一种良好的氛围，这是一种生存的智慧，也是事业保持快速发展的有效之道。</p>\n<p>在“刺头”身上放几个“马蝇”。几乎在每一个企业里都有某一些人拥有在某一方面不可替代的资源（如背景）或聪明，好动，上进心强，是某一方面或某几方面的专家，在此他们充满创新精神。对成功以及成相关的东西（金钱，权力，职位等）具有极其浓厚的兴趣，他们不会行规蹈矩，也不会轻易被权威所折服，更让人头痛的是，这些人不但在专业上有一套，往往在组织内的“兴风作浪上也很有一套。仔细分析一下我们就可以发现，这些人有一个共同的特点：那就是他们不会轻易被满足，他们具有强烈的占有欲。由于不会轻易满足，所以他们才会表现得与众不同，因为他们需要给领导留下更深刻的印象，因为他们希望由此而得到更鑫的满足。因为他们身叮着有刺激他们积极进取的“马蝇”，对于那些有优势的员工来说，他们并不畏惧更高的目标，更大的工作范畴，更有难度的任务，他们往往希望通过挑战这些来显示自己超人一等的能力及在公司里无可替代的地位，以便赢得更多的尊重。这就是叮在他们身上的“马蝇”。</p>\n<p>因此，谨慎地做好他们的工作是提升管理绩效的关键。以下几个方面的问题值得仔细关注的：</p>\n<p>如果你是一个善于辞令，善于捕捉他人心理的管理者，你可以度着找他们谈谈心，做做思想工作。<br>行动永远比语言更有说服力，在巧妙运用你的权利资本时，为这些高傲的家伙树立一个曲范，让他们看看一个有权威的人是怎么处理问题，实现团队目标的。<br>这些家伙往往好胜自负，进取心强，在委派任务的时候，最好用一句简洁有力，但颇能刺激他神经的话来结束：这个任务对你来说有困难吗？在得到他不服气或略带轻蔑的回答后，便可结束了，如果太多叮嘱和干预，只会引起这种人的反感和烦燥，甚至使他地于任务本身和你这个管理者更加不屑一顾。<br>运用你的智慧和鼓动力，在工作时有意的对此类员工进行一些“冷处理”，让他体会到个人的力量与团队的力量相比，是微不足道的，然后，在适当的时候鼓励其发挥专长，保全他的面子和自尊。<br>制度面前人人平等，从一开始就不要给这样的员工以任何错觉，不要让他们误以为自己有某些优势，就可以凌驾于制度之上，这点是长期驾驭这类人的关键，一定要坚持下来。<br>在对于想跳槽的员工，应注意：1，不要为了留住某些人轻易做出很难实现的承诺。2，如果有过承诺，一定要兑现，如果无法兑现，一定要给他们一个正面的说法，不能在员工面前扮演一个言而无信的管理者角色，那样只会为将来的动荡埋下隐患。<br>及时发现员工的情绪波动，特别是那些业务骨干，一定要把安抚民心做在前头，虽说亡羊补牢，为时未晚，但把预警工作做在前头，是不是可以避免一些不必要的损失呢？<br>如果员工去意已定，那么你不要太过勉强，应该善始善终，好说好散，在有必要的时候，可心请他们提前离开，重要的在于不要让某些人的“离去”变成有针对性，有目的性的挑衅，造成全公司员工的大面积情绪波动。<br>随时检讨公司晋升，薪酬，绩效考核等人力资源管理制度是否合理，避免因制度性原因而造成员工非正常性流<br>攻心为上，以理服人，以情动人。方为上策。<br>例外原则</p>\n<p>为了提高效率和控制大局，上级只保留处理例外和非常规事件的决定权和控制权，例行和常规的权力由部下分享。（一把抓的控制方式是一种错误的模式）</p>\n<p>管理的密决在于合理地授权。所谓授权，就是指为帮助下属完成任务，领导者将所属权力的一部分与其相应的责任授予下属。使领导能做领导的事，下属能做下属的事，这就是授权所应达到的目的。合理地授权可以使领导者摆脱能够由下属完成的日常任务，自已专心处理重大决策问题，还有助于培养下属的工作能力，有利于提高士气，授权是否合理是区分领导者才能高低的重要标志。正如韩非子所说的那样“下者尽已之能，中群尽人之力，上君尽人之智”，领导者做为“上君”，负责最高层的决策。就必须对下属进行合理的授权。<br>授权可以让未来规模更大的企业仍然保持小企业的活力，同时也可以为公司培养出发展所必需的大批出色的经营管理人才。<br>许多管理者都知道授权的重要性，但他们却总埋怨手下没有可以委托的人，须知才干是在实践中增长的，你总是不敢把艰难的工作交给下属，他们就永远没有显示才干或得不到提高的机会。正如你总是不敢孩子下地，他就永远也学不会走路。<br>授权与单纯的分派任务是不同的，分派任务是让下属照你的吩咐去做，他是被动的，而授权则是把整个事情委托给他，同时交付足够的权力让他做必要的决定。这有助于增长他的荣誉，使他有成就感。<br>适当放权既能给下属留下发展自已的空间，又能使管理者抽出更多的时间去督导员工工作，提高整个团队的工作效率也就顺理成章了。<br>授权并非一蹴而成，不能说一句“这件事交给你就以为完成了授权，授权一事需要授权者和被授权者双方密切的合作，彼此态诚恳，相互沟通了解。在授权的时候，授权者必须有心理准备，明确授予下属完成任务所必须的权力和责任。使他完全理解自己的任务，权力和责任。做到这一点后，就要让授任者依他自已的方式处理事情，不要随意干涉，并且随时给予支持，扶助，合理地授权并非对下属放任自流，撒手不管。授权者要保留监督的权利，在受权者出现不可原谅的错误时，随时取消他的受权资格。<br>合理的授权，有利于调动下属在工作中的积极性，主动性和创造性。激发下属工作情绪，增长其才干，使上级领导的思想意图为群体成员所接受。<br>授权可以发现人才，利用人才，锻炼人才，使企业的工作出现一个朝气蓬勃，生龙活虎的局面。<br>如果你想让下属有出色的表现，，你必须学会为他们“搭舞台”，在必要的时候，给他们提供一定的财力，物力，人力，让他们全身心地投入到工作中，而不会因此分散他们的精力，让他们产生顾虑。<br>管理学之父泰罗提倡领导者要学会合理的授权，尤其是要学会在遇到自已懂的知识时，，将决策权交给别人<br>授权的原则：<br>握大权，授小权（将一些繁重的，琐碎的事务性工作交由下属处理，自已保留例外事件和非常事件的决定权和控制权）〕<br>因事择人，视德才授权（泰罗授权理论中最为基本的准则就是因事择人，视德才授权，授权不是利益的分配，更不荣誉的照顾，而是为了将工作做得更出色的一种用人策略，所以应考虑用人更佳性。选择最适的人当受权人）。<br>先放后收。不要将一种权力无限度地授予下属。而要适时地加以控制或是回收，这可能会导致上下级之间脱节，从而让自已的下属处于“权力真空”的状态。相反，如若能时时监督下属的权力应用。<br>不越级授权。在企业中，主要实行的是领导负责制，这种体制具有明显的层次性。所以在授权下属权力时，一定要掌握尺度，不要越级授权，而要逐级进行，否则只会引起各级下属之间不必要的误解和职责的混乱。<br>有效的反馈。对于下属的工作表现的评价，不能太主观意断，而要有说服力，这就要求领导者在授权后，要与下属保持畅通的反馈的渠道。当你将一项权力授予下属，而他将一件工作完成的非常糟糕进，或许事情还不至于糟到无法挽回的地步，但更糟糕的是，你没有补救的办法，下属需要及时的反馈工作的进展情况，而你更需要向下属传授工作的改进之处。<br>全局性。一位领导要授权下属以不同的权力，在授权后，你要有足够的时间与精力把握一些全局性的工作，高明的领导在全局统筹的时候，善于采用纵向画线与横向划格的管理模式来实现组织控制。纵向画线是指界定各个部门对上，对下的权限，横向划格是指界定下级各部门之间的权限。这样既有利于下级充分利用自已的权力施展自已的才华，又不至于各部门成为有服从指挥的独立王国，从而有助于从整体上进行把握与协调。</p>\n<h1 id=\"鲇鱼效应\"><a href=\"#鲇鱼效应\" class=\"headerlink\" title=\"鲇鱼效应\"></a>鲇鱼效应</h1><p>一种动物如果没有对手，就会变得死所沉沉，同样一个人如果没有对手，那他就会甘于庸，养成惰性，最终导致庸碌无为。<br>招聘应届毕业生做为鲇鱼员工，因为应届毕业生给企业带来了鲶鱼效应，增强了整个团队的竞争意识和危机意识，从而制造出一种紧张气氛，使全休员工更加勤奋地工作，促使企业的竞争力不断的提升。<br>一个单位或部门，如果人员长期固定，彼此太熟悉，就容易产生惰性，削弱组织的活力，若从外部引进“鲇鱼”，他们能以崭新的面貌对原有部门产生强烈的冲击。他们能很好的刺激其他员工的竞争意识，克服员工安于现状，不思进取的惰性。<br>有意识地引入一些“鲇鱼”，通过他们挑战性的工作来打破昔日的平静，不仅可心激活整个团体，还能有效地解决原有员工知识不足的缺陷。<br>给自己找个对手：许多人都把对手视为心腹大患，是异已，是眼中钉，肉中刺，恨不得马上除之而后快，其实，能有一个强而有力的对手，反而是一种福气，一种造化，因为一个强而有力的对手会让你时刻都有危机感，会激发你更加旺盛的精神和斗志。<br>利用“鲇鱼效应”时， 要把握好尺度。“引起一个，带动一片”这种鲇鱼效应的应用是有条件的，要经过科学的评估和精心的安排，若不能将“鲇鱼效应”放在整个人力资源开发之中加以全盘考虑，就会适得其反，酿成“鲇鱼负效应”这很有可能会产生窝里斗的情况，不难看出，这种效应发挥作用的前提是出现了员工不思进取的现象。假如你所在的部门已经形成了龙腾上虎跃，锐意进取的气氛了，若仍坚持引进超量的“鲇鱼”，可能就会一些本来可以进取的“沙丁鱼”看不到希望而开熘，也可能会引发内讧，以至效率低下。<br>拿破仑曾经说过：狮子率领的兔子军，要远比兔子率领的狮子军做战能力强，这一句话一方面说明了首领的重要性，另一方面还说明这样一个道理：智慧和能力相当的人不能扎堆，能人扎堆对企业发展不利。在人力资源的配置方面，配置恬当，会出现一加一大于二，大于三，可能等于五，配置不当，人员失和，一加一可能等于零，也有可能成负数。<br>很多公司在内部出现职位空缺时，往往第一时间会猎头公司是，认为“外来的和尚好念经”却忽视了公司内部的人才，不予挖掘和起用，结果造成了很多企业精英的流失的管理事故。因此，适量引进“外业和尚好念经”，同时也让“庙里和尚会念经”，内外结合，形成有序的人才竞争机制，如此一来，组织就会更加有活力。</p>\n<h1 id=\"王安定论\"><a href=\"#王安定论\" class=\"headerlink\" title=\"王安定论\"></a>王安定论</h1><p>在信息社会里, 随着全传播渠道的发达,信息传递的速度大大提高,谁能以最快的反应把握商机,谁就能立于不败之地,速度就是效率!<br>现代社会是一个信息社会,信息传播的速度大大地提高了,,信息的快速传递缩短了空间距离,把世界各地的市场信息紧紧地联系在一起,信息是机会,就是财富,但是信息所提供的机会是稍纵即逝的,谁能快速拿捏,谁能把握市场供需,谁就能获得财富,也就能成为时代的佼佼者.对此,美藉华裔企业家王安博士提出了有名的”王安论断”,他认为要在信息万变的时代中力争上游,就要在速度上下功夫,惟有速度提高了,效率才能得到提升,王安论断一再被实践验证,具有极大的合理性.<br>王安儿时的一个故事：一天小王安遇见一只流浪的猫咪，决定收养它，可他不敢，怕妈妈反对，于是他回家先征求了妈妈的同意，可回到遇到猫咪的地方时，发现小猫已经饿死了。这次的事对小王安的影响非常的大，他知道凡事只要作了决定就得马上行动，效率才是第一的要务。<br>善于王安论断的理化内涵，我们会在任何时候都快人一步，人们常说“一步领先，步步领先，一步落后，步步落后”，因此，培养和树立超前意识，具备前瞻眼光，对于提高行事速度就显得极为重要了。<br>所谓前瞻眼光和超前意识，体现在三个方面：<br>在动态中准确地预见事物的发展趋势。<br>在静态中及时预见事的产生的变化。<br>在平平常常的工作，生活，学习以及友好往来中善于发现不显眼的契机，并预见到它蕴含的价值和意义，从而牢牢地抓住它，充分发展自己。</p>\n<h1 id=\"史密斯法则\"><a href=\"#史密斯法则\" class=\"headerlink\" title=\"史密斯法则\"></a>史密斯法则</h1><p>珍惜每一分钟，最大化时间的价值，几乎是每一位成功者必修的一课，学会有机管理时间，才能保证做事的效率，提高生活的质量。<br>神奇的三小时，人们早睡早起，这样可以比别人更早展开新的一天，在时间上就能跑在别人的前面，在这三小时（5-8点），你可不受任何人和事干扰做一些自己想做的事，且必须得讲求恒心，判养成早睡早起的习惯，以后你会受益无穷<br>疲劳常常只是厌倦的结果，要消除这种疲劳，停止工作是不行，必须变换工作，一个人要是能做一种以上的事，他会活得更有劲，闲暇对于智者来说是思考，对于享受者来说是养尊，对于愚者来说是虚度。</p>\n<h1 id=\"吉德拉法则\"><a href=\"#吉德拉法则\" class=\"headerlink\" title=\"吉德拉法则\"></a>吉德拉法则</h1><p>任何企业，如果想求生存，求发展，就必须既有效率，又有效益，当效益无法保证时，就要举起改革的斧子。<br>20世纪时，在意大利国际市场疲软，在意大利本国工资升高，物价上涨等情况的冲击下，再加上公司内部出现了管理问题，菲亚特汽车公司经历了历史上最不塂回首的日子，公司连年亏损，在世界汽车生产商的排名榜上接连下跌。在此，一个面临倒闭的企业，如果只是寄希望于对原有体制，管理方式进行修修补补，是无济无事的，要从根本上焕发企业的活力，提升企业的效率，增强企业的效率，增强企业的竞争力，就必须进行深刻的改革。正如吉德拉所说的：“凡是没有必要的，就把它摒弃”。<br>用人贵精：在管理上，并不是人多就好，有时管理人员越多，工作效率反而越差，只有找到最合适的人数，管理才能收到最好的效果。在一个公司中，吸有每个部门都真正达到了人员的最佳数量，才能最大阴谋的减少无用的工作时间，降低工作成本，从而达到企业利益的最大化。企业的庞杂，人员设置不合理等现象，会使企业官僚之风盛行，人浮于事，从而导致企业工作效率低下，需设法用最少的人做最多的事，极力减少成本，追求效益最大化。<br>精简的机构和人员是企业良好运行的根本，与大多数企业不同，沃尔玛在遇到麻烦时，不是采取增加机构和人员的办法来解决问题，相反，而是追本溯源，解聘失职人和精简相关机构。沃尔玛认为，只有这样才能有效的避免机构臃肿。<br>企业竞争力的来源在于用最少的人做最多的事。只有机构精简，人员精干，企业才能保持永久的活力，才能在激烈的竞争中立于不败之地。<br>要运好吉德拉法则，就需要我们培养一种果断决策的能力，切忌遇事举棋不定，优柔寡断，坚决果断的个性品质，无疑是决策者必备的素质。遇事举棋不定，犹豫不决，经常彷徨，不知所措的人，是那些没有主意，不能决择，依赖别人的人，这种主意不定，自信不坚的人，也难于得到别人的信任。<br>多米诺效应<br>一荣难俱荣，一损易俱损；在一个相互联系的系统中，一个很小的初始能量就可能产生一连串的连锁反应，人们就把它们称为“多米诺骨牌效应”或“多米诺效应”。</p>\n<h1 id=\"手表定理\"><a href=\"#手表定理\" class=\"headerlink\" title=\"手表定理\"></a>手表定理</h1><p>手表定理是指一个人有一只表时，可以知道现在是几点钟，而当他同时拥有两只表时却无法确定。两只表并不能告诉一个人更准确的时间，反而会让看表的人 失去对 准确时间的信心。你要做的就是选择其中较信赖的一只，尽力校准它，并以此作为你的标准，听从它的指引行事。记住尼采的话： ” 兄弟，如果你是幸运的，你只需有一种道德而不要贪多，这样，你过桥更容易些。 ”如果每个人都 ” 选择你所爱，爱你所选择 ” ，无论成败都可以心安理得。然而，困扰很多人的是：他们被 ” 两只表 ” 弄得无所，心身交瘁，不知自己该信仰哪一个，还有人在环境、他人的压力下，违心选择了自己并不喜欢的道路，为此而郁郁终生，即使取得了受人瞩目的成就，也 体会不到成功的快乐。</p>\n<p>手表定理在企业经营管理方面给我们一种非常直观的启发，就是对同一个人或同一个组织的管理不能同时采用两种不同的方法，不能同时设置两个不同的目 标。甚至 每一个人不能由两个人来同时指挥，否则将使这个企业或这个人无所适从。手表定理所指的另一层含义在于每个人都不能同时挑选两种不同的价值观，否则，你的行 为将陷于混乱。</p>\n<h1 id=\"彼得原理\"><a href=\"#彼得原理\" class=\"headerlink\" title=\"彼得原理\"></a>彼得原理</h1><p>彼得原理是美国学者劳伦斯彼得在对组织中人员晋升的相关现象研究后得出的一个结论；在各种组织中，由于习惯于对在某个等级上称职的人员进行晋升提拔，因而雇员总是趋向于晋升到其不称职的地位。彼得原理有时也被称为 ” 向上爬 ” 原理。这种现象在现实生活中无处不在：一名称职的教授被提升为大学校长后无法胜任；一个优秀的运动员被提升为主管体育的官员，而无所作为。</p>\n<p>对一个组织而言，一旦组织中的相当部分人员被推到了其不称职的级别，就会造成组织的人浮于事，效率低下，导致平庸者出人头地，发展停滞。因此，这就 要求改 变单纯的 ” 根据贡献决定晋升 ” 的企业员工晋升机制，不能因某个人在某一个岗位级别上干得很出色，就推断此人一定能够胜任更高一级的职务。要建立科学、合理的人员选聘机制，客观评价每一 位职工的能力和水平，将职工安排到其可以胜任的岗位。不要把岗位晋升当成对职工的主要奖励方式，应建立更有效的奖励机制，更多地以加薪、休假等方式作为奖 励手段。有时将一名职工晋升到一个其无法很好发挥才能的岗位，不仅不是对职工的奖励，反而使职工无法很好发挥才能，也给企业带来损失。</p>\n<p>对个人而言，虽然我们每个人都期待着不停地升职，但不要将往上爬作为自己的惟一动力。与其在一个无法完全胜任的岗位勉力支撑、无所适从，还不如找一个自己能游刃有余的岗位好好发挥自己的专长。</p>\n<p>鳄鱼法则<br>鳄鱼法则：其原意是假定一只鳄鱼咬住你的脚，如果你用手去试图挣脱你的脚，鳄鱼便会同时咬住你的脚与手。你愈挣扎，就被咬住得越多。所以，万一鳄鱼咬住你的脚，你唯一的办法就是牺牲一只脚。</p>\n<p>譬如在股市中，鳄鱼法则就是：当你发现自己的交易背离了市场的方向，必须立即止损，不得有任何延误，不得存有任何侥幸。</p>\n<h1 id=\"二八定律\"><a href=\"#二八定律\" class=\"headerlink\" title=\"二八定律\"></a>二八定律</h1><p>二八定律(巴莱多定律)：19世纪末20世纪初意大利的经济学家巴莱多认为，在任何一组东西中，最重要的只占其中一小部分，约20%，其余80%尽管是多数，却是次要的。 社会约80%的财富集中在20%的人手里，而80%的人只拥有20%的社会财富。这种统计的不平衡性在社会、经济及生活中无处不在，这就是二八法则。</p>\n<p>二八法则告诉我们，不要平均地分析、处理和看待问题，企业经营和管理中要抓住关键的少数;要找出那些能给企业带来80%利润、总量却仅占20%的关键客户，加强服务，达到事半功倍的效果;企业领导人要对工作认真分类分析，要把主要精力花在解决主要问题、抓主要项目上。</p>\n<p>20%的人成功——————80%的人不成功<br>20%的人用脖子以上赚钱——–80%的人脖子以下赚钱<br>20%的人正面思考————–80%的人负面思考<br>20%的人买时间—————-80%的人卖时间<br>20%的人找一个好员工———-80%的人找一份好工作<br>20%的人支配别人————–80%的人受人支配<br>20%的人做事业—————-80%的人做事情<br>20%的人重视经验————–80%的人重视学历<br>20%的人认为行动才有结果——80%的人认为知识就是力量<br>20%的人我要怎么做才有钱——80%的人我要有钱我就怎么做<br>20%的人计划未来————–80%的人早上起来才想今天干嘛<br>20%的人按成功经验行事——–80%的人按自己的意愿行事<br>20%的人做简单的事情———-80%的人不愿意做简单的事情<br>20%的人受成功的人影响——–80%的人受失败人的影响<br>20%的人状态很好————–80%的人态度不好<br>20%的人相信自己会成功————–80%的人不愿改变环境<br>20%的人永远赞美、鼓励————–80%的人永远漫骂、批评<br>20%的人会坚持————–80%的人会放弃</p>\n<h1 id=\"蝴蝶效应\"><a href=\"#蝴蝶效应\" class=\"headerlink\" title=\"蝴蝶效应\"></a>蝴蝶效应</h1><p>先从美国麻省理工学院气象学家洛伦兹（Lorenz）的发现谈起。为了预报天气，他用计算机求解仿真地球大气的13个方程式。为了更细致地考察结果，他把一个中间解取出，提高精度再送回。而当他喝了杯咖啡以后回来再看时竟大吃一惊：本来很小的差异，结果却偏离了十万八千里！计算机没有毛病，于是，洛伦兹（Lorenz）认定，他发现了新的现象：“对初始值的极端不稳定性”，即：“混沌 ”，又称“蝴蝶效应”，亚洲蝴蝶拍拍翅膀，将使美洲几个月后出现比狂风还厉害的龙卷风！这个发现非同小可，以致科学家都不理解，几家科学杂志也都拒登他的文章，认为“违背常理”：相近的初值代入确定的方程，结果也应相近才对，怎幺能大大远离呢！线性，指量与量之间按比例、成直线的关系，在空间和时间上代表规则和光滑的运动；而非线性则指不按比例、不成直线的关系，代表不规则的运动和突变。如问：两个眼睛的视敏度是一个眼睛的几倍？很容易想到的是两倍，可实际是 6－10倍！这就是非线性：1＋1不等于2。激光的生成就是非线性的！当外加电压较小时，激光器犹如普通电灯，光向四面八方散射；而当外加电压达到某一定值时，会突然出现一种全新现象：受激原子好象听到“向右看齐”的命令，发射出相位和方向都一致的单色光，就是激光。非线性的特点是：横断各个专业，渗透各个领域，几乎可以说是：“无处不在时时有。” 如：天体运动存在混沌；电、光与声波的振荡，会突陷混沌；地磁场在400万年间，方向突变16次，也是由于混沌。甚至人类自己，原来都是非线性的：与传统的想法相反，健康人的脑电图和心脏跳动并不是规则的，而是混沌的，混沌正是生命力的表现，混沌系统对外界的刺激反应，比非混沌系统快。由此可见，非线性就在我们身边，躲也躲不掉了。</p>\n<p>1979年12月，洛伦兹（Lorenz）在华盛顿的美国科学促进会的一次讲演中提出：一只蝴蝶在巴西扇动翅膀，有可能会在美国的德克萨斯引起一场龙卷风。他的演讲和结论给人们留下了极其深刻的印象。从此以后，所谓“蝴蝶效应”之说就不胫而走，名声远扬了。 “蝴蝶效应”之所以令人着迷、令人激动、发人深省，不但在于其大胆的想象力和迷人的美学色彩，更在于其深刻的科学内涵和内在的哲学魅力。混沌理论认为在混沌系统中，初始条件的十分微小的变化经过不断放大，对其未来状态会造成极其巨大的差别。</p>\n<p>我们可以用在西方流传的一首民谣对此作形象的说明。这首民谣说：丢失一个钉子，坏了一只蹄铁； 坏了一只蹄铁，折了一匹战马；折了一匹战马，伤了一位骑士；伤了一位骑士，输了一场战斗；输了一场战斗，亡了一个帝国。马蹄铁上一个钉子是否会丢失，本是初始条件的十分微小的变化，但其“长期”效应却是一个帝国存与亡的根本差别。这就是军事和政治领域中的所谓“蝴蝶效应”。有点不可思议，但是确实能够造成这样的恶果。一个明智的领导人一定要防微杜渐，看似一些极微小的事情却有可能造成集体内部的分崩离析，那时岂不是悔之晚矣？横过深谷的吊桥，常从一根细线拴个小石头开始。</p>\n<h1 id=\"蘑菰管理原理\"><a href=\"#蘑菰管理原理\" class=\"headerlink\" title=\"蘑菰管理原理\"></a>蘑菰管理原理</h1><p>蘑菰长在阴暗的角落，得不到阳光，也没有肥料，自生自灭，只有长到足够高的时候才开始被人关注，可此时它自己已经能够接受阳光了。</p>\n<p>蘑菰管理是大多数组织对待初入门者、初学者的一种管理方法。从传统的观念上讲，“蘑菰经历”是一件好事，它是人才蜕壳羽化前的一种磨炼，对人的意志和耐力的培养有促进作用。但用发展的眼光来看，蘑菰管理有着先天的不足：一是太慢，还没等它长高长大恐怕疯长的野草就已经把它盖住了，使它没有成长的机会；二是缺乏主动，有些本来基因较好的蘑菰，一钻出土就碰上了石头，因为得不到帮助，结果胎死腹中。</p>\n<p>让初入门者当上一段时间的“蘑菰”，可以消除他们不切实际的幻想，从而使他们更加接近现实，更实际、更理性地思考问题和处理问题。领导者应当注意的是，这一过程不可过长，时间太长便会使其消极退化乃至枯萎，须知不给阳光不给关爱不仅是任其自生自灭，而且更是对其成长的抑制。如何让他们成功地走过生命中的这一段，尽快吸取经验、成熟起来，这才是领导者所应当考虑的。</p>"},{"title":"shell 学习笔记","date":"2020-01-30T04:14:26.000Z","_content":"\n关于shell使用的一些基本知识和实践，持续更新。\n<!-- more -->\n\n- #! 是一种约定的写法，指示使用何种解释器；\n- 为什么使用./xx.sh的方式执行shell文件？\n./xx.sh 指定目录会让系统从指定的目录寻找可以执行的文件。如果是xx.sh，系统会从PATH中寻找可执行文件；\n```shell\n文件查找在很多系统中有存在，可以对比理解：\n    1 npm的路径寻找过程\n    2 java中class loader的依赖查找\n```\n- 反引号 和 $() 可以表示命令替换\n```shell\nNPM_LOC_1=`which npm`\nNPM_LOC_2=$(which npm)\n\nif [ $NPM_LOC_1 = $NPM_LOC_1 ]; then\n    echo \"相同\"\nfi\n```\n\n- = 之后有空格，可以表示命令替换\n```shell\na= ls ./\necho \"$a\"\n```\n- 运算符和操作数之间要有空格\n- 一般性输出使用echo，需要一定格式的可以使用printf\n- 特殊符号\n    - $#\n    - $@\n    - $*\n- 注释\n    - 单行注释 \n    ```shell\n     # 这是注释\n    ```\n    - 多行注释\n    ```shell\n    # 这是注释\n    # 这是注释\n    # 这是注释\n\n    :<<EOF\n    这是注释\n    这是注释\n    这是注释\n    EOF\n\n    ```\n- 变量\n    - 合法的变量名，数字，字母，下划线，不能以数字开头;\n    - 变量名和=之间不能有空格;\n    ```shell\n    name=`123`\n    echo ${name}\n    ```\n    - 类型：字符串, 数字, 数组\n    ```shell\n    name='test'\n    echo ${name}\n    name=1\n    echo ${name}\n    ```\n    - 变量使用，使用${变量名}，花括号可以省略，最佳实践是不要去掉花花括号；\n    - 使用readonly可以定义只读变量\n    - 删除变量\n    - 变量作用域\n        - 局部变量\n        - 环境变量\n        - shell 变量\n\n    - 字符串\n        - 单引号和双引号的区别：单引号内都是字符串，双引号内可以包括变量的引用和转义字符\n        - 拼接\n        ```\n        name1='I love '\n        name2='shell'\n        echo ${name1} ${name2} \n        ```\n        - 长度\n        ```\n        name='I love shell!'\n        echo ${#name}\n        ```\n        - 子串\n        ```\n        name='I love shell!'\n        echo ${name:1:2}\n        ```\n        - 查找（有问题）\n        ```\n        name='I love shell!'\n        echo `expr index \"${name}\" love`\n        ```\n    - 数字\n\n    - 数组\n        - 定义，使用圆括号包括，元素之间使用空格分隔\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        ```\n        - 赋值\n        ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        list[5]='c++'\n        ```\n        - 使用\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${list[1]}\n        ```\n        - 获取所有元素， 使用@或者*获取\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${list[@]}\n        ```\n        - 获取长度\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${#list[@]}\n        ```\n\n- 参数传递\n    - 使用$n获取传入的第n个参数\n    \n    ```shell\n    echo \"执行的文件名：$0\";\n    echo \"参数个数 $#\";\n    echo \"所有参数 $*\";\n    echo \"所有参数 $@\"\n    echo \"第一个参数为：$1\";\n    echo \"第二个参数为：$2\";\n    echo \"第三个参数为：$3\"; \n    echo \"脚本运行的当前进程ID号 $$\"\n    echo \"后台运行的最后一个进程的ID号 $!\"\n    echo \"显示Shell使用的当前选项 $-\"      \n    ```\n- 基本运算符\n    - 数学运算一般使用其他命令，如expr\n    - 数学运算也可以使用如下符号\n        - $(())\n        - $[]\n        ```shell\n        a=1\n        b=2\n        c=$[$a+$b]\n        d=$(($a+$b))\n        echo \"$c\"\n        echo \"$d\"\n        ```\n    - 算术运算， 加，减，乘，除，赋值，取余，相等，不等\n        - 条件表达式需要使用方括号，并且需要空格, [ $a == $b ]\n        - 算术运算符两边需要加空格\n        - 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算；\n    ```shell\n    a=1\n    b=2\n\n    val=`expr $a + $b`\n    echo \" a + b: ${val}\"\n\n    val=`expr $a / $b`\n    echo \" a / b: ${val}\"\n\n    val=`expr $a - $b`\n    echo \" a - b: ${val}\"\n\n    val=`expr $a \\* $b`\n    echo \" a * b: ${val}\"\n\n    val=`expr $a % $b`\n    echo \" a % b: ${val}\"\n\n    if [ $a == $b ]; then\n        echo \"a ==  b\"\n    else\n        echo \"a !=  b\"\n    fi\n    ```\n    - 关系运算\n        - 只支持数字，不支持字符串\n        - -eq\n        - -ne\n        - -gt\n        - -lt\n        - -ge\n        - -le\n\n        ```shell\n        a=1\n        b=2\n\n        if [ $a -eq $b ]; then\n            echo \"a -eq b: 相等\"\n        else \n            echo \"a -eq b: 不相等\"\n        fi\n\n        if [ $a -ne $b ]; then\n            echo \"a -ne b: 不相等\"\n        else \n            echo \"a -ne b: 相等\"\n        fi\n\n        if [ $a -gt $b ]; then\n            echo \"a -gt b: 大于\"\n        else \n            echo \"a -gt b: 小于等于\"\n        fi\n\n        if [ $a -lt $b ]; then\n            echo \"a -lt b: 小于\"\n        else \n            echo \"a -lt b: 大于等于\"\n        fi\n        ```\n    - 布尔运算\n        - !\n        - -o\n        - -a\n        ```shell\n        a=1\n        b=2\n\n        if [ $a -eq 1 -a $b -ne 2 ]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi  \n        ```\n    - 逻辑运算符，使用双中括号\n        - &&\n        - ||\n         ```shell\n        a=1\n        b=2\n\n        if [[ $a -eq 1 && $b -ne 2 ]]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi  \n        ```\n    - 字符串运算\n        - = 两个字符串是否相等\n        - != 两个字符串是否不相等\n        - -z 字符串长度是否是0\n        - -n 字符串长度是否不为0\n        - $ 字符串是否为空\n        - 字符串比较可以使用双中括号，双中括号提供了针对字符串比较的高级特性，使用双中括号 [[ ]] 进行字符串比较时，可以把右边的项看做一个模式，故而可以在 [[ ]] 中使用正则表达式：\n\n        ```shell\n        [[ \"$script_location\" != /* ]]\n        ```\n\n        ```shell\n        a=\"1\"\n        b=\"2\"\n\n        if [ -n $a ]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi \n        ```\n         ```shell\n        a=\"1\"\n        b=\"2\"\n\n        if [[ -n $a ]]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi \n        ```\n\n    - 文件测试运算\n        - -f file 判断文件是否是普通文件\n        - -r file 是否是可读文件\n        - -w file 是否是可写文件\n        - -x file 是否是可执行文件\n        ```shell\n        file=\"./test.sh\"\n        if [ -f $file ]; then\n            echo \"$file 是普通文件\"\n        fi\n        ```\n- 控制流\n    - if else fi\n    - if elif else fi\n    - for\n        - in列表可以包含替换、字符串和文件名。\n        - command1 指任何有效的命令和语句\n    ```shell\n    for var in item1 item2 item3 ... itmeN; do\n        command1\n    done\n    for num in `ls .`; do\n        echo ${num}\n    done\n    ```\n    - while\n    ```shell\n        while condition; do\n            command1\n        done\n    ```\n    - case\n    ```shell\n    case 值 in\n    模式1)\n        command1\n        command2\n        ;;\n    模式2)\n        command1\n        command2\n        ;;\n    *)\n        ;;\n    esac\n    ```\n    ```shell\n    name=\"apple\"\n    case $name in\n    \"apple\")\n        echo \"apple\"\n    ;;\n    \"bear\")\n        echo \"bear\"\n    ;;\n    esac    \n    ```\n- 函数\n    - 函数定义\n    ```shell\n    demofun() {\n        echo \"demo\"\n    }\n\n    demofun\n    ```\n    - 返回值 $?\n    - 函数参数 $n\n    - 调用 函数名\n    ```shell\n    add() {\n        return `expr $1 + $2`\n    }\n\n    add 1 2\n    echo \"add 1 2: $?\"\n    ```\n- 输入输出重定向\n\n\n","source":"_posts/shell学习.md","raw":"---\ntitle: shell 学习笔记\ndate: 2020-01-30 12:14:26\ntags: shell 语言学习\n---\n\n关于shell使用的一些基本知识和实践，持续更新。\n<!-- more -->\n\n- #! 是一种约定的写法，指示使用何种解释器；\n- 为什么使用./xx.sh的方式执行shell文件？\n./xx.sh 指定目录会让系统从指定的目录寻找可以执行的文件。如果是xx.sh，系统会从PATH中寻找可执行文件；\n```shell\n文件查找在很多系统中有存在，可以对比理解：\n    1 npm的路径寻找过程\n    2 java中class loader的依赖查找\n```\n- 反引号 和 $() 可以表示命令替换\n```shell\nNPM_LOC_1=`which npm`\nNPM_LOC_2=$(which npm)\n\nif [ $NPM_LOC_1 = $NPM_LOC_1 ]; then\n    echo \"相同\"\nfi\n```\n\n- = 之后有空格，可以表示命令替换\n```shell\na= ls ./\necho \"$a\"\n```\n- 运算符和操作数之间要有空格\n- 一般性输出使用echo，需要一定格式的可以使用printf\n- 特殊符号\n    - $#\n    - $@\n    - $*\n- 注释\n    - 单行注释 \n    ```shell\n     # 这是注释\n    ```\n    - 多行注释\n    ```shell\n    # 这是注释\n    # 这是注释\n    # 这是注释\n\n    :<<EOF\n    这是注释\n    这是注释\n    这是注释\n    EOF\n\n    ```\n- 变量\n    - 合法的变量名，数字，字母，下划线，不能以数字开头;\n    - 变量名和=之间不能有空格;\n    ```shell\n    name=`123`\n    echo ${name}\n    ```\n    - 类型：字符串, 数字, 数组\n    ```shell\n    name='test'\n    echo ${name}\n    name=1\n    echo ${name}\n    ```\n    - 变量使用，使用${变量名}，花括号可以省略，最佳实践是不要去掉花花括号；\n    - 使用readonly可以定义只读变量\n    - 删除变量\n    - 变量作用域\n        - 局部变量\n        - 环境变量\n        - shell 变量\n\n    - 字符串\n        - 单引号和双引号的区别：单引号内都是字符串，双引号内可以包括变量的引用和转义字符\n        - 拼接\n        ```\n        name1='I love '\n        name2='shell'\n        echo ${name1} ${name2} \n        ```\n        - 长度\n        ```\n        name='I love shell!'\n        echo ${#name}\n        ```\n        - 子串\n        ```\n        name='I love shell!'\n        echo ${name:1:2}\n        ```\n        - 查找（有问题）\n        ```\n        name='I love shell!'\n        echo `expr index \"${name}\" love`\n        ```\n    - 数字\n\n    - 数组\n        - 定义，使用圆括号包括，元素之间使用空格分隔\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        ```\n        - 赋值\n        ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        list[5]='c++'\n        ```\n        - 使用\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${list[1]}\n        ```\n        - 获取所有元素， 使用@或者*获取\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${list[@]}\n        ```\n        - 获取长度\n         ```shell\n        list=('java' 'c' 'javascript' 'c#')\n        echo ${#list[@]}\n        ```\n\n- 参数传递\n    - 使用$n获取传入的第n个参数\n    \n    ```shell\n    echo \"执行的文件名：$0\";\n    echo \"参数个数 $#\";\n    echo \"所有参数 $*\";\n    echo \"所有参数 $@\"\n    echo \"第一个参数为：$1\";\n    echo \"第二个参数为：$2\";\n    echo \"第三个参数为：$3\"; \n    echo \"脚本运行的当前进程ID号 $$\"\n    echo \"后台运行的最后一个进程的ID号 $!\"\n    echo \"显示Shell使用的当前选项 $-\"      \n    ```\n- 基本运算符\n    - 数学运算一般使用其他命令，如expr\n    - 数学运算也可以使用如下符号\n        - $(())\n        - $[]\n        ```shell\n        a=1\n        b=2\n        c=$[$a+$b]\n        d=$(($a+$b))\n        echo \"$c\"\n        echo \"$d\"\n        ```\n    - 算术运算， 加，减，乘，除，赋值，取余，相等，不等\n        - 条件表达式需要使用方括号，并且需要空格, [ $a == $b ]\n        - 算术运算符两边需要加空格\n        - 乘号(*)前边必须加反斜杠(\\)才能实现乘法运算；\n    ```shell\n    a=1\n    b=2\n\n    val=`expr $a + $b`\n    echo \" a + b: ${val}\"\n\n    val=`expr $a / $b`\n    echo \" a / b: ${val}\"\n\n    val=`expr $a - $b`\n    echo \" a - b: ${val}\"\n\n    val=`expr $a \\* $b`\n    echo \" a * b: ${val}\"\n\n    val=`expr $a % $b`\n    echo \" a % b: ${val}\"\n\n    if [ $a == $b ]; then\n        echo \"a ==  b\"\n    else\n        echo \"a !=  b\"\n    fi\n    ```\n    - 关系运算\n        - 只支持数字，不支持字符串\n        - -eq\n        - -ne\n        - -gt\n        - -lt\n        - -ge\n        - -le\n\n        ```shell\n        a=1\n        b=2\n\n        if [ $a -eq $b ]; then\n            echo \"a -eq b: 相等\"\n        else \n            echo \"a -eq b: 不相等\"\n        fi\n\n        if [ $a -ne $b ]; then\n            echo \"a -ne b: 不相等\"\n        else \n            echo \"a -ne b: 相等\"\n        fi\n\n        if [ $a -gt $b ]; then\n            echo \"a -gt b: 大于\"\n        else \n            echo \"a -gt b: 小于等于\"\n        fi\n\n        if [ $a -lt $b ]; then\n            echo \"a -lt b: 小于\"\n        else \n            echo \"a -lt b: 大于等于\"\n        fi\n        ```\n    - 布尔运算\n        - !\n        - -o\n        - -a\n        ```shell\n        a=1\n        b=2\n\n        if [ $a -eq 1 -a $b -ne 2 ]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi  \n        ```\n    - 逻辑运算符，使用双中括号\n        - &&\n        - ||\n         ```shell\n        a=1\n        b=2\n\n        if [[ $a -eq 1 && $b -ne 2 ]]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi  \n        ```\n    - 字符串运算\n        - = 两个字符串是否相等\n        - != 两个字符串是否不相等\n        - -z 字符串长度是否是0\n        - -n 字符串长度是否不为0\n        - $ 字符串是否为空\n        - 字符串比较可以使用双中括号，双中括号提供了针对字符串比较的高级特性，使用双中括号 [[ ]] 进行字符串比较时，可以把右边的项看做一个模式，故而可以在 [[ ]] 中使用正则表达式：\n\n        ```shell\n        [[ \"$script_location\" != /* ]]\n        ```\n\n        ```shell\n        a=\"1\"\n        b=\"2\"\n\n        if [ -n $a ]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi \n        ```\n         ```shell\n        a=\"1\"\n        b=\"2\"\n\n        if [[ -n $a ]]; then\n            echo \"true\"\n        else \n            echo \"false\"\n        fi \n        ```\n\n    - 文件测试运算\n        - -f file 判断文件是否是普通文件\n        - -r file 是否是可读文件\n        - -w file 是否是可写文件\n        - -x file 是否是可执行文件\n        ```shell\n        file=\"./test.sh\"\n        if [ -f $file ]; then\n            echo \"$file 是普通文件\"\n        fi\n        ```\n- 控制流\n    - if else fi\n    - if elif else fi\n    - for\n        - in列表可以包含替换、字符串和文件名。\n        - command1 指任何有效的命令和语句\n    ```shell\n    for var in item1 item2 item3 ... itmeN; do\n        command1\n    done\n    for num in `ls .`; do\n        echo ${num}\n    done\n    ```\n    - while\n    ```shell\n        while condition; do\n            command1\n        done\n    ```\n    - case\n    ```shell\n    case 值 in\n    模式1)\n        command1\n        command2\n        ;;\n    模式2)\n        command1\n        command2\n        ;;\n    *)\n        ;;\n    esac\n    ```\n    ```shell\n    name=\"apple\"\n    case $name in\n    \"apple\")\n        echo \"apple\"\n    ;;\n    \"bear\")\n        echo \"bear\"\n    ;;\n    esac    \n    ```\n- 函数\n    - 函数定义\n    ```shell\n    demofun() {\n        echo \"demo\"\n    }\n\n    demofun\n    ```\n    - 返回值 $?\n    - 函数参数 $n\n    - 调用 函数名\n    ```shell\n    add() {\n        return `expr $1 + $2`\n    }\n\n    add 1 2\n    echo \"add 1 2: $?\"\n    ```\n- 输入输出重定向\n\n\n","slug":"shell学习","published":1,"updated":"2020-02-01T12:46:09.267Z","_id":"ck60tw09m0000qlyxh0wo2cop","comments":1,"layout":"post","photos":[],"link":"","content":"<p>关于shell使用的一些基本知识和实践，持续更新。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>#! 是一种约定的写法，指示使用何种解释器；</p>\n</li>\n<li><p>为什么使用./xx.sh的方式执行shell文件？<br>./xx.sh 指定目录会让系统从指定的目录寻找可以执行的文件。如果是xx.sh，系统会从PATH中寻找可执行文件；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件查找在很多系统中有存在，可以对比理解：</span><br><span class=\"line\">    1 npm的路径寻找过程</span><br><span class=\"line\">    2 java中class loader的依赖查找</span><br></pre></td></tr></table></figure></li>\n<li><p>反引号 和 $() 可以表示命令替换</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NPM_LOC_1=`which npm`</span><br><span class=\"line\">NPM_LOC_2=$(which npm)</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $NPM_LOC_1 = $NPM_LOC_1 ]; then</span><br><span class=\"line\">    echo \"相同\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>= 之后有空格，可以表示命令替换</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a= ls ./</span><br><span class=\"line\">echo \"$a\"</span><br></pre></td></tr></table></figure></li>\n<li><p>运算符和操作数之间要有空格</p>\n</li>\n<li><p>一般性输出使用echo，需要一定格式的可以使用printf</p>\n</li>\n<li><p>特殊符号</p>\n<ul>\n<li>$#</li>\n<li>$@</li>\n<li>$*</li>\n</ul>\n</li>\n<li><p>注释</p>\n<ul>\n<li>单行注释 <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br></pre></td></tr></table></figure></li>\n<li>多行注释<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"></span><br><span class=\"line\">:&lt;&lt;EOF</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>变量</p>\n<ul>\n<li><p>合法的变量名，数字，字母，下划线，不能以数字开头;</p>\n</li>\n<li><p>变量名和=之间不能有空格;</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=`123`</span><br><span class=\"line\">echo $&#123;name&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>类型：字符串, 数字, 数组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name='test'</span><br><span class=\"line\">echo $&#123;name&#125;</span><br><span class=\"line\">name=1</span><br><span class=\"line\">echo $&#123;name&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>变量使用，使用${变量名}，花括号可以省略，最佳实践是不要去掉花花括号；</p>\n</li>\n<li><p>使用readonly可以定义只读变量</p>\n</li>\n<li><p>删除变量</p>\n</li>\n<li><p>变量作用域</p>\n<ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell 变量</li>\n</ul>\n</li>\n<li><p>字符串</p>\n<ul>\n<li>单引号和双引号的区别：单引号内都是字符串，双引号内可以包括变量的引用和转义字符</li>\n<li>拼接<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1&#x3D;&#39;I love &#39;</span><br><span class=\"line\">name2&#x3D;&#39;shell&#39;</span><br><span class=\"line\">echo $&#123;name1&#125; $&#123;name2&#125;</span><br></pre></td></tr></table></figure></li>\n<li>长度<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo $&#123;#name&#125;</span><br></pre></td></tr></table></figure></li>\n<li>子串<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo $&#123;name:1:2&#125;</span><br></pre></td></tr></table></figure></li>\n<li>查找（有问题）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo &#96;expr index &quot;$&#123;name&#125;&quot; love&#96;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>数字</p>\n</li>\n<li><p>数组</p>\n<ul>\n<li>定义，使用圆括号包括，元素之间使用空格分隔<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br></pre></td></tr></table></figure></li>\n<li>赋值<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">list[5]='c++'</span><br></pre></td></tr></table></figure></li>\n<li>使用<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;list[1]&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获取所有元素， 使用@或者*获取<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;list[@]&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获取长度<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;#list[@]&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参数传递</p>\n<ul>\n<li><p>使用$n获取传入的第n个参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"执行的文件名：$0\";</span><br><span class=\"line\">echo \"参数个数 $#\";</span><br><span class=\"line\">echo \"所有参数 $*\";</span><br><span class=\"line\">echo \"所有参数 $@\"</span><br><span class=\"line\">echo \"第一个参数为：$1\";</span><br><span class=\"line\">echo \"第二个参数为：$2\";</span><br><span class=\"line\">echo \"第三个参数为：$3\"; </span><br><span class=\"line\">echo \"脚本运行的当前进程ID号 $$\"</span><br><span class=\"line\">echo \"后台运行的最后一个进程的ID号 $!\"</span><br><span class=\"line\">echo \"显示Shell使用的当前选项 $-\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>基本运算符</p>\n<ul>\n<li><p>数学运算一般使用其他命令，如expr</p>\n</li>\n<li><p>数学运算也可以使用如下符号</p>\n<ul>\n<li>$(())</li>\n<li>$[]<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\">c=$[$a+$b]</span><br><span class=\"line\">d=$(($a+$b))</span><br><span class=\"line\">echo \"$c\"</span><br><span class=\"line\">echo \"$d\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>算术运算， 加，减，乘，除，赋值，取余，相等，不等</p>\n<ul>\n<li>条件表达式需要使用方括号，并且需要空格, [ $a == $b ]</li>\n<li>算术运算符两边需要加空格</li>\n<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a + $b`</span><br><span class=\"line\">echo \" a + b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a / $b`</span><br><span class=\"line\">echo \" a / b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a - $b`</span><br><span class=\"line\">echo \" a - b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a \\* $b`</span><br><span class=\"line\">echo \" a * b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a % $b`</span><br><span class=\"line\">echo \" a % b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a == $b ]; then</span><br><span class=\"line\">    echo \"a ==  b\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo \"a !=  b\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>关系运算</p>\n<ul>\n<li><p>只支持数字，不支持字符串</p>\n</li>\n<li><p>-eq</p>\n</li>\n<li><p>-ne</p>\n</li>\n<li><p>-gt</p>\n</li>\n<li><p>-lt</p>\n</li>\n<li><p>-ge</p>\n</li>\n<li><p>-le</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -eq $b ]; then</span><br><span class=\"line\">    echo \"a -eq b: 相等\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -eq b: 不相等\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -ne $b ]; then</span><br><span class=\"line\">    echo \"a -ne b: 不相等\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -ne b: 相等\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -gt $b ]; then</span><br><span class=\"line\">    echo \"a -gt b: 大于\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -gt b: 小于等于\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -lt $b ]; then</span><br><span class=\"line\">    echo \"a -lt b: 小于\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -lt b: 大于等于\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>布尔运算</p>\n<ul>\n<li>!</li>\n<li>-o</li>\n<li>-a<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -eq 1 -a $b -ne 2 ]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>逻辑运算符，使用双中括号</p>\n<ul>\n<li>&amp;&amp;</li>\n<li>||<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $a -eq 1 &amp;&amp; $b -ne 2 ]]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>字符串运算</p>\n<ul>\n<li><p>= 两个字符串是否相等</p>\n</li>\n<li><p>!= 两个字符串是否不相等</p>\n</li>\n<li><p>-z 字符串长度是否是0</p>\n</li>\n<li><p>-n 字符串长度是否不为0</p>\n</li>\n<li><p>$ 字符串是否为空</p>\n</li>\n<li><p>字符串比较可以使用双中括号，双中括号提供了针对字符串比较的高级特性，使用双中括号 [[ ]] 进行字符串比较时，可以把右边的项看做一个模式，故而可以在 [[ ]] 中使用正则表达式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ \"$script_location\" != /* ]]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=\"1\"</span><br><span class=\"line\">b=\"2\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -n $a ]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=\"1\"</span><br><span class=\"line\">b=\"2\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ -n $a ]]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>文件测试运算</p>\n<ul>\n<li>-f file 判断文件是否是普通文件</li>\n<li>-r file 是否是可读文件</li>\n<li>-w file 是否是可写文件</li>\n<li>-x file 是否是可执行文件<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file=\"./test.sh\"</span><br><span class=\"line\">if [ -f $file ]; then</span><br><span class=\"line\">    echo \"$file 是普通文件\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制流</p>\n<ul>\n<li>if else fi</li>\n<li>if elif else fi</li>\n<li>for<ul>\n<li>in列表可以包含替换、字符串和文件名。</li>\n<li>command1 指任何有效的命令和语句<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in item1 item2 item3 ... itmeN; do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">done</span><br><span class=\"line\">for num in `ls .`; do</span><br><span class=\"line\">    echo $&#123;num&#125;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>while<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while condition; do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>case<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 值 in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">模式2)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=\"apple\"</span><br><span class=\"line\">case $name in</span><br><span class=\"line\">\"apple\")</span><br><span class=\"line\">    echo \"apple\"</span><br><span class=\"line\">;;</span><br><span class=\"line\">\"bear\")</span><br><span class=\"line\">    echo \"bear\"</span><br><span class=\"line\">;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>函数</p>\n<ul>\n<li>函数定义<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demofun() &#123;</span><br><span class=\"line\">    echo \"demo\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">demofun</span><br></pre></td></tr></table></figure></li>\n<li>返回值 $?</li>\n<li>函数参数 $n</li>\n<li>调用 函数名<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add() &#123;</span><br><span class=\"line\">    return `expr $1 + $2`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add 1 2</span><br><span class=\"line\">echo \"add 1 2: $?\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>输入输出重定向</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>关于shell使用的一些基本知识和实践，持续更新。</p>","more":"<ul>\n<li><p>#! 是一种约定的写法，指示使用何种解释器；</p>\n</li>\n<li><p>为什么使用./xx.sh的方式执行shell文件？<br>./xx.sh 指定目录会让系统从指定的目录寻找可以执行的文件。如果是xx.sh，系统会从PATH中寻找可执行文件；</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">文件查找在很多系统中有存在，可以对比理解：</span><br><span class=\"line\">    1 npm的路径寻找过程</span><br><span class=\"line\">    2 java中class loader的依赖查找</span><br></pre></td></tr></table></figure></li>\n<li><p>反引号 和 $() 可以表示命令替换</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NPM_LOC_1=`which npm`</span><br><span class=\"line\">NPM_LOC_2=$(which npm)</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $NPM_LOC_1 = $NPM_LOC_1 ]; then</span><br><span class=\"line\">    echo \"相同\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>= 之后有空格，可以表示命令替换</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a= ls ./</span><br><span class=\"line\">echo \"$a\"</span><br></pre></td></tr></table></figure></li>\n<li><p>运算符和操作数之间要有空格</p>\n</li>\n<li><p>一般性输出使用echo，需要一定格式的可以使用printf</p>\n</li>\n<li><p>特殊符号</p>\n<ul>\n<li>$#</li>\n<li>$@</li>\n<li>$*</li>\n</ul>\n</li>\n<li><p>注释</p>\n<ul>\n<li>单行注释 <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br></pre></td></tr></table></figure></li>\n<li>多行注释<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 这是注释</span></span><br><span class=\"line\"></span><br><span class=\"line\">:&lt;&lt;EOF</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">这是注释</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>变量</p>\n<ul>\n<li><p>合法的变量名，数字，字母，下划线，不能以数字开头;</p>\n</li>\n<li><p>变量名和=之间不能有空格;</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=`123`</span><br><span class=\"line\">echo $&#123;name&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>类型：字符串, 数字, 数组</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name='test'</span><br><span class=\"line\">echo $&#123;name&#125;</span><br><span class=\"line\">name=1</span><br><span class=\"line\">echo $&#123;name&#125;</span><br></pre></td></tr></table></figure></li>\n<li><p>变量使用，使用${变量名}，花括号可以省略，最佳实践是不要去掉花花括号；</p>\n</li>\n<li><p>使用readonly可以定义只读变量</p>\n</li>\n<li><p>删除变量</p>\n</li>\n<li><p>变量作用域</p>\n<ul>\n<li>局部变量</li>\n<li>环境变量</li>\n<li>shell 变量</li>\n</ul>\n</li>\n<li><p>字符串</p>\n<ul>\n<li>单引号和双引号的区别：单引号内都是字符串，双引号内可以包括变量的引用和转义字符</li>\n<li>拼接<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name1&#x3D;&#39;I love &#39;</span><br><span class=\"line\">name2&#x3D;&#39;shell&#39;</span><br><span class=\"line\">echo $&#123;name1&#125; $&#123;name2&#125;</span><br></pre></td></tr></table></figure></li>\n<li>长度<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo $&#123;#name&#125;</span><br></pre></td></tr></table></figure></li>\n<li>子串<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo $&#123;name:1:2&#125;</span><br></pre></td></tr></table></figure></li>\n<li>查找（有问题）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name&#x3D;&#39;I love shell!&#39;</span><br><span class=\"line\">echo &#96;expr index &quot;$&#123;name&#125;&quot; love&#96;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>数字</p>\n</li>\n<li><p>数组</p>\n<ul>\n<li>定义，使用圆括号包括，元素之间使用空格分隔<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br></pre></td></tr></table></figure></li>\n<li>赋值<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">list[5]='c++'</span><br></pre></td></tr></table></figure></li>\n<li>使用<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;list[1]&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获取所有元素， 使用@或者*获取<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;list[@]&#125;</span><br></pre></td></tr></table></figure></li>\n<li>获取长度<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">list=('java' 'c' 'javascript' 'c#')</span><br><span class=\"line\">echo $&#123;#list[@]&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>参数传递</p>\n<ul>\n<li><p>使用$n获取传入的第n个参数</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"执行的文件名：$0\";</span><br><span class=\"line\">echo \"参数个数 $#\";</span><br><span class=\"line\">echo \"所有参数 $*\";</span><br><span class=\"line\">echo \"所有参数 $@\"</span><br><span class=\"line\">echo \"第一个参数为：$1\";</span><br><span class=\"line\">echo \"第二个参数为：$2\";</span><br><span class=\"line\">echo \"第三个参数为：$3\"; </span><br><span class=\"line\">echo \"脚本运行的当前进程ID号 $$\"</span><br><span class=\"line\">echo \"后台运行的最后一个进程的ID号 $!\"</span><br><span class=\"line\">echo \"显示Shell使用的当前选项 $-\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>基本运算符</p>\n<ul>\n<li><p>数学运算一般使用其他命令，如expr</p>\n</li>\n<li><p>数学运算也可以使用如下符号</p>\n<ul>\n<li>$(())</li>\n<li>$[]<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\">c=$[$a+$b]</span><br><span class=\"line\">d=$(($a+$b))</span><br><span class=\"line\">echo \"$c\"</span><br><span class=\"line\">echo \"$d\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>算术运算， 加，减，乘，除，赋值，取余，相等，不等</p>\n<ul>\n<li>条件表达式需要使用方括号，并且需要空格, [ $a == $b ]</li>\n<li>算术运算符两边需要加空格</li>\n<li>乘号(*)前边必须加反斜杠()才能实现乘法运算；<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a + $b`</span><br><span class=\"line\">echo \" a + b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a / $b`</span><br><span class=\"line\">echo \" a / b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a - $b`</span><br><span class=\"line\">echo \" a - b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a \\* $b`</span><br><span class=\"line\">echo \" a * b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">val=`expr $a % $b`</span><br><span class=\"line\">echo \" a % b: $&#123;val&#125;\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a == $b ]; then</span><br><span class=\"line\">    echo \"a ==  b\"</span><br><span class=\"line\">else</span><br><span class=\"line\">    echo \"a !=  b\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>关系运算</p>\n<ul>\n<li><p>只支持数字，不支持字符串</p>\n</li>\n<li><p>-eq</p>\n</li>\n<li><p>-ne</p>\n</li>\n<li><p>-gt</p>\n</li>\n<li><p>-lt</p>\n</li>\n<li><p>-ge</p>\n</li>\n<li><p>-le</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -eq $b ]; then</span><br><span class=\"line\">    echo \"a -eq b: 相等\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -eq b: 不相等\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -ne $b ]; then</span><br><span class=\"line\">    echo \"a -ne b: 不相等\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -ne b: 相等\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -gt $b ]; then</span><br><span class=\"line\">    echo \"a -gt b: 大于\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -gt b: 小于等于\"</span><br><span class=\"line\">fi</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -lt $b ]; then</span><br><span class=\"line\">    echo \"a -lt b: 小于\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"a -lt b: 大于等于\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>布尔运算</p>\n<ul>\n<li>!</li>\n<li>-o</li>\n<li>-a<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [ $a -eq 1 -a $b -ne 2 ]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>逻辑运算符，使用双中括号</p>\n<ul>\n<li>&amp;&amp;</li>\n<li>||<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=1</span><br><span class=\"line\">b=2</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ $a -eq 1 &amp;&amp; $b -ne 2 ]]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>字符串运算</p>\n<ul>\n<li><p>= 两个字符串是否相等</p>\n</li>\n<li><p>!= 两个字符串是否不相等</p>\n</li>\n<li><p>-z 字符串长度是否是0</p>\n</li>\n<li><p>-n 字符串长度是否不为0</p>\n</li>\n<li><p>$ 字符串是否为空</p>\n</li>\n<li><p>字符串比较可以使用双中括号，双中括号提供了针对字符串比较的高级特性，使用双中括号 [[ ]] 进行字符串比较时，可以把右边的项看做一个模式，故而可以在 [[ ]] 中使用正则表达式：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[[ \"$script_location\" != /* ]]</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=\"1\"</span><br><span class=\"line\">b=\"2\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [ -n $a ]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a=\"1\"</span><br><span class=\"line\">b=\"2\"</span><br><span class=\"line\"></span><br><span class=\"line\">if [[ -n $a ]]; then</span><br><span class=\"line\">    echo \"true\"</span><br><span class=\"line\">else </span><br><span class=\"line\">    echo \"false\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>文件测试运算</p>\n<ul>\n<li>-f file 判断文件是否是普通文件</li>\n<li>-r file 是否是可读文件</li>\n<li>-w file 是否是可写文件</li>\n<li>-x file 是否是可执行文件<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">file=\"./test.sh\"</span><br><span class=\"line\">if [ -f $file ]; then</span><br><span class=\"line\">    echo \"$file 是普通文件\"</span><br><span class=\"line\">fi</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>控制流</p>\n<ul>\n<li>if else fi</li>\n<li>if elif else fi</li>\n<li>for<ul>\n<li>in列表可以包含替换、字符串和文件名。</li>\n<li>command1 指任何有效的命令和语句<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">for var in item1 item2 item3 ... itmeN; do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">done</span><br><span class=\"line\">for num in `ls .`; do</span><br><span class=\"line\">    echo $&#123;num&#125;</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li>while<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">while condition; do</span><br><span class=\"line\">    command1</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></li>\n<li>case<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">case 值 in</span><br><span class=\"line\">模式1)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">模式2)</span><br><span class=\"line\">    command1</span><br><span class=\"line\">    command2</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">*)</span><br><span class=\"line\">    ;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">name=\"apple\"</span><br><span class=\"line\">case $name in</span><br><span class=\"line\">\"apple\")</span><br><span class=\"line\">    echo \"apple\"</span><br><span class=\"line\">;;</span><br><span class=\"line\">\"bear\")</span><br><span class=\"line\">    echo \"bear\"</span><br><span class=\"line\">;;</span><br><span class=\"line\">esac</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>函数</p>\n<ul>\n<li>函数定义<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">demofun() &#123;</span><br><span class=\"line\">    echo \"demo\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">demofun</span><br></pre></td></tr></table></figure></li>\n<li>返回值 $?</li>\n<li>函数参数 $n</li>\n<li>调用 函数名<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add() &#123;</span><br><span class=\"line\">    return `expr $1 + $2`</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">add 1 2</span><br><span class=\"line\">echo \"add 1 2: $?\"</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n<li><p>输入输出重定向</p>\n</li>\n</ul>"},{"title":"nginx 学习笔记","date":"2020-02-01T12:36:30.000Z","_content":"关于nginx使用的一些基本知识和实践，持续更新。\n<!-- more -->\n\n- nginx.config\n    - 使用```nginx -t```验证配置文件\n    - ```/usr/local/etc/nginx/```\n    - 方便管理，可以使用软链的方式，把这些文件统一管理\n    ```shell\n       ln -s /usr/local/etc/nginx /Users/xxx/xxx\n    ```\n   \n- 配置\n    - 配置类型\n        - http块\n            - 包括 HTTP 全局块、Server 块\n            - HTTP 全局块\n            HTTP 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n            - Server 块，虚拟服务器\n            它描述的是一组根据不同server_name指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 HTTP 部分。\n            - Location 块\n                - = ：该修饰符使用精确匹配并且终止搜索\n                - ~：该修饰符使用区分大小写的正则表达式匹配\n                - ~*：该修饰符使用不区分大小写的正则表达式匹配\n                - ^~：用于不含正则表达式的 URI 前，要求 Nginx 服务器找到标识 URI 和请求字符串匹配度最高的 Location 后，立即使用此 Location 处理请求，而不再使用 Location 块中的正则 URI 和请求字符串做匹配。\n                - 注意：如果 URI 包含正则表达式，则必须要有 ~ 或者 ~* 标识。\n        - 全局配置块\n        全局配置部分用来配置对整个 Server 都有效的参数。主要会设置一些影响 Nginx 服务器整体运行的配置指令，包括配置运行 Nginx 服务器的用户（组）、允许生成的 Worker Process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n        - events配置块\n        Events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 Work Process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 Word Process 可以同时支持的最大连接数等。\n    - 配置语法\n        - 配置文件由指令和指令块构成\n        - 每条指令以分号（;）结尾，指令和参数间以空格符分隔\n        - 指令块以大括号{}将多条指令组织在一起\n        - include 语句允许组合多个配置文件以提高可维护性\n        - 使用 # 添加注释\n        - 使用 $ 定义变量\n        - 部分指令的参数支持正则表达式\n            - local\n            - server_name\n- 灵活使用include\n- 常用命令\n    - nginx -s stop\n    - nginx -s reload\n    - nginx -t\n- 常用指令\n    - server_name\n        - 精确匹配\n        - 通配符\n        - 正则匹配，可以捕获匹配项\n    - proxy_pass\n        - 使用变量时，必需要用resolver指令解析变量中的域名\n   ```\n    server_name www.fleven.com;\n    server_name www.fleven.;\n    server_name .fleven.com;\n    server_name ~^[w]+.fleven.com$;\n   ```\n- 匹配顺序\n    - nginx里面有很多需要匹配的地方，比如server_name,local, 这些匹配按照从上到下的顺序执行，一旦匹配成功就停止后续的匹配，所以这些匹配条件的顺序是越精确的越在前面，越模糊的越在后面；\n- demo\n ```nginx\n# 全局配置\n#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  /data/nginx/logs/error.log;\n#error_log  /data/nginx/logs/error.log  notice;\n\n#日志文件存放路径 access_log path [format [buffer=size | off]]\naccess_log /data/nginx/logs/lazyegg.com/web/access.log combinedio;\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n#################################  events  ###############################\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    use epoll\n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    worker_connections  1024;\n\n    #keepalive 超时时间\n    keepalive_timeout 60;\n\n    #客户端请求头部的缓冲区大小。\n    client_header_buffer_size 4k;\n\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    #这个是指多长时间检查一次缓存的有效信息。\n    open_file_cache_valid 80s;\n        #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    open_file_cache_min_uses 1;\n\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n##############################   http    ##################################\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n\n    #默认文件类型\n    default_type application/octet-stream;\n\n    #默认编码\n    charset utf-8;\n\n    #服务器名字的hash表大小\n    server_names_hash_bucket_size 128;\n\n    #客户端请求头部的缓冲区大小。\n    client_header_buffer_size 32k;\n\n    #客户请求头缓冲大小。\n    large_client_header_buffers 4 64k;\n\n    #允许客户端请求的最大单个文件字节数\n    client_max_body_size 8m;\n\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    sendfile on;\n\n    #开启目录列表访问，适合下载服务器，默认关闭。\n    autoindex on;\n\n    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n\n    tcp_nodelay on;\n\n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n\n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n\n        #负载均衡配置\n    upstream lazyegg.net {\n\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n\n       #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name lazyegg.net;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/lazyegg;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n\n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n\n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n\n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access '$remote_addr - $remote_user [$time_local] \"$request\" '\n        '$status $body_bytes_sent \"$http_referer\" '\n        '\"$http_user_agent\" $http_x_forwarded_for';\n\n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n\n        #对 \"/connect-controller\" 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n\n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n ```\n \n - 参考\n    - [Nginx的这些妙用，你肯定有不知道的！](https://mp.weixin.qq.com/s/s15ZvxkHrRXYblzwuqFW2g)\n    - [nginx.conf 配置文件详解](https://juejin.im/post/5c1616186fb9a049a42ef21d)\n    - [关于Nginx的server_name](https://blog.51cto.com/onlyzq/535279)\n    - [nginx配置自定义变量实现日志动态分发](https://cloud.tencent.com/developer/article/1370009)\n    - [proxy_pass的小说明](https://segmentfault.com/a/1190000008061457)","source":"_posts/nginx.md","raw":"---\ntitle: nginx 学习笔记\ndate: 2020-02-01 20:36:30\ntags: nginx\n---\n关于nginx使用的一些基本知识和实践，持续更新。\n<!-- more -->\n\n- nginx.config\n    - 使用```nginx -t```验证配置文件\n    - ```/usr/local/etc/nginx/```\n    - 方便管理，可以使用软链的方式，把这些文件统一管理\n    ```shell\n       ln -s /usr/local/etc/nginx /Users/xxx/xxx\n    ```\n   \n- 配置\n    - 配置类型\n        - http块\n            - 包括 HTTP 全局块、Server 块\n            - HTTP 全局块\n            HTTP 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。\n            - Server 块，虚拟服务器\n            它描述的是一组根据不同server_name指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 HTTP 部分。\n            - Location 块\n                - = ：该修饰符使用精确匹配并且终止搜索\n                - ~：该修饰符使用区分大小写的正则表达式匹配\n                - ~*：该修饰符使用不区分大小写的正则表达式匹配\n                - ^~：用于不含正则表达式的 URI 前，要求 Nginx 服务器找到标识 URI 和请求字符串匹配度最高的 Location 后，立即使用此 Location 处理请求，而不再使用 Location 块中的正则 URI 和请求字符串做匹配。\n                - 注意：如果 URI 包含正则表达式，则必须要有 ~ 或者 ~* 标识。\n        - 全局配置块\n        全局配置部分用来配置对整个 Server 都有效的参数。主要会设置一些影响 Nginx 服务器整体运行的配置指令，包括配置运行 Nginx 服务器的用户（组）、允许生成的 Worker Process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。\n        - events配置块\n        Events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 Work Process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 Word Process 可以同时支持的最大连接数等。\n    - 配置语法\n        - 配置文件由指令和指令块构成\n        - 每条指令以分号（;）结尾，指令和参数间以空格符分隔\n        - 指令块以大括号{}将多条指令组织在一起\n        - include 语句允许组合多个配置文件以提高可维护性\n        - 使用 # 添加注释\n        - 使用 $ 定义变量\n        - 部分指令的参数支持正则表达式\n            - local\n            - server_name\n- 灵活使用include\n- 常用命令\n    - nginx -s stop\n    - nginx -s reload\n    - nginx -t\n- 常用指令\n    - server_name\n        - 精确匹配\n        - 通配符\n        - 正则匹配，可以捕获匹配项\n    - proxy_pass\n        - 使用变量时，必需要用resolver指令解析变量中的域名\n   ```\n    server_name www.fleven.com;\n    server_name www.fleven.;\n    server_name .fleven.com;\n    server_name ~^[w]+.fleven.com$;\n   ```\n- 匹配顺序\n    - nginx里面有很多需要匹配的地方，比如server_name,local, 这些匹配按照从上到下的顺序执行，一旦匹配成功就停止后续的匹配，所以这些匹配条件的顺序是越精确的越在前面，越模糊的越在后面；\n- demo\n ```nginx\n# 全局配置\n#定义Nginx运行的用户和用户组\nuser www www; \n\n#nginx进程数，通常设置成和cpu的数量相等\nworker_processes 4; \n\n#全局错误日志定义类型，[debug | info | notice | warn | error | crit]\n#error_log  /data/nginx/logs/error.log;\n#error_log  /data/nginx/logs/error.log  notice;\n\n#日志文件存放路径 access_log path [format [buffer=size | off]]\naccess_log /data/nginx/logs/lazyegg.com/web/access.log combinedio;\n\n#进程pid文件\n#pid        logs/nginx.pid;\n\n#指定进程可以打开的最大描述符：数目\n#工作模式与连接数上限\n##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。\n#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。\nworker_rlimit_nofile 65535;\n\n#################################  events  ###############################\nevents {\n    #参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型\n    use epoll\n    #单个进程最大连接数（最大连接数=连接数+进程数）\n    worker_connections  1024;\n\n    #keepalive 超时时间\n    keepalive_timeout 60;\n\n    #客户端请求头部的缓冲区大小。\n    client_header_buffer_size 4k;\n\n    #这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。\n    open_file_cache max=65535 inactive=60s;\n    #这个是指多长时间检查一次缓存的有效信息。\n    open_file_cache_valid 80s;\n        #open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。\n    open_file_cache_min_uses 1;\n\n    #语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.\n    open_file_cache_errors on;\n}\n\n##############################   http    ##################################\n\n#设定http服务器，利用它的反向代理功能提供负载均衡支持\nhttp{\n    #文件扩展名与文件类型映射表\n    include mime.types;\n\n    #默认文件类型\n    default_type application/octet-stream;\n\n    #默认编码\n    charset utf-8;\n\n    #服务器名字的hash表大小\n    server_names_hash_bucket_size 128;\n\n    #客户端请求头部的缓冲区大小。\n    client_header_buffer_size 32k;\n\n    #客户请求头缓冲大小。\n    large_client_header_buffers 4 64k;\n\n    #允许客户端请求的最大单个文件字节数\n    client_max_body_size 8m;\n\n    #开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。\n    sendfile on;\n\n    #开启目录列表访问，适合下载服务器，默认关闭。\n    autoindex on;\n\n    #此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用\n    tcp_nopush on;\n\n    tcp_nodelay on;\n\n    #长连接超时时间，单位是秒\n    keepalive_timeout 120;\n\n    #FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。\n    fastcgi_connect_timeout 300;\n    fastcgi_send_timeout 300;\n    fastcgi_read_timeout 300;\n    fastcgi_buffer_size 64k;\n    fastcgi_buffers 4 64k;\n    fastcgi_busy_buffers_size 128k;\n    fastcgi_temp_file_write_size 128k;\n\n    #gzip模块设置\n    gzip on; #开启gzip压缩输出\n    gzip_min_length 1k;    #最小压缩文件大小\n    gzip_buffers 4 16k;    #压缩缓冲区\n    gzip_http_version 1.0; #压缩版本（默认1.1，前端如果是squid2.5请使用1.0）\n    gzip_comp_level 2;     #压缩等级\n    gzip_types text/plain application/x-javascript text/css application/xml;    #压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。\n    gzip_vary on;\n\n    #开启限制IP连接数的时候需要使用\n    #limit_zone crawler $binary_remote_addr 10m;\n\n        #负载均衡配置\n    upstream lazyegg.net {\n\n        #upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。\n        server 192.168.80.121:80 weight=3;\n        server 192.168.80.122:80 weight=2;\n        server 192.168.80.123:80 weight=3;\n\n        #nginx的upstream目前支持4种方式的分配\n        #1、轮询（默认）\n        #每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n        #2、weight\n        #指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。\n        #例如：\n        #upstream bakend {\n        #    server 192.168.0.14 weight=10;\n        #    server 192.168.0.15 weight=10;\n        #}\n        #2、ip_hash\n        #每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n        #例如：\n        #upstream bakend {\n        #    ip_hash;\n        #    server 192.168.0.14:88;\n        #    server 192.168.0.15:80;\n        #}\n        #3、fair（第三方）\n        #按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n        #upstream backend {\n        #    server server1;\n        #    server server2;\n        #    fair;\n        #}\n        #4、url_hash（第三方）\n        #按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。\n        #例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n        #upstream backend {\n        #    server squid1:3128;\n        #    server squid2:3128;\n        #    hash $request_uri;\n        #    hash_method crc32;\n        #}\n\n        #tips:\n        #upstream bakend{#定义负载均衡设备的Ip及设备状态}{\n        #    ip_hash;\n        #    server 127.0.0.1:9090 down;\n        #    server 127.0.0.1:8080 weight=2;\n        #    server 127.0.0.1:6060;\n        #    server 127.0.0.1:7070 backup;\n        #}\n        #在需要使用负载均衡的server中增加 proxy_pass http://bakend/;\n\n        #每个设备的状态设置为:\n        #1.down表示单前的server暂时不参与负载\n        #2.weight为weight越大，负载的权重就越大。\n        #3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误\n        #4.fail_timeout:max_fails次失败后，暂停的时间。\n        #5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。\n\n        #nginx支持同时设置多组的负载均衡，用来给不用的server来使用。\n        #client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug\n        #client_body_temp_path设置记录文件的目录 可以设置最多3层目录\n        #location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡\n    }\n\n       #虚拟主机的配置\n    server {\n        #监听端口\n        listen 80;\n\n        #域名可以有多个，用空格隔开\n        server_name lazyegg.net;\n        #默认入口文件名称\n        index index.html index.htm index.php;\n        root /data/www/lazyegg;\n\n        #对******进行负载均衡\n        location ~ .*.(php|php5)?$\n        {\n            fastcgi_pass 127.0.0.1:9000;\n            fastcgi_index index.php;\n            include fastcgi.conf;\n        }\n\n        #图片缓存时间设置\n        location ~ .*.(gif|jpg|jpeg|png|bmp|swf)$\n        {\n            expires 10d;\n        }\n\n        #JS和CSS缓存时间设置\n        location ~ .*.(js|css)?$\n        {\n            expires 1h;\n        }\n\n        #日志格式设定\n        #$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；\n        #$remote_user：用来记录客户端用户名称；\n        #$time_local： 用来记录访问时间与时区；\n        #$request： 用来记录请求的url与http协议；\n        #$status： 用来记录请求状态；成功是200，\n        #$body_bytes_sent ：记录发送给客户端文件主体内容大小；\n        #$http_referer：用来记录从那个页面链接访问过来的；\n        #$http_user_agent：记录客户浏览器的相关信息；\n        #通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。\n        log_format access '$remote_addr - $remote_user [$time_local] \"$request\" '\n        '$status $body_bytes_sent \"$http_referer\" '\n        '\"$http_user_agent\" $http_x_forwarded_for';\n\n        #定义本虚拟主机的访问日志\n        access_log  /usr/local/nginx/logs/host.access.log  main;\n        access_log  /usr/local/nginx/logs/host.access.404.log  log404;\n\n        #对 \"/connect-controller\" 启用反向代理\n        location /connect-controller {\n            proxy_pass http://127.0.0.1:88; #请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）\n            proxy_redirect off;\n            proxy_set_header X-Real-IP $remote_addr;\n\n            #后端的Web服务器可以通过X-Forwarded-For获取用户真实IP\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n            #以下是一些反向代理的配置，可选。\n            proxy_set_header Host $host;\n\n            #允许客户端请求的最大单文件字节数\n            client_max_body_size 10m;\n\n            #缓冲区代理缓冲用户端请求的最大字节数，\n            #如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。\n            #无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误\n            client_body_buffer_size 128k;\n\n            #表示使nginx阻止HTTP应答代码为400或者更高的应答。\n            proxy_intercept_errors on;\n\n            #后端服务器连接的超时时间_发起握手等候响应超时时间\n            #nginx跟后端服务器连接超时时间(代理连接超时)\n            proxy_connect_timeout 90;\n\n            #后端服务器数据回传时间(代理发送超时)\n            #后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据\n            proxy_send_timeout 90;\n\n            #连接成功后，后端服务器响应时间(代理接收超时)\n            #连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）\n            proxy_read_timeout 90;\n\n            #设置代理服务器（nginx）保存用户头信息的缓冲区大小\n            #设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小\n            proxy_buffer_size 4k;\n\n            #proxy_buffers缓冲区，网页平均在32k以下的设置\n            #设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k\n            proxy_buffers 4 32k;\n\n            #高负荷下缓冲大小（proxy_buffers*2）\n            proxy_busy_buffers_size 64k;\n\n            #设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长\n            #设定缓存文件夹大小，大于这个值，将从upstream服务器传\n            proxy_temp_file_write_size 64k;\n        }\n\n        #本地动静分离反向代理配置\n        #所有jsp的页面均交由tomcat或resin处理\n        location ~ .(jsp|jspx|do)?$ {\n            proxy_set_header Host $host;\n            proxy_set_header X-Real-IP $remote_addr;\n            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            proxy_pass http://127.0.0.1:8080;\n        }\n    }\n}\n ```\n \n - 参考\n    - [Nginx的这些妙用，你肯定有不知道的！](https://mp.weixin.qq.com/s/s15ZvxkHrRXYblzwuqFW2g)\n    - [nginx.conf 配置文件详解](https://juejin.im/post/5c1616186fb9a049a42ef21d)\n    - [关于Nginx的server_name](https://blog.51cto.com/onlyzq/535279)\n    - [nginx配置自定义变量实现日志动态分发](https://cloud.tencent.com/developer/article/1370009)\n    - [proxy_pass的小说明](https://segmentfault.com/a/1190000008061457)","slug":"nginx","published":1,"updated":"2020-02-01T12:49:50.341Z","_id":"ck63kzmlm0000jniy9mgo7r9o","comments":1,"layout":"post","photos":[],"link":"","content":"<p>关于nginx使用的一些基本知识和实践，持续更新。</p>\n<a id=\"more\"></a>\n\n<ul>\n<li><p>nginx.config</p>\n<ul>\n<li>使用<code>nginx -t</code>验证配置文件</li>\n<li><code>/usr/local/etc/nginx/</code></li>\n<li>方便管理，可以使用软链的方式，把这些文件统一管理<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/etc/nginx /Users/xxx/xxx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>配置</p>\n<ul>\n<li>配置类型<ul>\n<li>http块<ul>\n<li>包括 HTTP 全局块、Server 块</li>\n<li>HTTP 全局块<br>HTTP 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li>\n<li>Server 块，虚拟服务器<br>它描述的是一组根据不同server_name指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 HTTP 部分。</li>\n<li>Location 块<ul>\n<li>= ：该修饰符使用精确匹配并且终止搜索</li>\n<li>~：该修饰符使用区分大小写的正则表达式匹配</li>\n<li>~*：该修饰符使用不区分大小写的正则表达式匹配</li>\n<li>^~：用于不含正则表达式的 URI 前，要求 Nginx 服务器找到标识 URI 和请求字符串匹配度最高的 Location 后，立即使用此 Location 处理请求，而不再使用 Location 块中的正则 URI 和请求字符串做匹配。</li>\n<li>注意：如果 URI 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>全局配置块<br>全局配置部分用来配置对整个 Server 都有效的参数。主要会设置一些影响 Nginx 服务器整体运行的配置指令，包括配置运行 Nginx 服务器的用户（组）、允许生成的 Worker Process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</li>\n<li>events配置块<br>Events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 Work Process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 Word Process 可以同时支持的最大连接数等。</li>\n</ul>\n</li>\n<li>配置语法<ul>\n<li>配置文件由指令和指令块构成</li>\n<li>每条指令以分号（;）结尾，指令和参数间以空格符分隔</li>\n<li>指令块以大括号{}将多条指令组织在一起</li>\n<li>include 语句允许组合多个配置文件以提高可维护性</li>\n<li>使用 # 添加注释</li>\n<li>使用 $ 定义变量</li>\n<li>部分指令的参数支持正则表达式<ul>\n<li>local</li>\n<li>server_name</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>灵活使用include</p>\n</li>\n<li><p>常用命令</p>\n<ul>\n<li>nginx -s stop</li>\n<li>nginx -s reload</li>\n<li>nginx -t</li>\n</ul>\n</li>\n<li><p>常用指令</p>\n<ul>\n<li>server_name<ul>\n<li>精确匹配</li>\n<li>通配符</li>\n<li>正则匹配，可以捕获匹配项</li>\n</ul>\n</li>\n<li>proxy_pass<ul>\n<li>使用变量时，必需要用resolver指令解析变量中的域名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_name www.fleven.com;</span><br><span class=\"line\">server_name www.fleven.;</span><br><span class=\"line\">server_name .fleven.com;</span><br><span class=\"line\">server_name ~^[w]+.fleven.com$;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>匹配顺序</p>\n<ul>\n<li>nginx里面有很多需要匹配的地方，比如server_name,local, 这些匹配按照从上到下的顺序执行，一旦匹配成功就停止后续的匹配，所以这些匹配条件的顺序是越精确的越在前面，越模糊的越在后面；</li>\n</ul>\n</li>\n<li><p>demo</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局配置</span></span><br><span class=\"line\"><span class=\"comment\">#定义Nginx运行的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> www www; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#nginx进程数，通常设置成和cpu的数量相等</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">4</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  /data/nginx/logs/error.log;</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  /data/nginx/logs/error.log  notice;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#日志文件存放路径 access_log path [format [buffer=size | off]]</span></span><br><span class=\"line\"><span class=\"attribute\">access_log</span> /data/nginx/logs/lazyegg.com/web/access.log combinedio;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程pid文件</span></span><br><span class=\"line\"><span class=\"comment\">#pid        logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#指定进程可以打开的最大描述符：数目</span></span><br><span class=\"line\"><span class=\"comment\">#工作模式与连接数上限</span></span><br><span class=\"line\"><span class=\"comment\">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class=\"line\"><span class=\"comment\">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class=\"line\"><span class=\"attribute\">worker_rlimit_nofile</span> <span class=\"number\">65535</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#################################  events  ###############################</span></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class=\"line\">    <span class=\"attribute\">use</span> <span class=\"literal\">epoll</span></span><br><span class=\"line\">    <span class=\"comment\">#单个进程最大连接数（最大连接数=连接数+进程数）</span></span><br><span class=\"line\">    worker_connections  <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#keepalive 超时时间</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span> <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户端请求头部的缓冲区大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">client_header_buffer_size</span> <span class=\"number\">4k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache</span> max=<span class=\"number\">65535</span> inactive=<span class=\"number\">60s</span>;</span><br><span class=\"line\">    <span class=\"comment\">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_valid</span> <span class=\"number\">80s</span>;</span><br><span class=\"line\">        <span class=\"comment\">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_min_uses</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##############################   http    ##################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class=\"line\">http&#123;</span><br><span class=\"line\">    <span class=\"comment\">#文件扩展名与文件类型映射表</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span> mime.types;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#默认文件类型</span></span><br><span class=\"line\">    <span class=\"attribute\">default_type</span> application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#默认编码</span></span><br><span class=\"line\">    <span class=\"attribute\">charset</span> utf-<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#服务器名字的hash表大小</span></span><br><span class=\"line\">    <span class=\"attribute\">server_names_hash_bucket_size</span> <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户端请求头部的缓冲区大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">client_header_buffer_size</span> <span class=\"number\">32k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户请求头缓冲大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">large_client_header_buffers</span> <span class=\"number\">4</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#允许客户端请求的最大单个文件字节数</span></span><br><span class=\"line\">    <span class=\"attribute\">client_max_body_size</span> <span class=\"number\">8m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启目录列表访问，适合下载服务器，默认关闭。</span></span><br><span class=\"line\">    <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class=\"line\">    <span class=\"attribute\">tcp_nopush</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">tcp_nodelay</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#长连接超时时间，单位是秒</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span> <span class=\"number\">120</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_connect_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_send_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_read_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_buffer_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_buffers</span> <span class=\"number\">4</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_busy_buffers_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_temp_file_write_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#gzip模块设置</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>; <span class=\"comment\">#开启gzip压缩输出</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_min_length</span> <span class=\"number\">1k</span>;    <span class=\"comment\">#最小压缩文件大小</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_buffers</span> <span class=\"number\">4</span> <span class=\"number\">16k</span>;    <span class=\"comment\">#压缩缓冲区</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_http_version</span> <span class=\"number\">1</span>.<span class=\"number\">0</span>; <span class=\"comment\">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_comp_level</span> <span class=\"number\">2</span>;     <span class=\"comment\">#压缩等级</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class=\"comment\">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_vary</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启限制IP连接数的时候需要使用</span></span><br><span class=\"line\">    <span class=\"comment\">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#负载均衡配置</span></span><br><span class=\"line\">    <span class=\"attribute\">upstream</span> lazyegg.net &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.121:80</span> weight=<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.122:80</span> weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.123:80</span> weight=<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#nginx的upstream目前支持4种方式的分配</span></span><br><span class=\"line\">        <span class=\"comment\">#1、轮询（默认）</span></span><br><span class=\"line\">        <span class=\"comment\">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class=\"line\">        <span class=\"comment\">#2、weight</span></span><br><span class=\"line\">        <span class=\"comment\">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class=\"line\">        <span class=\"comment\">#例如：</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.14 weight=10;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.15 weight=10;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#2、ip_hash</span></span><br><span class=\"line\">        <span class=\"comment\">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class=\"line\">        <span class=\"comment\">#例如：</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    ip_hash;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.14:88;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.15:80;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#3、fair（第三方）</span></span><br><span class=\"line\">        <span class=\"comment\">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream backend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server server1;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server server2;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fair;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#4、url_hash（第三方）</span></span><br><span class=\"line\">        <span class=\"comment\">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class=\"line\">        <span class=\"comment\">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream backend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server squid1:3128;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server squid2:3128;</span></span><br><span class=\"line\">        <span class=\"comment\">#    hash $request_uri;</span></span><br><span class=\"line\">        <span class=\"comment\">#    hash_method crc32;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#tips:</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    ip_hash;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:9090 down;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:6060;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:7070 backup;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#每个设备的状态设置为:</span></span><br><span class=\"line\">        <span class=\"comment\">#1.down表示单前的server暂时不参与负载</span></span><br><span class=\"line\">        <span class=\"comment\">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class=\"line\">        <span class=\"comment\">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class=\"line\">        <span class=\"comment\">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class=\"line\">        <span class=\"comment\">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class=\"line\">        <span class=\"comment\">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class=\"line\">        <span class=\"comment\">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class=\"line\">        <span class=\"comment\">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">#虚拟主机的配置</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#域名可以有多个，用空格隔开</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> lazyegg.net;</span><br><span class=\"line\">        <span class=\"comment\">#默认入口文件名称</span></span><br><span class=\"line\">        <span class=\"attribute\">index</span> index.html index.htm index.php;</span><br><span class=\"line\">        <span class=\"attribute\">root</span> /data/www/lazyegg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#对******进行负载均衡</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(php|php5)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_pass</span> <span class=\"number\">127.0.0.1:9000</span>;</span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_index</span> index.php;</span><br><span class=\"line\">            <span class=\"attribute\">include</span> fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#图片缓存时间设置</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">expires</span> <span class=\"number\">10d</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#JS和CSS缓存时间设置</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(js|css)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">expires</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#日志格式设定</span></span><br><span class=\"line\">        <span class=\"comment\">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class=\"line\">        <span class=\"comment\">#$remote_user：用来记录客户端用户名称；</span></span><br><span class=\"line\">        <span class=\"comment\">#$time_local： 用来记录访问时间与时区；</span></span><br><span class=\"line\">        <span class=\"comment\">#$request： 用来记录请求的url与http协议；</span></span><br><span class=\"line\">        <span class=\"comment\">#$status： 用来记录请求状态；成功是200，</span></span><br><span class=\"line\">        <span class=\"comment\">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class=\"line\">        <span class=\"comment\">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class=\"line\">        <span class=\"comment\">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class=\"line\">        <span class=\"comment\">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class=\"line\">        <span class=\"attribute\">log_format</span> access <span class=\"string\">'<span class=\"variable\">$remote_addr</span> - <span class=\"variable\">$remote_user</span> [<span class=\"variable\">$time_local</span>] \"<span class=\"variable\">$request</span>\" '</span></span><br><span class=\"line\">        <span class=\"string\">'<span class=\"variable\">$status</span> <span class=\"variable\">$body_bytes_sent</span> \"<span class=\"variable\">$http_referer</span>\" '</span></span><br><span class=\"line\">        <span class=\"string\">'\"<span class=\"variable\">$http_user_agent</span>\" <span class=\"variable\">$http_x_forwarded_for</span>'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#定义本虚拟主机的访问日志</span></span><br><span class=\"line\">        <span class=\"attribute\">access_log</span>  /usr/local/nginx/logs/host.access.log  main;</span><br><span class=\"line\">        <span class=\"attribute\">access_log</span>  /usr/local/nginx/logs/host.access.<span class=\"number\">404</span>.log  log404;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#对 \"/connect-controller\" 启用反向代理</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> /connect-controller &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:88; <span class=\"comment\">#请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_redirect</span> <span class=\"literal\">off</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#以下是一些反向代理的配置，可选。</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#允许客户端请求的最大单文件字节数</span></span><br><span class=\"line\">            <span class=\"attribute\">client_max_body_size</span> <span class=\"number\">10m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class=\"line\">            <span class=\"comment\">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class=\"line\">            <span class=\"comment\">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class=\"line\">            <span class=\"attribute\">client_body_buffer_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_intercept_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class=\"line\">            <span class=\"comment\">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_connect_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_send_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class=\"line\">            <span class=\"comment\">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_read_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class=\"line\">            <span class=\"comment\">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffer_size</span> <span class=\"number\">4k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class=\"line\">            <span class=\"comment\">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffers</span> <span class=\"number\">4</span> <span class=\"number\">32k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_busy_buffers_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class=\"line\">            <span class=\"comment\">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_temp_file_write_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#本地动静分离反向代理配置</span></span><br><span class=\"line\">        <span class=\"comment\">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参考<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/s15ZvxkHrRXYblzwuqFW2g\" target=\"_blank\" rel=\"noopener\">Nginx的这些妙用，你肯定有不知道的！</a></li>\n<li><a href=\"https://juejin.im/post/5c1616186fb9a049a42ef21d\" target=\"_blank\" rel=\"noopener\">nginx.conf 配置文件详解</a></li>\n<li><a href=\"https://blog.51cto.com/onlyzq/535279\" target=\"_blank\" rel=\"noopener\">关于Nginx的server_name</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1370009\" target=\"_blank\" rel=\"noopener\">nginx配置自定义变量实现日志动态分发</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008061457\" target=\"_blank\" rel=\"noopener\">proxy_pass的小说明</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>关于nginx使用的一些基本知识和实践，持续更新。</p>","more":"<ul>\n<li><p>nginx.config</p>\n<ul>\n<li>使用<code>nginx -t</code>验证配置文件</li>\n<li><code>/usr/local/etc/nginx/</code></li>\n<li>方便管理，可以使用软链的方式，把这些文件统一管理<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ln -s /usr/local/etc/nginx /Users/xxx/xxx</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><p>配置</p>\n<ul>\n<li>配置类型<ul>\n<li>http块<ul>\n<li>包括 HTTP 全局块、Server 块</li>\n<li>HTTP 全局块<br>HTTP 全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。</li>\n<li>Server 块，虚拟服务器<br>它描述的是一组根据不同server_name指令逻辑分割的资源，这些虚拟服务器响应 HTTP 请求，因此都包含在 HTTP 部分。</li>\n<li>Location 块<ul>\n<li>= ：该修饰符使用精确匹配并且终止搜索</li>\n<li>~：该修饰符使用区分大小写的正则表达式匹配</li>\n<li>~*：该修饰符使用不区分大小写的正则表达式匹配</li>\n<li>^~：用于不含正则表达式的 URI 前，要求 Nginx 服务器找到标识 URI 和请求字符串匹配度最高的 Location 后，立即使用此 Location 处理请求，而不再使用 Location 块中的正则 URI 和请求字符串做匹配。</li>\n<li>注意：如果 URI 包含正则表达式，则必须要有 ~ 或者 ~* 标识。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>全局配置块<br>全局配置部分用来配置对整个 Server 都有效的参数。主要会设置一些影响 Nginx 服务器整体运行的配置指令，包括配置运行 Nginx 服务器的用户（组）、允许生成的 Worker Process 数，进程 PID 存放路径、日志存放路径和类型以及配置文件的引入等。</li>\n<li>events配置块<br>Events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 Work Process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 Word Process 可以同时支持的最大连接数等。</li>\n</ul>\n</li>\n<li>配置语法<ul>\n<li>配置文件由指令和指令块构成</li>\n<li>每条指令以分号（;）结尾，指令和参数间以空格符分隔</li>\n<li>指令块以大括号{}将多条指令组织在一起</li>\n<li>include 语句允许组合多个配置文件以提高可维护性</li>\n<li>使用 # 添加注释</li>\n<li>使用 $ 定义变量</li>\n<li>部分指令的参数支持正则表达式<ul>\n<li>local</li>\n<li>server_name</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>灵活使用include</p>\n</li>\n<li><p>常用命令</p>\n<ul>\n<li>nginx -s stop</li>\n<li>nginx -s reload</li>\n<li>nginx -t</li>\n</ul>\n</li>\n<li><p>常用指令</p>\n<ul>\n<li>server_name<ul>\n<li>精确匹配</li>\n<li>通配符</li>\n<li>正则匹配，可以捕获匹配项</li>\n</ul>\n</li>\n<li>proxy_pass<ul>\n<li>使用变量时，必需要用resolver指令解析变量中的域名<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server_name www.fleven.com;</span><br><span class=\"line\">server_name www.fleven.;</span><br><span class=\"line\">server_name .fleven.com;</span><br><span class=\"line\">server_name ~^[w]+.fleven.com$;</span><br></pre></td></tr></table></figure></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>匹配顺序</p>\n<ul>\n<li>nginx里面有很多需要匹配的地方，比如server_name,local, 这些匹配按照从上到下的顺序执行，一旦匹配成功就停止后续的匹配，所以这些匹配条件的顺序是越精确的越在前面，越模糊的越在后面；</li>\n</ul>\n</li>\n<li><p>demo</p>\n<figure class=\"highlight nginx\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 全局配置</span></span><br><span class=\"line\"><span class=\"comment\">#定义Nginx运行的用户和用户组</span></span><br><span class=\"line\"><span class=\"attribute\">user</span> www www; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#nginx进程数，通常设置成和cpu的数量相等</span></span><br><span class=\"line\"><span class=\"attribute\">worker_processes</span> <span class=\"number\">4</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#全局错误日志定义类型，[debug | info | notice | warn | error | crit]</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  /data/nginx/logs/error.log;</span></span><br><span class=\"line\"><span class=\"comment\">#error_log  /data/nginx/logs/error.log  notice;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#日志文件存放路径 access_log path [format [buffer=size | off]]</span></span><br><span class=\"line\"><span class=\"attribute\">access_log</span> /data/nginx/logs/lazyegg.com/web/access.log combinedio;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#进程pid文件</span></span><br><span class=\"line\"><span class=\"comment\">#pid        logs/nginx.pid;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#指定进程可以打开的最大描述符：数目</span></span><br><span class=\"line\"><span class=\"comment\">#工作模式与连接数上限</span></span><br><span class=\"line\"><span class=\"comment\">##这个指令是指当一个nginx进程打开的最多文件描述符数目，理论值应该是最多打开文件数（ulimit -n）与nginx进程数相除，但是nginx分配请求并不是那么均匀，所以最好与ulimit -n 的值保持一致。</span></span><br><span class=\"line\"><span class=\"comment\">#这是因为nginx调度时分配请求到进程并不是那么的均衡，所以假如填写10240，总并发量达到3-4万时就有进程可能超过10240了，这时会返回502错误。</span></span><br><span class=\"line\"><span class=\"attribute\">worker_rlimit_nofile</span> <span class=\"number\">65535</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#################################  events  ###############################</span></span><br><span class=\"line\"><span class=\"section\">events</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">#参考事件模型，use [ kqueue | rtsig | epoll | /dev/poll | select | poll ]; epoll模型</span></span><br><span class=\"line\">    <span class=\"attribute\">use</span> <span class=\"literal\">epoll</span></span><br><span class=\"line\">    <span class=\"comment\">#单个进程最大连接数（最大连接数=连接数+进程数）</span></span><br><span class=\"line\">    worker_connections  <span class=\"number\">1024</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#keepalive 超时时间</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span> <span class=\"number\">60</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户端请求头部的缓冲区大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">client_header_buffer_size</span> <span class=\"number\">4k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#这个将为打开文件指定缓存，默认是没有启用的，max指定缓存数量，建议和打开文件数一致，inactive是指经过多长时间文件没被请求后删除缓存。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache</span> max=<span class=\"number\">65535</span> inactive=<span class=\"number\">60s</span>;</span><br><span class=\"line\">    <span class=\"comment\">#这个是指多长时间检查一次缓存的有效信息。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_valid</span> <span class=\"number\">80s</span>;</span><br><span class=\"line\">        <span class=\"comment\">#open_file_cache指令中的inactive参数时间内文件的最少使用次数，如果超过这个数字，文件描述符一直是在缓存中打开的，如上例，如果有一个文件在inactive时间内一次没被使用，它将被移除。</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_min_uses</span> <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#语法:open_file_cache_errors on | off 默认值:open_file_cache_errors off 使用字段:http, server, location 这个指令指定是否在搜索一个文件是记录cache错误.</span></span><br><span class=\"line\">    <span class=\"attribute\">open_file_cache_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">##############################   http    ##################################</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#设定http服务器，利用它的反向代理功能提供负载均衡支持</span></span><br><span class=\"line\">http&#123;</span><br><span class=\"line\">    <span class=\"comment\">#文件扩展名与文件类型映射表</span></span><br><span class=\"line\">    <span class=\"attribute\">include</span> mime.types;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#默认文件类型</span></span><br><span class=\"line\">    <span class=\"attribute\">default_type</span> application/octet-stream;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#默认编码</span></span><br><span class=\"line\">    <span class=\"attribute\">charset</span> utf-<span class=\"number\">8</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#服务器名字的hash表大小</span></span><br><span class=\"line\">    <span class=\"attribute\">server_names_hash_bucket_size</span> <span class=\"number\">128</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户端请求头部的缓冲区大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">client_header_buffer_size</span> <span class=\"number\">32k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#客户请求头缓冲大小。</span></span><br><span class=\"line\">    <span class=\"attribute\">large_client_header_buffers</span> <span class=\"number\">4</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#允许客户端请求的最大单个文件字节数</span></span><br><span class=\"line\">    <span class=\"attribute\">client_max_body_size</span> <span class=\"number\">8m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启高效文件传输模式，sendfile指令指定nginx是否调用sendfile函数来输出文件，对于普通应用设为 on，如果用来进行下载等应用磁盘IO重负载应用，可设置为off，以平衡磁盘与网络I/O处理速度，降低系统的负载。注意：如果图片显示不正常把这个改成off。</span></span><br><span class=\"line\">    <span class=\"attribute\">sendfile</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启目录列表访问，适合下载服务器，默认关闭。</span></span><br><span class=\"line\">    <span class=\"attribute\">autoindex</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#此选项允许或禁止使用socke的TCP_CORK的选项，此选项仅在使用sendfile的时候使用</span></span><br><span class=\"line\">    <span class=\"attribute\">tcp_nopush</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"attribute\">tcp_nodelay</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#长连接超时时间，单位是秒</span></span><br><span class=\"line\">    <span class=\"attribute\">keepalive_timeout</span> <span class=\"number\">120</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#FastCGI相关参数是为了改善网站的性能：减少资源占用，提高访问速度。下面参数看字面意思都能理解。</span></span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_connect_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_send_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_read_timeout</span> <span class=\"number\">300</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_buffer_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_buffers</span> <span class=\"number\">4</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_busy_buffers_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\">    <span class=\"attribute\">fastcgi_temp_file_write_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#gzip模块设置</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip</span> <span class=\"literal\">on</span>; <span class=\"comment\">#开启gzip压缩输出</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_min_length</span> <span class=\"number\">1k</span>;    <span class=\"comment\">#最小压缩文件大小</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_buffers</span> <span class=\"number\">4</span> <span class=\"number\">16k</span>;    <span class=\"comment\">#压缩缓冲区</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_http_version</span> <span class=\"number\">1</span>.<span class=\"number\">0</span>; <span class=\"comment\">#压缩版本（默认1.1，前端如果是squid2.5请使用1.0）</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_comp_level</span> <span class=\"number\">2</span>;     <span class=\"comment\">#压缩等级</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_types</span> text/plain application/x-javascript text/css application/xml;    <span class=\"comment\">#压缩类型，默认就已经包含textml，所以下面就不用再写了，写上去也不会有问题，但是会有一个warn。</span></span><br><span class=\"line\">    <span class=\"attribute\">gzip_vary</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#开启限制IP连接数的时候需要使用</span></span><br><span class=\"line\">    <span class=\"comment\">#limit_zone crawler $binary_remote_addr 10m;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#负载均衡配置</span></span><br><span class=\"line\">    <span class=\"attribute\">upstream</span> lazyegg.net &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#upstream的负载均衡，weight是权重，可以根据机器配置定义权重。weigth参数表示权值，权值越高被分配到的几率越大。</span></span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.121:80</span> weight=<span class=\"number\">3</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.122:80</span> weight=<span class=\"number\">2</span>;</span><br><span class=\"line\">        <span class=\"attribute\">server</span> <span class=\"number\">192.168.80.123:80</span> weight=<span class=\"number\">3</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#nginx的upstream目前支持4种方式的分配</span></span><br><span class=\"line\">        <span class=\"comment\">#1、轮询（默认）</span></span><br><span class=\"line\">        <span class=\"comment\">#每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。</span></span><br><span class=\"line\">        <span class=\"comment\">#2、weight</span></span><br><span class=\"line\">        <span class=\"comment\">#指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。</span></span><br><span class=\"line\">        <span class=\"comment\">#例如：</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.14 weight=10;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.15 weight=10;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#2、ip_hash</span></span><br><span class=\"line\">        <span class=\"comment\">#每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</span></span><br><span class=\"line\">        <span class=\"comment\">#例如：</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    ip_hash;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.14:88;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 192.168.0.15:80;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#3、fair（第三方）</span></span><br><span class=\"line\">        <span class=\"comment\">#按后端服务器的响应时间来分配请求，响应时间短的优先分配。</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream backend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server server1;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server server2;</span></span><br><span class=\"line\">        <span class=\"comment\">#    fair;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#4、url_hash（第三方）</span></span><br><span class=\"line\">        <span class=\"comment\">#按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。</span></span><br><span class=\"line\">        <span class=\"comment\">#例：在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream backend &#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server squid1:3128;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server squid2:3128;</span></span><br><span class=\"line\">        <span class=\"comment\">#    hash $request_uri;</span></span><br><span class=\"line\">        <span class=\"comment\">#    hash_method crc32;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#tips:</span></span><br><span class=\"line\">        <span class=\"comment\">#upstream bakend&#123;#定义负载均衡设备的Ip及设备状态&#125;&#123;</span></span><br><span class=\"line\">        <span class=\"comment\">#    ip_hash;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:9090 down;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:8080 weight=2;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:6060;</span></span><br><span class=\"line\">        <span class=\"comment\">#    server 127.0.0.1:7070 backup;</span></span><br><span class=\"line\">        <span class=\"comment\">#&#125;</span></span><br><span class=\"line\">        <span class=\"comment\">#在需要使用负载均衡的server中增加 proxy_pass http://bakend/;</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#每个设备的状态设置为:</span></span><br><span class=\"line\">        <span class=\"comment\">#1.down表示单前的server暂时不参与负载</span></span><br><span class=\"line\">        <span class=\"comment\">#2.weight为weight越大，负载的权重就越大。</span></span><br><span class=\"line\">        <span class=\"comment\">#3.max_fails：允许请求失败的次数默认为1.当超过最大次数时，返回proxy_next_upstream模块定义的错误</span></span><br><span class=\"line\">        <span class=\"comment\">#4.fail_timeout:max_fails次失败后，暂停的时间。</span></span><br><span class=\"line\">        <span class=\"comment\">#5.backup： 其它所有的非backup机器down或者忙的时候，请求backup机器。所以这台机器压力会最轻。</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#nginx支持同时设置多组的负载均衡，用来给不用的server来使用。</span></span><br><span class=\"line\">        <span class=\"comment\">#client_body_in_file_only设置为On 可以讲client post过来的数据记录到文件中用来做debug</span></span><br><span class=\"line\">        <span class=\"comment\">#client_body_temp_path设置记录文件的目录 可以设置最多3层目录</span></span><br><span class=\"line\">        <span class=\"comment\">#location对URL进行匹配.可以进行重定向或者进行新的代理 负载均衡</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">#虚拟主机的配置</span></span><br><span class=\"line\">    <span class=\"section\">server</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">#监听端口</span></span><br><span class=\"line\">        <span class=\"attribute\">listen</span> <span class=\"number\">80</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#域名可以有多个，用空格隔开</span></span><br><span class=\"line\">        <span class=\"attribute\">server_name</span> lazyegg.net;</span><br><span class=\"line\">        <span class=\"comment\">#默认入口文件名称</span></span><br><span class=\"line\">        <span class=\"attribute\">index</span> index.html index.htm index.php;</span><br><span class=\"line\">        <span class=\"attribute\">root</span> /data/www/lazyegg;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#对******进行负载均衡</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(php|php5)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_pass</span> <span class=\"number\">127.0.0.1:9000</span>;</span><br><span class=\"line\">            <span class=\"attribute\">fastcgi_index</span> index.php;</span><br><span class=\"line\">            <span class=\"attribute\">include</span> fastcgi.conf;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#图片缓存时间设置</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(gif|jpg|jpeg|png|bmp|swf)$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">expires</span> <span class=\"number\">10d</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#JS和CSS缓存时间设置</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .*.(js|css)?$</span></span><br><span class=\"line\"><span class=\"regexp\"></span>        &#123;</span><br><span class=\"line\">            <span class=\"attribute\">expires</span> <span class=\"number\">1h</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#日志格式设定</span></span><br><span class=\"line\">        <span class=\"comment\">#$remote_addr与$http_x_forwarded_for用以记录客户端的ip地址；</span></span><br><span class=\"line\">        <span class=\"comment\">#$remote_user：用来记录客户端用户名称；</span></span><br><span class=\"line\">        <span class=\"comment\">#$time_local： 用来记录访问时间与时区；</span></span><br><span class=\"line\">        <span class=\"comment\">#$request： 用来记录请求的url与http协议；</span></span><br><span class=\"line\">        <span class=\"comment\">#$status： 用来记录请求状态；成功是200，</span></span><br><span class=\"line\">        <span class=\"comment\">#$body_bytes_sent ：记录发送给客户端文件主体内容大小；</span></span><br><span class=\"line\">        <span class=\"comment\">#$http_referer：用来记录从那个页面链接访问过来的；</span></span><br><span class=\"line\">        <span class=\"comment\">#$http_user_agent：记录客户浏览器的相关信息；</span></span><br><span class=\"line\">        <span class=\"comment\">#通常web服务器放在反向代理的后面，这样就不能获取到客户的IP地址了，通过$remote_add拿到的IP地址是反向代理服务器的iP地址。反向代理服务器在转发请求的http头信息中，可以增加x_forwarded_for信息，用以记录原有客户端的IP地址和原来客户端的请求的服务器地址。</span></span><br><span class=\"line\">        <span class=\"attribute\">log_format</span> access <span class=\"string\">'<span class=\"variable\">$remote_addr</span> - <span class=\"variable\">$remote_user</span> [<span class=\"variable\">$time_local</span>] \"<span class=\"variable\">$request</span>\" '</span></span><br><span class=\"line\">        <span class=\"string\">'<span class=\"variable\">$status</span> <span class=\"variable\">$body_bytes_sent</span> \"<span class=\"variable\">$http_referer</span>\" '</span></span><br><span class=\"line\">        <span class=\"string\">'\"<span class=\"variable\">$http_user_agent</span>\" <span class=\"variable\">$http_x_forwarded_for</span>'</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#定义本虚拟主机的访问日志</span></span><br><span class=\"line\">        <span class=\"attribute\">access_log</span>  /usr/local/nginx/logs/host.access.log  main;</span><br><span class=\"line\">        <span class=\"attribute\">access_log</span>  /usr/local/nginx/logs/host.access.<span class=\"number\">404</span>.log  log404;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#对 \"/connect-controller\" 启用反向代理</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> /connect-controller &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:88; <span class=\"comment\">#请注意此处端口号不能与虚拟主机监听的端口号一样（也就是server监听的端口）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_redirect</span> <span class=\"literal\">off</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端的Web服务器可以通过X-Forwarded-For获取用户真实IP</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#以下是一些反向代理的配置，可选。</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#允许客户端请求的最大单文件字节数</span></span><br><span class=\"line\">            <span class=\"attribute\">client_max_body_size</span> <span class=\"number\">10m</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#缓冲区代理缓冲用户端请求的最大字节数，</span></span><br><span class=\"line\">            <span class=\"comment\">#如果把它设置为比较大的数值，例如256k，那么，无论使用firefox还是IE浏览器，来提交任意小于256k的图片，都很正常。如果注释该指令，使用默认的client_body_buffer_size设置，也就是操作系统页面大小的两倍，8k或者16k，问题就出现了。</span></span><br><span class=\"line\">            <span class=\"comment\">#无论使用firefox4.0还是IE8.0，提交一个比较大，200k左右的图片，都返回500 Internal Server Error错误</span></span><br><span class=\"line\">            <span class=\"attribute\">client_body_buffer_size</span> <span class=\"number\">128k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#表示使nginx阻止HTTP应答代码为400或者更高的应答。</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_intercept_errors</span> <span class=\"literal\">on</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器连接的超时时间_发起握手等候响应超时时间</span></span><br><span class=\"line\">            <span class=\"comment\">#nginx跟后端服务器连接超时时间(代理连接超时)</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_connect_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器数据回传时间(代理发送超时)</span></span><br><span class=\"line\">            <span class=\"comment\">#后端服务器数据回传时间_就是在规定时间之内后端服务器必须传完所有的数据</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_send_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#连接成功后，后端服务器响应时间(代理接收超时)</span></span><br><span class=\"line\">            <span class=\"comment\">#连接成功后_等候后端服务器响应时间_其实已经进入后端的排队之中等候处理（也可以说是后端服务器处理请求的时间）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_read_timeout</span> <span class=\"number\">90</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#设置代理服务器（nginx）保存用户头信息的缓冲区大小</span></span><br><span class=\"line\">            <span class=\"comment\">#设置从被代理服务器读取的第一部分应答的缓冲区大小，通常情况下这部分应答中包含一个小的应答头，默认情况下这个值的大小为指令proxy_buffers中指定的一个缓冲区的大小，不过可以将其设置为更小</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffer_size</span> <span class=\"number\">4k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#proxy_buffers缓冲区，网页平均在32k以下的设置</span></span><br><span class=\"line\">            <span class=\"comment\">#设置用于读取应答（来自被代理服务器）的缓冲区数目和大小，默认情况也为分页大小，根据操作系统的不同可能是4k或者8k</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_buffers</span> <span class=\"number\">4</span> <span class=\"number\">32k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#高负荷下缓冲大小（proxy_buffers*2）</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_busy_buffers_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"comment\">#设置在写入proxy_temp_path时数据的大小，预防一个工作进程在传递文件时阻塞太长</span></span><br><span class=\"line\">            <span class=\"comment\">#设定缓存文件夹大小，大于这个值，将从upstream服务器传</span></span><br><span class=\"line\">            <span class=\"attribute\">proxy_temp_file_write_size</span> <span class=\"number\">64k</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">#本地动静分离反向代理配置</span></span><br><span class=\"line\">        <span class=\"comment\">#所有jsp的页面均交由tomcat或resin处理</span></span><br><span class=\"line\">        <span class=\"attribute\">location</span> <span class=\"regexp\">~ .(jsp|jspx|do)?$</span> &#123;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> Host <span class=\"variable\">$host</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Real-IP <span class=\"variable\">$remote_addr</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_set_header</span> X-Forwarded-For <span class=\"variable\">$proxy_add_x_forwarded_for</span>;</span><br><span class=\"line\">            <span class=\"attribute\">proxy_pass</span> http://127.0.0.1:8080;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参考<ul>\n<li><a href=\"https://mp.weixin.qq.com/s/s15ZvxkHrRXYblzwuqFW2g\" target=\"_blank\" rel=\"noopener\">Nginx的这些妙用，你肯定有不知道的！</a></li>\n<li><a href=\"https://juejin.im/post/5c1616186fb9a049a42ef21d\" target=\"_blank\" rel=\"noopener\">nginx.conf 配置文件详解</a></li>\n<li><a href=\"https://blog.51cto.com/onlyzq/535279\" target=\"_blank\" rel=\"noopener\">关于Nginx的server_name</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1370009\" target=\"_blank\" rel=\"noopener\">nginx配置自定义变量实现日志动态分发</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000008061457\" target=\"_blank\" rel=\"noopener\">proxy_pass的小说明</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"},{"title":"搭建git服务器","date":"2020-02-04T08:02:25.000Z","_content":"\n以centos为例，简单介绍如何搭建git服务器。\n<!-- more -->\n\n# 安装git\n```shell\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel\nyum install git\n```\n# 创建用户\n创建一个git用户组和用户，用于运行git服务，并设置密码\n```shell\nsudo groupadd git\nsudo useradd -g git\nsudo passwd git\n```\n# 创建登录证书\n 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub, 把公钥导入到/home/git/.ssh/authorized_keys，如果需要创建：\n```shell\ncd /home/git/\nmkdir .ssh\nchmod 755 .ssh\ntouch .ssh/authorized_keys\nchmod 644 .ssh/authorized_keys\n```\n# 初始化git仓库\n需要选定一个目录作为git仓库，比如/home/gitrepo/demo.git\n```shell\ncd /home\nmkdir gitrepo\nchown git:git gitrepo\ncd gitrepo\n\n# 创建仓库\ngit init —bare demo.git\n```\n\n# 修改仓库的用户组和用户\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n```shell\nchown -R git:git demo.git\n```\n\n# 禁用用户git的shell登录\n处于安全考虑，用户git禁用shell登录\n```shell\nvi /etc/passwd\n#git:x:1001:1001:,,,:/home/git:/bin/bash 改成\ngit:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n```\n\n# clone 远程仓库\n至此，git仓库就可以使用了\n```shell\ngit clone git@192.168.1.1:/home/gitrepo/demo.git\n```\n\n参考\n- [搭建git服务器](https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664)\n- [git服务器搭建](https://www.runoob.com/git/git-server.html)","source":"_posts/git服务器搭建.md","raw":"---\ntitle: 搭建git服务器\ndate: 2020-02-04 16:02:25\ntags: git\n---\n\n以centos为例，简单介绍如何搭建git服务器。\n<!-- more -->\n\n# 安装git\n```shell\nyum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel\nyum install git\n```\n# 创建用户\n创建一个git用户组和用户，用于运行git服务，并设置密码\n```shell\nsudo groupadd git\nsudo useradd -g git\nsudo passwd git\n```\n# 创建登录证书\n 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub, 把公钥导入到/home/git/.ssh/authorized_keys，如果需要创建：\n```shell\ncd /home/git/\nmkdir .ssh\nchmod 755 .ssh\ntouch .ssh/authorized_keys\nchmod 644 .ssh/authorized_keys\n```\n# 初始化git仓库\n需要选定一个目录作为git仓库，比如/home/gitrepo/demo.git\n```shell\ncd /home\nmkdir gitrepo\nchown git:git gitrepo\ncd gitrepo\n\n# 创建仓库\ngit init —bare demo.git\n```\n\n# 修改仓库的用户组和用户\nGit就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：\n```shell\nchown -R git:git demo.git\n```\n\n# 禁用用户git的shell登录\n处于安全考虑，用户git禁用shell登录\n```shell\nvi /etc/passwd\n#git:x:1001:1001:,,,:/home/git:/bin/bash 改成\ngit:x:1001:1001:,,,:/home/git:/usr/bin/git-shell\n```\n\n# clone 远程仓库\n至此，git仓库就可以使用了\n```shell\ngit clone git@192.168.1.1:/home/gitrepo/demo.git\n```\n\n参考\n- [搭建git服务器](https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664)\n- [git服务器搭建](https://www.runoob.com/git/git-server.html)","slug":"git服务器搭建","published":1,"updated":"2020-02-04T08:07:40.861Z","_id":"ck67ln3vk0000tqiy39msbbid","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以centos为例，简单介绍如何搭建git服务器。</p>\n<a id=\"more\"></a>\n\n<h1 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h1><p>创建一个git用户组和用户，用于运行git服务，并设置密码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo groupadd git</span><br><span class=\"line\">sudo useradd -g git</span><br><span class=\"line\">sudo passwd git</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建登录证书\"><a href=\"#创建登录证书\" class=\"headerlink\" title=\"创建登录证书\"></a>创建登录证书</h1><p> 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub, 把公钥导入到/home/git/.ssh/authorized_keys，如果需要创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/</span><br><span class=\"line\">mkdir .ssh</span><br><span class=\"line\">chmod 755 .ssh</span><br><span class=\"line\">touch .ssh/authorized_keys</span><br><span class=\"line\">chmod 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n<h1 id=\"初始化git仓库\"><a href=\"#初始化git仓库\" class=\"headerlink\" title=\"初始化git仓库\"></a>初始化git仓库</h1><p>需要选定一个目录作为git仓库，比如/home/gitrepo/demo.git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home</span><br><span class=\"line\">mkdir gitrepo</span><br><span class=\"line\">chown git:git gitrepo</span><br><span class=\"line\">cd gitrepo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建仓库</span></span><br><span class=\"line\">git init —bare demo.git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改仓库的用户组和用户\"><a href=\"#修改仓库的用户组和用户\" class=\"headerlink\" title=\"修改仓库的用户组和用户\"></a>修改仓库的用户组和用户</h1><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R git:git demo.git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"禁用用户git的shell登录\"><a href=\"#禁用用户git的shell登录\" class=\"headerlink\" title=\"禁用用户git的shell登录\"></a>禁用用户git的shell登录</h1><p>处于安全考虑，用户git禁用shell登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/passwd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">git:x:1001:1001:,,,:/home/git:/bin/bash 改成</span></span><br><span class=\"line\">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"clone-远程仓库\"><a href=\"#clone-远程仓库\" class=\"headerlink\" title=\"clone 远程仓库\"></a>clone 远程仓库</h1><p>至此，git仓库就可以使用了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@192.168.1.1:/home/gitrepo/demo.git</span><br></pre></td></tr></table></figure>\n\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664\" target=\"_blank\" rel=\"noopener\">搭建git服务器</a></li>\n<li><a href=\"https://www.runoob.com/git/git-server.html\" target=\"_blank\" rel=\"noopener\">git服务器搭建</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>以centos为例，简单介绍如何搭建git服务器。</p>","more":"<h1 id=\"安装git\"><a href=\"#安装git\" class=\"headerlink\" title=\"安装git\"></a>安装git</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-devel</span><br><span class=\"line\">yum install git</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建用户\"><a href=\"#创建用户\" class=\"headerlink\" title=\"创建用户\"></a>创建用户</h1><p>创建一个git用户组和用户，用于运行git服务，并设置密码</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo groupadd git</span><br><span class=\"line\">sudo useradd -g git</span><br><span class=\"line\">sudo passwd git</span><br></pre></td></tr></table></figure>\n<h1 id=\"创建登录证书\"><a href=\"#创建登录证书\" class=\"headerlink\" title=\"创建登录证书\"></a>创建登录证书</h1><p> 收集所有需要登录的用户的公钥，公钥位于id_rsa.pub, 把公钥导入到/home/git/.ssh/authorized_keys，如果需要创建：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home/git/</span><br><span class=\"line\">mkdir .ssh</span><br><span class=\"line\">chmod 755 .ssh</span><br><span class=\"line\">touch .ssh/authorized_keys</span><br><span class=\"line\">chmod 644 .ssh/authorized_keys</span><br></pre></td></tr></table></figure>\n<h1 id=\"初始化git仓库\"><a href=\"#初始化git仓库\" class=\"headerlink\" title=\"初始化git仓库\"></a>初始化git仓库</h1><p>需要选定一个目录作为git仓库，比如/home/gitrepo/demo.git</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /home</span><br><span class=\"line\">mkdir gitrepo</span><br><span class=\"line\">chown git:git gitrepo</span><br><span class=\"line\">cd gitrepo</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> 创建仓库</span></span><br><span class=\"line\">git init —bare demo.git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"修改仓库的用户组和用户\"><a href=\"#修改仓库的用户组和用户\" class=\"headerlink\" title=\"修改仓库的用户组和用户\"></a>修改仓库的用户组和用户</h1><p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">chown -R git:git demo.git</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"禁用用户git的shell登录\"><a href=\"#禁用用户git的shell登录\" class=\"headerlink\" title=\"禁用用户git的shell登录\"></a>禁用用户git的shell登录</h1><p>处于安全考虑，用户git禁用shell登录</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /etc/passwd</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">git:x:1001:1001:,,,:/home/git:/bin/bash 改成</span></span><br><span class=\"line\">git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"clone-远程仓库\"><a href=\"#clone-远程仓库\" class=\"headerlink\" title=\"clone 远程仓库\"></a>clone 远程仓库</h1><p>至此，git仓库就可以使用了</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone git@192.168.1.1:/home/gitrepo/demo.git</span><br></pre></td></tr></table></figure>\n\n<p>参考</p>\n<ul>\n<li><a href=\"https://www.liaoxuefeng.com/wiki/896043488029600/899998870925664\" target=\"_blank\" rel=\"noopener\">搭建git服务器</a></li>\n<li><a href=\"https://www.runoob.com/git/git-server.html\" target=\"_blank\" rel=\"noopener\">git服务器搭建</a></li>\n</ul>"},{"title":"关于相声之浅见","date":"2020-02-04T15:06:44.000Z","_content":"\n我喜欢相声。\n<!-- more -->\n小学初中时，听收音机，看综艺大观，唐爱国的懒汉糖葫芦是我最喜欢的相声，我们某个时候不就是那个懒汉吗，总是喜欢幻想，现实却是多么骨干。\n\n<!-- more -->\n\n高中时，大概2002年前后，省吃俭用，攒了5块钱，买了一盒相声大全的磁带，主要是姜昆和唐杰忠相声，里面有姜昆的虎口遐想等等，还有一个侯宝林的原声录音，这个磁带我翻来覆去的听。很多段子我都能说下来，说实话我是很喜欢姜昆和唐杰忠的相声，他们给了我那个年代的快乐。\n\n在我大学的时候，睡前除了听中国之声的《天涯共此时》， 也开始听郭德纲的段子。MP3，MP4里面大部分是老郭的段子，那时候老郭还没有固定的“于谦\"，段子的主角一般是“我”，里面的事都是自我的幻想，自我的讽刺，自我的挖苦，自我的乖张，自我的觉醒，自我的奋进，自我调侃，也不低俗，也不损人。那些段子就像是说我们自己的在学校或者刚工作时的挣扎，幻想，失落与调侃。\n\n后来工作了也怎么听相声了，再后来，就老郭和于谦的段子了，再听就没有之前有趣，也是境地换了，老郭的段子除了笑，也没有啥了，渐渐也就不听了。\n\n再后来就是老郭的各种八卦了，老郭其实不仅仅一个相声演员了，他更多的是个娱乐圈里的艺人了，电视，电影，综艺，没有他不参与的，这点有点像冯巩。其实我觉得也很难让他再拿出喜闻乐见的相声作品了。\n\n作为普通观众，我觉得文艺作品一定要有情感，这样才能打动人心, 才有生命力；情感是复杂，喜怒哀乐，悲伤，失落，快乐，痛苦等等...\n\n给我的感觉，这几年，老郭的段子只能给一类人看，就是缺”笑“的人，缺啥补啥。这类人慢慢成钢丝的主体，老郭也就越迎合他们，也就越来越没有雅俗共赏的元素了。\n\n以理科生的科研思维和工程思路，一切都可以“公式”化，其实这里的公式化，窃以为是产业化。有商业头脑的老郭肯定知道这个，要不然，他也不会办相声培训班了。相声公式化，意在解决相声创作难的问题，我认为这是一个有效的途径，这是让相声走进专业课堂的一个途径。\n\n这些年来，姜昆，冯巩等人都曾在相声人才的培养及相声教育上下了不少功夫，可是收效甚微，相声市场及人才还是萎靡不振。\n\n相声产业化是老郭现在正在做的事，当年老郭以一个草根的人设，其独特的语言风格在当时算是一声春雷，惊醒了那些靠体制吃饭，靠师承糊弄观众的缺乏新意的相声们。\n\n相声的其独特的语言特点，也让它的创新比较难，在当前网络传播快速的时代，一个包袱，甚至是包袱的思路，一经表演，就已经成为过去式，相声演员很难用一个段子一直表演，观众也不会买账。\n\n传统的相声演员显然没有看到这种传播速度的改变，也没有看到越来越越多的挑剔的观众。观众们的审美发生了根本的变化，跟过时候，观众贪图眼前的快乐，他们很少考虑段子背后的东西。然而师承严重的体制内相声，一直沿袭着建国后相声变革后的理念，寓教于乐，使得他们在创作上的约束太多，以至于很难在把日常，世俗，市侩，市井的元素放在创作里，从而使得他们的创作源泉越发枯竭。\n\n作为一个爱好者，我认为相声需要创新，我也不知道创新的方向在哪里，但我知道反正不应该是现在的这个样子；这种情况下，任何创新都是被容忍的，任何翻天覆地的创新都是从细微的改变而来。","source":"_posts/公式相声之浅见.md","raw":"---\ntitle: 关于相声之浅见\ndate: 2020-02-04 23:06:44\ntags: 社会思考\n---\n\n我喜欢相声。\n<!-- more -->\n小学初中时，听收音机，看综艺大观，唐爱国的懒汉糖葫芦是我最喜欢的相声，我们某个时候不就是那个懒汉吗，总是喜欢幻想，现实却是多么骨干。\n\n<!-- more -->\n\n高中时，大概2002年前后，省吃俭用，攒了5块钱，买了一盒相声大全的磁带，主要是姜昆和唐杰忠相声，里面有姜昆的虎口遐想等等，还有一个侯宝林的原声录音，这个磁带我翻来覆去的听。很多段子我都能说下来，说实话我是很喜欢姜昆和唐杰忠的相声，他们给了我那个年代的快乐。\n\n在我大学的时候，睡前除了听中国之声的《天涯共此时》， 也开始听郭德纲的段子。MP3，MP4里面大部分是老郭的段子，那时候老郭还没有固定的“于谦\"，段子的主角一般是“我”，里面的事都是自我的幻想，自我的讽刺，自我的挖苦，自我的乖张，自我的觉醒，自我的奋进，自我调侃，也不低俗，也不损人。那些段子就像是说我们自己的在学校或者刚工作时的挣扎，幻想，失落与调侃。\n\n后来工作了也怎么听相声了，再后来，就老郭和于谦的段子了，再听就没有之前有趣，也是境地换了，老郭的段子除了笑，也没有啥了，渐渐也就不听了。\n\n再后来就是老郭的各种八卦了，老郭其实不仅仅一个相声演员了，他更多的是个娱乐圈里的艺人了，电视，电影，综艺，没有他不参与的，这点有点像冯巩。其实我觉得也很难让他再拿出喜闻乐见的相声作品了。\n\n作为普通观众，我觉得文艺作品一定要有情感，这样才能打动人心, 才有生命力；情感是复杂，喜怒哀乐，悲伤，失落，快乐，痛苦等等...\n\n给我的感觉，这几年，老郭的段子只能给一类人看，就是缺”笑“的人，缺啥补啥。这类人慢慢成钢丝的主体，老郭也就越迎合他们，也就越来越没有雅俗共赏的元素了。\n\n以理科生的科研思维和工程思路，一切都可以“公式”化，其实这里的公式化，窃以为是产业化。有商业头脑的老郭肯定知道这个，要不然，他也不会办相声培训班了。相声公式化，意在解决相声创作难的问题，我认为这是一个有效的途径，这是让相声走进专业课堂的一个途径。\n\n这些年来，姜昆，冯巩等人都曾在相声人才的培养及相声教育上下了不少功夫，可是收效甚微，相声市场及人才还是萎靡不振。\n\n相声产业化是老郭现在正在做的事，当年老郭以一个草根的人设，其独特的语言风格在当时算是一声春雷，惊醒了那些靠体制吃饭，靠师承糊弄观众的缺乏新意的相声们。\n\n相声的其独特的语言特点，也让它的创新比较难，在当前网络传播快速的时代，一个包袱，甚至是包袱的思路，一经表演，就已经成为过去式，相声演员很难用一个段子一直表演，观众也不会买账。\n\n传统的相声演员显然没有看到这种传播速度的改变，也没有看到越来越越多的挑剔的观众。观众们的审美发生了根本的变化，跟过时候，观众贪图眼前的快乐，他们很少考虑段子背后的东西。然而师承严重的体制内相声，一直沿袭着建国后相声变革后的理念，寓教于乐，使得他们在创作上的约束太多，以至于很难在把日常，世俗，市侩，市井的元素放在创作里，从而使得他们的创作源泉越发枯竭。\n\n作为一个爱好者，我认为相声需要创新，我也不知道创新的方向在哪里，但我知道反正不应该是现在的这个样子；这种情况下，任何创新都是被容忍的，任何翻天覆地的创新都是从细微的改变而来。","slug":"公式相声之浅见","published":1,"updated":"2021-02-16T04:58:00.191Z","_id":"ck680o2sm0000iviyhqws7ymq","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我喜欢相声。</p>\n<a id=\"more\"></a>\n<p>小学初中时，听收音机，看综艺大观，唐爱国的懒汉糖葫芦是我最喜欢的相声，我们某个时候不就是那个懒汉吗，总是喜欢幻想，现实却是多么骨干。</p>\n<!-- more -->\n\n<p>高中时，大概2002年前后，省吃俭用，攒了5块钱，买了一盒相声大全的磁带，主要是姜昆和唐杰忠相声，里面有姜昆的虎口遐想等等，还有一个侯宝林的原声录音，这个磁带我翻来覆去的听。很多段子我都能说下来，说实话我是很喜欢姜昆和唐杰忠的相声，他们给了我那个年代的快乐。</p>\n<p>在我大学的时候，睡前除了听中国之声的《天涯共此时》， 也开始听郭德纲的段子。MP3，MP4里面大部分是老郭的段子，那时候老郭还没有固定的“于谦”，段子的主角一般是“我”，里面的事都是自我的幻想，自我的讽刺，自我的挖苦，自我的乖张，自我的觉醒，自我的奋进，自我调侃，也不低俗，也不损人。那些段子就像是说我们自己的在学校或者刚工作时的挣扎，幻想，失落与调侃。</p>\n<p>后来工作了也怎么听相声了，再后来，就老郭和于谦的段子了，再听就没有之前有趣，也是境地换了，老郭的段子除了笑，也没有啥了，渐渐也就不听了。</p>\n<p>再后来就是老郭的各种八卦了，老郭其实不仅仅一个相声演员了，他更多的是个娱乐圈里的艺人了，电视，电影，综艺，没有他不参与的，这点有点像冯巩。其实我觉得也很难让他再拿出喜闻乐见的相声作品了。</p>\n<p>作为普通观众，我觉得文艺作品一定要有情感，这样才能打动人心, 才有生命力；情感是复杂，喜怒哀乐，悲伤，失落，快乐，痛苦等等…</p>\n<p>给我的感觉，这几年，老郭的段子只能给一类人看，就是缺”笑“的人，缺啥补啥。这类人慢慢成钢丝的主体，老郭也就越迎合他们，也就越来越没有雅俗共赏的元素了。</p>\n<p>以理科生的科研思维和工程思路，一切都可以“公式”化，其实这里的公式化，窃以为是产业化。有商业头脑的老郭肯定知道这个，要不然，他也不会办相声培训班了。相声公式化，意在解决相声创作难的问题，我认为这是一个有效的途径，这是让相声走进专业课堂的一个途径。</p>\n<p>这些年来，姜昆，冯巩等人都曾在相声人才的培养及相声教育上下了不少功夫，可是收效甚微，相声市场及人才还是萎靡不振。</p>\n<p>相声产业化是老郭现在正在做的事，当年老郭以一个草根的人设，其独特的语言风格在当时算是一声春雷，惊醒了那些靠体制吃饭，靠师承糊弄观众的缺乏新意的相声们。</p>\n<p>相声的其独特的语言特点，也让它的创新比较难，在当前网络传播快速的时代，一个包袱，甚至是包袱的思路，一经表演，就已经成为过去式，相声演员很难用一个段子一直表演，观众也不会买账。</p>\n<p>传统的相声演员显然没有看到这种传播速度的改变，也没有看到越来越越多的挑剔的观众。观众们的审美发生了根本的变化，跟过时候，观众贪图眼前的快乐，他们很少考虑段子背后的东西。然而师承严重的体制内相声，一直沿袭着建国后相声变革后的理念，寓教于乐，使得他们在创作上的约束太多，以至于很难在把日常，世俗，市侩，市井的元素放在创作里，从而使得他们的创作源泉越发枯竭。</p>\n<p>作为一个爱好者，我认为相声需要创新，我也不知道创新的方向在哪里，但我知道反正不应该是现在的这个样子；这种情况下，任何创新都是被容忍的，任何翻天覆地的创新都是从细微的改变而来。</p>\n","site":{"data":{}},"excerpt":"<p>我喜欢相声。</p>","more":"<p>小学初中时，听收音机，看综艺大观，唐爱国的懒汉糖葫芦是我最喜欢的相声，我们某个时候不就是那个懒汉吗，总是喜欢幻想，现实却是多么骨干。</p>\n<!-- more -->\n\n<p>高中时，大概2002年前后，省吃俭用，攒了5块钱，买了一盒相声大全的磁带，主要是姜昆和唐杰忠相声，里面有姜昆的虎口遐想等等，还有一个侯宝林的原声录音，这个磁带我翻来覆去的听。很多段子我都能说下来，说实话我是很喜欢姜昆和唐杰忠的相声，他们给了我那个年代的快乐。</p>\n<p>在我大学的时候，睡前除了听中国之声的《天涯共此时》， 也开始听郭德纲的段子。MP3，MP4里面大部分是老郭的段子，那时候老郭还没有固定的“于谦”，段子的主角一般是“我”，里面的事都是自我的幻想，自我的讽刺，自我的挖苦，自我的乖张，自我的觉醒，自我的奋进，自我调侃，也不低俗，也不损人。那些段子就像是说我们自己的在学校或者刚工作时的挣扎，幻想，失落与调侃。</p>\n<p>后来工作了也怎么听相声了，再后来，就老郭和于谦的段子了，再听就没有之前有趣，也是境地换了，老郭的段子除了笑，也没有啥了，渐渐也就不听了。</p>\n<p>再后来就是老郭的各种八卦了，老郭其实不仅仅一个相声演员了，他更多的是个娱乐圈里的艺人了，电视，电影，综艺，没有他不参与的，这点有点像冯巩。其实我觉得也很难让他再拿出喜闻乐见的相声作品了。</p>\n<p>作为普通观众，我觉得文艺作品一定要有情感，这样才能打动人心, 才有生命力；情感是复杂，喜怒哀乐，悲伤，失落，快乐，痛苦等等…</p>\n<p>给我的感觉，这几年，老郭的段子只能给一类人看，就是缺”笑“的人，缺啥补啥。这类人慢慢成钢丝的主体，老郭也就越迎合他们，也就越来越没有雅俗共赏的元素了。</p>\n<p>以理科生的科研思维和工程思路，一切都可以“公式”化，其实这里的公式化，窃以为是产业化。有商业头脑的老郭肯定知道这个，要不然，他也不会办相声培训班了。相声公式化，意在解决相声创作难的问题，我认为这是一个有效的途径，这是让相声走进专业课堂的一个途径。</p>\n<p>这些年来，姜昆，冯巩等人都曾在相声人才的培养及相声教育上下了不少功夫，可是收效甚微，相声市场及人才还是萎靡不振。</p>\n<p>相声产业化是老郭现在正在做的事，当年老郭以一个草根的人设，其独特的语言风格在当时算是一声春雷，惊醒了那些靠体制吃饭，靠师承糊弄观众的缺乏新意的相声们。</p>\n<p>相声的其独特的语言特点，也让它的创新比较难，在当前网络传播快速的时代，一个包袱，甚至是包袱的思路，一经表演，就已经成为过去式，相声演员很难用一个段子一直表演，观众也不会买账。</p>\n<p>传统的相声演员显然没有看到这种传播速度的改变，也没有看到越来越越多的挑剔的观众。观众们的审美发生了根本的变化，跟过时候，观众贪图眼前的快乐，他们很少考虑段子背后的东西。然而师承严重的体制内相声，一直沿袭着建国后相声变革后的理念，寓教于乐，使得他们在创作上的约束太多，以至于很难在把日常，世俗，市侩，市井的元素放在创作里，从而使得他们的创作源泉越发枯竭。</p>\n<p>作为一个爱好者，我认为相声需要创新，我也不知道创新的方向在哪里，但我知道反正不应该是现在的这个样子；这种情况下，任何创新都是被容忍的，任何翻天覆地的创新都是从细微的改变而来。</p>"},{"title":"机会来的时候，你准备好了吗","date":"2020-02-10T12:31:03.000Z","_content":"什么是机会？什么是运气？什么是实力？机会也是实力的一部分！\n<!-- more -->\n疫情的发生，让在线教育，在线办公火了，今天是开学第一天，比双十一的量大多了，绝大部分学校都是使用的在线服务，大部分的在线服务基本在崩溃与缓慢之间切换。\n\n很多人练就了抓住机会的能力，可以当机会真的来的时候，我们是不是能够利用好机会呢。不积跬步无以至千里，同样的千里之堤毁于蚁穴，把握机会的能力是点滴积累的结果。\n\n我们不仅要活在当下，还要心怀信念，这个信念就是机会一定会来，当下要做的所有事，就是要为那个一定来的机会夯基础，做准备！\n","source":"_posts/机会来的时候，你准备好了吗.md","raw":"---\ntitle: 机会来的时候，你准备好了吗\ndate: 2020-02-10 20:31:03\ntags: 反思 个人成长\n---\n什么是机会？什么是运气？什么是实力？机会也是实力的一部分！\n<!-- more -->\n疫情的发生，让在线教育，在线办公火了，今天是开学第一天，比双十一的量大多了，绝大部分学校都是使用的在线服务，大部分的在线服务基本在崩溃与缓慢之间切换。\n\n很多人练就了抓住机会的能力，可以当机会真的来的时候，我们是不是能够利用好机会呢。不积跬步无以至千里，同样的千里之堤毁于蚁穴，把握机会的能力是点滴积累的结果。\n\n我们不仅要活在当下，还要心怀信念，这个信念就是机会一定会来，当下要做的所有事，就是要为那个一定来的机会夯基础，做准备！\n","slug":"机会来的时候，你准备好了吗","published":1,"updated":"2021-02-16T04:57:28.905Z","_id":"ck6gg8kaa0000wkiy4jev0tpn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>什么是机会？什么是运气？什么是实力？机会也是实力的一部分！</p>\n<a id=\"more\"></a>\n<p>疫情的发生，让在线教育，在线办公火了，今天是开学第一天，比双十一的量大多了，绝大部分学校都是使用的在线服务，大部分的在线服务基本在崩溃与缓慢之间切换。</p>\n<p>很多人练就了抓住机会的能力，可以当机会真的来的时候，我们是不是能够利用好机会呢。不积跬步无以至千里，同样的千里之堤毁于蚁穴，把握机会的能力是点滴积累的结果。</p>\n<p>我们不仅要活在当下，还要心怀信念，这个信念就是机会一定会来，当下要做的所有事，就是要为那个一定来的机会夯基础，做准备！</p>\n","site":{"data":{}},"excerpt":"<p>什么是机会？什么是运气？什么是实力？机会也是实力的一部分！</p>","more":"<p>疫情的发生，让在线教育，在线办公火了，今天是开学第一天，比双十一的量大多了，绝大部分学校都是使用的在线服务，大部分的在线服务基本在崩溃与缓慢之间切换。</p>\n<p>很多人练就了抓住机会的能力，可以当机会真的来的时候，我们是不是能够利用好机会呢。不积跬步无以至千里，同样的千里之堤毁于蚁穴，把握机会的能力是点滴积累的结果。</p>\n<p>我们不仅要活在当下，还要心怀信念，这个信念就是机会一定会来，当下要做的所有事，就是要为那个一定来的机会夯基础，做准备！</p>"},{"title":"使用提取文本，升级版本号","date":"2020-02-19T16:38:06.000Z","_content":"\n使用shell写Android的自动构建脚本时，需要从build.gradle中读取当前的版本号，自动加1，最后写入build.gradle。其中使用到grep，sek命令，具体代码如下：\n\n基本思路：\n- 通过grep获取版本号的位置，存到临时文件tmpshelldata.txt\n- 使用sed提取tmpshelldata.txt中的具体版本号，并且用命令替换赋值给一个变量version1\n- 通过 version1 加 1，计算新的版本号\n- 使用sed命令，用新版本号 代替 老版本号\n- 删除临时文件\n\nsed的一些技巧：\n- 提取字符串 是使用正则替换的方法，用\\1捕获到的字符串，替换其他的，\\1其实要提取的字符串\n- 在mac上使用 -i替换，后面必须加个\"\", 否则不生效，这和linux上不同\n\n```shell\ngradleSrc=./\n\nfunction updateVersionHomePatch(){\n    touch ./tmpshelldata.txt\n    grep -o \"def versionHomePatch = \\([0-9]*\\)\" $gradleSrc > ./tmpshelldata.txt\n    version1=`sed 's/.*def versionHomePatch = \\([0-9]*\\)/\\1/' ./tmpshelldata.txt`\n    echo \"当前版本：$version1\";\n    add=1\n    count=$[$version1+add]\n    echo \"打包版本：$count\"\n    new=\"def versionHomePatch = $count\"\n    sed -i \"\" \"s/def versionHomePatch = $version1/def versionHomePatch = $count/\" \n    cd $gradleSrc\n    rm -f ./tmpshelldata.txt\n}\n\nupdateVersionHomePatch\n```","source":"_posts/shell学习: 提取文本，升级版本号.md","raw":"---\ntitle: 使用提取文本，升级版本号\ndate: 2020-02-20 00:38:06\ntags: shell 语言学习\n---\n\n使用shell写Android的自动构建脚本时，需要从build.gradle中读取当前的版本号，自动加1，最后写入build.gradle。其中使用到grep，sek命令，具体代码如下：\n\n基本思路：\n- 通过grep获取版本号的位置，存到临时文件tmpshelldata.txt\n- 使用sed提取tmpshelldata.txt中的具体版本号，并且用命令替换赋值给一个变量version1\n- 通过 version1 加 1，计算新的版本号\n- 使用sed命令，用新版本号 代替 老版本号\n- 删除临时文件\n\nsed的一些技巧：\n- 提取字符串 是使用正则替换的方法，用\\1捕获到的字符串，替换其他的，\\1其实要提取的字符串\n- 在mac上使用 -i替换，后面必须加个\"\", 否则不生效，这和linux上不同\n\n```shell\ngradleSrc=./\n\nfunction updateVersionHomePatch(){\n    touch ./tmpshelldata.txt\n    grep -o \"def versionHomePatch = \\([0-9]*\\)\" $gradleSrc > ./tmpshelldata.txt\n    version1=`sed 's/.*def versionHomePatch = \\([0-9]*\\)/\\1/' ./tmpshelldata.txt`\n    echo \"当前版本：$version1\";\n    add=1\n    count=$[$version1+add]\n    echo \"打包版本：$count\"\n    new=\"def versionHomePatch = $count\"\n    sed -i \"\" \"s/def versionHomePatch = $version1/def versionHomePatch = $count/\" \n    cd $gradleSrc\n    rm -f ./tmpshelldata.txt\n}\n\nupdateVersionHomePatch\n```","slug":"shell学习: 提取文本，升级版本号","published":1,"updated":"2020-02-19T16:50:38.637Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6tk5wce00001as66soy5c06","content":"<p>使用shell写Android的自动构建脚本时，需要从build.gradle中读取当前的版本号，自动加1，最后写入build.gradle。其中使用到grep，sek命令，具体代码如下：</p>\n<p>基本思路：</p>\n<ul>\n<li>通过grep获取版本号的位置，存到临时文件tmpshelldata.txt</li>\n<li>使用sed提取tmpshelldata.txt中的具体版本号，并且用命令替换赋值给一个变量version1</li>\n<li>通过 version1 加 1，计算新的版本号</li>\n<li>使用sed命令，用新版本号 代替 老版本号</li>\n<li>删除临时文件</li>\n</ul>\n<p>sed的一些技巧：</p>\n<ul>\n<li>提取字符串 是使用正则替换的方法，用\\1捕获到的字符串，替换其他的，\\1其实要提取的字符串</li>\n<li>在mac上使用 -i替换，后面必须加个””, 否则不生效，这和linux上不同</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradleSrc=./</span><br><span class=\"line\"></span><br><span class=\"line\">function updateVersionHomePatch()&#123;</span><br><span class=\"line\">    touch ./tmpshelldata.txt</span><br><span class=\"line\">    grep -o \"def versionHomePatch = \\([0-9]*\\)\" $gradleSrc &gt; ./tmpshelldata.txt</span><br><span class=\"line\">    version1=`sed 's/.*def versionHomePatch = \\([0-9]*\\)/\\1/' ./tmpshelldata.txt`</span><br><span class=\"line\">    echo \"当前版本：$version1\";</span><br><span class=\"line\">    add=1</span><br><span class=\"line\">    count=$[$version1+add]</span><br><span class=\"line\">    echo \"打包版本：$count\"</span><br><span class=\"line\">    new=\"def versionHomePatch = $count\"</span><br><span class=\"line\">    sed -i \"\" \"s/def versionHomePatch = $version1/def versionHomePatch = $count/\" </span><br><span class=\"line\">    cd $gradleSrc</span><br><span class=\"line\">    rm -f ./tmpshelldata.txt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">updateVersionHomePatch</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>使用shell写Android的自动构建脚本时，需要从build.gradle中读取当前的版本号，自动加1，最后写入build.gradle。其中使用到grep，sek命令，具体代码如下：</p>\n<p>基本思路：</p>\n<ul>\n<li>通过grep获取版本号的位置，存到临时文件tmpshelldata.txt</li>\n<li>使用sed提取tmpshelldata.txt中的具体版本号，并且用命令替换赋值给一个变量version1</li>\n<li>通过 version1 加 1，计算新的版本号</li>\n<li>使用sed命令，用新版本号 代替 老版本号</li>\n<li>删除临时文件</li>\n</ul>\n<p>sed的一些技巧：</p>\n<ul>\n<li>提取字符串 是使用正则替换的方法，用\\1捕获到的字符串，替换其他的，\\1其实要提取的字符串</li>\n<li>在mac上使用 -i替换，后面必须加个””, 否则不生效，这和linux上不同</li>\n</ul>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gradleSrc=./</span><br><span class=\"line\"></span><br><span class=\"line\">function updateVersionHomePatch()&#123;</span><br><span class=\"line\">    touch ./tmpshelldata.txt</span><br><span class=\"line\">    grep -o \"def versionHomePatch = \\([0-9]*\\)\" $gradleSrc &gt; ./tmpshelldata.txt</span><br><span class=\"line\">    version1=`sed 's/.*def versionHomePatch = \\([0-9]*\\)/\\1/' ./tmpshelldata.txt`</span><br><span class=\"line\">    echo \"当前版本：$version1\";</span><br><span class=\"line\">    add=1</span><br><span class=\"line\">    count=$[$version1+add]</span><br><span class=\"line\">    echo \"打包版本：$count\"</span><br><span class=\"line\">    new=\"def versionHomePatch = $count\"</span><br><span class=\"line\">    sed -i \"\" \"s/def versionHomePatch = $version1/def versionHomePatch = $count/\" </span><br><span class=\"line\">    cd $gradleSrc</span><br><span class=\"line\">    rm -f ./tmpshelldata.txt</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">updateVersionHomePatch</span><br></pre></td></tr></table></figure>"},{"title":"mac下解压报22错误","date":"2020-02-09T04:59:37.000Z","_content":"\nmac升级到10.15.1，使用mac自带的归档使用工具解压zip文件时，有时会报错”错误22 - 无效的参数。“，\n\n第一次遇到时以为是zip文件问题，后来又遇到，开始怀疑是个普遍问题。查了下资料确实普遍存在，官网[帖子](https://discussionschinese.apple.com/thread/250728523)上很多网友在讨论这个问题，给出很多解决办法。不过亲测使用unar可以很好的解决这个问题。\n\n```shell\nsudo brew install unar\nunar -e GBK 出问题的zip文件\n```\n\n","source":"_posts/mac下解压报22错误.md","raw":"---\ntitle: mac下解压报22错误\ndate: 2020-02-09 12:59:37\ntags: 日常\n---\n\nmac升级到10.15.1，使用mac自带的归档使用工具解压zip文件时，有时会报错”错误22 - 无效的参数。“，\n\n第一次遇到时以为是zip文件问题，后来又遇到，开始怀疑是个普遍问题。查了下资料确实普遍存在，官网[帖子](https://discussionschinese.apple.com/thread/250728523)上很多网友在讨论这个问题，给出很多解决办法。不过亲测使用unar可以很好的解决这个问题。\n\n```shell\nsudo brew install unar\nunar -e GBK 出问题的zip文件\n```\n\n","slug":"mac下解压报22错误","published":1,"updated":"2020-02-19T18:05:10.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck6wg1hod00009ts674ch13c8","content":"<p>mac升级到10.15.1，使用mac自带的归档使用工具解压zip文件时，有时会报错”错误22 - 无效的参数。“，</p>\n<p>第一次遇到时以为是zip文件问题，后来又遇到，开始怀疑是个普遍问题。查了下资料确实普遍存在，官网<a href=\"https://discussionschinese.apple.com/thread/250728523\" target=\"_blank\" rel=\"noopener\">帖子</a>上很多网友在讨论这个问题，给出很多解决办法。不过亲测使用unar可以很好的解决这个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo brew install unar</span><br><span class=\"line\">unar -e GBK 出问题的zip文件</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<p>mac升级到10.15.1，使用mac自带的归档使用工具解压zip文件时，有时会报错”错误22 - 无效的参数。“，</p>\n<p>第一次遇到时以为是zip文件问题，后来又遇到，开始怀疑是个普遍问题。查了下资料确实普遍存在，官网<a href=\"https://discussionschinese.apple.com/thread/250728523\" target=\"_blank\" rel=\"noopener\">帖子</a>上很多网友在讨论这个问题，给出很多解决办法。不过亲测使用unar可以很好的解决这个问题。</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo brew install unar</span><br><span class=\"line\">unar -e GBK 出问题的zip文件</span><br></pre></td></tr></table></figure>\n\n"},{"title":"发票的半自动填写","date":"2020-02-21T16:23:26.000Z","_content":"\n每个月都有一天都会比较头疼，填写发票！每天的开发工作都要加班完成，这种琐碎的事情更不想做了，但是作为职场中，走报销是日常工作的一部分。作为写代码的手艺人，天天给客户赋能，为啥不利用技术给自己赋能呢？\n\n忙里偷闲，搞起来吧！\n<!-- more -->\n\n描述下我们的报销流程：报销人整理票据，打印成纸质发票，打包，按照固定格式填写到google sheet上，将google sheet的链接共享给财务助理，报销人的流程就走完了；其中票据类型常用的是增值税发票，出租金发票；\n\n这个流程中, 可以自动化的过程：票据整理，填写，发送链接。本身这最少投入，最大产出的思路分析，发送链接就是粘贴复制，自动化不够麻烦的。票据整理需要人工参与，需要考虑一种自动化的整理方式，产出数据，填写需要数据。\n\n- 票据整理\n    - 利用百度云文字识别的android sdk，给增值税发票拍照，识别获取发票的时间，金额及类型；\n百度云文字识别还是很良心，一天有500次的免费试用；\n    - 将以上识别到数据做排序，去重操作，输出一个json字符串；\n涉及到ak和sk，暂不开源，如有需要请邮箱联系。\n\n- 填写自动化\n    - google sheet支持在线编程修改其sheet，语言是JavaScript；\n    - 利用票据整理出来的数据，自动生成sheet表格\n\n```javascript\n// type = 1, 五星酒店，type = 2, 航空旅费\nvar data = [{type: 1, amount: 150.00, date: 2020-01-19}];\n\nfunction myFunction() {\n  var baseRowIndex = 5;\n  var activeSpreadSheet = SpreadsheetApp.getActiveSpreadsheet();\n  var activeSheet = activeSpreadSheet.getActiveSheet();\n  var count = data.length;\n  activeSheet.insertRows(baseRowIndex, count);\n  var range;\n\n  for (var rowIndex = 0; rowIndex < count; rowIndex++) {\n    var rowData = data[rowIndex];\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 1);\n    range.setValue(rowData[\"date\"]);\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 2);\n    range.setValue(\"华盛顿\");\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 3);\n    if (rowData[\"type\"] == 1) {\n      range.setValue(\"五星酒店\");\n    } else {\n      range.setValue(\"航空旅费\");\n    }\n   \n    range = activeSheet.getRange(baseRowIndex + rowIndex, 4);\n    range.setValue(rowData[\"amount\"]);\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 5);\n    range.setValue(1);\n\n  }\n\n  // 合计\n  var totalRowIndex = baseRowIndex + rowIndex;\n  activeSheet.insertRows(totalRowIndex, 1);\n  range = activeSheet.getRange(totalRowIndex, 1);\n  range.setValue(\"合计\");\n  range = activeSheet.getRange(totalRowIndex, 2);\n  range.setValue(\"华盛顿\");\n  range = activeSheet.getRange(totalRowIndex, 4);\n  range.setFormula(\"=SUM(D\" + baseRowIndex + \":D\" + (baseRowIndex + count - 1) + \")\");\n\n  // 餐费合计\n  var foodTotalRowIndex = totalRowIndex + 1;\n  activeSheet.insertRows(foodTotalRowIndex, 1);\n  range = activeSheet.getRange(foodTotalRowIndex, 1);\n  range.setValue(\"航空旅费合计\");\n  range = activeSheet.getRange(foodTotalRowIndex, 2);\n  range.setValue(\"华盛顿\");\n  range = activeSheet.getRange(foodTotalRowIndex, 4);\n  range.setFormula('=SUMIFS(D:D,C:C,\"*航空旅费\")');\n\n  var ui = SpreadsheetApp.getUi();\n  ui.alert(\"done\", ui.ButtonSet.OK);\n}\n\n```\n\n整个开发历时3个半小时，经过以上的流程改造，实现了半自动化，每次填报发票能省去看发票找数字及填写过程，能省一半的时间，收益足矣。","source":"_posts/发票的半自动填写.md","raw":"---\ntitle: 发票的半自动填写\ndate: 2020-02-22 00:23:26\ntags: 日常 自制 创意\n---\n\n每个月都有一天都会比较头疼，填写发票！每天的开发工作都要加班完成，这种琐碎的事情更不想做了，但是作为职场中，走报销是日常工作的一部分。作为写代码的手艺人，天天给客户赋能，为啥不利用技术给自己赋能呢？\n\n忙里偷闲，搞起来吧！\n<!-- more -->\n\n描述下我们的报销流程：报销人整理票据，打印成纸质发票，打包，按照固定格式填写到google sheet上，将google sheet的链接共享给财务助理，报销人的流程就走完了；其中票据类型常用的是增值税发票，出租金发票；\n\n这个流程中, 可以自动化的过程：票据整理，填写，发送链接。本身这最少投入，最大产出的思路分析，发送链接就是粘贴复制，自动化不够麻烦的。票据整理需要人工参与，需要考虑一种自动化的整理方式，产出数据，填写需要数据。\n\n- 票据整理\n    - 利用百度云文字识别的android sdk，给增值税发票拍照，识别获取发票的时间，金额及类型；\n百度云文字识别还是很良心，一天有500次的免费试用；\n    - 将以上识别到数据做排序，去重操作，输出一个json字符串；\n涉及到ak和sk，暂不开源，如有需要请邮箱联系。\n\n- 填写自动化\n    - google sheet支持在线编程修改其sheet，语言是JavaScript；\n    - 利用票据整理出来的数据，自动生成sheet表格\n\n```javascript\n// type = 1, 五星酒店，type = 2, 航空旅费\nvar data = [{type: 1, amount: 150.00, date: 2020-01-19}];\n\nfunction myFunction() {\n  var baseRowIndex = 5;\n  var activeSpreadSheet = SpreadsheetApp.getActiveSpreadsheet();\n  var activeSheet = activeSpreadSheet.getActiveSheet();\n  var count = data.length;\n  activeSheet.insertRows(baseRowIndex, count);\n  var range;\n\n  for (var rowIndex = 0; rowIndex < count; rowIndex++) {\n    var rowData = data[rowIndex];\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 1);\n    range.setValue(rowData[\"date\"]);\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 2);\n    range.setValue(\"华盛顿\");\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 3);\n    if (rowData[\"type\"] == 1) {\n      range.setValue(\"五星酒店\");\n    } else {\n      range.setValue(\"航空旅费\");\n    }\n   \n    range = activeSheet.getRange(baseRowIndex + rowIndex, 4);\n    range.setValue(rowData[\"amount\"]);\n\n    range = activeSheet.getRange(baseRowIndex + rowIndex, 5);\n    range.setValue(1);\n\n  }\n\n  // 合计\n  var totalRowIndex = baseRowIndex + rowIndex;\n  activeSheet.insertRows(totalRowIndex, 1);\n  range = activeSheet.getRange(totalRowIndex, 1);\n  range.setValue(\"合计\");\n  range = activeSheet.getRange(totalRowIndex, 2);\n  range.setValue(\"华盛顿\");\n  range = activeSheet.getRange(totalRowIndex, 4);\n  range.setFormula(\"=SUM(D\" + baseRowIndex + \":D\" + (baseRowIndex + count - 1) + \")\");\n\n  // 餐费合计\n  var foodTotalRowIndex = totalRowIndex + 1;\n  activeSheet.insertRows(foodTotalRowIndex, 1);\n  range = activeSheet.getRange(foodTotalRowIndex, 1);\n  range.setValue(\"航空旅费合计\");\n  range = activeSheet.getRange(foodTotalRowIndex, 2);\n  range.setValue(\"华盛顿\");\n  range = activeSheet.getRange(foodTotalRowIndex, 4);\n  range.setFormula('=SUMIFS(D:D,C:C,\"*航空旅费\")');\n\n  var ui = SpreadsheetApp.getUi();\n  ui.alert(\"done\", ui.ButtonSet.OK);\n}\n\n```\n\n整个开发历时3个半小时，经过以上的流程改造，实现了半自动化，每次填报发票能省去看发票找数字及填写过程，能省一半的时间，收益足矣。","slug":"发票的半自动填写","published":1,"updated":"2020-02-21T17:25:20.175Z","_id":"ck6wg1hok00019ts6ejuya9u5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>每个月都有一天都会比较头疼，填写发票！每天的开发工作都要加班完成，这种琐碎的事情更不想做了，但是作为职场中，走报销是日常工作的一部分。作为写代码的手艺人，天天给客户赋能，为啥不利用技术给自己赋能呢？</p>\n<p>忙里偷闲，搞起来吧！</p>\n<a id=\"more\"></a>\n\n<p>描述下我们的报销流程：报销人整理票据，打印成纸质发票，打包，按照固定格式填写到google sheet上，将google sheet的链接共享给财务助理，报销人的流程就走完了；其中票据类型常用的是增值税发票，出租金发票；</p>\n<p>这个流程中, 可以自动化的过程：票据整理，填写，发送链接。本身这最少投入，最大产出的思路分析，发送链接就是粘贴复制，自动化不够麻烦的。票据整理需要人工参与，需要考虑一种自动化的整理方式，产出数据，填写需要数据。</p>\n<ul>\n<li><p>票据整理</p>\n<ul>\n<li>利用百度云文字识别的android sdk，给增值税发票拍照，识别获取发票的时间，金额及类型；<br>百度云文字识别还是很良心，一天有500次的免费试用；</li>\n<li>将以上识别到数据做排序，去重操作，输出一个json字符串；<br>涉及到ak和sk，暂不开源，如有需要请邮箱联系。</li>\n</ul>\n</li>\n<li><p>填写自动化</p>\n<ul>\n<li>google sheet支持在线编程修改其sheet，语言是JavaScript；</li>\n<li>利用票据整理出来的数据，自动生成sheet表格</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type = 1, 五星酒店，type = 2, 航空旅费</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = [&#123;<span class=\"attr\">type</span>: <span class=\"number\">1</span>, <span class=\"attr\">amount</span>: <span class=\"number\">150.00</span>, <span class=\"attr\">date</span>: <span class=\"number\">2020</span><span class=\"number\">-01</span><span class=\"number\">-19</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> baseRowIndex = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> activeSpreadSheet = SpreadsheetApp.getActiveSpreadsheet();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> activeSheet = activeSpreadSheet.getActiveSheet();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = data.length;</span><br><span class=\"line\">  activeSheet.insertRows(baseRowIndex, count);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> range;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rowIndex = <span class=\"number\">0</span>; rowIndex &lt; count; rowIndex++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rowData = data[rowIndex];</span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">    range.setValue(rowData[<span class=\"string\">\"date\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">    range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rowData[<span class=\"string\">\"type\"</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      range.setValue(<span class=\"string\">\"五星酒店\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      range.setValue(<span class=\"string\">\"航空旅费\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">    range.setValue(rowData[<span class=\"string\">\"amount\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">5</span>);</span><br><span class=\"line\">    range.setValue(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 合计</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> totalRowIndex = baseRowIndex + rowIndex;</span><br><span class=\"line\">  activeSheet.insertRows(totalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"合计\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">  range.setFormula(<span class=\"string\">\"=SUM(D\"</span> + baseRowIndex + <span class=\"string\">\":D\"</span> + (baseRowIndex + count - <span class=\"number\">1</span>) + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 餐费合计</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> foodTotalRowIndex = totalRowIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">  activeSheet.insertRows(foodTotalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"航空旅费合计\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">  range.setFormula(<span class=\"string\">'=SUMIFS(D:D,C:C,\"*航空旅费\")'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ui = SpreadsheetApp.getUi();</span><br><span class=\"line\">  ui.alert(<span class=\"string\">\"done\"</span>, ui.ButtonSet.OK);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个开发历时3个半小时，经过以上的流程改造，实现了半自动化，每次填报发票能省去看发票找数字及填写过程，能省一半的时间，收益足矣。</p>\n","site":{"data":{}},"excerpt":"<p>每个月都有一天都会比较头疼，填写发票！每天的开发工作都要加班完成，这种琐碎的事情更不想做了，但是作为职场中，走报销是日常工作的一部分。作为写代码的手艺人，天天给客户赋能，为啥不利用技术给自己赋能呢？</p>\n<p>忙里偷闲，搞起来吧！</p>","more":"<p>描述下我们的报销流程：报销人整理票据，打印成纸质发票，打包，按照固定格式填写到google sheet上，将google sheet的链接共享给财务助理，报销人的流程就走完了；其中票据类型常用的是增值税发票，出租金发票；</p>\n<p>这个流程中, 可以自动化的过程：票据整理，填写，发送链接。本身这最少投入，最大产出的思路分析，发送链接就是粘贴复制，自动化不够麻烦的。票据整理需要人工参与，需要考虑一种自动化的整理方式，产出数据，填写需要数据。</p>\n<ul>\n<li><p>票据整理</p>\n<ul>\n<li>利用百度云文字识别的android sdk，给增值税发票拍照，识别获取发票的时间，金额及类型；<br>百度云文字识别还是很良心，一天有500次的免费试用；</li>\n<li>将以上识别到数据做排序，去重操作，输出一个json字符串；<br>涉及到ak和sk，暂不开源，如有需要请邮箱联系。</li>\n</ul>\n</li>\n<li><p>填写自动化</p>\n<ul>\n<li>google sheet支持在线编程修改其sheet，语言是JavaScript；</li>\n<li>利用票据整理出来的数据，自动生成sheet表格</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// type = 1, 五星酒店，type = 2, 航空旅费</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> data = [&#123;<span class=\"attr\">type</span>: <span class=\"number\">1</span>, <span class=\"attr\">amount</span>: <span class=\"number\">150.00</span>, <span class=\"attr\">date</span>: <span class=\"number\">2020</span><span class=\"number\">-01</span><span class=\"number\">-19</span>&#125;];</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">myFunction</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> baseRowIndex = <span class=\"number\">5</span>;</span><br><span class=\"line\">  <span class=\"keyword\">var</span> activeSpreadSheet = SpreadsheetApp.getActiveSpreadsheet();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> activeSheet = activeSpreadSheet.getActiveSheet();</span><br><span class=\"line\">  <span class=\"keyword\">var</span> count = data.length;</span><br><span class=\"line\">  activeSheet.insertRows(baseRowIndex, count);</span><br><span class=\"line\">  <span class=\"keyword\">var</span> range;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">var</span> rowIndex = <span class=\"number\">0</span>; rowIndex &lt; count; rowIndex++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> rowData = data[rowIndex];</span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">    range.setValue(rowData[<span class=\"string\">\"date\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">    range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (rowData[<span class=\"string\">\"type\"</span>] == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">      range.setValue(<span class=\"string\">\"五星酒店\"</span>);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      range.setValue(<span class=\"string\">\"航空旅费\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">   </span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">    range.setValue(rowData[<span class=\"string\">\"amount\"</span>]);</span><br><span class=\"line\"></span><br><span class=\"line\">    range = activeSheet.getRange(baseRowIndex + rowIndex, <span class=\"number\">5</span>);</span><br><span class=\"line\">    range.setValue(<span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 合计</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> totalRowIndex = baseRowIndex + rowIndex;</span><br><span class=\"line\">  activeSheet.insertRows(totalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"合计\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(totalRowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">  range.setFormula(<span class=\"string\">\"=SUM(D\"</span> + baseRowIndex + <span class=\"string\">\":D\"</span> + (baseRowIndex + count - <span class=\"number\">1</span>) + <span class=\"string\">\")\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 餐费合计</span></span><br><span class=\"line\">  <span class=\"keyword\">var</span> foodTotalRowIndex = totalRowIndex + <span class=\"number\">1</span>;</span><br><span class=\"line\">  activeSheet.insertRows(foodTotalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">1</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"航空旅费合计\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">2</span>);</span><br><span class=\"line\">  range.setValue(<span class=\"string\">\"华盛顿\"</span>);</span><br><span class=\"line\">  range = activeSheet.getRange(foodTotalRowIndex, <span class=\"number\">4</span>);</span><br><span class=\"line\">  range.setFormula(<span class=\"string\">'=SUMIFS(D:D,C:C,\"*航空旅费\")'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">var</span> ui = SpreadsheetApp.getUi();</span><br><span class=\"line\">  ui.alert(<span class=\"string\">\"done\"</span>, ui.ButtonSet.OK);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>整个开发历时3个半小时，经过以上的流程改造，实现了半自动化，每次填报发票能省去看发票找数字及填写过程，能省一半的时间，收益足矣。</p>"},{"title":"EventBus源码解析(一)","date":"2020-02-26T16:51:19.000Z","_content":"\n### 观察者模式\n描述一对多的依赖的关系，当一个对象的状态发生变化时，所有依赖它的对象都会获得通知：\n<!-- more -->\n### 事件总线\n消息或者事件流动的通道，不同的组件或者模块通过这个通道获取获取和发布消息；\n事件总线涉及到4个角色：\n- 订阅者，subscriber，获取指定类型的消息或者事件\n- 发布者，publisher，触发或者发布消息或者事件\n- 事件 Event，订阅者和发布者之间沟通的信息载体，普通的java类，只包括数据\n- 事件总线，EventBus，管理订阅者和信息的存储，同时负责事件的分发和流转； \n通过事件总线 组件之间相互解耦，发布者不知道具体订阅者的存在。\n\n![架构图](../../img/eventbus-1.png)\n\n以上是事件总线的总体思想，如果我们设计一款EventBus，该考虑哪些设计呢？我觉得以下几个问题是比较核心的设计：\n- 如何管理订阅者\n- 如何存储事件\n- 如何触发事件\n- 如何分发事件\n\n我看下EventBus是如何处理这些问题的（版本3.2.0），\n### 如何管理订阅者\nEventvBus的订阅者通过注解实现注册，有个两个方式：\n- 运行时加载订阅\n基本思路是在register时，通过反射获取当前class的中所有使用了Subscriber注解的方法，把他们加到事件集合里；\n我们重点分析注解查找方法SubscriberMethodFinder类的findUsingReflection方法\n```java\n// subscriberClass 就是通过EventBus.register的对象的类\nprivate List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {\n    // 使用prepareFindState，在查找中限制类的实例个数，应该是基于性能的考虑，因为findState是存在多个map用于临时存储订阅者，订阅者所在的类及事件之间的关系\n  // findState就是递归过程中共享数据的变量\n    FindState findState = prepareFindState();\n// 初始化findState\n    findState.initForSubscriber(subscriberClass);\n// 开始递归\n    while (findState.clazz != null) {\n// 该方法包括查找注解的核心逻辑\n// 1 获取subscriberClass里的所有方法\n// 2 遍历这些方法，check是否是public，是否包含1个参数\n// 3 解析参数类型，解析方法名，存入findState对应的关系中\n        findUsingReflectionInSingleClass(findState);\n// 查找父类\n        findState.moveToSuperclass();\n    }\n//释放findState, 返回查找结果，SubscriberMethod列表\n    return getMethodsAndRelease(findState);\n}\n```\n这个里面有一个技巧需要注意，就是控制findState个数，以及在递归中使用。\n\n- 编译时通过SubscriberIndex加载订阅\n使用如例:\n```java\n@Subscribe(threadMode = ThreadMode.MAIN)\npublic void onMessageEvent(MessageEvent event) {/* Do something */};\n```\n基本实现是思路：使用注解生成器EventBusAnnotationProcessor编译时生成Subscribe的注册类。所以注册的整个过程由2个阶段构成，编译时和运行时。编译时负责收集所有了订阅的类及其类内的回调，运行时执行这些注册，并触发对应的回调。\n- EventBusAnnotationProcessor 负责解析注解类，收集并验证所有使用过Subscribe的方法和方法所在的类，基于收集到方法和类，生成Subscribe的注册类的java文件。\nEventBusAnnotationProcessor 继承自AbstractProcessor类，AbstractProcessor类负责插入式注解处理器的注解处理过程，很多框架都使用这个技术，以后我会单独研究学习和大家分享，[可以看这里简单了解](https://juejin.im/post/5d35b8846fb9a07efd474a5a)。整体上这个类可以获取编译时环境，及注解的类型，使用注册的类型和方法，注解里使用方法等等，通过这个类我们基本上在编译时获取注解相关的所有信息；\n需要注意的一点是，如果需要指定文件名和报名，可以在build.gradle 里做如下的声明：\n```java\njavaCompileOptions {\n    annotationProcessorOptions {\n        includeCompileClasspath true\n        arguments = [eventBusIndex: 'com.demo.EventBusIndex']\n    }\n}\n\n```\nAbstractProcessor有很多虚方法，最重要的是process，注解的处理主要通过这个方法处理。重点分析这个方法的处理流程：\n- 这个方法有2个输入参数，annotations，指定注解类型的集合，roundEnvironment，用于查询使用指定注解类型的类型的处理器；\n- 获取build.gradle中指定的包名，该包名是通过注解生成类的包名；\n- 收集使用过指定注解的所有类型，并把这些数据组织成ListMap<TypeElement, ExecutableElement> list的数据；\n- 依据上一步的list，验证注解类型的可见性，public为可见，private和protect，检查回调方法的参数类型是否是可见类和可用类；\n- 生成代码，主要依据list做字符串拼接，文件的路径是以声明的包名目录，比如com.demo.EventBusIndex，其文件所在的位置是,代码目录/build/generated/ap_generated_sources/版本变体/out/com/demo/EventBusIndex.java\n生成的文件的大概是这样的\n\n```java\n/** This class is generated by EventBus, do not edit. */\npublic class MyEventBusIndex implements SubscriberInfoIndex {\n    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n    static {\n        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();\n\n    putIndex(new SimpleSubscriberInfo(com.demo.MainActivity.class, true, new SubscriberMethodInfo[] {\n            new SubscriberMethodInfo(\"setVolume\", com.demo.VolumeChangeEvent.class, ThreadMode.MAIN),\n            new SubscriberMethodInfo(\"onFinishEvent\", com.demo.FinishEvent.class, ThreadMode.MAIN),\n            new SubscriberMethodInfo(\"onCameraStateEvent\", com.umu.event.CameraStateEvent.class, ThreadMode.MAIN),\n    }));}\nprivate static void putIndex(SubscriberInfo info) {\n       SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n}\n\n@Override\npublic SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {\n    SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n        if (info != null) {\n            return info;\n        } else {\n            return null;\n       }}}\n```\n其中需要仔细理解的是putIndex(SubscriberInfo info),SubscriberInfo描述了包含订阅的类，及其所有的订阅方法\n同时要在Application种手动的将生成的EventBusIndex类提供给EventBus\n```java\nEventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();\n```\n以上，EventBus实现了订阅者的管理和订阅的注册","source":"_posts/EventBus源码解析(一).md","raw":"---\ntitle: EventBus源码解析(一)\ndate: 2020-02-27 00:51:19\ntags: java android EventBus\n---\n\n### 观察者模式\n描述一对多的依赖的关系，当一个对象的状态发生变化时，所有依赖它的对象都会获得通知：\n<!-- more -->\n### 事件总线\n消息或者事件流动的通道，不同的组件或者模块通过这个通道获取获取和发布消息；\n事件总线涉及到4个角色：\n- 订阅者，subscriber，获取指定类型的消息或者事件\n- 发布者，publisher，触发或者发布消息或者事件\n- 事件 Event，订阅者和发布者之间沟通的信息载体，普通的java类，只包括数据\n- 事件总线，EventBus，管理订阅者和信息的存储，同时负责事件的分发和流转； \n通过事件总线 组件之间相互解耦，发布者不知道具体订阅者的存在。\n\n![架构图](../../img/eventbus-1.png)\n\n以上是事件总线的总体思想，如果我们设计一款EventBus，该考虑哪些设计呢？我觉得以下几个问题是比较核心的设计：\n- 如何管理订阅者\n- 如何存储事件\n- 如何触发事件\n- 如何分发事件\n\n我看下EventBus是如何处理这些问题的（版本3.2.0），\n### 如何管理订阅者\nEventvBus的订阅者通过注解实现注册，有个两个方式：\n- 运行时加载订阅\n基本思路是在register时，通过反射获取当前class的中所有使用了Subscriber注解的方法，把他们加到事件集合里；\n我们重点分析注解查找方法SubscriberMethodFinder类的findUsingReflection方法\n```java\n// subscriberClass 就是通过EventBus.register的对象的类\nprivate List<SubscriberMethod> findUsingReflection(Class<?> subscriberClass) {\n    // 使用prepareFindState，在查找中限制类的实例个数，应该是基于性能的考虑，因为findState是存在多个map用于临时存储订阅者，订阅者所在的类及事件之间的关系\n  // findState就是递归过程中共享数据的变量\n    FindState findState = prepareFindState();\n// 初始化findState\n    findState.initForSubscriber(subscriberClass);\n// 开始递归\n    while (findState.clazz != null) {\n// 该方法包括查找注解的核心逻辑\n// 1 获取subscriberClass里的所有方法\n// 2 遍历这些方法，check是否是public，是否包含1个参数\n// 3 解析参数类型，解析方法名，存入findState对应的关系中\n        findUsingReflectionInSingleClass(findState);\n// 查找父类\n        findState.moveToSuperclass();\n    }\n//释放findState, 返回查找结果，SubscriberMethod列表\n    return getMethodsAndRelease(findState);\n}\n```\n这个里面有一个技巧需要注意，就是控制findState个数，以及在递归中使用。\n\n- 编译时通过SubscriberIndex加载订阅\n使用如例:\n```java\n@Subscribe(threadMode = ThreadMode.MAIN)\npublic void onMessageEvent(MessageEvent event) {/* Do something */};\n```\n基本实现是思路：使用注解生成器EventBusAnnotationProcessor编译时生成Subscribe的注册类。所以注册的整个过程由2个阶段构成，编译时和运行时。编译时负责收集所有了订阅的类及其类内的回调，运行时执行这些注册，并触发对应的回调。\n- EventBusAnnotationProcessor 负责解析注解类，收集并验证所有使用过Subscribe的方法和方法所在的类，基于收集到方法和类，生成Subscribe的注册类的java文件。\nEventBusAnnotationProcessor 继承自AbstractProcessor类，AbstractProcessor类负责插入式注解处理器的注解处理过程，很多框架都使用这个技术，以后我会单独研究学习和大家分享，[可以看这里简单了解](https://juejin.im/post/5d35b8846fb9a07efd474a5a)。整体上这个类可以获取编译时环境，及注解的类型，使用注册的类型和方法，注解里使用方法等等，通过这个类我们基本上在编译时获取注解相关的所有信息；\n需要注意的一点是，如果需要指定文件名和报名，可以在build.gradle 里做如下的声明：\n```java\njavaCompileOptions {\n    annotationProcessorOptions {\n        includeCompileClasspath true\n        arguments = [eventBusIndex: 'com.demo.EventBusIndex']\n    }\n}\n\n```\nAbstractProcessor有很多虚方法，最重要的是process，注解的处理主要通过这个方法处理。重点分析这个方法的处理流程：\n- 这个方法有2个输入参数，annotations，指定注解类型的集合，roundEnvironment，用于查询使用指定注解类型的类型的处理器；\n- 获取build.gradle中指定的包名，该包名是通过注解生成类的包名；\n- 收集使用过指定注解的所有类型，并把这些数据组织成ListMap<TypeElement, ExecutableElement> list的数据；\n- 依据上一步的list，验证注解类型的可见性，public为可见，private和protect，检查回调方法的参数类型是否是可见类和可用类；\n- 生成代码，主要依据list做字符串拼接，文件的路径是以声明的包名目录，比如com.demo.EventBusIndex，其文件所在的位置是,代码目录/build/generated/ap_generated_sources/版本变体/out/com/demo/EventBusIndex.java\n生成的文件的大概是这样的\n\n```java\n/** This class is generated by EventBus, do not edit. */\npublic class MyEventBusIndex implements SubscriberInfoIndex {\n    private static final Map<Class<?>, SubscriberInfo> SUBSCRIBER_INDEX;\n\n    static {\n        SUBSCRIBER_INDEX = new HashMap<Class<?>, SubscriberInfo>();\n\n    putIndex(new SimpleSubscriberInfo(com.demo.MainActivity.class, true, new SubscriberMethodInfo[] {\n            new SubscriberMethodInfo(\"setVolume\", com.demo.VolumeChangeEvent.class, ThreadMode.MAIN),\n            new SubscriberMethodInfo(\"onFinishEvent\", com.demo.FinishEvent.class, ThreadMode.MAIN),\n            new SubscriberMethodInfo(\"onCameraStateEvent\", com.umu.event.CameraStateEvent.class, ThreadMode.MAIN),\n    }));}\nprivate static void putIndex(SubscriberInfo info) {\n       SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n}\n\n@Override\npublic SubscriberInfo getSubscriberInfo(Class<?> subscriberClass) {\n    SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n        if (info != null) {\n            return info;\n        } else {\n            return null;\n       }}}\n```\n其中需要仔细理解的是putIndex(SubscriberInfo info),SubscriberInfo描述了包含订阅的类，及其所有的订阅方法\n同时要在Application种手动的将生成的EventBusIndex类提供给EventBus\n```java\nEventBus eventBus = EventBus.builder().addIndex(new MyEventBusIndex()).build();\n```\n以上，EventBus实现了订阅者的管理和订阅的注册","slug":"EventBus源码解析(一)","published":1,"updated":"2021-02-16T04:58:26.321Z","_id":"ck73ki4ic0000vds61uwz5o2g","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>描述一对多的依赖的关系，当一个对象的状态发生变化时，所有依赖它的对象都会获得通知：</p>\n<a id=\"more\"></a>\n<h3 id=\"事件总线\"><a href=\"#事件总线\" class=\"headerlink\" title=\"事件总线\"></a>事件总线</h3><p>消息或者事件流动的通道，不同的组件或者模块通过这个通道获取获取和发布消息；<br>事件总线涉及到4个角色：</p>\n<ul>\n<li>订阅者，subscriber，获取指定类型的消息或者事件</li>\n<li>发布者，publisher，触发或者发布消息或者事件</li>\n<li>事件 Event，订阅者和发布者之间沟通的信息载体，普通的java类，只包括数据</li>\n<li>事件总线，EventBus，管理订阅者和信息的存储，同时负责事件的分发和流转；<br>通过事件总线 组件之间相互解耦，发布者不知道具体订阅者的存在。</li>\n</ul>\n<p><img src=\"../../img/eventbus-1.png\" alt=\"架构图\"></p>\n<p>以上是事件总线的总体思想，如果我们设计一款EventBus，该考虑哪些设计呢？我觉得以下几个问题是比较核心的设计：</p>\n<ul>\n<li>如何管理订阅者</li>\n<li>如何存储事件</li>\n<li>如何触发事件</li>\n<li>如何分发事件</li>\n</ul>\n<p>我看下EventBus是如何处理这些问题的（版本3.2.0），</p>\n<h3 id=\"如何管理订阅者\"><a href=\"#如何管理订阅者\" class=\"headerlink\" title=\"如何管理订阅者\"></a>如何管理订阅者</h3><p>EventvBus的订阅者通过注解实现注册，有个两个方式：</p>\n<ul>\n<li><p>运行时加载订阅<br>基本思路是在register时，通过反射获取当前class的中所有使用了Subscriber注解的方法，把他们加到事件集合里；<br>我们重点分析注解查找方法SubscriberMethodFinder类的findUsingReflection方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// subscriberClass 就是通过EventBus.register的对象的类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingReflection</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用prepareFindState，在查找中限制类的实例个数，应该是基于性能的考虑，因为findState是存在多个map用于临时存储订阅者，订阅者所在的类及事件之间的关系</span></span><br><span class=\"line\">  <span class=\"comment\">// findState就是递归过程中共享数据的变量</span></span><br><span class=\"line\">    FindState findState = prepareFindState();</span><br><span class=\"line\"><span class=\"comment\">// 初始化findState</span></span><br><span class=\"line\">    findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\"><span class=\"comment\">// 开始递归</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 该方法包括查找注解的核心逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// 1 获取subscriberClass里的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 2 遍历这些方法，check是否是public，是否包含1个参数</span></span><br><span class=\"line\"><span class=\"comment\">// 3 解析参数类型，解析方法名，存入findState对应的关系中</span></span><br><span class=\"line\">        findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\"><span class=\"comment\">// 查找父类</span></span><br><span class=\"line\">        findState.moveToSuperclass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//释放findState, 返回查找结果，SubscriberMethod列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个里面有一个技巧需要注意，就是控制findState个数，以及在递归中使用。</p>\n</li>\n<li><p>编译时通过SubscriberIndex加载订阅<br>使用如例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessageEvent</span><span class=\"params\">(MessageEvent event)</span> </span>&#123;<span class=\"comment\">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>基本实现是思路：使用注解生成器EventBusAnnotationProcessor编译时生成Subscribe的注册类。所以注册的整个过程由2个阶段构成，编译时和运行时。编译时负责收集所有了订阅的类及其类内的回调，运行时执行这些注册，并触发对应的回调。</p>\n</li>\n<li><p>EventBusAnnotationProcessor 负责解析注解类，收集并验证所有使用过Subscribe的方法和方法所在的类，基于收集到方法和类，生成Subscribe的注册类的java文件。<br>EventBusAnnotationProcessor 继承自AbstractProcessor类，AbstractProcessor类负责插入式注解处理器的注解处理过程，很多框架都使用这个技术，以后我会单独研究学习和大家分享，<a href=\"https://juejin.im/post/5d35b8846fb9a07efd474a5a\" target=\"_blank\" rel=\"noopener\">可以看这里简单了解</a>。整体上这个类可以获取编译时环境，及注解的类型，使用注册的类型和方法，注解里使用方法等等，通过这个类我们基本上在编译时获取注解相关的所有信息；<br>需要注意的一点是，如果需要指定文件名和报名，可以在build.gradle 里做如下的声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javaCompileOptions &#123;</span><br><span class=\"line\">    annotationProcessorOptions &#123;</span><br><span class=\"line\">        includeCompileClasspath <span class=\"keyword\">true</span></span><br><span class=\"line\">        arguments = [eventBusIndex: <span class=\"string\">'com.demo.EventBusIndex'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AbstractProcessor有很多虚方法，最重要的是process，注解的处理主要通过这个方法处理。重点分析这个方法的处理流程：</p>\n</li>\n<li><p>这个方法有2个输入参数，annotations，指定注解类型的集合，roundEnvironment，用于查询使用指定注解类型的类型的处理器；</p>\n</li>\n<li><p>获取build.gradle中指定的包名，该包名是通过注解生成类的包名；</p>\n</li>\n<li><p>收集使用过指定注解的所有类型，并把这些数据组织成ListMap&lt;TypeElement, ExecutableElement&gt; list的数据；</p>\n</li>\n<li><p>依据上一步的list，验证注解类型的可见性，public为可见，private和protect，检查回调方法的参数类型是否是可见类和可用类；</p>\n</li>\n<li><p>生成代码，主要依据list做字符串拼接，文件的路径是以声明的包名目录，比如com.demo.EventBusIndex，其文件所在的位置是,代码目录/build/generated/ap_generated_sources/版本变体/out/com/demo/EventBusIndex.java<br>生成的文件的大概是这样的</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This class is generated by EventBus, do not edit. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEventBusIndex</span> <span class=\"keyword\">implements</span> <span class=\"title\">SubscriberInfoIndex</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        SUBSCRIBER_INDEX = <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    putIndex(new SimpleSubscriberInfo(com.demo.MainActivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubscriberMethodInfo(<span class=\"string\">\"setVolume\"</span>, com.demo.VolumeChangeEvent<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">ThreadMode</span>.<span class=\"title\">MAIN</span>),</span></span><br><span class=\"line\">            new SubscriberMethodInfo(\"onFinishEvent\", com.demo.FinishEvent.class, ThreadMode.MAIN),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubscriberMethodInfo(<span class=\"string\">\"onCameraStateEvent\"</span>, com.umu.event.CameraStateEvent<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">ThreadMode</span>.<span class=\"title\">MAIN</span>),</span></span><br><span class=\"line\"><span class=\"class\">    &#125;))</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">putIndex</span><span class=\"params\">(SubscriberInfo info)</span> </span>&#123;</span><br><span class=\"line\">       SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SubscriberInfo <span class=\"title\">getSubscriberInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">    SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> info;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>其中需要仔细理解的是putIndex(SubscriberInfo info),SubscriberInfo描述了包含订阅的类，及其所有的订阅方法<br>同时要在Application种手动的将生成的EventBusIndex类提供给EventBus</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus eventBus = EventBus.builder().addIndex(<span class=\"keyword\">new</span> MyEventBusIndex()).build();</span><br></pre></td></tr></table></figure>\n<p>以上，EventBus实现了订阅者的管理和订阅的注册</p>\n","site":{"data":{}},"excerpt":"<h3 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h3><p>描述一对多的依赖的关系，当一个对象的状态发生变化时，所有依赖它的对象都会获得通知：</p>","more":"<h3 id=\"事件总线\"><a href=\"#事件总线\" class=\"headerlink\" title=\"事件总线\"></a>事件总线</h3><p>消息或者事件流动的通道，不同的组件或者模块通过这个通道获取获取和发布消息；<br>事件总线涉及到4个角色：</p>\n<ul>\n<li>订阅者，subscriber，获取指定类型的消息或者事件</li>\n<li>发布者，publisher，触发或者发布消息或者事件</li>\n<li>事件 Event，订阅者和发布者之间沟通的信息载体，普通的java类，只包括数据</li>\n<li>事件总线，EventBus，管理订阅者和信息的存储，同时负责事件的分发和流转；<br>通过事件总线 组件之间相互解耦，发布者不知道具体订阅者的存在。</li>\n</ul>\n<p><img src=\"../../img/eventbus-1.png\" alt=\"架构图\"></p>\n<p>以上是事件总线的总体思想，如果我们设计一款EventBus，该考虑哪些设计呢？我觉得以下几个问题是比较核心的设计：</p>\n<ul>\n<li>如何管理订阅者</li>\n<li>如何存储事件</li>\n<li>如何触发事件</li>\n<li>如何分发事件</li>\n</ul>\n<p>我看下EventBus是如何处理这些问题的（版本3.2.0），</p>\n<h3 id=\"如何管理订阅者\"><a href=\"#如何管理订阅者\" class=\"headerlink\" title=\"如何管理订阅者\"></a>如何管理订阅者</h3><p>EventvBus的订阅者通过注解实现注册，有个两个方式：</p>\n<ul>\n<li><p>运行时加载订阅<br>基本思路是在register时，通过反射获取当前class的中所有使用了Subscriber注解的方法，把他们加到事件集合里；<br>我们重点分析注解查找方法SubscriberMethodFinder类的findUsingReflection方法</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// subscriberClass 就是通过EventBus.register的对象的类</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> List&lt;SubscriberMethod&gt; <span class=\"title\">findUsingReflection</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用prepareFindState，在查找中限制类的实例个数，应该是基于性能的考虑，因为findState是存在多个map用于临时存储订阅者，订阅者所在的类及事件之间的关系</span></span><br><span class=\"line\">  <span class=\"comment\">// findState就是递归过程中共享数据的变量</span></span><br><span class=\"line\">    FindState findState = prepareFindState();</span><br><span class=\"line\"><span class=\"comment\">// 初始化findState</span></span><br><span class=\"line\">    findState.initForSubscriber(subscriberClass);</span><br><span class=\"line\"><span class=\"comment\">// 开始递归</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (findState.clazz != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\"><span class=\"comment\">// 该方法包括查找注解的核心逻辑</span></span><br><span class=\"line\"><span class=\"comment\">// 1 获取subscriberClass里的所有方法</span></span><br><span class=\"line\"><span class=\"comment\">// 2 遍历这些方法，check是否是public，是否包含1个参数</span></span><br><span class=\"line\"><span class=\"comment\">// 3 解析参数类型，解析方法名，存入findState对应的关系中</span></span><br><span class=\"line\">        findUsingReflectionInSingleClass(findState);</span><br><span class=\"line\"><span class=\"comment\">// 查找父类</span></span><br><span class=\"line\">        findState.moveToSuperclass();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"><span class=\"comment\">//释放findState, 返回查找结果，SubscriberMethod列表</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> getMethodsAndRelease(findState);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>这个里面有一个技巧需要注意，就是控制findState个数，以及在递归中使用。</p>\n</li>\n<li><p>编译时通过SubscriberIndex加载订阅<br>使用如例:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Subscribe</span>(threadMode = ThreadMode.MAIN)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onMessageEvent</span><span class=\"params\">(MessageEvent event)</span> </span>&#123;<span class=\"comment\">/* Do something */</span>&#125;;</span><br></pre></td></tr></table></figure>\n<p>基本实现是思路：使用注解生成器EventBusAnnotationProcessor编译时生成Subscribe的注册类。所以注册的整个过程由2个阶段构成，编译时和运行时。编译时负责收集所有了订阅的类及其类内的回调，运行时执行这些注册，并触发对应的回调。</p>\n</li>\n<li><p>EventBusAnnotationProcessor 负责解析注解类，收集并验证所有使用过Subscribe的方法和方法所在的类，基于收集到方法和类，生成Subscribe的注册类的java文件。<br>EventBusAnnotationProcessor 继承自AbstractProcessor类，AbstractProcessor类负责插入式注解处理器的注解处理过程，很多框架都使用这个技术，以后我会单独研究学习和大家分享，<a href=\"https://juejin.im/post/5d35b8846fb9a07efd474a5a\" target=\"_blank\" rel=\"noopener\">可以看这里简单了解</a>。整体上这个类可以获取编译时环境，及注解的类型，使用注册的类型和方法，注解里使用方法等等，通过这个类我们基本上在编译时获取注解相关的所有信息；<br>需要注意的一点是，如果需要指定文件名和报名，可以在build.gradle 里做如下的声明：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">javaCompileOptions &#123;</span><br><span class=\"line\">    annotationProcessorOptions &#123;</span><br><span class=\"line\">        includeCompileClasspath <span class=\"keyword\">true</span></span><br><span class=\"line\">        arguments = [eventBusIndex: <span class=\"string\">'com.demo.EventBusIndex'</span>]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>AbstractProcessor有很多虚方法，最重要的是process，注解的处理主要通过这个方法处理。重点分析这个方法的处理流程：</p>\n</li>\n<li><p>这个方法有2个输入参数，annotations，指定注解类型的集合，roundEnvironment，用于查询使用指定注解类型的类型的处理器；</p>\n</li>\n<li><p>获取build.gradle中指定的包名，该包名是通过注解生成类的包名；</p>\n</li>\n<li><p>收集使用过指定注解的所有类型，并把这些数据组织成ListMap&lt;TypeElement, ExecutableElement&gt; list的数据；</p>\n</li>\n<li><p>依据上一步的list，验证注解类型的可见性，public为可见，private和protect，检查回调方法的参数类型是否是可见类和可用类；</p>\n</li>\n<li><p>生成代码，主要依据list做字符串拼接，文件的路径是以声明的包名目录，比如com.demo.EventBusIndex，其文件所在的位置是,代码目录/build/generated/ap_generated_sources/版本变体/out/com/demo/EventBusIndex.java<br>生成的文件的大概是这样的</p>\n</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** This class is generated by EventBus, do not edit. */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyEventBusIndex</span> <span class=\"keyword\">implements</span> <span class=\"title\">SubscriberInfoIndex</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;</span><br><span class=\"line\">        SUBSCRIBER_INDEX = <span class=\"keyword\">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    putIndex(new SimpleSubscriberInfo(com.demo.MainActivity.class, true, new SubscriberMethodInfo[] &#123;</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubscriberMethodInfo(<span class=\"string\">\"setVolume\"</span>, com.demo.VolumeChangeEvent<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">ThreadMode</span>.<span class=\"title\">MAIN</span>),</span></span><br><span class=\"line\">            new SubscriberMethodInfo(\"onFinishEvent\", com.demo.FinishEvent.class, ThreadMode.MAIN),</span><br><span class=\"line\">            <span class=\"keyword\">new</span> SubscriberMethodInfo(<span class=\"string\">\"onCameraStateEvent\"</span>, com.umu.event.CameraStateEvent<span class=\"class\">.<span class=\"keyword\">class</span>, <span class=\"title\">ThreadMode</span>.<span class=\"title\">MAIN</span>),</span></span><br><span class=\"line\"><span class=\"class\">    &#125;))</span>;&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">putIndex</span><span class=\"params\">(SubscriberInfo info)</span> </span>&#123;</span><br><span class=\"line\">       SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Override</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> SubscriberInfo <span class=\"title\">getSubscriberInfo</span><span class=\"params\">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class=\"line\">    SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (info != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> info;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">       &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>\n<p>其中需要仔细理解的是putIndex(SubscriberInfo info),SubscriberInfo描述了包含订阅的类，及其所有的订阅方法<br>同时要在Application种手动的将生成的EventBusIndex类提供给EventBus</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">EventBus eventBus = EventBus.builder().addIndex(<span class=\"keyword\">new</span> MyEventBusIndex()).build();</span><br></pre></td></tr></table></figure>\n<p>以上，EventBus实现了订阅者的管理和订阅的注册</p>"},{"title":"android手机执行go程序","date":"2020-03-02T15:23:11.000Z","_content":"\n# 概述\n本文通过在root的android手机中执行一个go程序，来简单记录这基本过程和过程中使用的工具。\n<!--more-->\n# root android手机\n我使用kingRoot，不过现在官方已经关闭了。幸好网络上很多下载可用，我选用的是5.3.6版本。\nroot的原理其实很简单就是把su程序放在系统目录的/system/xbin下，但是要打开这个有需要su的权限，于是打破这个死循环的方式就是各种root方式的区别了，但是本质上都是利用系统漏洞，因为手机厂商在手机出厂时，都是禁掉su权限的，也是不允许随意刷机的。\n# 编写go程序并变成可在arm平台运行的程序\n我们来一段简单的示例代码\n```go\npackage main\nimport (\n    \"net/http\"\n    \"time\"\n)\nfunc main() {\n    http.HandleFunc(\"/\", myResponse)\n    http.ListenAndServe(\"127.0.0.1:8888\", nil)\n}\nfunc myResponse(w http.ResponseWriter,r* http.Request) {\n    t := time.Now()\n    timeString := t.Format(\"2006-01-02 15:04:05\")\n    str := \"hello world! I am from go. time:\"\n    str += timeString\n    w.Write([]byte(str))\n}\n```\n- 本机平台编译测试一下\n```shell\ngo build demo_service.go\n./demo_service\nwget 127.0.0.1:8888 -O test.html | vi ./test.html\n```\n- 交叉编译成arm平台的程序\n```shell\nGOOS=\"linux\" GOARCH=\"arm\" go build demo_service_arm32.go\n```\n# 复制demo_service_arm32.go到android手机\n- 通过adb push把文件复制到sdcard上，通过mv命令把文件从sdcar上移动到/data/data，最后执行。\n```shell\nadb push ./demo_service_arm32 /sdcard\nadb shell\nsu\ncd /sdcard\nmv ./demo_service_arm32 /data/data\nchmod 777 ./demo_service_arm32\n./demo_service_arm32\n```\n手机浏览器打开127.0.0.1:8888就可以看到结果了","source":"_posts/android手机执行go程序.md","raw":"---\ntitle: android手机执行go程序\ndate: 2020-03-02 23:23:11\ntags: go android linux 刷机 root\n---\n\n# 概述\n本文通过在root的android手机中执行一个go程序，来简单记录这基本过程和过程中使用的工具。\n<!--more-->\n# root android手机\n我使用kingRoot，不过现在官方已经关闭了。幸好网络上很多下载可用，我选用的是5.3.6版本。\nroot的原理其实很简单就是把su程序放在系统目录的/system/xbin下，但是要打开这个有需要su的权限，于是打破这个死循环的方式就是各种root方式的区别了，但是本质上都是利用系统漏洞，因为手机厂商在手机出厂时，都是禁掉su权限的，也是不允许随意刷机的。\n# 编写go程序并变成可在arm平台运行的程序\n我们来一段简单的示例代码\n```go\npackage main\nimport (\n    \"net/http\"\n    \"time\"\n)\nfunc main() {\n    http.HandleFunc(\"/\", myResponse)\n    http.ListenAndServe(\"127.0.0.1:8888\", nil)\n}\nfunc myResponse(w http.ResponseWriter,r* http.Request) {\n    t := time.Now()\n    timeString := t.Format(\"2006-01-02 15:04:05\")\n    str := \"hello world! I am from go. time:\"\n    str += timeString\n    w.Write([]byte(str))\n}\n```\n- 本机平台编译测试一下\n```shell\ngo build demo_service.go\n./demo_service\nwget 127.0.0.1:8888 -O test.html | vi ./test.html\n```\n- 交叉编译成arm平台的程序\n```shell\nGOOS=\"linux\" GOARCH=\"arm\" go build demo_service_arm32.go\n```\n# 复制demo_service_arm32.go到android手机\n- 通过adb push把文件复制到sdcard上，通过mv命令把文件从sdcar上移动到/data/data，最后执行。\n```shell\nadb push ./demo_service_arm32 /sdcard\nadb shell\nsu\ncd /sdcard\nmv ./demo_service_arm32 /data/data\nchmod 777 ./demo_service_arm32\n./demo_service_arm32\n```\n手机浏览器打开127.0.0.1:8888就可以看到结果了","slug":"android手机执行go程序","published":1,"updated":"2020-03-02T15:30:14.494Z","_id":"ck7am7mbd0000ufs61gyselwy","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文通过在root的android手机中执行一个go程序，来简单记录这基本过程和过程中使用的工具。</p>\n<a id=\"more\"></a>\n<h1 id=\"root-android手机\"><a href=\"#root-android手机\" class=\"headerlink\" title=\"root android手机\"></a>root android手机</h1><p>我使用kingRoot，不过现在官方已经关闭了。幸好网络上很多下载可用，我选用的是5.3.6版本。<br>root的原理其实很简单就是把su程序放在系统目录的/system/xbin下，但是要打开这个有需要su的权限，于是打破这个死循环的方式就是各种root方式的区别了，但是本质上都是利用系统漏洞，因为手机厂商在手机出厂时，都是禁掉su权限的，也是不允许随意刷机的。</p>\n<h1 id=\"编写go程序并变成可在arm平台运行的程序\"><a href=\"#编写go程序并变成可在arm平台运行的程序\" class=\"headerlink\" title=\"编写go程序并变成可在arm平台运行的程序\"></a>编写go程序并变成可在arm平台运行的程序</h1><p>我们来一段简单的示例代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, myResponse)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">\"127.0.0.1:8888\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myResponse</span><span class=\"params\">(w http.ResponseWriter,r* http.Request)</span></span> &#123;</span><br><span class=\"line\">    t := time.Now()</span><br><span class=\"line\">    timeString := t.Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</span><br><span class=\"line\">    str := <span class=\"string\">\"hello world! I am from go. time:\"</span></span><br><span class=\"line\">    str += timeString</span><br><span class=\"line\">    w.Write([]<span class=\"keyword\">byte</span>(str))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>本机平台编译测试一下<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build demo_service.go</span><br><span class=\"line\">./demo_service</span><br><span class=\"line\">wget 127.0.0.1:8888 -O test.html | vi ./test.html</span><br></pre></td></tr></table></figure></li>\n<li>交叉编译成arm平台的程序<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GOOS=\"linux\" GOARCH=\"arm\" go build demo_service_arm32.go</span><br></pre></td></tr></table></figure>\n<h1 id=\"复制demo-service-arm32-go到android手机\"><a href=\"#复制demo-service-arm32-go到android手机\" class=\"headerlink\" title=\"复制demo_service_arm32.go到android手机\"></a>复制demo_service_arm32.go到android手机</h1></li>\n<li>通过adb push把文件复制到sdcard上，通过mv命令把文件从sdcar上移动到/data/data，最后执行。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb push ./demo_service_arm32 /sdcard</span><br><span class=\"line\">adb shell</span><br><span class=\"line\">su</span><br><span class=\"line\">cd /sdcard</span><br><span class=\"line\">mv ./demo_service_arm32 /data/data</span><br><span class=\"line\">chmod 777 ./demo_service_arm32</span><br><span class=\"line\">./demo_service_arm32</span><br></pre></td></tr></table></figure>\n手机浏览器打开127.0.0.1:8888就可以看到结果了</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文通过在root的android手机中执行一个go程序，来简单记录这基本过程和过程中使用的工具。</p>","more":"<h1 id=\"root-android手机\"><a href=\"#root-android手机\" class=\"headerlink\" title=\"root android手机\"></a>root android手机</h1><p>我使用kingRoot，不过现在官方已经关闭了。幸好网络上很多下载可用，我选用的是5.3.6版本。<br>root的原理其实很简单就是把su程序放在系统目录的/system/xbin下，但是要打开这个有需要su的权限，于是打破这个死循环的方式就是各种root方式的区别了，但是本质上都是利用系统漏洞，因为手机厂商在手机出厂时，都是禁掉su权限的，也是不允许随意刷机的。</p>\n<h1 id=\"编写go程序并变成可在arm平台运行的程序\"><a href=\"#编写go程序并变成可在arm平台运行的程序\" class=\"headerlink\" title=\"编写go程序并变成可在arm平台运行的程序\"></a>编写go程序并变成可在arm平台运行的程序</h1><p>我们来一段简单的示例代码</p>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">    <span class=\"string\">\"net/http\"</span></span><br><span class=\"line\">    <span class=\"string\">\"time\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    http.HandleFunc(<span class=\"string\">\"/\"</span>, myResponse)</span><br><span class=\"line\">    http.ListenAndServe(<span class=\"string\">\"127.0.0.1:8888\"</span>, <span class=\"literal\">nil</span>)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">myResponse</span><span class=\"params\">(w http.ResponseWriter,r* http.Request)</span></span> &#123;</span><br><span class=\"line\">    t := time.Now()</span><br><span class=\"line\">    timeString := t.Format(<span class=\"string\">\"2006-01-02 15:04:05\"</span>)</span><br><span class=\"line\">    str := <span class=\"string\">\"hello world! I am from go. time:\"</span></span><br><span class=\"line\">    str += timeString</span><br><span class=\"line\">    w.Write([]<span class=\"keyword\">byte</span>(str))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>本机平台编译测试一下<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go build demo_service.go</span><br><span class=\"line\">./demo_service</span><br><span class=\"line\">wget 127.0.0.1:8888 -O test.html | vi ./test.html</span><br></pre></td></tr></table></figure></li>\n<li>交叉编译成arm平台的程序<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GOOS=\"linux\" GOARCH=\"arm\" go build demo_service_arm32.go</span><br></pre></td></tr></table></figure>\n<h1 id=\"复制demo-service-arm32-go到android手机\"><a href=\"#复制demo-service-arm32-go到android手机\" class=\"headerlink\" title=\"复制demo_service_arm32.go到android手机\"></a>复制demo_service_arm32.go到android手机</h1></li>\n<li>通过adb push把文件复制到sdcard上，通过mv命令把文件从sdcar上移动到/data/data，最后执行。<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">adb push ./demo_service_arm32 /sdcard</span><br><span class=\"line\">adb shell</span><br><span class=\"line\">su</span><br><span class=\"line\">cd /sdcard</span><br><span class=\"line\">mv ./demo_service_arm32 /data/data</span><br><span class=\"line\">chmod 777 ./demo_service_arm32</span><br><span class=\"line\">./demo_service_arm32</span><br></pre></td></tr></table></figure>\n手机浏览器打开127.0.0.1:8888就可以看到结果了</li>\n</ul>"},{"title":"go入门学习笔记","date":"2020-03-02T15:33:30.568Z","_content":"go入门学习笔记\n<!-- more -->\n# 准备\n- demo的前提条件，本机上按照有go的编译环境。\n- 来一段代码测试下\n```go\npackage main\nimport (\n\t\"fmt\"\n)\nfunc main()  {\n\tfmt.Printf(\"hello world\")\n}\n```\n- 调试方法\n    - 目前基本是打印的方式，如果熟悉PHP的话，你懂得这方式.\n    - 常用的打印方式：fmt.Print/fmt.Println/fmt.Printf.\n    - 使用fmt.Printf打印变量\n        - %+v 打印包括字段在内的实例的完整信息\n        - %#v 打印包括字段和限定类型名称在内的实例的完整信息\n        - %T 打印某个类型的完整信息\n    - 使用panic, 获取执行点的堆栈信息\n    - 使用defer来跟踪代码执行过程\n    \n","source":"_posts/go入门.md","raw":"---\ntitle: go入门学习笔记\ndate: 2020年03月02日23:34:09\ntags: go 语言学习\n---\ngo入门学习笔记\n<!-- more -->\n# 准备\n- demo的前提条件，本机上按照有go的编译环境。\n- 来一段代码测试下\n```go\npackage main\nimport (\n\t\"fmt\"\n)\nfunc main()  {\n\tfmt.Printf(\"hello world\")\n}\n```\n- 调试方法\n    - 目前基本是打印的方式，如果熟悉PHP的话，你懂得这方式.\n    - 常用的打印方式：fmt.Print/fmt.Println/fmt.Printf.\n    - 使用fmt.Printf打印变量\n        - %+v 打印包括字段在内的实例的完整信息\n        - %#v 打印包括字段和限定类型名称在内的实例的完整信息\n        - %T 打印某个类型的完整信息\n    - 使用panic, 获取执行点的堆栈信息\n    - 使用defer来跟踪代码执行过程\n    \n","slug":"go入门","published":1,"updated":"2021-02-16T04:58:41.896Z","_id":"ck8o45s8c00001cs67a9baxju","comments":1,"layout":"post","photos":[],"link":"","content":"<p>go入门学习笔记</p>\n<a id=\"more\"></a>\n<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>demo的前提条件，本机上按照有go的编译环境。</li>\n<li>来一段代码测试下<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>调试方法<ul>\n<li>目前基本是打印的方式，如果熟悉PHP的话，你懂得这方式.</li>\n<li>常用的打印方式：fmt.Print/fmt.Println/fmt.Printf.</li>\n<li>使用fmt.Printf打印变量<ul>\n<li>%+v 打印包括字段在内的实例的完整信息</li>\n<li>%#v 打印包括字段和限定类型名称在内的实例的完整信息</li>\n<li>%T 打印某个类型的完整信息</li>\n</ul>\n</li>\n<li>使用panic, 获取执行点的堆栈信息</li>\n<li>使用defer来跟踪代码执行过程</li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>go入门学习笔记</p>","more":"<h1 id=\"准备\"><a href=\"#准备\" class=\"headerlink\" title=\"准备\"></a>准备</h1><ul>\n<li>demo的前提条件，本机上按照有go的编译环境。</li>\n<li>来一段代码测试下<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">\t<span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>  &#123;</span><br><span class=\"line\">\tfmt.Printf(<span class=\"string\">\"hello world\"</span>)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></li>\n<li>调试方法<ul>\n<li>目前基本是打印的方式，如果熟悉PHP的话，你懂得这方式.</li>\n<li>常用的打印方式：fmt.Print/fmt.Println/fmt.Printf.</li>\n<li>使用fmt.Printf打印变量<ul>\n<li>%+v 打印包括字段在内的实例的完整信息</li>\n<li>%#v 打印包括字段和限定类型名称在内的实例的完整信息</li>\n<li>%T 打印某个类型的完整信息</li>\n</ul>\n</li>\n<li>使用panic, 获取执行点的堆栈信息</li>\n<li>使用defer来跟踪代码执行过程</li>\n</ul>\n</li>\n</ul>"},{"title":"indexedDB杂想","date":"2020-04-06T06:44:19.000Z","_content":"\n## 仔细理解下indexedDB的设计哲学：\n### indexedDB的数据基于键值对\nvalue可以是任何复杂类型的object，键值就是这个这些对象的键值；\n### 基于事务的操作模型\n在indexedDB内的任何操作都是再事务内的；\n这种基于事务的操作模型会很好的处理用户打开两个tab时的数据操作带来的不一致问题；\n###  API都是异步的\n数据库数据读取，插入，删除等所有的数据库都是异步的。这些操作都需要请求（request），数据库接收请求，接收请求，并执行请求中callback操作，操作结果会以dom event的形式通知\n###  基于请求对象模型\n请求本质上沟通用户层和数据库层的通信方式，请求上可以绑定事件，用以接收数据库层的操作结果。不同的数据库操作返回的请求对象也不同，包含的对象也是不同的；\n###  当数据库操作结果可用时，数据库以dom event的方式通知使用者\n在几乎所有的请求对象中，success和error都是可用的。需要注意的是success不能往上冒泡以及取消数据操作，而error却可以，error可以取消任何正在运行的数据库事务\n###  对象数据，而不是关系数据库\n###  NoSql 数据库\n###  遵循同一来源策略\n## 如何理解异步\n在用户端上的操作上，indexeddb的操作思想和ajax一致，他们都是异步的，发送请求，然后结束，通过事件的形式通知，js的单线程和浏览器的宿主环境决定操作上不宜使用同步操作，这种思想被借鉴到很多地方，比如nginx和nodesjs，实际上很多不同操作环境的交互越来越多的使用这种方式，前端最常用的js和webview交互，在本质上也是这种，再具体实现上，因为webview和js不能传递包装好的request的请求，所以以消息队列的方式实现request的包装，在js侧上看和request数据库的操作类似；\n\n在理解上，可以简单的看成请求-通知的模型，和观察者模式有异曲同工之妙；\n\n随着前端技术标准化的发展，很多异步通信会被归结为一种标准化的操作；\n\n## js的异步写法\n前端在异步上的写法也越来越方便快捷，常用的有 callback模式，promise模式，async-await模式，以及生成器；我之前限于浅薄的认识，没有思考过这些模式的组合带来的一些效果，但是在indexedDB的接口封装中，这些模式的组合使用会带来更便利的使用。简单的分析下idb-keyval的实现思路。 作者把indexedDB的异步封装成了promise的形式，使用callback的模式封装具体的对数据库的操作，而用户端端看到的完全是promise化的接口。仔细品味以下核心代码：\n```js\n_withIDBStore(type: IDBTransactionMode, callback: ((store: IDBObjectStore) => void)): Promise<void> {\n    return this._dbp.then(db => new Promise<void>((resolve, reject) => {\n        const transaction = db.transaction(this.storeName, type);\n        const store = transaction.objectStore(this.storeName)\n        transaction.oncomplete = () => resolve();\n        transaction.onabort = transaction.onerror = () => reject(transaction.error);\n        callback(store);\n    }));\n}\n```\n在一个事务中，callback负责完成store的指定操作，比如get，put之类, oncomplete在事务完成后触发，这样就把一个transaction封装在了一个promise，而callback有留出了自定义操作的灵活。这种简洁的处理，有非常好借鉴意义。举个实际点的栗子：\n封装一个用户购买游戏道具的标准流程：当用户发起购买时，1 请求接口，获取当前用户的等级；2 根据用户的等级，弹出不同的道具弹窗；3 用户选择关闭弹窗或者选择一个道具，发起支付，这个流程作为一个服务组件，弹不同的道具弹窗就是一个自定义动作，是不同的游戏关卡中自己定义的，核心代码如下：\n```js\n\nfunction purchaseProps(userId: string, openDialogCallback: (userInfo: any) => Promise<void>) {\n    return fetch(`${get_userinfo_url}`).then(userInfo => new Promise((resolve, reject) => {\n            const dialog = openDialogCallback(userInfo);\n            dialog.then(propId => {\n            resolve(propId);\n            // doPay(); 继续封装道具购买流程\n        }, () => {\n            reject();\n        }).catch(reason => reject(reason));\n    }));\n}\n\n// 使用者\npurchaseProps('king', userInfo => openKingDialong()).then((propId: string) => {\n    doPay(); // 发起支付\n})\n\n```\n\n","source":"_posts/indexedDB杂想.md","raw":"---\ntitle: indexedDB杂想\ndate: 2020-04-06 14:44:19\ntags: 技术杂想\n---\n\n## 仔细理解下indexedDB的设计哲学：\n### indexedDB的数据基于键值对\nvalue可以是任何复杂类型的object，键值就是这个这些对象的键值；\n### 基于事务的操作模型\n在indexedDB内的任何操作都是再事务内的；\n这种基于事务的操作模型会很好的处理用户打开两个tab时的数据操作带来的不一致问题；\n###  API都是异步的\n数据库数据读取，插入，删除等所有的数据库都是异步的。这些操作都需要请求（request），数据库接收请求，接收请求，并执行请求中callback操作，操作结果会以dom event的形式通知\n###  基于请求对象模型\n请求本质上沟通用户层和数据库层的通信方式，请求上可以绑定事件，用以接收数据库层的操作结果。不同的数据库操作返回的请求对象也不同，包含的对象也是不同的；\n###  当数据库操作结果可用时，数据库以dom event的方式通知使用者\n在几乎所有的请求对象中，success和error都是可用的。需要注意的是success不能往上冒泡以及取消数据操作，而error却可以，error可以取消任何正在运行的数据库事务\n###  对象数据，而不是关系数据库\n###  NoSql 数据库\n###  遵循同一来源策略\n## 如何理解异步\n在用户端上的操作上，indexeddb的操作思想和ajax一致，他们都是异步的，发送请求，然后结束，通过事件的形式通知，js的单线程和浏览器的宿主环境决定操作上不宜使用同步操作，这种思想被借鉴到很多地方，比如nginx和nodesjs，实际上很多不同操作环境的交互越来越多的使用这种方式，前端最常用的js和webview交互，在本质上也是这种，再具体实现上，因为webview和js不能传递包装好的request的请求，所以以消息队列的方式实现request的包装，在js侧上看和request数据库的操作类似；\n\n在理解上，可以简单的看成请求-通知的模型，和观察者模式有异曲同工之妙；\n\n随着前端技术标准化的发展，很多异步通信会被归结为一种标准化的操作；\n\n## js的异步写法\n前端在异步上的写法也越来越方便快捷，常用的有 callback模式，promise模式，async-await模式，以及生成器；我之前限于浅薄的认识，没有思考过这些模式的组合带来的一些效果，但是在indexedDB的接口封装中，这些模式的组合使用会带来更便利的使用。简单的分析下idb-keyval的实现思路。 作者把indexedDB的异步封装成了promise的形式，使用callback的模式封装具体的对数据库的操作，而用户端端看到的完全是promise化的接口。仔细品味以下核心代码：\n```js\n_withIDBStore(type: IDBTransactionMode, callback: ((store: IDBObjectStore) => void)): Promise<void> {\n    return this._dbp.then(db => new Promise<void>((resolve, reject) => {\n        const transaction = db.transaction(this.storeName, type);\n        const store = transaction.objectStore(this.storeName)\n        transaction.oncomplete = () => resolve();\n        transaction.onabort = transaction.onerror = () => reject(transaction.error);\n        callback(store);\n    }));\n}\n```\n在一个事务中，callback负责完成store的指定操作，比如get，put之类, oncomplete在事务完成后触发，这样就把一个transaction封装在了一个promise，而callback有留出了自定义操作的灵活。这种简洁的处理，有非常好借鉴意义。举个实际点的栗子：\n封装一个用户购买游戏道具的标准流程：当用户发起购买时，1 请求接口，获取当前用户的等级；2 根据用户的等级，弹出不同的道具弹窗；3 用户选择关闭弹窗或者选择一个道具，发起支付，这个流程作为一个服务组件，弹不同的道具弹窗就是一个自定义动作，是不同的游戏关卡中自己定义的，核心代码如下：\n```js\n\nfunction purchaseProps(userId: string, openDialogCallback: (userInfo: any) => Promise<void>) {\n    return fetch(`${get_userinfo_url}`).then(userInfo => new Promise((resolve, reject) => {\n            const dialog = openDialogCallback(userInfo);\n            dialog.then(propId => {\n            resolve(propId);\n            // doPay(); 继续封装道具购买流程\n        }, () => {\n            reject();\n        }).catch(reason => reject(reason));\n    }));\n}\n\n// 使用者\npurchaseProps('king', userInfo => openKingDialong()).then((propId: string) => {\n    doPay(); // 发起支付\n})\n\n```\n\n","slug":"indexedDB杂想","published":1,"updated":"2020-04-06T06:50:42.038Z","_id":"ck8o45s8k00011cs68urn23iu","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"仔细理解下indexedDB的设计哲学：\"><a href=\"#仔细理解下indexedDB的设计哲学：\" class=\"headerlink\" title=\"仔细理解下indexedDB的设计哲学：\"></a>仔细理解下indexedDB的设计哲学：</h2><h3 id=\"indexedDB的数据基于键值对\"><a href=\"#indexedDB的数据基于键值对\" class=\"headerlink\" title=\"indexedDB的数据基于键值对\"></a>indexedDB的数据基于键值对</h3><p>value可以是任何复杂类型的object，键值就是这个这些对象的键值；</p>\n<h3 id=\"基于事务的操作模型\"><a href=\"#基于事务的操作模型\" class=\"headerlink\" title=\"基于事务的操作模型\"></a>基于事务的操作模型</h3><p>在indexedDB内的任何操作都是再事务内的；<br>这种基于事务的操作模型会很好的处理用户打开两个tab时的数据操作带来的不一致问题；</p>\n<h3 id=\"API都是异步的\"><a href=\"#API都是异步的\" class=\"headerlink\" title=\"API都是异步的\"></a>API都是异步的</h3><p>数据库数据读取，插入，删除等所有的数据库都是异步的。这些操作都需要请求（request），数据库接收请求，接收请求，并执行请求中callback操作，操作结果会以dom event的形式通知</p>\n<h3 id=\"基于请求对象模型\"><a href=\"#基于请求对象模型\" class=\"headerlink\" title=\"基于请求对象模型\"></a>基于请求对象模型</h3><p>请求本质上沟通用户层和数据库层的通信方式，请求上可以绑定事件，用以接收数据库层的操作结果。不同的数据库操作返回的请求对象也不同，包含的对象也是不同的；</p>\n<h3 id=\"当数据库操作结果可用时，数据库以dom-event的方式通知使用者\"><a href=\"#当数据库操作结果可用时，数据库以dom-event的方式通知使用者\" class=\"headerlink\" title=\"当数据库操作结果可用时，数据库以dom event的方式通知使用者\"></a>当数据库操作结果可用时，数据库以dom event的方式通知使用者</h3><p>在几乎所有的请求对象中，success和error都是可用的。需要注意的是success不能往上冒泡以及取消数据操作，而error却可以，error可以取消任何正在运行的数据库事务</p>\n<h3 id=\"对象数据，而不是关系数据库\"><a href=\"#对象数据，而不是关系数据库\" class=\"headerlink\" title=\"对象数据，而不是关系数据库\"></a>对象数据，而不是关系数据库</h3><h3 id=\"NoSql-数据库\"><a href=\"#NoSql-数据库\" class=\"headerlink\" title=\"NoSql 数据库\"></a>NoSql 数据库</h3><h3 id=\"遵循同一来源策略\"><a href=\"#遵循同一来源策略\" class=\"headerlink\" title=\"遵循同一来源策略\"></a>遵循同一来源策略</h3><h2 id=\"如何理解异步\"><a href=\"#如何理解异步\" class=\"headerlink\" title=\"如何理解异步\"></a>如何理解异步</h2><p>在用户端上的操作上，indexeddb的操作思想和ajax一致，他们都是异步的，发送请求，然后结束，通过事件的形式通知，js的单线程和浏览器的宿主环境决定操作上不宜使用同步操作，这种思想被借鉴到很多地方，比如nginx和nodesjs，实际上很多不同操作环境的交互越来越多的使用这种方式，前端最常用的js和webview交互，在本质上也是这种，再具体实现上，因为webview和js不能传递包装好的request的请求，所以以消息队列的方式实现request的包装，在js侧上看和request数据库的操作类似；</p>\n<p>在理解上，可以简单的看成请求-通知的模型，和观察者模式有异曲同工之妙；</p>\n<p>随着前端技术标准化的发展，很多异步通信会被归结为一种标准化的操作；</p>\n<h2 id=\"js的异步写法\"><a href=\"#js的异步写法\" class=\"headerlink\" title=\"js的异步写法\"></a>js的异步写法</h2><p>前端在异步上的写法也越来越方便快捷，常用的有 callback模式，promise模式，async-await模式，以及生成器；我之前限于浅薄的认识，没有思考过这些模式的组合带来的一些效果，但是在indexedDB的接口封装中，这些模式的组合使用会带来更便利的使用。简单的分析下idb-keyval的实现思路。 作者把indexedDB的异步封装成了promise的形式，使用callback的模式封装具体的对数据库的操作，而用户端端看到的完全是promise化的接口。仔细品味以下核心代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withIDBStore(type: IDBTransactionMode, <span class=\"attr\">callback</span>: <span class=\"function\">(<span class=\"params\">(store: IDBObjectStore</span>) =&gt;</span> <span class=\"keyword\">void</span>)): <span class=\"built_in\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._dbp.then(<span class=\"function\"><span class=\"params\">db</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> transaction = db.transaction(<span class=\"keyword\">this</span>.storeName, type);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> store = transaction.objectStore(<span class=\"keyword\">this</span>.storeName)</span><br><span class=\"line\">        transaction.oncomplete = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve();</span><br><span class=\"line\">        transaction.onabort = transaction.onerror = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(transaction.error);</span><br><span class=\"line\">        callback(store);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个事务中，callback负责完成store的指定操作，比如get，put之类, oncomplete在事务完成后触发，这样就把一个transaction封装在了一个promise，而callback有留出了自定义操作的灵活。这种简洁的处理，有非常好借鉴意义。举个实际点的栗子：<br>封装一个用户购买游戏道具的标准流程：当用户发起购买时，1 请求接口，获取当前用户的等级；2 根据用户的等级，弹出不同的道具弹窗；3 用户选择关闭弹窗或者选择一个道具，发起支付，这个流程作为一个服务组件，弹不同的道具弹窗就是一个自定义动作，是不同的游戏关卡中自己定义的，核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">purchaseProps</span>(<span class=\"params\">userId: string, openDialogCallback: (userInfo: any</span>) =&gt; <span class=\"title\">Promise</span>&lt;<span class=\"title\">void</span>&gt;) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`<span class=\"subst\">$&#123;get_userinfo_url&#125;</span>`</span>).then(<span class=\"function\"><span class=\"params\">userInfo</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> dialog = openDialogCallback(userInfo);</span><br><span class=\"line\">            dialog.then(<span class=\"function\"><span class=\"params\">propId</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(propId);</span><br><span class=\"line\">            <span class=\"comment\">// doPay(); 继续封装道具购买流程</span></span><br><span class=\"line\">        &#125;, () =&gt; &#123;</span><br><span class=\"line\">            reject();</span><br><span class=\"line\">        &#125;).catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> reject(reason));</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者</span></span><br><span class=\"line\">purchaseProps(<span class=\"string\">'king'</span>, userInfo =&gt; openKingDialong()).then(<span class=\"function\">(<span class=\"params\">propId: string</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    doPay(); <span class=\"comment\">// 发起支付</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"仔细理解下indexedDB的设计哲学：\"><a href=\"#仔细理解下indexedDB的设计哲学：\" class=\"headerlink\" title=\"仔细理解下indexedDB的设计哲学：\"></a>仔细理解下indexedDB的设计哲学：</h2><h3 id=\"indexedDB的数据基于键值对\"><a href=\"#indexedDB的数据基于键值对\" class=\"headerlink\" title=\"indexedDB的数据基于键值对\"></a>indexedDB的数据基于键值对</h3><p>value可以是任何复杂类型的object，键值就是这个这些对象的键值；</p>\n<h3 id=\"基于事务的操作模型\"><a href=\"#基于事务的操作模型\" class=\"headerlink\" title=\"基于事务的操作模型\"></a>基于事务的操作模型</h3><p>在indexedDB内的任何操作都是再事务内的；<br>这种基于事务的操作模型会很好的处理用户打开两个tab时的数据操作带来的不一致问题；</p>\n<h3 id=\"API都是异步的\"><a href=\"#API都是异步的\" class=\"headerlink\" title=\"API都是异步的\"></a>API都是异步的</h3><p>数据库数据读取，插入，删除等所有的数据库都是异步的。这些操作都需要请求（request），数据库接收请求，接收请求，并执行请求中callback操作，操作结果会以dom event的形式通知</p>\n<h3 id=\"基于请求对象模型\"><a href=\"#基于请求对象模型\" class=\"headerlink\" title=\"基于请求对象模型\"></a>基于请求对象模型</h3><p>请求本质上沟通用户层和数据库层的通信方式，请求上可以绑定事件，用以接收数据库层的操作结果。不同的数据库操作返回的请求对象也不同，包含的对象也是不同的；</p>\n<h3 id=\"当数据库操作结果可用时，数据库以dom-event的方式通知使用者\"><a href=\"#当数据库操作结果可用时，数据库以dom-event的方式通知使用者\" class=\"headerlink\" title=\"当数据库操作结果可用时，数据库以dom event的方式通知使用者\"></a>当数据库操作结果可用时，数据库以dom event的方式通知使用者</h3><p>在几乎所有的请求对象中，success和error都是可用的。需要注意的是success不能往上冒泡以及取消数据操作，而error却可以，error可以取消任何正在运行的数据库事务</p>\n<h3 id=\"对象数据，而不是关系数据库\"><a href=\"#对象数据，而不是关系数据库\" class=\"headerlink\" title=\"对象数据，而不是关系数据库\"></a>对象数据，而不是关系数据库</h3><h3 id=\"NoSql-数据库\"><a href=\"#NoSql-数据库\" class=\"headerlink\" title=\"NoSql 数据库\"></a>NoSql 数据库</h3><h3 id=\"遵循同一来源策略\"><a href=\"#遵循同一来源策略\" class=\"headerlink\" title=\"遵循同一来源策略\"></a>遵循同一来源策略</h3><h2 id=\"如何理解异步\"><a href=\"#如何理解异步\" class=\"headerlink\" title=\"如何理解异步\"></a>如何理解异步</h2><p>在用户端上的操作上，indexeddb的操作思想和ajax一致，他们都是异步的，发送请求，然后结束，通过事件的形式通知，js的单线程和浏览器的宿主环境决定操作上不宜使用同步操作，这种思想被借鉴到很多地方，比如nginx和nodesjs，实际上很多不同操作环境的交互越来越多的使用这种方式，前端最常用的js和webview交互，在本质上也是这种，再具体实现上，因为webview和js不能传递包装好的request的请求，所以以消息队列的方式实现request的包装，在js侧上看和request数据库的操作类似；</p>\n<p>在理解上，可以简单的看成请求-通知的模型，和观察者模式有异曲同工之妙；</p>\n<p>随着前端技术标准化的发展，很多异步通信会被归结为一种标准化的操作；</p>\n<h2 id=\"js的异步写法\"><a href=\"#js的异步写法\" class=\"headerlink\" title=\"js的异步写法\"></a>js的异步写法</h2><p>前端在异步上的写法也越来越方便快捷，常用的有 callback模式，promise模式，async-await模式，以及生成器；我之前限于浅薄的认识，没有思考过这些模式的组合带来的一些效果，但是在indexedDB的接口封装中，这些模式的组合使用会带来更便利的使用。简单的分析下idb-keyval的实现思路。 作者把indexedDB的异步封装成了promise的形式，使用callback的模式封装具体的对数据库的操作，而用户端端看到的完全是promise化的接口。仔细品味以下核心代码：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_withIDBStore(type: IDBTransactionMode, <span class=\"attr\">callback</span>: <span class=\"function\">(<span class=\"params\">(store: IDBObjectStore</span>) =&gt;</span> <span class=\"keyword\">void</span>)): <span class=\"built_in\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt; &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>._dbp.then(<span class=\"function\"><span class=\"params\">db</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>&lt;<span class=\"keyword\">void</span>&gt;<span class=\"function\">(<span class=\"params\">(resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">const</span> transaction = db.transaction(<span class=\"keyword\">this</span>.storeName, type);</span><br><span class=\"line\">        <span class=\"keyword\">const</span> store = transaction.objectStore(<span class=\"keyword\">this</span>.storeName)</span><br><span class=\"line\">        transaction.oncomplete = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> resolve();</span><br><span class=\"line\">        transaction.onabort = transaction.onerror = <span class=\"function\"><span class=\"params\">()</span> =&gt;</span> reject(transaction.error);</span><br><span class=\"line\">        callback(store);</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>在一个事务中，callback负责完成store的指定操作，比如get，put之类, oncomplete在事务完成后触发，这样就把一个transaction封装在了一个promise，而callback有留出了自定义操作的灵活。这种简洁的处理，有非常好借鉴意义。举个实际点的栗子：<br>封装一个用户购买游戏道具的标准流程：当用户发起购买时，1 请求接口，获取当前用户的等级；2 根据用户的等级，弹出不同的道具弹窗；3 用户选择关闭弹窗或者选择一个道具，发起支付，这个流程作为一个服务组件，弹不同的道具弹窗就是一个自定义动作，是不同的游戏关卡中自己定义的，核心代码如下：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">purchaseProps</span>(<span class=\"params\">userId: string, openDialogCallback: (userInfo: any</span>) =&gt; <span class=\"title\">Promise</span>&lt;<span class=\"title\">void</span>&gt;) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> fetch(<span class=\"string\">`<span class=\"subst\">$&#123;get_userinfo_url&#125;</span>`</span>).then(<span class=\"function\"><span class=\"params\">userInfo</span> =&gt;</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Promise</span>(<span class=\"function\">(<span class=\"params\">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">const</span> dialog = openDialogCallback(userInfo);</span><br><span class=\"line\">            dialog.then(<span class=\"function\"><span class=\"params\">propId</span> =&gt;</span> &#123;</span><br><span class=\"line\">            resolve(propId);</span><br><span class=\"line\">            <span class=\"comment\">// doPay(); 继续封装道具购买流程</span></span><br><span class=\"line\">        &#125;, () =&gt; &#123;</span><br><span class=\"line\">            reject();</span><br><span class=\"line\">        &#125;).catch(<span class=\"function\"><span class=\"params\">reason</span> =&gt;</span> reject(reason));</span><br><span class=\"line\">    &#125;));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用者</span></span><br><span class=\"line\">purchaseProps(<span class=\"string\">'king'</span>, userInfo =&gt; openKingDialong()).then(<span class=\"function\">(<span class=\"params\">propId: string</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    doPay(); <span class=\"comment\">// 发起支付</span></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n"},{"title":"2020年4月4日·全国哀悼日","date":"2020-04-03T16:00:00.000Z","_content":"\n疫情中逝去的每一个生命，都不只是一个简单的数字或名字。\n<!-- more -->\n他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。\n\n我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。\n\n全球确诊病例已经突破百万！祈祷他们早日康复！\n\n祝福健康与我们每一个人同在！\n","source":"_posts/20200404.md","raw":"---\ntitle: 2020年4月4日·全国哀悼日\ndate: 2020-04-04\ntags: 社会 感悟\n---\n\n疫情中逝去的每一个生命，都不只是一个简单的数字或名字。\n<!-- more -->\n他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。\n\n我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。\n\n全球确诊病例已经突破百万！祈祷他们早日康复！\n\n祝福健康与我们每一个人同在！\n","slug":"20200404","published":1,"updated":"2021-02-16T04:58:16.217Z","_id":"ck8o4n7870000bps6ffhj66ac","comments":1,"layout":"post","photos":[],"link":"","content":"<p>疫情中逝去的每一个生命，都不只是一个简单的数字或名字。</p>\n<a id=\"more\"></a>\n<p>他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。</p>\n<p>我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。</p>\n<p>全球确诊病例已经突破百万！祈祷他们早日康复！</p>\n<p>祝福健康与我们每一个人同在！</p>\n","site":{"data":{}},"excerpt":"<p>疫情中逝去的每一个生命，都不只是一个简单的数字或名字。</p>","more":"<p>他们是父亲、母亲、儿女、兄妹，是我们血脉相连的骨肉同胞。</p>\n<p>我们向逝世同胞致哀，同时也向那些与死神不屈抗争的生命致敬，向那种生死瞬间的人间大爱致礼。</p>\n<p>全球确诊病例已经突破百万！祈祷他们早日康复！</p>\n<p>祝福健康与我们每一个人同在！</p>"},{"title":"一起的一起","date":"2020-04-26T18:29:54.000Z","_content":"\n有感最近所在公司有一起奋斗了很多年的老同志离职。\n\n就像是夫妻间的七年之痒。\n总有一些委屈不想忍耐，总有一些原则不想将就，总有一些事情不再重要，总有一些未来不想等待，总有一些决定不再犹豫，总有一些结果不想回避；\n\n宴席散，酒留肚肠，沁入脾胃，化作心雨寄离伤；\n夕阳西下，人各天涯，不敢见屏幕，默然线上代码数万行；\n\n闭眼回想，往事如昨，太多的经历，要加上“一起”这个词！\n\n一起跑步，一起午饭，一起晚饭，一起赶地铁；\n一起聚餐，一起k歌，一起游船，一起看大海，\n一起撩妹，一起游戏，一起写码，一起改bug，\n一起熬夜，一起加班，一起上线，一起赶进度，\n一起开会，一起争论，一起流泪，一起挨批评，\n一起郁闷，一起沮丧，一起吐槽，一起想跳楼，\n一起失败，一起成功，一起奋斗，一起赶项目，\n一起走，一起玩，一起读书，一起进步，\n一起吃，一起喝，一起回家，一起高兴，\n一起疯，一起狂，一起犯二，一起癫狂，\n一起的一起总是流淌在日常的生活里，\n一起的一起总是泼洒在生活的阳光里，\n一起的一起总是徜徉在阳光的沙滩上，\n站在沙滩，面朝大海，背靠背的歌唱！\n...\n\n人生就是这样，一起一起着，就各奔了西东，不知是迷路了，还是走散了，总之，我们是不在一起了；\n\n一起一起着，就成了一起的往事，一起的回忆；\n一起一起着，就成了一起的遗憾，一起的怅然；\n一起一起着，就成了一起的永远，一起的梦幻；\n\n\n人的出生就是伴随着和母体的分离，离别是人的宿命，可是不论怎样，母子连心。\n\n心若在，梦就在，一起追梦，向阳而生，就是一起的一起！\n\n\n","source":"_posts/一起的一起.md","raw":"---\ntitle: 一起的一起\ndate: 2020-04-27 02:29:54\ntags: 人生感悟\n---\n\n有感最近所在公司有一起奋斗了很多年的老同志离职。\n\n就像是夫妻间的七年之痒。\n总有一些委屈不想忍耐，总有一些原则不想将就，总有一些事情不再重要，总有一些未来不想等待，总有一些决定不再犹豫，总有一些结果不想回避；\n\n宴席散，酒留肚肠，沁入脾胃，化作心雨寄离伤；\n夕阳西下，人各天涯，不敢见屏幕，默然线上代码数万行；\n\n闭眼回想，往事如昨，太多的经历，要加上“一起”这个词！\n\n一起跑步，一起午饭，一起晚饭，一起赶地铁；\n一起聚餐，一起k歌，一起游船，一起看大海，\n一起撩妹，一起游戏，一起写码，一起改bug，\n一起熬夜，一起加班，一起上线，一起赶进度，\n一起开会，一起争论，一起流泪，一起挨批评，\n一起郁闷，一起沮丧，一起吐槽，一起想跳楼，\n一起失败，一起成功，一起奋斗，一起赶项目，\n一起走，一起玩，一起读书，一起进步，\n一起吃，一起喝，一起回家，一起高兴，\n一起疯，一起狂，一起犯二，一起癫狂，\n一起的一起总是流淌在日常的生活里，\n一起的一起总是泼洒在生活的阳光里，\n一起的一起总是徜徉在阳光的沙滩上，\n站在沙滩，面朝大海，背靠背的歌唱！\n...\n\n人生就是这样，一起一起着，就各奔了西东，不知是迷路了，还是走散了，总之，我们是不在一起了；\n\n一起一起着，就成了一起的往事，一起的回忆；\n一起一起着，就成了一起的遗憾，一起的怅然；\n一起一起着，就成了一起的永远，一起的梦幻；\n\n\n人的出生就是伴随着和母体的分离，离别是人的宿命，可是不论怎样，母子连心。\n\n心若在，梦就在，一起追梦，向阳而生，就是一起的一起！\n\n\n","slug":"一起的一起","published":1,"updated":"2020-05-02T14:58:11.353Z","_id":"ck9hghdgx0000d1s6gi0r0tc1","comments":1,"layout":"post","photos":[],"link":"","content":"<p>有感最近所在公司有一起奋斗了很多年的老同志离职。</p>\n<p>就像是夫妻间的七年之痒。<br>总有一些委屈不想忍耐，总有一些原则不想将就，总有一些事情不再重要，总有一些未来不想等待，总有一些决定不再犹豫，总有一些结果不想回避；</p>\n<p>宴席散，酒留肚肠，沁入脾胃，化作心雨寄离伤；<br>夕阳西下，人各天涯，不敢见屏幕，默然线上代码数万行；</p>\n<p>闭眼回想，往事如昨，太多的经历，要加上“一起”这个词！</p>\n<p>一起跑步，一起午饭，一起晚饭，一起赶地铁；<br>一起聚餐，一起k歌，一起游船，一起看大海，<br>一起撩妹，一起游戏，一起写码，一起改bug，<br>一起熬夜，一起加班，一起上线，一起赶进度，<br>一起开会，一起争论，一起流泪，一起挨批评，<br>一起郁闷，一起沮丧，一起吐槽，一起想跳楼，<br>一起失败，一起成功，一起奋斗，一起赶项目，<br>一起走，一起玩，一起读书，一起进步，<br>一起吃，一起喝，一起回家，一起高兴，<br>一起疯，一起狂，一起犯二，一起癫狂，<br>一起的一起总是流淌在日常的生活里，<br>一起的一起总是泼洒在生活的阳光里，<br>一起的一起总是徜徉在阳光的沙滩上，<br>站在沙滩，面朝大海，背靠背的歌唱！<br>…</p>\n<p>人生就是这样，一起一起着，就各奔了西东，不知是迷路了，还是走散了，总之，我们是不在一起了；</p>\n<p>一起一起着，就成了一起的往事，一起的回忆；<br>一起一起着，就成了一起的遗憾，一起的怅然；<br>一起一起着，就成了一起的永远，一起的梦幻；</p>\n<p>人的出生就是伴随着和母体的分离，离别是人的宿命，可是不论怎样，母子连心。</p>\n<p>心若在，梦就在，一起追梦，向阳而生，就是一起的一起！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>有感最近所在公司有一起奋斗了很多年的老同志离职。</p>\n<p>就像是夫妻间的七年之痒。<br>总有一些委屈不想忍耐，总有一些原则不想将就，总有一些事情不再重要，总有一些未来不想等待，总有一些决定不再犹豫，总有一些结果不想回避；</p>\n<p>宴席散，酒留肚肠，沁入脾胃，化作心雨寄离伤；<br>夕阳西下，人各天涯，不敢见屏幕，默然线上代码数万行；</p>\n<p>闭眼回想，往事如昨，太多的经历，要加上“一起”这个词！</p>\n<p>一起跑步，一起午饭，一起晚饭，一起赶地铁；<br>一起聚餐，一起k歌，一起游船，一起看大海，<br>一起撩妹，一起游戏，一起写码，一起改bug，<br>一起熬夜，一起加班，一起上线，一起赶进度，<br>一起开会，一起争论，一起流泪，一起挨批评，<br>一起郁闷，一起沮丧，一起吐槽，一起想跳楼，<br>一起失败，一起成功，一起奋斗，一起赶项目，<br>一起走，一起玩，一起读书，一起进步，<br>一起吃，一起喝，一起回家，一起高兴，<br>一起疯，一起狂，一起犯二，一起癫狂，<br>一起的一起总是流淌在日常的生活里，<br>一起的一起总是泼洒在生活的阳光里，<br>一起的一起总是徜徉在阳光的沙滩上，<br>站在沙滩，面朝大海，背靠背的歌唱！<br>…</p>\n<p>人生就是这样，一起一起着，就各奔了西东，不知是迷路了，还是走散了，总之，我们是不在一起了；</p>\n<p>一起一起着，就成了一起的往事，一起的回忆；<br>一起一起着，就成了一起的遗憾，一起的怅然；<br>一起一起着，就成了一起的永远，一起的梦幻；</p>\n<p>人的出生就是伴随着和母体的分离，离别是人的宿命，可是不论怎样，母子连心。</p>\n<p>心若在，梦就在，一起追梦，向阳而生，就是一起的一起！</p>\n"},{"title":"The Zen of Python","date":"2020-04-26T18:29:54.000Z","_content":"\nBeautiful is better than ugly.\n\nExplicit is better than implicit.\n\nSimple is better than complex.\n\nComplex is better than complicated.\n\nFlat is better than nested.\n\nSparse is better than dense.\n\nReadability counts.\n\nSpecial cases aren't special enough \nto break the rules.\n\nAlthough practicality beats purity.\n\nErrors should never pass silently.\n\nUnless explicitly silenced.\n\nIn the face of ambiguity, refuse the temptation to guess.\n\nThere should be one-- and preferably only one --obvious way to do it.\n\nAlthough that way may not be obvious at first unless you're Dutch.\n\nNow is better than never.\n\nAlthough never is often better than *right* now.\n\nIf the implementation is hard to explain, it's a bad idea.\n\nIf the implementation is easy to explain, it may be a good idea.\n\nNamespaces are one honking great idea -- let's do more of those!\n\n---\n\n优美优于丑陋；\n\n明了优于隐晦；\n\n简单优于复杂；\n\n复杂优于凌乱；\n\n扁平优于嵌套；\n\n稀疏优于稠密；\n\n可读性很重要；\n\n即使实用比纯粹更优，\n特例亦不可违背原则。\n\n错误绝不能悄悄忽略，\n除非它明确需要如此。\n\n面对不确定性，\n拒绝妄加猜测。\n\n任何问题应有一种，\n且最好只有一种，\n显而易见的解决方法。\n\n尽管这方法一开始并非如此直观，\n除非你是荷兰人。\n\n做优于不做，\n然而不假思索还不如不做。\n\n很难解释的，必然是坏方法。\n\n很好解释的，可能是好方法。\n\n命名空间是个绝妙的主意，\n我们应好好利用它。\n\n[The Zen of Python](https://www.python.org/dev/peps/pep-0020/)","source":"_posts/python之禅.md","raw":"---\ntitle: The Zen of Python\ndate: 2020-04-27 02:29:54\ntags: Python 语言学习\n---\n\nBeautiful is better than ugly.\n\nExplicit is better than implicit.\n\nSimple is better than complex.\n\nComplex is better than complicated.\n\nFlat is better than nested.\n\nSparse is better than dense.\n\nReadability counts.\n\nSpecial cases aren't special enough \nto break the rules.\n\nAlthough practicality beats purity.\n\nErrors should never pass silently.\n\nUnless explicitly silenced.\n\nIn the face of ambiguity, refuse the temptation to guess.\n\nThere should be one-- and preferably only one --obvious way to do it.\n\nAlthough that way may not be obvious at first unless you're Dutch.\n\nNow is better than never.\n\nAlthough never is often better than *right* now.\n\nIf the implementation is hard to explain, it's a bad idea.\n\nIf the implementation is easy to explain, it may be a good idea.\n\nNamespaces are one honking great idea -- let's do more of those!\n\n---\n\n优美优于丑陋；\n\n明了优于隐晦；\n\n简单优于复杂；\n\n复杂优于凌乱；\n\n扁平优于嵌套；\n\n稀疏优于稠密；\n\n可读性很重要；\n\n即使实用比纯粹更优，\n特例亦不可违背原则。\n\n错误绝不能悄悄忽略，\n除非它明确需要如此。\n\n面对不确定性，\n拒绝妄加猜测。\n\n任何问题应有一种，\n且最好只有一种，\n显而易见的解决方法。\n\n尽管这方法一开始并非如此直观，\n除非你是荷兰人。\n\n做优于不做，\n然而不假思索还不如不做。\n\n很难解释的，必然是坏方法。\n\n很好解释的，可能是好方法。\n\n命名空间是个绝妙的主意，\n我们应好好利用它。\n\n[The Zen of Python](https://www.python.org/dev/peps/pep-0020/)","slug":"python之禅","published":1,"updated":"2020-04-26T18:37:46.335Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9hghdh50001d1s6e8mpfz1u","content":"<p>Beautiful is better than ugly.</p>\n<p>Explicit is better than implicit.</p>\n<p>Simple is better than complex.</p>\n<p>Complex is better than complicated.</p>\n<p>Flat is better than nested.</p>\n<p>Sparse is better than dense.</p>\n<p>Readability counts.</p>\n<p>Special cases aren’t special enough<br>to break the rules.</p>\n<p>Although practicality beats purity.</p>\n<p>Errors should never pass silently.</p>\n<p>Unless explicitly silenced.</p>\n<p>In the face of ambiguity, refuse the temptation to guess.</p>\n<p>There should be one– and preferably only one –obvious way to do it.</p>\n<p>Although that way may not be obvious at first unless you’re Dutch.</p>\n<p>Now is better than never.</p>\n<p>Although never is often better than <em>right</em> now.</p>\n<p>If the implementation is hard to explain, it’s a bad idea.</p>\n<p>If the implementation is easy to explain, it may be a good idea.</p>\n<p>Namespaces are one honking great idea – let’s do more of those!</p>\n<hr>\n<p>优美优于丑陋；</p>\n<p>明了优于隐晦；</p>\n<p>简单优于复杂；</p>\n<p>复杂优于凌乱；</p>\n<p>扁平优于嵌套；</p>\n<p>稀疏优于稠密；</p>\n<p>可读性很重要；</p>\n<p>即使实用比纯粹更优，<br>特例亦不可违背原则。</p>\n<p>错误绝不能悄悄忽略，<br>除非它明确需要如此。</p>\n<p>面对不确定性，<br>拒绝妄加猜测。</p>\n<p>任何问题应有一种，<br>且最好只有一种，<br>显而易见的解决方法。</p>\n<p>尽管这方法一开始并非如此直观，<br>除非你是荷兰人。</p>\n<p>做优于不做，<br>然而不假思索还不如不做。</p>\n<p>很难解释的，必然是坏方法。</p>\n<p>很好解释的，可能是好方法。</p>\n<p>命名空间是个绝妙的主意，<br>我们应好好利用它。</p>\n<p><a href=\"https://www.python.org/dev/peps/pep-0020/\" target=\"_blank\" rel=\"noopener\">The Zen of Python</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Beautiful is better than ugly.</p>\n<p>Explicit is better than implicit.</p>\n<p>Simple is better than complex.</p>\n<p>Complex is better than complicated.</p>\n<p>Flat is better than nested.</p>\n<p>Sparse is better than dense.</p>\n<p>Readability counts.</p>\n<p>Special cases aren’t special enough<br>to break the rules.</p>\n<p>Although practicality beats purity.</p>\n<p>Errors should never pass silently.</p>\n<p>Unless explicitly silenced.</p>\n<p>In the face of ambiguity, refuse the temptation to guess.</p>\n<p>There should be one– and preferably only one –obvious way to do it.</p>\n<p>Although that way may not be obvious at first unless you’re Dutch.</p>\n<p>Now is better than never.</p>\n<p>Although never is often better than <em>right</em> now.</p>\n<p>If the implementation is hard to explain, it’s a bad idea.</p>\n<p>If the implementation is easy to explain, it may be a good idea.</p>\n<p>Namespaces are one honking great idea – let’s do more of those!</p>\n<hr>\n<p>优美优于丑陋；</p>\n<p>明了优于隐晦；</p>\n<p>简单优于复杂；</p>\n<p>复杂优于凌乱；</p>\n<p>扁平优于嵌套；</p>\n<p>稀疏优于稠密；</p>\n<p>可读性很重要；</p>\n<p>即使实用比纯粹更优，<br>特例亦不可违背原则。</p>\n<p>错误绝不能悄悄忽略，<br>除非它明确需要如此。</p>\n<p>面对不确定性，<br>拒绝妄加猜测。</p>\n<p>任何问题应有一种，<br>且最好只有一种，<br>显而易见的解决方法。</p>\n<p>尽管这方法一开始并非如此直观，<br>除非你是荷兰人。</p>\n<p>做优于不做，<br>然而不假思索还不如不做。</p>\n<p>很难解释的，必然是坏方法。</p>\n<p>很好解释的，可能是好方法。</p>\n<p>命名空间是个绝妙的主意，<br>我们应好好利用它。</p>\n<p><a href=\"https://www.python.org/dev/peps/pep-0020/\" target=\"_blank\" rel=\"noopener\">The Zen of Python</a></p>\n"},{"title":"养娃日志（1）","date":"2017-09-26T16:00:00.000Z","_content":"记录养娃过程中的快乐与辛酸，与娃一起成长！\n<!-- more -->\n\n2017-09-27\n\n下午，牧牧呕吐了4次，牧妈在QQ上告诉我：娃吃了点纸巾，把早晨吃的饭都快吐出来了。我正在给一个弹窗增加回调方法，准备今晚的上线，比较着急，听到这个消息，我心情瞬间变得很烦躁，我有点上火：牧妈怎么回事，怎么能让孩子吃到纸巾？我在上班也不让我省心。。。我在QQ略带责备的语气说了几句。\n\n忙完工作上的事，我电话给牧妈，我的理性告诉我，这个事情不能怨她，但是语气还是略带责备。后面我已经无心吃饭，我去sogo的6楼转了一圈，决定回家，虽然工作日我很少在10点之前回去，但今天为了早些看到孩子，我决定回去。\n\n我第一次感觉到这个孩子给我的吸引力。也许我已经慢慢进入爸爸的角色了","source":"_posts/养娃日志1.md","raw":"---\ntitle: 养娃日志（1）\ntags: 生活 养娃\ndate: 2017-09-27\n---\n记录养娃过程中的快乐与辛酸，与娃一起成长！\n<!-- more -->\n\n2017-09-27\n\n下午，牧牧呕吐了4次，牧妈在QQ上告诉我：娃吃了点纸巾，把早晨吃的饭都快吐出来了。我正在给一个弹窗增加回调方法，准备今晚的上线，比较着急，听到这个消息，我心情瞬间变得很烦躁，我有点上火：牧妈怎么回事，怎么能让孩子吃到纸巾？我在上班也不让我省心。。。我在QQ略带责备的语气说了几句。\n\n忙完工作上的事，我电话给牧妈，我的理性告诉我，这个事情不能怨她，但是语气还是略带责备。后面我已经无心吃饭，我去sogo的6楼转了一圈，决定回家，虽然工作日我很少在10点之前回去，但今天为了早些看到孩子，我决定回去。\n\n我第一次感觉到这个孩子给我的吸引力。也许我已经慢慢进入爸爸的角色了","slug":"养娃日志1","published":1,"updated":"2020-05-02T14:55:01.740Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck9ps6y250000x3s6cxztc0zc","content":"<p>记录养娃过程中的快乐与辛酸，与娃一起成长！</p>\n<a id=\"more\"></a>\n\n<p>2017-09-27</p>\n<p>下午，牧牧呕吐了4次，牧妈在QQ上告诉我：娃吃了点纸巾，把早晨吃的饭都快吐出来了。我正在给一个弹窗增加回调方法，准备今晚的上线，比较着急，听到这个消息，我心情瞬间变得很烦躁，我有点上火：牧妈怎么回事，怎么能让孩子吃到纸巾？我在上班也不让我省心。。。我在QQ略带责备的语气说了几句。</p>\n<p>忙完工作上的事，我电话给牧妈，我的理性告诉我，这个事情不能怨她，但是语气还是略带责备。后面我已经无心吃饭，我去sogo的6楼转了一圈，决定回家，虽然工作日我很少在10点之前回去，但今天为了早些看到孩子，我决定回去。</p>\n<p>我第一次感觉到这个孩子给我的吸引力。也许我已经慢慢进入爸爸的角色了</p>\n","site":{"data":{}},"excerpt":"<p>记录养娃过程中的快乐与辛酸，与娃一起成长！</p>","more":"<p>2017-09-27</p>\n<p>下午，牧牧呕吐了4次，牧妈在QQ上告诉我：娃吃了点纸巾，把早晨吃的饭都快吐出来了。我正在给一个弹窗增加回调方法，准备今晚的上线，比较着急，听到这个消息，我心情瞬间变得很烦躁，我有点上火：牧妈怎么回事，怎么能让孩子吃到纸巾？我在上班也不让我省心。。。我在QQ略带责备的语气说了几句。</p>\n<p>忙完工作上的事，我电话给牧妈，我的理性告诉我，这个事情不能怨她，但是语气还是略带责备。后面我已经无心吃饭，我去sogo的6楼转了一圈，决定回家，虽然工作日我很少在10点之前回去，但今天为了早些看到孩子，我决定回去。</p>\n<p>我第一次感觉到这个孩子给我的吸引力。也许我已经慢慢进入爸爸的角色了</p>"},{"title":"养娃日志（2）","date":"2020-05-02T14:58:25.000Z","_content":"\n五一休假的第二天，与妻，娃一起午饭。\n<!-- more -->\n娃摸着妻手腕上的一个疤痕，嫩声的问：妈妈，这是什么？\n\n妻吃了一口菜，悠悠说道：\"当年真是SB，竟然为了前男友，用烟头烫自己！\"。\n\n我哈哈大笑，\"这不是刻骨铭心的爱情嘛！\"。\n\n妻说：“谁还没点难忘的青春!”\n\n我突然想到一个问题，问妻：“等娃长大了，如果他失恋，为了前女友死去活来，然后问你：妈，为了表明我爱的决心，我要用烟头在手腕上留个痕迹。 你该怎么说？”。\n\n妻愤然道：“我就说，烫吧，反正你会后悔的...”\n\n当我们的老一辈告诉我们他们的人生经验时，我们内心总是听之任之，全然不会把这些话当做真理性的知识去记住去理解，同样当我们把我们的人生经验告诉下一辈时，他们肯定也是听之任之，是的，人生经验难以推广。\n\n人生难以复制，与其模仿别人，不如活成自己！\n\n别人的人生或苦难，或富贵，或卑贱，或荣耀，对我们来说都像是自己人生旅途上的风景，可停车赞叹，可扼腕叹息，抑或高山仰止，抑或报以不屑，但是都不会影响你旅途的目标，你可以参照他们，总结他们，但是你成不了他们，你只能成为你自己。\n\n所以我会对娃说：“我和你妈想法一样，烫不烫随你，反正我们说的你也不会听”\n\n\n","source":"_posts/养娃日志2.md","raw":"---\ntitle: 养娃日志（2）\ntags: 生活 养娃\ndate: 2020-05-02 22:58:25\n---\n\n五一休假的第二天，与妻，娃一起午饭。\n<!-- more -->\n娃摸着妻手腕上的一个疤痕，嫩声的问：妈妈，这是什么？\n\n妻吃了一口菜，悠悠说道：\"当年真是SB，竟然为了前男友，用烟头烫自己！\"。\n\n我哈哈大笑，\"这不是刻骨铭心的爱情嘛！\"。\n\n妻说：“谁还没点难忘的青春!”\n\n我突然想到一个问题，问妻：“等娃长大了，如果他失恋，为了前女友死去活来，然后问你：妈，为了表明我爱的决心，我要用烟头在手腕上留个痕迹。 你该怎么说？”。\n\n妻愤然道：“我就说，烫吧，反正你会后悔的...”\n\n当我们的老一辈告诉我们他们的人生经验时，我们内心总是听之任之，全然不会把这些话当做真理性的知识去记住去理解，同样当我们把我们的人生经验告诉下一辈时，他们肯定也是听之任之，是的，人生经验难以推广。\n\n人生难以复制，与其模仿别人，不如活成自己！\n\n别人的人生或苦难，或富贵，或卑贱，或荣耀，对我们来说都像是自己人生旅途上的风景，可停车赞叹，可扼腕叹息，抑或高山仰止，抑或报以不屑，但是都不会影响你旅途的目标，你可以参照他们，总结他们，但是你成不了他们，你只能成为你自己。\n\n所以我会对娃说：“我和你妈想法一样，烫不烫随你，反正我们说的你也不会听”\n\n\n","slug":"养娃日志2","published":1,"updated":"2021-02-16T04:58:05.107Z","_id":"ck9ps6y2e0001x3s6ctwpdis0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>五一休假的第二天，与妻，娃一起午饭。</p>\n<a id=\"more\"></a>\n<p>娃摸着妻手腕上的一个疤痕，嫩声的问：妈妈，这是什么？</p>\n<p>妻吃了一口菜，悠悠说道：”当年真是SB，竟然为了前男友，用烟头烫自己！”。</p>\n<p>我哈哈大笑，”这不是刻骨铭心的爱情嘛！”。</p>\n<p>妻说：“谁还没点难忘的青春!”</p>\n<p>我突然想到一个问题，问妻：“等娃长大了，如果他失恋，为了前女友死去活来，然后问你：妈，为了表明我爱的决心，我要用烟头在手腕上留个痕迹。 你该怎么说？”。</p>\n<p>妻愤然道：“我就说，烫吧，反正你会后悔的…”</p>\n<p>当我们的老一辈告诉我们他们的人生经验时，我们内心总是听之任之，全然不会把这些话当做真理性的知识去记住去理解，同样当我们把我们的人生经验告诉下一辈时，他们肯定也是听之任之，是的，人生经验难以推广。</p>\n<p>人生难以复制，与其模仿别人，不如活成自己！</p>\n<p>别人的人生或苦难，或富贵，或卑贱，或荣耀，对我们来说都像是自己人生旅途上的风景，可停车赞叹，可扼腕叹息，抑或高山仰止，抑或报以不屑，但是都不会影响你旅途的目标，你可以参照他们，总结他们，但是你成不了他们，你只能成为你自己。</p>\n<p>所以我会对娃说：“我和你妈想法一样，烫不烫随你，反正我们说的你也不会听”</p>\n","site":{"data":{}},"excerpt":"<p>五一休假的第二天，与妻，娃一起午饭。</p>","more":"<p>娃摸着妻手腕上的一个疤痕，嫩声的问：妈妈，这是什么？</p>\n<p>妻吃了一口菜，悠悠说道：”当年真是SB，竟然为了前男友，用烟头烫自己！”。</p>\n<p>我哈哈大笑，”这不是刻骨铭心的爱情嘛！”。</p>\n<p>妻说：“谁还没点难忘的青春!”</p>\n<p>我突然想到一个问题，问妻：“等娃长大了，如果他失恋，为了前女友死去活来，然后问你：妈，为了表明我爱的决心，我要用烟头在手腕上留个痕迹。 你该怎么说？”。</p>\n<p>妻愤然道：“我就说，烫吧，反正你会后悔的…”</p>\n<p>当我们的老一辈告诉我们他们的人生经验时，我们内心总是听之任之，全然不会把这些话当做真理性的知识去记住去理解，同样当我们把我们的人生经验告诉下一辈时，他们肯定也是听之任之，是的，人生经验难以推广。</p>\n<p>人生难以复制，与其模仿别人，不如活成自己！</p>\n<p>别人的人生或苦难，或富贵，或卑贱，或荣耀，对我们来说都像是自己人生旅途上的风景，可停车赞叹，可扼腕叹息，抑或高山仰止，抑或报以不屑，但是都不会影响你旅途的目标，你可以参照他们，总结他们，但是你成不了他们，你只能成为你自己。</p>\n<p>所以我会对娃说：“我和你妈想法一样，烫不烫随你，反正我们说的你也不会听”</p>"},{"title":"软件兴国","date":"2020-05-24T15:51:12.000Z","_content":"如何思考软件在中国发展中的作用？\n<!-- more -->\n最近美国特朗普政府对中国新一轮的科技绞杀开始了，我认为这不是最后一次，也不是最严重的一次，更多风雨还在后面。\n\n随着智能手机在国内的普及，软件已经和每个人息息相关，在我看来，社会文明发展的高低取决于软件化程度的高低。\n极度发达的社会，必然有极度发达的软件，相应的，极度发达的软件促使社会文明程度的发达。软件影响了人类社会的方方面面，未来的黑客帝国，也是因为软件的兴起。\n\n美国对中国的新一轮制裁，归根结底是对中国高级软件技术的限制，新中国成立后，中国在老一辈科研人员的艰苦奋斗下，在核武器，航天技术的突破赢得了世界的认可。现在我们需要在软件上实现突破才能再次突破现有的地位，赢得世界对中国大国地位的认可。\n\n软件上的突破实际上对各个行业的系统化升级改造，需要完整的软件开发工具链的自主化，实现在软件技术上中国创新和中国影响力。\n\n我窃以为，国内软件业还非常落后，就像是洋务运动后的中国，我们会用洋钉，洋灯，洋车，洋机器，可是没有一个我们可以完整的自主造出来。从业十余年，用到的软件开发语言没有一个国产的，用到开发工具没有一个国产，用到的设计理念绝大部分也不是国内自主创新的，我们这些所谓的开发人员特别像那时候的买办，转卖洋人的东西给国人，顺手打了个国产的标签。从这个角度看，我们的软件行业被更高级的洋软件殖****民了， 软件现代化，我们还有很多路要走。\n\n我们常用 站在巨人的肩膀上 这句话来麻痹自己，其实站在巨人的肩膀是对的啊，关键是站在哪个巨人的肩膀上呢，我们站在美国这个巨人的肩膀上，人家要不要你站，还不是看人家的心情吗！所以艰苦奋斗，自力更生什么时候都不要扔。我们要坚决的发展自主的软件研发体系，各个行业的软件体系；\n\n软件行业为什么那么重要呢？\n- 从全球来看，软件行业是相对更加是智力密集行业，这个行业的人员普遍高于其他行业，如果这个行业的平均智力水平不高，那么其他行业的平均智力水平可想而知。\n- 软件是硬件的生命和灵魂。硬件是机械的，有软件的硬件才够灵活和智能，才是能创造大价值的。\n- 软件行业的成长是不能复制的。硬件的生成其实是可以复制的，生产线可以组装产业工人可以培训，但是软件行业需要大量的协作，大量的普通开发人员，需要这些大量的普通开发人员付出自己的大量优质的智力活动，需要每个开发人员投入自己的智慧，经验，创造力和想象力。\n- 软件是最复杂的，它看不见，摸不着，但是它又实实在在控制着数以亿万计的硬件，它的生成过程就是智力活动的过程。\n\n\n目前看，软件代表着一个国家最高的科技实力和科技行业的整体水平，软件兴，则中国兴！\n\n中国软件，加油！ 中国，加油！\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/软件兴国.md","raw":"---\ntitle: 软件兴国\ntags: 随想\ndate: 2020-05-24 23:51:12\n---\n如何思考软件在中国发展中的作用？\n<!-- more -->\n最近美国特朗普政府对中国新一轮的科技绞杀开始了，我认为这不是最后一次，也不是最严重的一次，更多风雨还在后面。\n\n随着智能手机在国内的普及，软件已经和每个人息息相关，在我看来，社会文明发展的高低取决于软件化程度的高低。\n极度发达的社会，必然有极度发达的软件，相应的，极度发达的软件促使社会文明程度的发达。软件影响了人类社会的方方面面，未来的黑客帝国，也是因为软件的兴起。\n\n美国对中国的新一轮制裁，归根结底是对中国高级软件技术的限制，新中国成立后，中国在老一辈科研人员的艰苦奋斗下，在核武器，航天技术的突破赢得了世界的认可。现在我们需要在软件上实现突破才能再次突破现有的地位，赢得世界对中国大国地位的认可。\n\n软件上的突破实际上对各个行业的系统化升级改造，需要完整的软件开发工具链的自主化，实现在软件技术上中国创新和中国影响力。\n\n我窃以为，国内软件业还非常落后，就像是洋务运动后的中国，我们会用洋钉，洋灯，洋车，洋机器，可是没有一个我们可以完整的自主造出来。从业十余年，用到的软件开发语言没有一个国产的，用到开发工具没有一个国产，用到的设计理念绝大部分也不是国内自主创新的，我们这些所谓的开发人员特别像那时候的买办，转卖洋人的东西给国人，顺手打了个国产的标签。从这个角度看，我们的软件行业被更高级的洋软件殖****民了， 软件现代化，我们还有很多路要走。\n\n我们常用 站在巨人的肩膀上 这句话来麻痹自己，其实站在巨人的肩膀是对的啊，关键是站在哪个巨人的肩膀上呢，我们站在美国这个巨人的肩膀上，人家要不要你站，还不是看人家的心情吗！所以艰苦奋斗，自力更生什么时候都不要扔。我们要坚决的发展自主的软件研发体系，各个行业的软件体系；\n\n软件行业为什么那么重要呢？\n- 从全球来看，软件行业是相对更加是智力密集行业，这个行业的人员普遍高于其他行业，如果这个行业的平均智力水平不高，那么其他行业的平均智力水平可想而知。\n- 软件是硬件的生命和灵魂。硬件是机械的，有软件的硬件才够灵活和智能，才是能创造大价值的。\n- 软件行业的成长是不能复制的。硬件的生成其实是可以复制的，生产线可以组装产业工人可以培训，但是软件行业需要大量的协作，大量的普通开发人员，需要这些大量的普通开发人员付出自己的大量优质的智力活动，需要每个开发人员投入自己的智慧，经验，创造力和想象力。\n- 软件是最复杂的，它看不见，摸不着，但是它又实实在在控制着数以亿万计的硬件，它的生成过程就是智力活动的过程。\n\n\n目前看，软件代表着一个国家最高的科技实力和科技行业的整体水平，软件兴，则中国兴！\n\n中国软件，加油！ 中国，加油！\n\n\n\n\n\n\n\n\n\n\n\n","slug":"软件兴国","published":1,"updated":"2021-02-16T04:55:24.611Z","_id":"ckalazpb90000ybyxgas5h8ul","comments":1,"layout":"post","photos":[],"link":"","content":"<p>如何思考软件在中国发展中的作用？</p>\n<a id=\"more\"></a>\n<p>最近美国特朗普政府对中国新一轮的科技绞杀开始了，我认为这不是最后一次，也不是最严重的一次，更多风雨还在后面。</p>\n<p>随着智能手机在国内的普及，软件已经和每个人息息相关，在我看来，社会文明发展的高低取决于软件化程度的高低。<br>极度发达的社会，必然有极度发达的软件，相应的，极度发达的软件促使社会文明程度的发达。软件影响了人类社会的方方面面，未来的黑客帝国，也是因为软件的兴起。</p>\n<p>美国对中国的新一轮制裁，归根结底是对中国高级软件技术的限制，新中国成立后，中国在老一辈科研人员的艰苦奋斗下，在核武器，航天技术的突破赢得了世界的认可。现在我们需要在软件上实现突破才能再次突破现有的地位，赢得世界对中国大国地位的认可。</p>\n<p>软件上的突破实际上对各个行业的系统化升级改造，需要完整的软件开发工具链的自主化，实现在软件技术上中国创新和中国影响力。</p>\n<p>我窃以为，国内软件业还非常落后，就像是洋务运动后的中国，我们会用洋钉，洋灯，洋车，洋机器，可是没有一个我们可以完整的自主造出来。从业十余年，用到的软件开发语言没有一个国产的，用到开发工具没有一个国产，用到的设计理念绝大部分也不是国内自主创新的，我们这些所谓的开发人员特别像那时候的买办，转卖洋人的东西给国人，顺手打了个国产的标签。从这个角度看，我们的软件行业被更高级的洋软件殖****民了， 软件现代化，我们还有很多路要走。</p>\n<p>我们常用 站在巨人的肩膀上 这句话来麻痹自己，其实站在巨人的肩膀是对的啊，关键是站在哪个巨人的肩膀上呢，我们站在美国这个巨人的肩膀上，人家要不要你站，还不是看人家的心情吗！所以艰苦奋斗，自力更生什么时候都不要扔。我们要坚决的发展自主的软件研发体系，各个行业的软件体系；</p>\n<p>软件行业为什么那么重要呢？</p>\n<ul>\n<li>从全球来看，软件行业是相对更加是智力密集行业，这个行业的人员普遍高于其他行业，如果这个行业的平均智力水平不高，那么其他行业的平均智力水平可想而知。</li>\n<li>软件是硬件的生命和灵魂。硬件是机械的，有软件的硬件才够灵活和智能，才是能创造大价值的。</li>\n<li>软件行业的成长是不能复制的。硬件的生成其实是可以复制的，生产线可以组装产业工人可以培训，但是软件行业需要大量的协作，大量的普通开发人员，需要这些大量的普通开发人员付出自己的大量优质的智力活动，需要每个开发人员投入自己的智慧，经验，创造力和想象力。</li>\n<li>软件是最复杂的，它看不见，摸不着，但是它又实实在在控制着数以亿万计的硬件，它的生成过程就是智力活动的过程。</li>\n</ul>\n<p>目前看，软件代表着一个国家最高的科技实力和科技行业的整体水平，软件兴，则中国兴！</p>\n<p>中国软件，加油！ 中国，加油！</p>\n","site":{"data":{}},"excerpt":"<p>如何思考软件在中国发展中的作用？</p>","more":"<p>最近美国特朗普政府对中国新一轮的科技绞杀开始了，我认为这不是最后一次，也不是最严重的一次，更多风雨还在后面。</p>\n<p>随着智能手机在国内的普及，软件已经和每个人息息相关，在我看来，社会文明发展的高低取决于软件化程度的高低。<br>极度发达的社会，必然有极度发达的软件，相应的，极度发达的软件促使社会文明程度的发达。软件影响了人类社会的方方面面，未来的黑客帝国，也是因为软件的兴起。</p>\n<p>美国对中国的新一轮制裁，归根结底是对中国高级软件技术的限制，新中国成立后，中国在老一辈科研人员的艰苦奋斗下，在核武器，航天技术的突破赢得了世界的认可。现在我们需要在软件上实现突破才能再次突破现有的地位，赢得世界对中国大国地位的认可。</p>\n<p>软件上的突破实际上对各个行业的系统化升级改造，需要完整的软件开发工具链的自主化，实现在软件技术上中国创新和中国影响力。</p>\n<p>我窃以为，国内软件业还非常落后，就像是洋务运动后的中国，我们会用洋钉，洋灯，洋车，洋机器，可是没有一个我们可以完整的自主造出来。从业十余年，用到的软件开发语言没有一个国产的，用到开发工具没有一个国产，用到的设计理念绝大部分也不是国内自主创新的，我们这些所谓的开发人员特别像那时候的买办，转卖洋人的东西给国人，顺手打了个国产的标签。从这个角度看，我们的软件行业被更高级的洋软件殖****民了， 软件现代化，我们还有很多路要走。</p>\n<p>我们常用 站在巨人的肩膀上 这句话来麻痹自己，其实站在巨人的肩膀是对的啊，关键是站在哪个巨人的肩膀上呢，我们站在美国这个巨人的肩膀上，人家要不要你站，还不是看人家的心情吗！所以艰苦奋斗，自力更生什么时候都不要扔。我们要坚决的发展自主的软件研发体系，各个行业的软件体系；</p>\n<p>软件行业为什么那么重要呢？</p>\n<ul>\n<li>从全球来看，软件行业是相对更加是智力密集行业，这个行业的人员普遍高于其他行业，如果这个行业的平均智力水平不高，那么其他行业的平均智力水平可想而知。</li>\n<li>软件是硬件的生命和灵魂。硬件是机械的，有软件的硬件才够灵活和智能，才是能创造大价值的。</li>\n<li>软件行业的成长是不能复制的。硬件的生成其实是可以复制的，生产线可以组装产业工人可以培训，但是软件行业需要大量的协作，大量的普通开发人员，需要这些大量的普通开发人员付出自己的大量优质的智力活动，需要每个开发人员投入自己的智慧，经验，创造力和想象力。</li>\n<li>软件是最复杂的，它看不见，摸不着，但是它又实实在在控制着数以亿万计的硬件，它的生成过程就是智力活动的过程。</li>\n</ul>\n<p>目前看，软件代表着一个国家最高的科技实力和科技行业的整体水平，软件兴，则中国兴！</p>\n<p>中国软件，加油！ 中国，加油！</p>"},{"title":"何为领袖之国","date":"2020-08-19T16:00:00.000Z","_content":"\nVision 远见，\nCommitment 担当，\nCapacity 实力，\nLeadership 领导力，\nAccomplishment 成就，\nCredibility 可信可靠，\n\n以上是一个世界领袖国所必备的素质和能力要求，也是领袖之人的必备的素质和能力要求；\n\n","source":"_posts/何为领袖之国.md","raw":"---\ntitle: 何为领袖之国\ndate: 2020-08-20\n---\n\nVision 远见，\nCommitment 担当，\nCapacity 实力，\nLeadership 领导力，\nAccomplishment 成就，\nCredibility 可信可靠，\n\n以上是一个世界领袖国所必备的素质和能力要求，也是领袖之人的必备的素质和能力要求；\n\n","slug":"何为领袖之国","published":1,"updated":"2020-09-06T05:36:47.819Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeqo3qmy0001daiyhu05118r","content":"<p>Vision 远见，<br>Commitment 担当，<br>Capacity 实力，<br>Leadership 领导力，<br>Accomplishment 成就，<br>Credibility 可信可靠，</p>\n<p>以上是一个世界领袖国所必备的素质和能力要求，也是领袖之人的必备的素质和能力要求；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Vision 远见，<br>Commitment 担当，<br>Capacity 实力，<br>Leadership 领导力，<br>Accomplishment 成就，<br>Credibility 可信可靠，</p>\n<p>以上是一个世界领袖国所必备的素质和能力要求，也是领袖之人的必备的素质和能力要求；</p>\n"},{"title":"关于横财","date":"2020-09-05T16:00:00.000Z","_content":"\n以下是这个时代（2020-09-06 13:38:01）关于赚钱的一种认知：\n<!-- more -->\n你永远赚不到超出你认知范围之外的钱，除非靠着运气；但是运气赚到的钱，往往又会靠着实力亏掉。这是一种必然。\n你所赚的每一分钱，都是你对这个世界认知的变现。你所亏的每一分钱，都是因为对这个世界认知有缺陷。\n\n这个世界最大的公平在于：当你的财富大于自己认知的时候，这个社会就会有100种方法来收割你；直到你的认知和财富匹配为止。","source":"_posts/关于横财.md","raw":"---\ntitle: 关于横财\ndate: 2020-09-06\n---\n\n以下是这个时代（2020-09-06 13:38:01）关于赚钱的一种认知：\n<!-- more -->\n你永远赚不到超出你认知范围之外的钱，除非靠着运气；但是运气赚到的钱，往往又会靠着实力亏掉。这是一种必然。\n你所赚的每一分钱，都是你对这个世界认知的变现。你所亏的每一分钱，都是因为对这个世界认知有缺陷。\n\n这个世界最大的公平在于：当你的财富大于自己认知的时候，这个社会就会有100种方法来收割你；直到你的认知和财富匹配为止。","slug":"关于横财","published":1,"updated":"2021-02-16T04:57:57.377Z","_id":"ckeqo3qmz0002daiy7udw2mso","comments":1,"layout":"post","photos":[],"link":"","content":"<p>以下是这个时代（2020-09-06 13:38:01）关于赚钱的一种认知：</p>\n<a id=\"more\"></a>\n<p>你永远赚不到超出你认知范围之外的钱，除非靠着运气；但是运气赚到的钱，往往又会靠着实力亏掉。这是一种必然。<br>你所赚的每一分钱，都是你对这个世界认知的变现。你所亏的每一分钱，都是因为对这个世界认知有缺陷。</p>\n<p>这个世界最大的公平在于：当你的财富大于自己认知的时候，这个社会就会有100种方法来收割你；直到你的认知和财富匹配为止。</p>\n","site":{"data":{}},"excerpt":"<p>以下是这个时代（2020-09-06 13:38:01）关于赚钱的一种认知：</p>","more":"<p>你永远赚不到超出你认知范围之外的钱，除非靠着运气；但是运气赚到的钱，往往又会靠着实力亏掉。这是一种必然。<br>你所赚的每一分钱，都是你对这个世界认知的变现。你所亏的每一分钱，都是因为对这个世界认知有缺陷。</p>\n<p>这个世界最大的公平在于：当你的财富大于自己认知的时候，这个社会就会有100种方法来收割你；直到你的认知和财富匹配为止。</p>"},{"title":"学习方法论（1）","date":"2020-06-27T16:00:00.000Z","_content":"\n学习技术点时，搞清楚这个技术的前因后果，这个技术为解决什么问题而产生的，现在能解决什么问题，是怎么实现的，如何使用，有没有副作用。","source":"_posts/学习1.md","raw":"---\ntitle: 学习方法论（1）\ndate: 2020-06-28\n---\n\n学习技术点时，搞清楚这个技术的前因后果，这个技术为解决什么问题而产生的，现在能解决什么问题，是怎么实现的，如何使用，有没有副作用。","slug":"学习1","published":1,"updated":"2020-09-06T05:21:57.693Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeqo3qmz0003daiyam7d6qkp","content":"<p>学习技术点时，搞清楚这个技术的前因后果，这个技术为解决什么问题而产生的，现在能解决什么问题，是怎么实现的，如何使用，有没有副作用。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>学习技术点时，搞清楚这个技术的前因后果，这个技术为解决什么问题而产生的，现在能解决什么问题，是怎么实现的，如何使用，有没有副作用。</p>\n"},{"title":"学习方法论（2）","date":"2020-06-30T16:00:00.000Z","_content":"\nflutter的动画抽象出了4个概念以及对应的抽象类，相当于用这4个构建了一个动画实现的模型和框架，各个类的职责分明，，易于理解和使用。这种抽象出基本模型，或者抽象类的实现方法是很多框架的基本思路,比如yaf，koa。它们用有限的类构建了一类运行方式。\n\n这可以总结成一种思维模型 行为构建，就是在高层次上去定义和构建业务运行的基本形式，分析和识别里面内在的行为和联系，要习惯用概念之间的联系去推理和分析。\n\n在平时阅读代码的过程中也要善于使用这种思维模型，总结和抽象本身没有这种抽象的代码。只有有过这种总结，才能真正吸收代码的思想和其中的技巧。\n","source":"_posts/学习2.md","raw":"---\ntitle: 学习方法论（2）\ndate: 2020-07-01\n---\n\nflutter的动画抽象出了4个概念以及对应的抽象类，相当于用这4个构建了一个动画实现的模型和框架，各个类的职责分明，，易于理解和使用。这种抽象出基本模型，或者抽象类的实现方法是很多框架的基本思路,比如yaf，koa。它们用有限的类构建了一类运行方式。\n\n这可以总结成一种思维模型 行为构建，就是在高层次上去定义和构建业务运行的基本形式，分析和识别里面内在的行为和联系，要习惯用概念之间的联系去推理和分析。\n\n在平时阅读代码的过程中也要善于使用这种思维模型，总结和抽象本身没有这种抽象的代码。只有有过这种总结，才能真正吸收代码的思想和其中的技巧。\n","slug":"学习2","published":1,"updated":"2020-09-06T05:23:05.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeqo3qn00004daiy3ttkfm9j","content":"<p>flutter的动画抽象出了4个概念以及对应的抽象类，相当于用这4个构建了一个动画实现的模型和框架，各个类的职责分明，，易于理解和使用。这种抽象出基本模型，或者抽象类的实现方法是很多框架的基本思路,比如yaf，koa。它们用有限的类构建了一类运行方式。</p>\n<p>这可以总结成一种思维模型 行为构建，就是在高层次上去定义和构建业务运行的基本形式，分析和识别里面内在的行为和联系，要习惯用概念之间的联系去推理和分析。</p>\n<p>在平时阅读代码的过程中也要善于使用这种思维模型，总结和抽象本身没有这种抽象的代码。只有有过这种总结，才能真正吸收代码的思想和其中的技巧。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>flutter的动画抽象出了4个概念以及对应的抽象类，相当于用这4个构建了一个动画实现的模型和框架，各个类的职责分明，，易于理解和使用。这种抽象出基本模型，或者抽象类的实现方法是很多框架的基本思路,比如yaf，koa。它们用有限的类构建了一类运行方式。</p>\n<p>这可以总结成一种思维模型 行为构建，就是在高层次上去定义和构建业务运行的基本形式，分析和识别里面内在的行为和联系，要习惯用概念之间的联系去推理和分析。</p>\n<p>在平时阅读代码的过程中也要善于使用这种思维模型，总结和抽象本身没有这种抽象的代码。只有有过这种总结，才能真正吸收代码的思想和其中的技巧。</p>\n"},{"title":"扛”疫“","date":"2020-01-29T04:56:40.000Z","_content":"\n- 2020-01-29 12:56:40\n在家办公\n遇到问题时的分析意识\n\n- 2020-05-25 00:11:18\n综合我看到的新闻，消息，目前疫情还在持续，全球需求都在萎缩，供给也会随之萎缩，失业率上升，经济和政治不稳定性增加。局部战争，局部冲突的风险增加，地缘政治冲突持续扩大，全球化进程的路径发生转变。\n\n- 2020-09-06 13:31:46\n口罩已是常备之物，犹如内衣，不带反觉不雅。","source":"_posts/我的扛疫.md","raw":"---\ntitle: 扛”疫“\ndate: 2020-01-29 12:56:40\n---\n\n- 2020-01-29 12:56:40\n在家办公\n遇到问题时的分析意识\n\n- 2020-05-25 00:11:18\n综合我看到的新闻，消息，目前疫情还在持续，全球需求都在萎缩，供给也会随之萎缩，失业率上升，经济和政治不稳定性增加。局部战争，局部冲突的风险增加，地缘政治冲突持续扩大，全球化进程的路径发生转变。\n\n- 2020-09-06 13:31:46\n口罩已是常备之物，犹如内衣，不带反觉不雅。","slug":"我的扛疫","published":1,"updated":"2020-09-06T05:32:55.698Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckeqo3qn10005daiy7c7kgpwq","content":"<ul>\n<li><p>2020-01-29 12:56:40<br>在家办公<br>遇到问题时的分析意识</p>\n</li>\n<li><p>2020-05-25 00:11:18<br>综合我看到的新闻，消息，目前疫情还在持续，全球需求都在萎缩，供给也会随之萎缩，失业率上升，经济和政治不稳定性增加。局部战争，局部冲突的风险增加，地缘政治冲突持续扩大，全球化进程的路径发生转变。</p>\n</li>\n<li><p>2020-09-06 13:31:46<br>口罩已是常备之物，犹如内衣，不带反觉不雅。</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<ul>\n<li><p>2020-01-29 12:56:40<br>在家办公<br>遇到问题时的分析意识</p>\n</li>\n<li><p>2020-05-25 00:11:18<br>综合我看到的新闻，消息，目前疫情还在持续，全球需求都在萎缩，供给也会随之萎缩，失业率上升，经济和政治不稳定性增加。局部战争，局部冲突的风险增加，地缘政治冲突持续扩大，全球化进程的路径发生转变。</p>\n</li>\n<li><p>2020-09-06 13:31:46<br>口罩已是常备之物，犹如内衣，不带反觉不雅。</p>\n</li>\n</ul>\n"},{"title":"江湖","date":"2020-08-06T16:00:00.000Z","_content":"告诉你，我的江湖\n<!-- more -->\n\n说什么江湖恨，\n江湖刀剑歇；\n\n说什么儿女情，\n女神嫁他人；\n\n说什么兄弟义，\n恩怨斩愁肠;\n\n江湖恩情义，\n人生酸辣甜；\n\n道不尽的西风瘦马，\n说不清的真假葫芦案；\n\n故垒西边，\n荒草一片；\n\n东临碣石，\n海沽石烂；\n\n多少豪杰埋江湖，\n江湖还道，\n自有新人笑。\n\n","source":"_posts/江湖.md","raw":"---\ntitle: 江湖\ndate: 2020-08-07\n---\n告诉你，我的江湖\n<!-- more -->\n\n说什么江湖恨，\n江湖刀剑歇；\n\n说什么儿女情，\n女神嫁他人；\n\n说什么兄弟义，\n恩怨斩愁肠;\n\n江湖恩情义，\n人生酸辣甜；\n\n道不尽的西风瘦马，\n说不清的真假葫芦案；\n\n故垒西边，\n荒草一片；\n\n东临碣石，\n海沽石烂；\n\n多少豪杰埋江湖，\n江湖还道，\n自有新人笑。\n\n","slug":"江湖","published":1,"updated":"2021-02-16T04:56:43.740Z","_id":"ckeqo3qn10006daiy6fcb7hiv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>告诉你，我的江湖</p>\n<a id=\"more\"></a>\n\n<p>说什么江湖恨，<br>江湖刀剑歇；</p>\n<p>说什么儿女情，<br>女神嫁他人；</p>\n<p>说什么兄弟义，<br>恩怨斩愁肠;</p>\n<p>江湖恩情义，<br>人生酸辣甜；</p>\n<p>道不尽的西风瘦马，<br>说不清的真假葫芦案；</p>\n<p>故垒西边，<br>荒草一片；</p>\n<p>东临碣石，<br>海沽石烂；</p>\n<p>多少豪杰埋江湖，<br>江湖还道，<br>自有新人笑。</p>\n","site":{"data":{}},"excerpt":"<p>告诉你，我的江湖</p>","more":"<p>说什么江湖恨，<br>江湖刀剑歇；</p>\n<p>说什么儿女情，<br>女神嫁他人；</p>\n<p>说什么兄弟义，<br>恩怨斩愁肠;</p>\n<p>江湖恩情义，<br>人生酸辣甜；</p>\n<p>道不尽的西风瘦马，<br>说不清的真假葫芦案；</p>\n<p>故垒西边，<br>荒草一片；</p>\n<p>东临碣石，<br>海沽石烂；</p>\n<p>多少豪杰埋江湖，<br>江湖还道，<br>自有新人笑。</p>"},{"title":"随机与确定的随想","date":"2020-06-26T16:00:00.000Z","_content":"\n在种地靠天吃饭的年月，生存的所有…，都取决于'天老爷 '能否风调雨顺，但是 天老爷 的的心情谁能告诉你呢，几千年的农时经验都不能说清楚，于是不确定性根植很多农人的骨子里。现时代，一个人最大的天真就是认为自己生活在一个确定的和有规律的世界。农人即便遭遇颗粒无收，他也不会灰心，因为不确定，来年还有机会，还会继续努力耕种，天真的人一旦无所成，开始反思自己的付出，分析自己的努力，甚至开始怀疑这个世界，但是这个世界上很多大改变是这些天真的人促成的，而这个世界的基础则是那些'农人'。\n\n受历史唯物主义观的影响，大历史确实是有内在的客观原因和发展规律，当阅读鲜活的历史事件时，充满了大量的随机和偶然，很多个人的行为推动了历史的一小步， 而这一小步就成了撬动大历史发展的杠杆。\n\n从这个角度说，每个人类个体，活出独特的自我，才是个人对这个世界最大的贡献。","source":"_posts/随机与确定的随想.md","raw":"---\ntitle: 随机与确定的随想\ndate: 2020-06-27\n---\n\n在种地靠天吃饭的年月，生存的所有…，都取决于'天老爷 '能否风调雨顺，但是 天老爷 的的心情谁能告诉你呢，几千年的农时经验都不能说清楚，于是不确定性根植很多农人的骨子里。现时代，一个人最大的天真就是认为自己生活在一个确定的和有规律的世界。农人即便遭遇颗粒无收，他也不会灰心，因为不确定，来年还有机会，还会继续努力耕种，天真的人一旦无所成，开始反思自己的付出，分析自己的努力，甚至开始怀疑这个世界，但是这个世界上很多大改变是这些天真的人促成的，而这个世界的基础则是那些'农人'。\n\n受历史唯物主义观的影响，大历史确实是有内在的客观原因和发展规律，当阅读鲜活的历史事件时，充满了大量的随机和偶然，很多个人的行为推动了历史的一小步， 而这一小步就成了撬动大历史发展的杠杆。\n\n从这个角度说，每个人类个体，活出独特的自我，才是个人对这个世界最大的贡献。","slug":"随机与确定的随想","published":1,"updated":"2020-09-06T05:53:55.486Z","_id":"ckeqo3qn20007daiy7votej17","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在种地靠天吃饭的年月，生存的所有…，都取决于’天老爷 ‘能否风调雨顺，但是 天老爷 的的心情谁能告诉你呢，几千年的农时经验都不能说清楚，于是不确定性根植很多农人的骨子里。现时代，一个人最大的天真就是认为自己生活在一个确定的和有规律的世界。农人即便遭遇颗粒无收，他也不会灰心，因为不确定，来年还有机会，还会继续努力耕种，天真的人一旦无所成，开始反思自己的付出，分析自己的努力，甚至开始怀疑这个世界，但是这个世界上很多大改变是这些天真的人促成的，而这个世界的基础则是那些’农人’。</p>\n<p>受历史唯物主义观的影响，大历史确实是有内在的客观原因和发展规律，当阅读鲜活的历史事件时，充满了大量的随机和偶然，很多个人的行为推动了历史的一小步， 而这一小步就成了撬动大历史发展的杠杆。</p>\n<p>从这个角度说，每个人类个体，活出独特的自我，才是个人对这个世界最大的贡献。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在种地靠天吃饭的年月，生存的所有…，都取决于’天老爷 ‘能否风调雨顺，但是 天老爷 的的心情谁能告诉你呢，几千年的农时经验都不能说清楚，于是不确定性根植很多农人的骨子里。现时代，一个人最大的天真就是认为自己生活在一个确定的和有规律的世界。农人即便遭遇颗粒无收，他也不会灰心，因为不确定，来年还有机会，还会继续努力耕种，天真的人一旦无所成，开始反思自己的付出，分析自己的努力，甚至开始怀疑这个世界，但是这个世界上很多大改变是这些天真的人促成的，而这个世界的基础则是那些’农人’。</p>\n<p>受历史唯物主义观的影响，大历史确实是有内在的客观原因和发展规律，当阅读鲜活的历史事件时，充满了大量的随机和偶然，很多个人的行为推动了历史的一小步， 而这一小步就成了撬动大历史发展的杠杆。</p>\n<p>从这个角度说，每个人类个体，活出独特的自我，才是个人对这个世界最大的贡献。</p>\n"},{"title":"软件设计的哲学 - ch1","date":"2021-01-31T16:00:00.000Z","_content":"严正声明：\n该系列是从github上搬运而来，仅为自己阅读学习使用，请勿商用，请不要从此处搬运到别处！如对原作者造成不必要的版权侵害，敬请告知，我将立即删除该副本。\n我将保留合理使用开源软件的法律解释的权力。\n<!-- more -->\n# 第 1 章 介绍\n\n编写计算机软件是人类历史上最纯粹的创作活动之一。程序员不受诸如物理定律等实际限制的约束。我们可以用现实世界中永远不会存在的行为创建令人兴奋的虚拟世界。编程不需要很高的身体技能或协调能力，例如芭蕾或篮球。所有编程都需要具有创造力的头脑和组织思想的能力。如果您可以可视化系统，则可以在计算机程序中实现它。\n\n这意味着编写软件的最大限制是我们了解所创建系统的能力。随着程序的发展和获得更多功能，它变得复杂，其组件之间具有微妙的依赖性。随着时间的流逝，复杂性不断累积，程序员在修改系统时将所有相关因素牢记在心中变得越来越难。这会减慢开发速度并导致错误，从而进一步延缓开发速度并增加成本。在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。\n\n好的开发工具可以帮助我们应对复杂性，并且在过去的几十年中已经创建了许多出色的工具。但是，仅凭工具我们只能做些事情。如果我们想简化编写软件的过程，从而可以更便宜地构建功能更强大的系统，则必须找到简化软件的方法。尽管我们尽了最大努力，但复杂度仍会随着时间的推移而增加，但是更简单的设计使我们能够在复杂性压倒性优势之前构建更大，功能更强大的系统。\n\n有两种解决复杂性的通用方法，这两种方法都将在本书中进行讨论。第一种方法是通过使代码更简单和更明显来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性。\n\n解决复杂性的第二种方法是封装它，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为模块化设计。在模块化设计中，软件系统分为模块，例如面向对象语言的类。这些模块被设计为彼此相对独立，以便程序员可以在一个模块上工作而不必了解其他模块的细节。\n\n由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。\n\n不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分可视化大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。\n\n由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。\n\n增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。\n\n增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。\n\n如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。\n\n这本书有两个总体目标。首先是描述软件复杂性的性质：“复杂性”是什么意思，为什么重要，以及当程序具有不必要的复杂性时如何识别？本书的第二个也是更具挑战性的目标是介绍可在软件开发过程中使用的技术，以最大程度地减少复杂性。不幸的是，没有简单的方法可以保证出色的软件设计。取而代之的是，我将提出一些与哲学紧密相关的高级概念，例如“类应该很深”或“定义不存在的错误”。这些概念可能不会立即确定最佳设计，但您可以使用它们来比较设计备选方案并指导您探索设计空间。\n\n## 1.1 How to use this book 如何使用这本书\n\n这里描述的许多设计原则有些抽象，因此如果不看实际的代码，可能很难理解它们。找到足够小的示例以包含在书中，但是又足够大以说明真实系统的问题是一个挑战（如果遇到好的示例，请发给我）。因此，这本书可能不足以让您学习如何应用这些原理。\n\n使用本书的最佳方法是与代码审查结合使用。阅读其他人的代码时，请考虑它是否符合此处讨论的概念，以及它与代码的复杂性之间的关系。在别人的代码中比在您的代码中更容易看到设计问题。您可以使用此处描述的红色标记来发现问题并提出改进建议。查看代码还将使您接触到新的设计方法和编程技术。\n\n改善设计技能的最好方法之一就是学会识别危险信号：信号表明一段代码可能比需要的复杂。在本书的过程中，我将指出一些危险信号，这些危险信号指示与每个主要设计问题有关的问题；最重要的内容总结在书的后面。然后，您可以在编码时使用它们：当看到红色标记时，停下来寻找可消除问题的替代设计。当您第一次尝试这种方法时，您可能必须尝试几种设计替代方案，然后才能找到消除危险信号的方案。不要轻易放弃：解决问题之前尝试的替代方法越多，您就会学到更多。随着时间的流逝，您会发现代码中的危险信号越来越少，并且您的设计越来越清晰。\n\n在应用本书中的思想时，务必要节制和谨慎。每条规则都有例外，每条原则都有其局限性。如果您将任何设计创意都发挥到极致，那么您可能会陷入困境。精美的设计反映了相互竞争的思想和方法之间的平衡。有几章的标题为“太过分”，它们描述了如何在做得过大的事情上识别自己。\n\n本书中几乎所有示例都是使用 Java 或 C ++编写的，并且大部分讨论都是针对以面向对象的语言设计类的。但是，这些想法也适用于其他领域。几乎所有与方法有关的思想也可以应用于没有面向对象功能的语言中的功能，例如 C。设计思想还适用于除类之外的模块，例如子系统或网络服务。\n\n在这种背景下，让我们详细讨论导致复杂性的原因以及如何简化软件系统。\n","source":"_posts/软件设计的哲学-ch1.md","raw":"---\ntitle: 软件设计的哲学 - ch1\ndate: 2021-02-1\ntags: 软件设计的哲学 软件开发 方法论\n---\n严正声明：\n该系列是从github上搬运而来，仅为自己阅读学习使用，请勿商用，请不要从此处搬运到别处！如对原作者造成不必要的版权侵害，敬请告知，我将立即删除该副本。\n我将保留合理使用开源软件的法律解释的权力。\n<!-- more -->\n# 第 1 章 介绍\n\n编写计算机软件是人类历史上最纯粹的创作活动之一。程序员不受诸如物理定律等实际限制的约束。我们可以用现实世界中永远不会存在的行为创建令人兴奋的虚拟世界。编程不需要很高的身体技能或协调能力，例如芭蕾或篮球。所有编程都需要具有创造力的头脑和组织思想的能力。如果您可以可视化系统，则可以在计算机程序中实现它。\n\n这意味着编写软件的最大限制是我们了解所创建系统的能力。随着程序的发展和获得更多功能，它变得复杂，其组件之间具有微妙的依赖性。随着时间的流逝，复杂性不断累积，程序员在修改系统时将所有相关因素牢记在心中变得越来越难。这会减慢开发速度并导致错误，从而进一步延缓开发速度并增加成本。在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。\n\n好的开发工具可以帮助我们应对复杂性，并且在过去的几十年中已经创建了许多出色的工具。但是，仅凭工具我们只能做些事情。如果我们想简化编写软件的过程，从而可以更便宜地构建功能更强大的系统，则必须找到简化软件的方法。尽管我们尽了最大努力，但复杂度仍会随着时间的推移而增加，但是更简单的设计使我们能够在复杂性压倒性优势之前构建更大，功能更强大的系统。\n\n有两种解决复杂性的通用方法，这两种方法都将在本书中进行讨论。第一种方法是通过使代码更简单和更明显来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性。\n\n解决复杂性的第二种方法是封装它，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为模块化设计。在模块化设计中，软件系统分为模块，例如面向对象语言的类。这些模块被设计为彼此相对独立，以便程序员可以在一个模块上工作而不必了解其他模块的细节。\n\n由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。\n\n不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分可视化大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。\n\n由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。\n\n增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。\n\n增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。\n\n如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。\n\n这本书有两个总体目标。首先是描述软件复杂性的性质：“复杂性”是什么意思，为什么重要，以及当程序具有不必要的复杂性时如何识别？本书的第二个也是更具挑战性的目标是介绍可在软件开发过程中使用的技术，以最大程度地减少复杂性。不幸的是，没有简单的方法可以保证出色的软件设计。取而代之的是，我将提出一些与哲学紧密相关的高级概念，例如“类应该很深”或“定义不存在的错误”。这些概念可能不会立即确定最佳设计，但您可以使用它们来比较设计备选方案并指导您探索设计空间。\n\n## 1.1 How to use this book 如何使用这本书\n\n这里描述的许多设计原则有些抽象，因此如果不看实际的代码，可能很难理解它们。找到足够小的示例以包含在书中，但是又足够大以说明真实系统的问题是一个挑战（如果遇到好的示例，请发给我）。因此，这本书可能不足以让您学习如何应用这些原理。\n\n使用本书的最佳方法是与代码审查结合使用。阅读其他人的代码时，请考虑它是否符合此处讨论的概念，以及它与代码的复杂性之间的关系。在别人的代码中比在您的代码中更容易看到设计问题。您可以使用此处描述的红色标记来发现问题并提出改进建议。查看代码还将使您接触到新的设计方法和编程技术。\n\n改善设计技能的最好方法之一就是学会识别危险信号：信号表明一段代码可能比需要的复杂。在本书的过程中，我将指出一些危险信号，这些危险信号指示与每个主要设计问题有关的问题；最重要的内容总结在书的后面。然后，您可以在编码时使用它们：当看到红色标记时，停下来寻找可消除问题的替代设计。当您第一次尝试这种方法时，您可能必须尝试几种设计替代方案，然后才能找到消除危险信号的方案。不要轻易放弃：解决问题之前尝试的替代方法越多，您就会学到更多。随着时间的流逝，您会发现代码中的危险信号越来越少，并且您的设计越来越清晰。\n\n在应用本书中的思想时，务必要节制和谨慎。每条规则都有例外，每条原则都有其局限性。如果您将任何设计创意都发挥到极致，那么您可能会陷入困境。精美的设计反映了相互竞争的思想和方法之间的平衡。有几章的标题为“太过分”，它们描述了如何在做得过大的事情上识别自己。\n\n本书中几乎所有示例都是使用 Java 或 C ++编写的，并且大部分讨论都是针对以面向对象的语言设计类的。但是，这些想法也适用于其他领域。几乎所有与方法有关的思想也可以应用于没有面向对象功能的语言中的功能，例如 C。设计思想还适用于除类之外的模块，例如子系统或网络服务。\n\n在这种背景下，让我们详细讨论导致复杂性的原因以及如何简化软件系统。\n","slug":"软件设计的哲学-ch1","published":1,"updated":"2021-02-16T05:13:42.686Z","_id":"ckl6pcbze0000s4iy7pkhe0bd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>严正声明：<br>该系列是从github上搬运而来，仅为自己阅读学习使用，请勿商用，请不要从此处搬运到别处！如对原作者造成不必要的版权侵害，敬请告知，我将立即删除该副本。<br>我将保留合理使用开源软件的法律解释的权力。</p>\n<a id=\"more\"></a>\n<h1 id=\"第-1-章-介绍\"><a href=\"#第-1-章-介绍\" class=\"headerlink\" title=\"第 1 章 介绍\"></a>第 1 章 介绍</h1><p>编写计算机软件是人类历史上最纯粹的创作活动之一。程序员不受诸如物理定律等实际限制的约束。我们可以用现实世界中永远不会存在的行为创建令人兴奋的虚拟世界。编程不需要很高的身体技能或协调能力，例如芭蕾或篮球。所有编程都需要具有创造力的头脑和组织思想的能力。如果您可以可视化系统，则可以在计算机程序中实现它。</p>\n<p>这意味着编写软件的最大限制是我们了解所创建系统的能力。随着程序的发展和获得更多功能，它变得复杂，其组件之间具有微妙的依赖性。随着时间的流逝，复杂性不断累积，程序员在修改系统时将所有相关因素牢记在心中变得越来越难。这会减慢开发速度并导致错误，从而进一步延缓开发速度并增加成本。在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。</p>\n<p>好的开发工具可以帮助我们应对复杂性，并且在过去的几十年中已经创建了许多出色的工具。但是，仅凭工具我们只能做些事情。如果我们想简化编写软件的过程，从而可以更便宜地构建功能更强大的系统，则必须找到简化软件的方法。尽管我们尽了最大努力，但复杂度仍会随着时间的推移而增加，但是更简单的设计使我们能够在复杂性压倒性优势之前构建更大，功能更强大的系统。</p>\n<p>有两种解决复杂性的通用方法，这两种方法都将在本书中进行讨论。第一种方法是通过使代码更简单和更明显来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性。</p>\n<p>解决复杂性的第二种方法是封装它，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为模块化设计。在模块化设计中，软件系统分为模块，例如面向对象语言的类。这些模块被设计为彼此相对独立，以便程序员可以在一个模块上工作而不必了解其他模块的细节。</p>\n<p>由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。</p>\n<p>不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分可视化大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。</p>\n<p>由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。</p>\n<p>增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。</p>\n<p>增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。</p>\n<p>如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。</p>\n<p>这本书有两个总体目标。首先是描述软件复杂性的性质：“复杂性”是什么意思，为什么重要，以及当程序具有不必要的复杂性时如何识别？本书的第二个也是更具挑战性的目标是介绍可在软件开发过程中使用的技术，以最大程度地减少复杂性。不幸的是，没有简单的方法可以保证出色的软件设计。取而代之的是，我将提出一些与哲学紧密相关的高级概念，例如“类应该很深”或“定义不存在的错误”。这些概念可能不会立即确定最佳设计，但您可以使用它们来比较设计备选方案并指导您探索设计空间。</p>\n<h2 id=\"1-1-How-to-use-this-book-如何使用这本书\"><a href=\"#1-1-How-to-use-this-book-如何使用这本书\" class=\"headerlink\" title=\"1.1 How to use this book 如何使用这本书\"></a>1.1 How to use this book 如何使用这本书</h2><p>这里描述的许多设计原则有些抽象，因此如果不看实际的代码，可能很难理解它们。找到足够小的示例以包含在书中，但是又足够大以说明真实系统的问题是一个挑战（如果遇到好的示例，请发给我）。因此，这本书可能不足以让您学习如何应用这些原理。</p>\n<p>使用本书的最佳方法是与代码审查结合使用。阅读其他人的代码时，请考虑它是否符合此处讨论的概念，以及它与代码的复杂性之间的关系。在别人的代码中比在您的代码中更容易看到设计问题。您可以使用此处描述的红色标记来发现问题并提出改进建议。查看代码还将使您接触到新的设计方法和编程技术。</p>\n<p>改善设计技能的最好方法之一就是学会识别危险信号：信号表明一段代码可能比需要的复杂。在本书的过程中，我将指出一些危险信号，这些危险信号指示与每个主要设计问题有关的问题；最重要的内容总结在书的后面。然后，您可以在编码时使用它们：当看到红色标记时，停下来寻找可消除问题的替代设计。当您第一次尝试这种方法时，您可能必须尝试几种设计替代方案，然后才能找到消除危险信号的方案。不要轻易放弃：解决问题之前尝试的替代方法越多，您就会学到更多。随着时间的流逝，您会发现代码中的危险信号越来越少，并且您的设计越来越清晰。</p>\n<p>在应用本书中的思想时，务必要节制和谨慎。每条规则都有例外，每条原则都有其局限性。如果您将任何设计创意都发挥到极致，那么您可能会陷入困境。精美的设计反映了相互竞争的思想和方法之间的平衡。有几章的标题为“太过分”，它们描述了如何在做得过大的事情上识别自己。</p>\n<p>本书中几乎所有示例都是使用 Java 或 C ++编写的，并且大部分讨论都是针对以面向对象的语言设计类的。但是，这些想法也适用于其他领域。几乎所有与方法有关的思想也可以应用于没有面向对象功能的语言中的功能，例如 C。设计思想还适用于除类之外的模块，例如子系统或网络服务。</p>\n<p>在这种背景下，让我们详细讨论导致复杂性的原因以及如何简化软件系统。</p>\n","site":{"data":{}},"excerpt":"<p>严正声明：<br>该系列是从github上搬运而来，仅为自己阅读学习使用，请勿商用，请不要从此处搬运到别处！如对原作者造成不必要的版权侵害，敬请告知，我将立即删除该副本。<br>我将保留合理使用开源软件的法律解释的权力。</p>","more":"<h1 id=\"第-1-章-介绍\"><a href=\"#第-1-章-介绍\" class=\"headerlink\" title=\"第 1 章 介绍\"></a>第 1 章 介绍</h1><p>编写计算机软件是人类历史上最纯粹的创作活动之一。程序员不受诸如物理定律等实际限制的约束。我们可以用现实世界中永远不会存在的行为创建令人兴奋的虚拟世界。编程不需要很高的身体技能或协调能力，例如芭蕾或篮球。所有编程都需要具有创造力的头脑和组织思想的能力。如果您可以可视化系统，则可以在计算机程序中实现它。</p>\n<p>这意味着编写软件的最大限制是我们了解所创建系统的能力。随着程序的发展和获得更多功能，它变得复杂，其组件之间具有微妙的依赖性。随着时间的流逝，复杂性不断累积，程序员在修改系统时将所有相关因素牢记在心中变得越来越难。这会减慢开发速度并导致错误，从而进一步延缓开发速度并增加成本。在任何程序的生命周期中，复杂性都会不可避免地增加。程序越大，工作的人越多，管理复杂性就越困难。</p>\n<p>好的开发工具可以帮助我们应对复杂性，并且在过去的几十年中已经创建了许多出色的工具。但是，仅凭工具我们只能做些事情。如果我们想简化编写软件的过程，从而可以更便宜地构建功能更强大的系统，则必须找到简化软件的方法。尽管我们尽了最大努力，但复杂度仍会随着时间的推移而增加，但是更简单的设计使我们能够在复杂性压倒性优势之前构建更大，功能更强大的系统。</p>\n<p>有两种解决复杂性的通用方法，这两种方法都将在本书中进行讨论。第一种方法是通过使代码更简单和更明显来消除复杂性。例如，可以通过消除特殊情况或以一致的方式使用标识符来降低复杂性。</p>\n<p>解决复杂性的第二种方法是封装它，以便程序员可以在系统上工作而不会立即暴露其所有复杂性。这种方法称为模块化设计。在模块化设计中，软件系统分为模块，例如面向对象语言的类。这些模块被设计为彼此相对独立，以便程序员可以在一个模块上工作而不必了解其他模块的细节。</p>\n<p>由于软件具有很好的延展性，因此软件设计是一个贯穿软件系统整个生命周期的连续过程。这使得软件设计与诸如建筑物，船舶或桥梁的物理系统的设计不同。但是，并非总是以这种方式查看软件设计。在编程的大部分历史中，设计都集中在项目的开始，就像其他工程学科一样。这种方法的极端称为瀑布模型，该模型将项目划分为离散的阶段，例如需求定义，设计，编码，测试和维护。在瀑布模型中，每个阶段都在下一阶段开始之前完成；在许多情况下，每个阶段都由不同的人负责。在设计阶段，立即设计整个系统。</p>\n<p>不幸的是，瀑布模型很少适用于软件。软件系统本质上比物理系统复杂。在构建任何东西之前，不可能充分可视化大型软件系统的设计，以了解其所有含义。结果，初始设计将有许多问题。在实施良好之前，问题不会变得明显。但是，瀑布模型的结构此时无法适应主要的设计更改（例如，设计师可能已转移到其他项目）。因此，开发人员尝试在不改变整体设计的情况下解决问题。这导致复杂性的爆炸式增长。</p>\n<p>由于这些问题，当今大多数软件开发项目都使用诸如敏捷开发之类的增量方法，其中初始设计着重于整体功能的一小部分。设计，实施和评估此子集。发现和纠正原始设计的问题，然后设计，实施和评估更多功能。每次迭代都会暴露现有设计的问题，这些问题在设计下一组功能之前就已得到解决。通过以这种方式扩展设计，可以在系统仍然很小的情况下解决初始设计的问题。较新的功能受益于较早功能的实施过程中获得的经验，因此问题较少。</p>\n<p>增量方法适用于软件，因为软件具有足够的延展性，可以在实施过程中进行重大的设计更改。相比之下，对物理系统而言，主要的设计更改更具挑战性：例如，在建筑过程中更改支撑桥梁的塔架数量不切实际。</p>\n<p>增量开发意味着永远不会完成软件设计。设计在系统的整个生命周期中不断发生：开发人员应始终在思考设计问题。增量开发还意味着不断的重新设计。系统或组件的初始设计几乎从来都不是最好的。经验不可避免地显示出更好的做事方式。作为软件开发人员，您应该始终在寻找机会来改进正在开发的系统的设计，并且应该计划将部分时间花费在设计改进上。</p>\n<p>如果软件开发人员应始终考虑设计问题，而降低复杂性是软件设计中最重要的要素，则软件开发人员应始终考虑复杂性。这本书是关于如何使用复杂性来指导软件设计的整个生命周期。</p>\n<p>这本书有两个总体目标。首先是描述软件复杂性的性质：“复杂性”是什么意思，为什么重要，以及当程序具有不必要的复杂性时如何识别？本书的第二个也是更具挑战性的目标是介绍可在软件开发过程中使用的技术，以最大程度地减少复杂性。不幸的是，没有简单的方法可以保证出色的软件设计。取而代之的是，我将提出一些与哲学紧密相关的高级概念，例如“类应该很深”或“定义不存在的错误”。这些概念可能不会立即确定最佳设计，但您可以使用它们来比较设计备选方案并指导您探索设计空间。</p>\n<h2 id=\"1-1-How-to-use-this-book-如何使用这本书\"><a href=\"#1-1-How-to-use-this-book-如何使用这本书\" class=\"headerlink\" title=\"1.1 How to use this book 如何使用这本书\"></a>1.1 How to use this book 如何使用这本书</h2><p>这里描述的许多设计原则有些抽象，因此如果不看实际的代码，可能很难理解它们。找到足够小的示例以包含在书中，但是又足够大以说明真实系统的问题是一个挑战（如果遇到好的示例，请发给我）。因此，这本书可能不足以让您学习如何应用这些原理。</p>\n<p>使用本书的最佳方法是与代码审查结合使用。阅读其他人的代码时，请考虑它是否符合此处讨论的概念，以及它与代码的复杂性之间的关系。在别人的代码中比在您的代码中更容易看到设计问题。您可以使用此处描述的红色标记来发现问题并提出改进建议。查看代码还将使您接触到新的设计方法和编程技术。</p>\n<p>改善设计技能的最好方法之一就是学会识别危险信号：信号表明一段代码可能比需要的复杂。在本书的过程中，我将指出一些危险信号，这些危险信号指示与每个主要设计问题有关的问题；最重要的内容总结在书的后面。然后，您可以在编码时使用它们：当看到红色标记时，停下来寻找可消除问题的替代设计。当您第一次尝试这种方法时，您可能必须尝试几种设计替代方案，然后才能找到消除危险信号的方案。不要轻易放弃：解决问题之前尝试的替代方法越多，您就会学到更多。随着时间的流逝，您会发现代码中的危险信号越来越少，并且您的设计越来越清晰。</p>\n<p>在应用本书中的思想时，务必要节制和谨慎。每条规则都有例外，每条原则都有其局限性。如果您将任何设计创意都发挥到极致，那么您可能会陷入困境。精美的设计反映了相互竞争的思想和方法之间的平衡。有几章的标题为“太过分”，它们描述了如何在做得过大的事情上识别自己。</p>\n<p>本书中几乎所有示例都是使用 Java 或 C ++编写的，并且大部分讨论都是针对以面向对象的语言设计类的。但是，这些想法也适用于其他领域。几乎所有与方法有关的思想也可以应用于没有面向对象功能的语言中的功能，例如 C。设计思想还适用于除类之外的模块，例如子系统或网络服务。</p>\n<p>在这种背景下，让我们详细讨论导致复杂性的原因以及如何简化软件系统。</p>"},{"title":"软件设计的哲学 - ch21","abbrlink":43804,"date":"2021-02-20T16:00:00.000Z","_content":"结论\n<!-- more -->\n# 第 21 章 结论\n\n> Chapter 21 Conclusion\n\nThis book is about one thing: complexity. Dealing with complexity is the most important challenge in software design. It is what makes systems hard to build and maintain, and it often makes them slow as well. Over the course of the book I have tried to describe the root causes that lead to complexity, such as dependencies and obscurity. I have discussed red flags that can help you identify unnecessary complexity, such as information leakage, unneeded error conditions, or names that are too generic. I have presented some general ideas you can use to create simpler software systems, such as striving for classes that are deep and generic, defining errors out of existence, and separating interface documentation from implementation documentation. And, finally, I have discussed the investment mindset needed to produce simple designs.\n\n> 这本书是关于一件事的：复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助您识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。\n\n>> 看到过一句话：创意来源于复杂。\n\n>> 设计过程也是识别复杂，消化复杂性的过程。\n\nThe downside of all these suggestions is that they create extra work in the early stages of a project. Furthermore, if you aren’t used to thinking about design issues, then you will slow down even more while you learn good design techniques. If the only thing that matters to you is making your current code work as soon as possible, then thinking about design will seem like drudge work that is getting in the way of your real goal.\n\n> 所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果您不习惯于思考设计问题，那么当您学习良好的设计技巧时，您甚至会放慢脚步。如果对您而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了您实现真正的目标。\n\n>> 一直认为设计是开发工作的一个既定任务，只是这个任务很难评估和量化。\n\n>> 开发过程的前期思考，应该重视设计质量。从操作上说，尽可能收集或者找到解决当前编程问题的所有设计方案，并从中找出你认为最好的方案，并且说出的选择的理由，或者不选择的理由。如果有时间，可以用动态的观点思考，这个方案运行一段时间会出现什么问题，那时该如何解决？\n\nOn the other hand, if good design is an important goal for you, then the ideas in this book should make programming more fun. Design is a fascinating puzzle: how can a particular problem be solved with the simplest possible structure? It’s fun to explore different approaches, and it’s a great feeling to discover a solution that is both simple and powerful. A clean, simple, and obvious design is a beautiful thing.\n\n> 另一方面，如果良好的设计对您来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。\n\n>> 个人认为，良好的设计是实现编程的手段和方式，不是编程的目标。但是良好的设计，会让你的实现更省时省力，让代码有更强健的生命力并且有思考的美感和艺术的优雅性。\n\nFurthermore, the investments you make in good design will pay off quickly. The modules you defined carefully at the beginning of a project will save you time later as you reuse them over and over. The clear documentation that you wrote six months ago will save you time when you return to the code to add a new feature. The time you spent honing your design skills will also pay for itself: as your skills and experience grow, you will find that you can produce good designs more and more quickly. Good design doesn’t really take much longer than quick-and-dirty design, once you know how.\n\n> 此外，您对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为您节省时间，因为您一遍又一遍地重复使用它们。您六个月前编写的清晰文档将为您节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，您会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。\n\n>> 设计能力的成长源于平时的刻意练习和点滴的总结，以及设计失败后的痛苦。\n\nThe reward for being a good designer is that you get to spend a larger fraction of your time in the design phase, which is fun. Poor designers spend most of their time chasing bugs in complicated and brittle code. If you improve your design skills, not only will you produce higher quality software more quickly, but the software development process will be more enjoyable.\n\n> 成为优秀设计师的好处是，您可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。\n","source":"_posts/软件设计的哲学-ch21.md","raw":"---\ntitle: 软件设计的哲学 - ch21\ntags: 软件设计的哲学 软件开发 方法论\nabbrlink: 43804\ndate: 2021-02-21 00:00:00\n---\n结论\n<!-- more -->\n# 第 21 章 结论\n\n> Chapter 21 Conclusion\n\nThis book is about one thing: complexity. Dealing with complexity is the most important challenge in software design. It is what makes systems hard to build and maintain, and it often makes them slow as well. Over the course of the book I have tried to describe the root causes that lead to complexity, such as dependencies and obscurity. I have discussed red flags that can help you identify unnecessary complexity, such as information leakage, unneeded error conditions, or names that are too generic. I have presented some general ideas you can use to create simpler software systems, such as striving for classes that are deep and generic, defining errors out of existence, and separating interface documentation from implementation documentation. And, finally, I have discussed the investment mindset needed to produce simple designs.\n\n> 这本书是关于一件事的：复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助您识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。\n\n>> 看到过一句话：创意来源于复杂。\n\n>> 设计过程也是识别复杂，消化复杂性的过程。\n\nThe downside of all these suggestions is that they create extra work in the early stages of a project. Furthermore, if you aren’t used to thinking about design issues, then you will slow down even more while you learn good design techniques. If the only thing that matters to you is making your current code work as soon as possible, then thinking about design will seem like drudge work that is getting in the way of your real goal.\n\n> 所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果您不习惯于思考设计问题，那么当您学习良好的设计技巧时，您甚至会放慢脚步。如果对您而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了您实现真正的目标。\n\n>> 一直认为设计是开发工作的一个既定任务，只是这个任务很难评估和量化。\n\n>> 开发过程的前期思考，应该重视设计质量。从操作上说，尽可能收集或者找到解决当前编程问题的所有设计方案，并从中找出你认为最好的方案，并且说出的选择的理由，或者不选择的理由。如果有时间，可以用动态的观点思考，这个方案运行一段时间会出现什么问题，那时该如何解决？\n\nOn the other hand, if good design is an important goal for you, then the ideas in this book should make programming more fun. Design is a fascinating puzzle: how can a particular problem be solved with the simplest possible structure? It’s fun to explore different approaches, and it’s a great feeling to discover a solution that is both simple and powerful. A clean, simple, and obvious design is a beautiful thing.\n\n> 另一方面，如果良好的设计对您来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。\n\n>> 个人认为，良好的设计是实现编程的手段和方式，不是编程的目标。但是良好的设计，会让你的实现更省时省力，让代码有更强健的生命力并且有思考的美感和艺术的优雅性。\n\nFurthermore, the investments you make in good design will pay off quickly. The modules you defined carefully at the beginning of a project will save you time later as you reuse them over and over. The clear documentation that you wrote six months ago will save you time when you return to the code to add a new feature. The time you spent honing your design skills will also pay for itself: as your skills and experience grow, you will find that you can produce good designs more and more quickly. Good design doesn’t really take much longer than quick-and-dirty design, once you know how.\n\n> 此外，您对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为您节省时间，因为您一遍又一遍地重复使用它们。您六个月前编写的清晰文档将为您节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，您会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。\n\n>> 设计能力的成长源于平时的刻意练习和点滴的总结，以及设计失败后的痛苦。\n\nThe reward for being a good designer is that you get to spend a larger fraction of your time in the design phase, which is fun. Poor designers spend most of their time chasing bugs in complicated and brittle code. If you improve your design skills, not only will you produce higher quality software more quickly, but the software development process will be more enjoyable.\n\n> 成为优秀设计师的好处是，您可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。\n","slug":"软件设计的哲学-ch21","published":1,"updated":"2022-10-22T12:08:38.740Z","_id":"ckl6pcbzl0001s4iy73u211uw","comments":1,"layout":"post","photos":[],"link":"","content":"<p>结论</p>\n<a id=\"more\"></a>\n<h1 id=\"第-21-章-结论\"><a href=\"#第-21-章-结论\" class=\"headerlink\" title=\"第 21 章 结论\"></a>第 21 章 结论</h1><blockquote>\n<p>Chapter 21 Conclusion</p>\n</blockquote>\n<p>This book is about one thing: complexity. Dealing with complexity is the most important challenge in software design. It is what makes systems hard to build and maintain, and it often makes them slow as well. Over the course of the book I have tried to describe the root causes that lead to complexity, such as dependencies and obscurity. I have discussed red flags that can help you identify unnecessary complexity, such as information leakage, unneeded error conditions, or names that are too generic. I have presented some general ideas you can use to create simpler software systems, such as striving for classes that are deep and generic, defining errors out of existence, and separating interface documentation from implementation documentation. And, finally, I have discussed the investment mindset needed to produce simple designs.</p>\n<blockquote>\n<p>这本书是关于一件事的：复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助您识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>看到过一句话：创意来源于复杂。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>设计过程也是识别复杂，消化复杂性的过程。</p>\n</blockquote>\n</blockquote>\n<p>The downside of all these suggestions is that they create extra work in the early stages of a project. Furthermore, if you aren’t used to thinking about design issues, then you will slow down even more while you learn good design techniques. If the only thing that matters to you is making your current code work as soon as possible, then thinking about design will seem like drudge work that is getting in the way of your real goal.</p>\n<blockquote>\n<p>所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果您不习惯于思考设计问题，那么当您学习良好的设计技巧时，您甚至会放慢脚步。如果对您而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了您实现真正的目标。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>一直认为设计是开发工作的一个既定任务，只是这个任务很难评估和量化。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>开发过程的前期思考，应该重视设计质量。从操作上说，尽可能收集或者找到解决当前编程问题的所有设计方案，并从中找出你认为最好的方案，并且说出的选择的理由，或者不选择的理由。如果有时间，可以用动态的观点思考，这个方案运行一段时间会出现什么问题，那时该如何解决？</p>\n</blockquote>\n</blockquote>\n<p>On the other hand, if good design is an important goal for you, then the ideas in this book should make programming more fun. Design is a fascinating puzzle: how can a particular problem be solved with the simplest possible structure? It’s fun to explore different approaches, and it’s a great feeling to discover a solution that is both simple and powerful. A clean, simple, and obvious design is a beautiful thing.</p>\n<blockquote>\n<p>另一方面，如果良好的设计对您来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>个人认为，良好的设计是实现编程的手段和方式，不是编程的目标。但是良好的设计，会让你的实现更省时省力，让代码有更强健的生命力并且有思考的美感和艺术的优雅性。</p>\n</blockquote>\n</blockquote>\n<p>Furthermore, the investments you make in good design will pay off quickly. The modules you defined carefully at the beginning of a project will save you time later as you reuse them over and over. The clear documentation that you wrote six months ago will save you time when you return to the code to add a new feature. The time you spent honing your design skills will also pay for itself: as your skills and experience grow, you will find that you can produce good designs more and more quickly. Good design doesn’t really take much longer than quick-and-dirty design, once you know how.</p>\n<blockquote>\n<p>此外，您对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为您节省时间，因为您一遍又一遍地重复使用它们。您六个月前编写的清晰文档将为您节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，您会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>设计能力的成长源于平时的刻意练习和点滴的总结，以及设计失败后的痛苦。</p>\n</blockquote>\n</blockquote>\n<p>The reward for being a good designer is that you get to spend a larger fraction of your time in the design phase, which is fun. Poor designers spend most of their time chasing bugs in complicated and brittle code. If you improve your design skills, not only will you produce higher quality software more quickly, but the software development process will be more enjoyable.</p>\n<blockquote>\n<p>成为优秀设计师的好处是，您可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>结论</p>","more":"<h1 id=\"第-21-章-结论\"><a href=\"#第-21-章-结论\" class=\"headerlink\" title=\"第 21 章 结论\"></a>第 21 章 结论</h1><blockquote>\n<p>Chapter 21 Conclusion</p>\n</blockquote>\n<p>This book is about one thing: complexity. Dealing with complexity is the most important challenge in software design. It is what makes systems hard to build and maintain, and it often makes them slow as well. Over the course of the book I have tried to describe the root causes that lead to complexity, such as dependencies and obscurity. I have discussed red flags that can help you identify unnecessary complexity, such as information leakage, unneeded error conditions, or names that are too generic. I have presented some general ideas you can use to create simpler software systems, such as striving for classes that are deep and generic, defining errors out of existence, and separating interface documentation from implementation documentation. And, finally, I have discussed the investment mindset needed to produce simple designs.</p>\n<blockquote>\n<p>这本书是关于一件事的：复杂性。处理复杂性是软件设计中最重要的挑战。这是使系统难以构建和维护的原因，并且通常也使它们变慢。在本书的整个过程中，我试图描述导致复杂性的根本原因，例如依赖性和模糊性。我已经讨论了可以帮助您识别不必要的复杂性的危险标记，例如信息泄漏，不必要的错误情况或名称过于笼统。我已经提出了一些通用的思想，可以用来创建更简单的软件系统，例如，努力研究更深和更通用的类，定义不存在的错误以及将接口文档与实现文档分离。最后，我讨论了产生简单设计所需的投资思路。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>看到过一句话：创意来源于复杂。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>设计过程也是识别复杂，消化复杂性的过程。</p>\n</blockquote>\n</blockquote>\n<p>The downside of all these suggestions is that they create extra work in the early stages of a project. Furthermore, if you aren’t used to thinking about design issues, then you will slow down even more while you learn good design techniques. If the only thing that matters to you is making your current code work as soon as possible, then thinking about design will seem like drudge work that is getting in the way of your real goal.</p>\n<blockquote>\n<p>所有这些建议的缺点是它们会在项目的早期阶段创建额外的工作。此外，如果您不习惯于思考设计问题，那么当您学习良好的设计技巧时，您甚至会放慢脚步。如果对您而言唯一重要的事情就是尽快使当前代码工作，那么思考设计就好像是在费劲工作，而这实际上妨碍了您实现真正的目标。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>一直认为设计是开发工作的一个既定任务，只是这个任务很难评估和量化。</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>开发过程的前期思考，应该重视设计质量。从操作上说，尽可能收集或者找到解决当前编程问题的所有设计方案，并从中找出你认为最好的方案，并且说出的选择的理由，或者不选择的理由。如果有时间，可以用动态的观点思考，这个方案运行一段时间会出现什么问题，那时该如何解决？</p>\n</blockquote>\n</blockquote>\n<p>On the other hand, if good design is an important goal for you, then the ideas in this book should make programming more fun. Design is a fascinating puzzle: how can a particular problem be solved with the simplest possible structure? It’s fun to explore different approaches, and it’s a great feeling to discover a solution that is both simple and powerful. A clean, simple, and obvious design is a beautiful thing.</p>\n<blockquote>\n<p>另一方面，如果良好的设计对您来说是重要的目标，那么本书中的思想应使编程更有趣。设计是一个令人着迷的难题：如何用最简单的结构解决特定问题？探索不同的方法很有趣，找到一种既简单又强大的解决方案是一种很好的感觉。干净，简单和明显的设计是一件美丽的事情。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>个人认为，良好的设计是实现编程的手段和方式，不是编程的目标。但是良好的设计，会让你的实现更省时省力，让代码有更强健的生命力并且有思考的美感和艺术的优雅性。</p>\n</blockquote>\n</blockquote>\n<p>Furthermore, the investments you make in good design will pay off quickly. The modules you defined carefully at the beginning of a project will save you time later as you reuse them over and over. The clear documentation that you wrote six months ago will save you time when you return to the code to add a new feature. The time you spent honing your design skills will also pay for itself: as your skills and experience grow, you will find that you can produce good designs more and more quickly. Good design doesn’t really take much longer than quick-and-dirty design, once you know how.</p>\n<blockquote>\n<p>此外，您对优质设计的投资将很快获得回报。在项目开始时仔细定义的模块将为您节省时间，因为您一遍又一遍地重复使用它们。您六个月前编写的清晰文档将为您节省返回代码添加新功能的时间。花在磨练设计技能上的时间也将有所回报：随着技能和经验的增长，您会发现可以越来越快地制作出好的设计。一旦知道了什么，一个好的设计实际上并不会比一个简单的设计花费更多的时间。</p>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>设计能力的成长源于平时的刻意练习和点滴的总结，以及设计失败后的痛苦。</p>\n</blockquote>\n</blockquote>\n<p>The reward for being a good designer is that you get to spend a larger fraction of your time in the design phase, which is fun. Poor designers spend most of their time chasing bugs in complicated and brittle code. If you improve your design skills, not only will you produce higher quality software more quickly, but the software development process will be more enjoyable.</p>\n<blockquote>\n<p>成为优秀设计师的好处是，您可以在设计阶段花费大部分时间，这很有趣。可怜的设计师花费大量时间在复杂而脆弱的代码中寻找错误。如果提高设计技能，不仅可以更快地生产出更高质量的软件，而且软件开发过程也将变得更加愉快。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch17","date":"2021-02-16T16:00:00.000Z","_content":"一致性\n<!-- more -->\n# 第 17 章 一致性\n\n> Chapter 17 Consistency\n\nConsistency is a powerful tool for reducing the complexity of a system and making its behavior more obvious. If a system is consistent, it means that similar things are done in similar ways, and dissimilar things are done in different ways. Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach. If a system is not implemented in a consistent fashion, developers must learn about each situation separately. This will take more time.\n\n> 一致性是降低系统复杂性并使其行为更明显的强大工具。如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦您了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。\n\nConsistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptions made based on familiar-looking situations will be safe. Consistency allows developers to work more quickly with fewer mistakes.\n\n> 一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。\n\n## 17.1 Examples of consistency 一致性示例\n\nConsistency can be applied at many levels in a system; here are a few examples.\n\n> 一致性可以应用于系统中的许多级别。这里有一些例子。\n\nNames. Chapter 14 has already discussed the benefits of using names in a consistent way.\n\n> 名字。第 14 章已经讨论了以一致的方式使用名称的好处。\n\nCoding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers. Modern style guides address a range of issues, such as indentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make code easier to read and can reduce some kinds of errors.\n\n> 编码样式。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。\n\nInterfaces. An interface with multiple implementations is another example of consistency. Once you understand one implementation of the interface, any other implementation becomes easier to understand because you already know the features it will have to provide.\n\n> 接口。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为您已经知道它将必须提供的功能。\n\nDesign patterns. Design patterns are generally-accepted solutions to certain common problems, such as the model-view-controller approach to user interface design. If you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers. Design patterns are discussed in more detail in Section 19.5.\n\n设计模式。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果您可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且您的代码对读者来说也会更明显。设计模式将在 19.5 节中详细讨论。\n\nInvariants. An invariant is a property of a variable or structure that is always true. For example, a data structure storing lines of text might enforce an invariant that each line is terminated by a newline character. Invariants reduce the number of special cases that must be considered in code and make it easier to reason about the code’s behavior.\n\n不变量。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。\n\n## 17.2 Ensuring consistency 确保一致性\n\nConsistency is hard to maintain, especially when many people work on a project over a long time. People in one group may not know about conventions established in another group. Newcomers don’t know the rules, so they unintentionally violate the conventions and create new conventions that conflict with existing ones. Here are a few tips for establishing and maintaining consistency:\n\n> 一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：\n\nDocument. Create a document that lists the most important overall conventions, such as coding style guidelines. Place the document in a spot where developers are likely to see it, such as a conspicuous place on the project Wiki. Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these.\n\n> 文献。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。\n\nFor conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you don’t write the conventions down, it’s unlikely that other people will follow them.\n\n> 对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果您不写下约定，那么其他人不太可能会遵循它们。\n\nEnforce. Even with good documentation, it’s hard for developers to remember all of the conventions. The best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly well for low-level syntactic conventions.\n\n> 执行。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。\n\nOne of my recent projects had problems with line termination characters. Some developers worked on Unix, where lines are terminated by newlines; others worked on Windows, where lines are normally terminated by a carriage-return followed by a newline. If a developer on one system made a small edit to a file previously edited on the other system, the editor would sometimes replace all of the line terminators with ones appropriate for that system. This gave the appearance that every line of the file had been modified, which made it hard to track the meaningful changes. We established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.\n\n> 我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。\n\nWe eventually solved this problem by writing a short script that was executed automatically before changes are committed to the source code repository. The script checks all of the files that have been modified and aborts the commit if any of them contain carriage returns. The script can also be run manually to repair damaged files by replacing carriage-return/newline sequences with newlines. This instantly eliminated the problems, and it also helped train new developers.\n\n> 我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。\n\nCode reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions. The more nit-picky that code reviewers are, the more quickly everyone on the team will learn the conventions, and the cleaner the code will be.\n\n> 代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。\n\nWhen in Rome ... The most important convention of all is that every developer should follow the old adage “When in Rome, do as the Romans do.” When working in a new file, look around to see how the existing code is structured. Are all public variables and methods declared before private ones? Are the methods in alphabetical order? Do variables use “camel case,” as in firstServerName, or “snake case,” as in first_server_name? When you see anything that looks like it might possibly be a convention, follow it. When making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.\n\n> 在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当您看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。\n\nDon’t change existing conventions. Resist the urge to “improve” on existing conventions. Having a “better idea” is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approach that wasn’t available when the old convention was established? Second, is the new approach so much better that it is worth taking the time to update all of the old uses? If your organization agrees that the answers to both questions are “yes,” then go ahead and make the upgrade; when you are done, there should be no sign of the old convention. However, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future. Overall, reconsidering established conventions is rarely a good use of developer time.\n\n> 不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。您的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，您是否拥有大量的新信息来证明您的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果您的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，您仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。\n\n## 17.3 Taking it too far 走得太远\n\nConsistency means not only that similar things should be done in similar ways, but that dissimilar things should be done in different ways. If you become overzealous about consistency and try to force dissimilar things into the same approach, such as by using the same variable name for things that are really different or using an existing design pattern for a task that doesn’t fit the pattern, you’ll create complexity and confusion. Consistency only provides benefits when developers have confidence that “if it looks like an x, it really is an x.”\n\n> 一致性不仅意味着相似的事情应该以相似的方式完成，而且不同的事情也应该以不同的方式完成。如果您对一致性过于热衷，并试图将不同的事物强制采用相同的方法，例如对确实不同的事物使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么会造成复杂性和混乱。一致性只有在开发人员确信“如果看起来像 x 时，它确实是 x”时才有好处。\n\n## 17.4 Conclusion 结论\n\nConsistency is another example of the investment mindset. It will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team. The return on this investment is that your code will be more obvious. Developers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.\n\n> 一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是您的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。\n","source":"_posts/软件设计的哲学-ch17.md","raw":"---\ntitle: 软件设计的哲学 - ch17\ndate: 2021-02-17\ntags: 软件设计的哲学 软件开发 方法论\n---\n一致性\n<!-- more -->\n# 第 17 章 一致性\n\n> Chapter 17 Consistency\n\nConsistency is a powerful tool for reducing the complexity of a system and making its behavior more obvious. If a system is consistent, it means that similar things are done in similar ways, and dissimilar things are done in different ways. Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach. If a system is not implemented in a consistent fashion, developers must learn about each situation separately. This will take more time.\n\n> 一致性是降低系统复杂性并使其行为更明显的强大工具。如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦您了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。\n\nConsistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptions made based on familiar-looking situations will be safe. Consistency allows developers to work more quickly with fewer mistakes.\n\n> 一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。\n\n## 17.1 Examples of consistency 一致性示例\n\nConsistency can be applied at many levels in a system; here are a few examples.\n\n> 一致性可以应用于系统中的许多级别。这里有一些例子。\n\nNames. Chapter 14 has already discussed the benefits of using names in a consistent way.\n\n> 名字。第 14 章已经讨论了以一致的方式使用名称的好处。\n\nCoding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers. Modern style guides address a range of issues, such as indentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make code easier to read and can reduce some kinds of errors.\n\n> 编码样式。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。\n\nInterfaces. An interface with multiple implementations is another example of consistency. Once you understand one implementation of the interface, any other implementation becomes easier to understand because you already know the features it will have to provide.\n\n> 接口。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为您已经知道它将必须提供的功能。\n\nDesign patterns. Design patterns are generally-accepted solutions to certain common problems, such as the model-view-controller approach to user interface design. If you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers. Design patterns are discussed in more detail in Section 19.5.\n\n设计模式。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果您可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且您的代码对读者来说也会更明显。设计模式将在 19.5 节中详细讨论。\n\nInvariants. An invariant is a property of a variable or structure that is always true. For example, a data structure storing lines of text might enforce an invariant that each line is terminated by a newline character. Invariants reduce the number of special cases that must be considered in code and make it easier to reason about the code’s behavior.\n\n不变量。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。\n\n## 17.2 Ensuring consistency 确保一致性\n\nConsistency is hard to maintain, especially when many people work on a project over a long time. People in one group may not know about conventions established in another group. Newcomers don’t know the rules, so they unintentionally violate the conventions and create new conventions that conflict with existing ones. Here are a few tips for establishing and maintaining consistency:\n\n> 一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：\n\nDocument. Create a document that lists the most important overall conventions, such as coding style guidelines. Place the document in a spot where developers are likely to see it, such as a conspicuous place on the project Wiki. Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these.\n\n> 文献。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。\n\nFor conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you don’t write the conventions down, it’s unlikely that other people will follow them.\n\n> 对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果您不写下约定，那么其他人不太可能会遵循它们。\n\nEnforce. Even with good documentation, it’s hard for developers to remember all of the conventions. The best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly well for low-level syntactic conventions.\n\n> 执行。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。\n\nOne of my recent projects had problems with line termination characters. Some developers worked on Unix, where lines are terminated by newlines; others worked on Windows, where lines are normally terminated by a carriage-return followed by a newline. If a developer on one system made a small edit to a file previously edited on the other system, the editor would sometimes replace all of the line terminators with ones appropriate for that system. This gave the appearance that every line of the file had been modified, which made it hard to track the meaningful changes. We established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.\n\n> 我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。\n\nWe eventually solved this problem by writing a short script that was executed automatically before changes are committed to the source code repository. The script checks all of the files that have been modified and aborts the commit if any of them contain carriage returns. The script can also be run manually to repair damaged files by replacing carriage-return/newline sequences with newlines. This instantly eliminated the problems, and it also helped train new developers.\n\n> 我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。\n\nCode reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions. The more nit-picky that code reviewers are, the more quickly everyone on the team will learn the conventions, and the cleaner the code will be.\n\n> 代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。\n\nWhen in Rome ... The most important convention of all is that every developer should follow the old adage “When in Rome, do as the Romans do.” When working in a new file, look around to see how the existing code is structured. Are all public variables and methods declared before private ones? Are the methods in alphabetical order? Do variables use “camel case,” as in firstServerName, or “snake case,” as in first_server_name? When you see anything that looks like it might possibly be a convention, follow it. When making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.\n\n> 在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当您看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。\n\nDon’t change existing conventions. Resist the urge to “improve” on existing conventions. Having a “better idea” is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approach that wasn’t available when the old convention was established? Second, is the new approach so much better that it is worth taking the time to update all of the old uses? If your organization agrees that the answers to both questions are “yes,” then go ahead and make the upgrade; when you are done, there should be no sign of the old convention. However, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future. Overall, reconsidering established conventions is rarely a good use of developer time.\n\n> 不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。您的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，您是否拥有大量的新信息来证明您的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果您的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，您仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。\n\n## 17.3 Taking it too far 走得太远\n\nConsistency means not only that similar things should be done in similar ways, but that dissimilar things should be done in different ways. If you become overzealous about consistency and try to force dissimilar things into the same approach, such as by using the same variable name for things that are really different or using an existing design pattern for a task that doesn’t fit the pattern, you’ll create complexity and confusion. Consistency only provides benefits when developers have confidence that “if it looks like an x, it really is an x.”\n\n> 一致性不仅意味着相似的事情应该以相似的方式完成，而且不同的事情也应该以不同的方式完成。如果您对一致性过于热衷，并试图将不同的事物强制采用相同的方法，例如对确实不同的事物使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么会造成复杂性和混乱。一致性只有在开发人员确信“如果看起来像 x 时，它确实是 x”时才有好处。\n\n## 17.4 Conclusion 结论\n\nConsistency is another example of the investment mindset. It will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team. The return on this investment is that your code will be more obvious. Developers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.\n\n> 一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是您的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。\n","slug":"软件设计的哲学-ch17","published":1,"updated":"2021-02-16T04:53:10.568Z","_id":"ckl6pcbzy0002s4iy0jzr76u8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>一致性</p>\n<a id=\"more\"></a>\n<h1 id=\"第-17-章-一致性\"><a href=\"#第-17-章-一致性\" class=\"headerlink\" title=\"第 17 章 一致性\"></a>第 17 章 一致性</h1><blockquote>\n<p>Chapter 17 Consistency</p>\n</blockquote>\n<p>Consistency is a powerful tool for reducing the complexity of a system and making its behavior more obvious. If a system is consistent, it means that similar things are done in similar ways, and dissimilar things are done in different ways. Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach. If a system is not implemented in a consistent fashion, developers must learn about each situation separately. This will take more time.</p>\n<blockquote>\n<p>一致性是降低系统复杂性并使其行为更明显的强大工具。如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦您了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。</p>\n</blockquote>\n<p>Consistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptions made based on familiar-looking situations will be safe. Consistency allows developers to work more quickly with fewer mistakes.</p>\n<blockquote>\n<p>一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。</p>\n</blockquote>\n<h2 id=\"17-1-Examples-of-consistency-一致性示例\"><a href=\"#17-1-Examples-of-consistency-一致性示例\" class=\"headerlink\" title=\"17.1 Examples of consistency 一致性示例\"></a>17.1 Examples of consistency 一致性示例</h2><p>Consistency can be applied at many levels in a system; here are a few examples.</p>\n<blockquote>\n<p>一致性可以应用于系统中的许多级别。这里有一些例子。</p>\n</blockquote>\n<p>Names. Chapter 14 has already discussed the benefits of using names in a consistent way.</p>\n<blockquote>\n<p>名字。第 14 章已经讨论了以一致的方式使用名称的好处。</p>\n</blockquote>\n<p>Coding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers. Modern style guides address a range of issues, such as indentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make code easier to read and can reduce some kinds of errors.</p>\n<blockquote>\n<p>编码样式。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。</p>\n</blockquote>\n<p>Interfaces. An interface with multiple implementations is another example of consistency. Once you understand one implementation of the interface, any other implementation becomes easier to understand because you already know the features it will have to provide.</p>\n<blockquote>\n<p>接口。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为您已经知道它将必须提供的功能。</p>\n</blockquote>\n<p>Design patterns. Design patterns are generally-accepted solutions to certain common problems, such as the model-view-controller approach to user interface design. If you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers. Design patterns are discussed in more detail in Section 19.5.</p>\n<p>设计模式。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果您可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且您的代码对读者来说也会更明显。设计模式将在 19.5 节中详细讨论。</p>\n<p>Invariants. An invariant is a property of a variable or structure that is always true. For example, a data structure storing lines of text might enforce an invariant that each line is terminated by a newline character. Invariants reduce the number of special cases that must be considered in code and make it easier to reason about the code’s behavior.</p>\n<p>不变量。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。</p>\n<h2 id=\"17-2-Ensuring-consistency-确保一致性\"><a href=\"#17-2-Ensuring-consistency-确保一致性\" class=\"headerlink\" title=\"17.2 Ensuring consistency 确保一致性\"></a>17.2 Ensuring consistency 确保一致性</h2><p>Consistency is hard to maintain, especially when many people work on a project over a long time. People in one group may not know about conventions established in another group. Newcomers don’t know the rules, so they unintentionally violate the conventions and create new conventions that conflict with existing ones. Here are a few tips for establishing and maintaining consistency:</p>\n<blockquote>\n<p>一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：</p>\n</blockquote>\n<p>Document. Create a document that lists the most important overall conventions, such as coding style guidelines. Place the document in a spot where developers are likely to see it, such as a conspicuous place on the project Wiki. Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these.</p>\n<blockquote>\n<p>文献。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。</p>\n</blockquote>\n<p>For conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you don’t write the conventions down, it’s unlikely that other people will follow them.</p>\n<blockquote>\n<p>对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果您不写下约定，那么其他人不太可能会遵循它们。</p>\n</blockquote>\n<p>Enforce. Even with good documentation, it’s hard for developers to remember all of the conventions. The best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly well for low-level syntactic conventions.</p>\n<blockquote>\n<p>执行。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。</p>\n</blockquote>\n<p>One of my recent projects had problems with line termination characters. Some developers worked on Unix, where lines are terminated by newlines; others worked on Windows, where lines are normally terminated by a carriage-return followed by a newline. If a developer on one system made a small edit to a file previously edited on the other system, the editor would sometimes replace all of the line terminators with ones appropriate for that system. This gave the appearance that every line of the file had been modified, which made it hard to track the meaningful changes. We established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.</p>\n<blockquote>\n<p>我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。</p>\n</blockquote>\n<p>We eventually solved this problem by writing a short script that was executed automatically before changes are committed to the source code repository. The script checks all of the files that have been modified and aborts the commit if any of them contain carriage returns. The script can also be run manually to repair damaged files by replacing carriage-return/newline sequences with newlines. This instantly eliminated the problems, and it also helped train new developers.</p>\n<blockquote>\n<p>我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。</p>\n</blockquote>\n<p>Code reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions. The more nit-picky that code reviewers are, the more quickly everyone on the team will learn the conventions, and the cleaner the code will be.</p>\n<blockquote>\n<p>代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。</p>\n</blockquote>\n<p>When in Rome … The most important convention of all is that every developer should follow the old adage “When in Rome, do as the Romans do.” When working in a new file, look around to see how the existing code is structured. Are all public variables and methods declared before private ones? Are the methods in alphabetical order? Do variables use “camel case,” as in firstServerName, or “snake case,” as in first_server_name? When you see anything that looks like it might possibly be a convention, follow it. When making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.</p>\n<blockquote>\n<p>在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当您看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。</p>\n</blockquote>\n<p>Don’t change existing conventions. Resist the urge to “improve” on existing conventions. Having a “better idea” is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approach that wasn’t available when the old convention was established? Second, is the new approach so much better that it is worth taking the time to update all of the old uses? If your organization agrees that the answers to both questions are “yes,” then go ahead and make the upgrade; when you are done, there should be no sign of the old convention. However, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future. Overall, reconsidering established conventions is rarely a good use of developer time.</p>\n<blockquote>\n<p>不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。您的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，您是否拥有大量的新信息来证明您的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果您的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，您仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。</p>\n</blockquote>\n<h2 id=\"17-3-Taking-it-too-far-走得太远\"><a href=\"#17-3-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"17.3 Taking it too far 走得太远\"></a>17.3 Taking it too far 走得太远</h2><p>Consistency means not only that similar things should be done in similar ways, but that dissimilar things should be done in different ways. If you become overzealous about consistency and try to force dissimilar things into the same approach, such as by using the same variable name for things that are really different or using an existing design pattern for a task that doesn’t fit the pattern, you’ll create complexity and confusion. Consistency only provides benefits when developers have confidence that “if it looks like an x, it really is an x.”</p>\n<blockquote>\n<p>一致性不仅意味着相似的事情应该以相似的方式完成，而且不同的事情也应该以不同的方式完成。如果您对一致性过于热衷，并试图将不同的事物强制采用相同的方法，例如对确实不同的事物使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么会造成复杂性和混乱。一致性只有在开发人员确信“如果看起来像 x 时，它确实是 x”时才有好处。</p>\n</blockquote>\n<h2 id=\"17-4-Conclusion-结论\"><a href=\"#17-4-Conclusion-结论\" class=\"headerlink\" title=\"17.4 Conclusion 结论\"></a>17.4 Conclusion 结论</h2><p>Consistency is another example of the investment mindset. It will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team. The return on this investment is that your code will be more obvious. Developers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.</p>\n<blockquote>\n<p>一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是您的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>一致性</p>","more":"<h1 id=\"第-17-章-一致性\"><a href=\"#第-17-章-一致性\" class=\"headerlink\" title=\"第 17 章 一致性\"></a>第 17 章 一致性</h1><blockquote>\n<p>Chapter 17 Consistency</p>\n</blockquote>\n<p>Consistency is a powerful tool for reducing the complexity of a system and making its behavior more obvious. If a system is consistent, it means that similar things are done in similar ways, and dissimilar things are done in different ways. Consistency creates cognitive leverage: once you have learned how something is done in one place, you can use that knowledge to immediately understand other places that use the same approach. If a system is not implemented in a consistent fashion, developers must learn about each situation separately. This will take more time.</p>\n<blockquote>\n<p>一致性是降低系统复杂性并使其行为更明显的强大工具。如果系统是一致的，则意味着相似的事情以相似的方式完成，而不同的事情则以不同的方式完成。一致性会产生认知影响力：一旦您了解了某个地方的工作方式，就可以使用该知识立即了解其他使用相同方法的地方。如果系统的实施方式不一致，则开发人员必须分别了解每种情况。这将花费更多时间。</p>\n</blockquote>\n<p>Consistency reduces mistakes. If a system is not consistent, two situations may appear the same when in fact they are different. A developer may see a pattern that looks familiar and make incorrect assumptions based on previous encounters with that pattern. On the other hand, if the system is consistent, assumptions made based on familiar-looking situations will be safe. Consistency allows developers to work more quickly with fewer mistakes.</p>\n<blockquote>\n<p>一致性减少了错误。如果系统不一致，则实际上两种情况可能不同，但两种情况可能看起来相同。开发人员可能会看到一个看起来很熟悉的模式，并根据以前对该模式的遭遇做出错误的假设。另一方面，如果系统是一致的，则基于熟悉情况的假设将是安全的。一致性允许开发人员以更少的错误来更快地工作。</p>\n</blockquote>\n<h2 id=\"17-1-Examples-of-consistency-一致性示例\"><a href=\"#17-1-Examples-of-consistency-一致性示例\" class=\"headerlink\" title=\"17.1 Examples of consistency 一致性示例\"></a>17.1 Examples of consistency 一致性示例</h2><p>Consistency can be applied at many levels in a system; here are a few examples.</p>\n<blockquote>\n<p>一致性可以应用于系统中的许多级别。这里有一些例子。</p>\n</blockquote>\n<p>Names. Chapter 14 has already discussed the benefits of using names in a consistent way.</p>\n<blockquote>\n<p>名字。第 14 章已经讨论了以一致的方式使用名称的好处。</p>\n</blockquote>\n<p>Coding style. It is common nowadays for development organizations to have style guides that restrict program structure beyond the rules enforced by compilers. Modern style guides address a range of issues, such as indentation, curly-brace placement, order of declarations, naming, commenting, and restrictions on language features considered dangerous. Style guidelines make code easier to read and can reduce some kinds of errors.</p>\n<blockquote>\n<p>编码样式。如今，开发组织通常拥有样式指南，这些样式指南将程序结构限制在编译器所强制执行的规则之外。现代风格指南解决了一系列问题，例如缩进，大括号放置，声明顺序，命名，注释以及对认为危险的语言功能的限制。样式指南使代码更易于阅读，并且可以减少某些类型的错误。</p>\n</blockquote>\n<p>Interfaces. An interface with multiple implementations is another example of consistency. Once you understand one implementation of the interface, any other implementation becomes easier to understand because you already know the features it will have to provide.</p>\n<blockquote>\n<p>接口。具有多个实现的接口是一致性的另一个示例。一旦了解了接口的一种实现，其他任何实现都将变得更易于理解，因为您已经知道它将必须提供的功能。</p>\n</blockquote>\n<p>Design patterns. Design patterns are generally-accepted solutions to certain common problems, such as the model-view-controller approach to user interface design. If you can use an existing design pattern to solve the problem, the implementation will proceed more quickly, it is more likely to work, and your code will be more obvious to readers. Design patterns are discussed in more detail in Section 19.5.</p>\n<p>设计模式。设计模式是某些常见问题的普遍接受的解决方案，例如用于用户界面设计的模型视图控制器方法。如果您可以使用现有的设计模式来解决问题，则实现会更快地进行，更有可能起作用，并且您的代码对读者来说也会更明显。设计模式将在 19.5 节中详细讨论。</p>\n<p>Invariants. An invariant is a property of a variable or structure that is always true. For example, a data structure storing lines of text might enforce an invariant that each line is terminated by a newline character. Invariants reduce the number of special cases that must be considered in code and make it easier to reason about the code’s behavior.</p>\n<p>不变量。不变式是始终为真的变量或结构的属性。例如，存储文本行的数据结构可能会强制要求每行以换行符终止。不变式减少了代码中必须考虑的特殊情况的数量，并使推理行为的方式变得更加容易。</p>\n<h2 id=\"17-2-Ensuring-consistency-确保一致性\"><a href=\"#17-2-Ensuring-consistency-确保一致性\" class=\"headerlink\" title=\"17.2 Ensuring consistency 确保一致性\"></a>17.2 Ensuring consistency 确保一致性</h2><p>Consistency is hard to maintain, especially when many people work on a project over a long time. People in one group may not know about conventions established in another group. Newcomers don’t know the rules, so they unintentionally violate the conventions and create new conventions that conflict with existing ones. Here are a few tips for establishing and maintaining consistency:</p>\n<blockquote>\n<p>一致性很难维护，尤其是当许多人长时间从事一个项目时。一组人可能不了解另一组中建立的约定。新来者不了解规则，因此他们无意间违反了约定并创建了与现有约定冲突的新约定。以下是建立和保持一致性的一些技巧：</p>\n</blockquote>\n<p>Document. Create a document that lists the most important overall conventions, such as coding style guidelines. Place the document in a spot where developers are likely to see it, such as a conspicuous place on the project Wiki. Encourage new people joining the group to read the document, and encourage existing people to review it every once in a while. Several style guides from various organizations have been published on the Web; consider starting with one of these.</p>\n<blockquote>\n<p>文献。创建一个列出最重要的总体约定的文档，例如编码样式准则。将文档放置在开发人员可能会看到的位置，例如项目 Wiki 上的显眼位置。鼓励新成员加入小组阅读文档，并鼓励现有人员不时审阅该文档。Web 上已经发布了来自各个组织的一些样式指南；考虑从其中之一开始。</p>\n</blockquote>\n<p>For conventions that are more localized, such as invariants, find an appropriate spot in the code to document them. If you don’t write the conventions down, it’s unlikely that other people will follow them.</p>\n<blockquote>\n<p>对于局部性更强的约定，例如不变式，请在代码中找到合适的位置进行记录。如果您不写下约定，那么其他人不太可能会遵循它们。</p>\n</blockquote>\n<p>Enforce. Even with good documentation, it’s hard for developers to remember all of the conventions. The best way to enforce conventions is to write a tool that checks for violations, and make sure that code cannot be committed to the repository unless it passes the checker. Automated checkers work particularly well for low-level syntactic conventions.</p>\n<blockquote>\n<p>执行。即使有好的文档，开发人员也很难记住所有约定。实施约定的最佳方法是编写一个检查违规的工具，并确保除非通过检查程序，否则代码无法提交到存储库。自动检查器对于底层语法约定特别有用。</p>\n</blockquote>\n<p>One of my recent projects had problems with line termination characters. Some developers worked on Unix, where lines are terminated by newlines; others worked on Windows, where lines are normally terminated by a carriage-return followed by a newline. If a developer on one system made a small edit to a file previously edited on the other system, the editor would sometimes replace all of the line terminators with ones appropriate for that system. This gave the appearance that every line of the file had been modified, which made it hard to track the meaningful changes. We established a convention that files should contain newlines only, but it was hard to ensure that every tool used by every developer followed the convention. Every time a new developer joined the project, we would experience a rash of line termination problems while that developer adjusted to the convention.</p>\n<blockquote>\n<p>我最近的一个项目有行终止字符的问题。一些开发人员在 Unix 上工作，行被换行终止;其他的工作在 Windows 上，行通常由一个 carriage-return 后跟一个换行符来结束。如果一个系统上的开发人员对先前在另一个系统上编辑过的文件进行了小的编辑，那么编辑器有时会将所有行终止符替换为适合该系统的行终止符。这给人的感觉是文件的每一行都被修改了，这使得跟踪有意义的更改变得很困难。我们建立了一个约定，即文件应该只包含换行，但是很难确保每个开发人员使用的每个工具都遵循这个约定。每当一个新的开发人员加入这个项目，我们就会经历一连串的线路终止问题，而那个开发人员就会适应这个约定。</p>\n</blockquote>\n<p>We eventually solved this problem by writing a short script that was executed automatically before changes are committed to the source code repository. The script checks all of the files that have been modified and aborts the commit if any of them contain carriage returns. The script can also be run manually to repair damaged files by replacing carriage-return/newline sequences with newlines. This instantly eliminated the problems, and it also helped train new developers.</p>\n<blockquote>\n<p>我们最终通过编写一个简短的脚本解决了这个问题，该脚本在更改提交到源代码存储库之前自动执行。该脚本检查所有已修改的文件，如果其中任何一个包含回车符，则中止提交。还可以通过用换行符替换回车/换行符序列来手动运行脚本以修复损坏的文件。这立即消除了问题，并且还帮助培训了新开发人员。</p>\n</blockquote>\n<p>Code reviews provide another opportunity for enforcing conventions and for educating new developers about the conventions. The more nit-picky that code reviewers are, the more quickly everyone on the team will learn the conventions, and the cleaner the code will be.</p>\n<blockquote>\n<p>代码审查为实施约定和向新开发者提供有关约定的教育提供了另一个机会。代码审阅者越挑剔，团队中的每个人都将更快地学习约定，并且代码越干净。</p>\n</blockquote>\n<p>When in Rome … The most important convention of all is that every developer should follow the old adage “When in Rome, do as the Romans do.” When working in a new file, look around to see how the existing code is structured. Are all public variables and methods declared before private ones? Are the methods in alphabetical order? Do variables use “camel case,” as in firstServerName, or “snake case,” as in first_server_name? When you see anything that looks like it might possibly be a convention, follow it. When making a design decision, ask yourself if it’s likely that a similar decision was made elsewhere in the project; if so, find an existing example and use the same approach in your new code.</p>\n<blockquote>\n<p>在罗马时……最重要的约定是每个开发人员都应遵循古老的格言“在罗马时，就像罗马人一样。” 在处理新文件时，请环顾四周以了解现有代码的结构。是否在私有变量和方法之前声明了所有公共变量和方法？方法是否按字母顺序排列？变量是否使用 firstServerName 中的“ camel case”或使用 first_server_name 中的“ snake case”？当您看到任何看起来可能是约定的内容时，请遵循该约定。在做出设计决策时，请问自己是否有可能在项目的其他地方做出了类似的决策；如果是这样，请找到一个现有示例，并在新代码中使用相同的方法。</p>\n</blockquote>\n<p>Don’t change existing conventions. Resist the urge to “improve” on existing conventions. Having a “better idea” is not a sufficient excuse to introduce inconsistencies. Your new idea may indeed be better, but the value of consistency over inconsistency is almost always greater than the value of one approach over another. Before introducing inconsistent behavior, ask yourself two questions. First, do you have significant new information justifying your approach that wasn’t available when the old convention was established? Second, is the new approach so much better that it is worth taking the time to update all of the old uses? If your organization agrees that the answers to both questions are “yes,” then go ahead and make the upgrade; when you are done, there should be no sign of the old convention. However, you still run the risk that other developers will not know about the new convention, so they may reintroduce the old approach in the future. Overall, reconsidering established conventions is rarely a good use of developer time.</p>\n<blockquote>\n<p>不要更改现有约定。抵制“改善”现有公约的冲动。拥有一个“更好的主意”不足以引起矛盾。您的新想法可能确实更好，但是一致性胜于不一致的价值几乎总是大于一种方法胜过另一种方法的价值。在引入不一致的行为之前，请问自己两个问题。首先，您是否拥有大量的新信息来证明您的方法在建立旧约定时是不可用的？其次，新方法是否好得多，值得花时间更新所有旧用法？如果您的组织同意对两个问题的回答均为“是”，则继续进行升级；否则，请进行升级。完成后，应该没有旧约定的迹象。然而，您仍然冒着其他开发人员不了解新约定的风险，因此他们将来可能会重新引入旧方法。总体而言，重新考虑已建立的约定很少会很好地利用开发人员时间。</p>\n</blockquote>\n<h2 id=\"17-3-Taking-it-too-far-走得太远\"><a href=\"#17-3-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"17.3 Taking it too far 走得太远\"></a>17.3 Taking it too far 走得太远</h2><p>Consistency means not only that similar things should be done in similar ways, but that dissimilar things should be done in different ways. If you become overzealous about consistency and try to force dissimilar things into the same approach, such as by using the same variable name for things that are really different or using an existing design pattern for a task that doesn’t fit the pattern, you’ll create complexity and confusion. Consistency only provides benefits when developers have confidence that “if it looks like an x, it really is an x.”</p>\n<blockquote>\n<p>一致性不仅意味着相似的事情应该以相似的方式完成，而且不同的事情也应该以不同的方式完成。如果您对一致性过于热衷，并试图将不同的事物强制采用相同的方法，例如对确实不同的事物使用相同的变量名，或者对不适合该模式的任务使用现有的设计模式，那么会造成复杂性和混乱。一致性只有在开发人员确信“如果看起来像 x 时，它确实是 x”时才有好处。</p>\n</blockquote>\n<h2 id=\"17-4-Conclusion-结论\"><a href=\"#17-4-Conclusion-结论\" class=\"headerlink\" title=\"17.4 Conclusion 结论\"></a>17.4 Conclusion 结论</h2><p>Consistency is another example of the investment mindset. It will take a bit of extra work to ensure consistency: work to decide on conventions, work to create automated checkers, work to look for similar situations to mimic in new code, and work in code reviews to educate the team. The return on this investment is that your code will be more obvious. Developers will be able to understand the code’s behavior more quickly and accurately, and this will allow them to work faster, with fewer bugs.</p>\n<blockquote>\n<p>一致性是投资心态的另一个例子。确保一致性的工作将需要一些额外的工作：确定约定，创建自动检查程序，寻找类似情况以模仿新代码，以及进行代码审查以教育团队。这项投资的回报是您的代码将更加明显。开发人员将能够更快，更准确地了解代码的行为，这将使他们能够以更少的错误来更快地工作。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch2","date":"2021-02-01T16:00:00.000Z","_content":"复杂性的本质\n<!-- more -->\n# 第 2 章 复杂性的本质\n\n这本书是关于如何设计软件系统以最小化其复杂性。第一步是了解敌人。究竟什么是“复杂性”？您如何判断系统是否过于复杂？是什么导致系统变得复杂？本章将在较高层次上解决这些问题。后续章节将向您展示如何从较低的层次上根据特定的结构特征来识别复杂性。\n\n识别复杂性的能力是至关重要的设计技能。它使您可以先找出问题，然后再付出大量努力，并可以在其他选择中做出正确的选择。判断一个设计是否简单比创建一个简单的设计要容易得多，但是一旦您认识到一个系统过于复杂，就可以使用该功能指导您的设计哲学走向简单。如果设计看起来很复杂，请尝试其他方法，看看是否更简单。随着时间的流逝，您会注意到某些技术往往会导致设计更简单，而其他技术则与复杂性相关。这将使您更快地制作更简单的设计。\n\n本章还列出了一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节将采用本章的内容，并用其论证各种改进和结论。\n\n## 2.1 Complexity defined 复杂性的定义\n\n出于本书的目的，我以实用的方式定义“复杂性”。复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂。如果很容易理解和修改，那就很简单。\n\n您还可以考虑成本和收益方面的复杂性。在复杂的系统中，要实施甚至很小的改进都需要大量的工作。在一个简单的系统中，可以用更少的精力实现更大的改进。\n\n复杂性是开发人员在尝试实现特定目标时在特定时间点所经历的。它不一定与系统的整体大小或功能有关。人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，那么就本书而言，它并不复杂。当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。\n\n复杂性取决于最常见的活动。如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。为了用粗略的数学方法来表征：\n\n![](../../img/figures/00009.gif)\n\n系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。\n\n读者比作家更容易理解复杂性。如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。当您遇到这种情况时，有必要对其他开发人员进行调查，以找出为什么代码对他们而言似乎很复杂；从您的观点与观点之间的脱节中可能可以学习一些有趣的课程。作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码。\n\n## 2.2 Symptoms of complexity 复杂性的症状\n\n复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。\n\n变更放大：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如图 2.1（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于图 2.1（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。\n\n认知负荷：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。\n\n系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。\n\n![](../../img/figures/00010.jpeg)\n\n图 2.1：网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。\n\n未知的未知:复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。图 2.1(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。\n\n在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。\n\n良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。第 18 章讨论使代码更明显的技术。\n\n## 2.3 Causes of complexity 复杂性的原因\n\n既然您已经了解了复杂性的高级症状以及为什么复杂性会使软件开发变得困难，那么下一步就是了解导致复杂性的原因，以便我们设计系统来避免这些问题。复杂性是由两件事引起的：依赖性和模糊性。本节从高层次讨论这些因素。随后的章节将讨论它们与低级设计决策之间的关系。\n\n就本书而言，当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。在图 2.1（a）的网站示例中，背景色在所有页面之间创建了依赖关系。所有页面都必须具有相同的背景，因此，如果更改一页的背景，则必须更改所有背景。依赖关系的另一个示例发生在网络协议中。通常，协议的发送方和接收方有单独的代码，但是它们必须分别符合协议。更改发送方的代码几乎总是需要在接收方进行相应的更改，反之亦然。\n\n考虑网站示例。在每个页面分别指定背景的旧网站中，所有网页都是相互依赖的。新的网站通过在中心位置指定背景色并提供一个 API，供各个页面在呈现它们时检索该颜色，从而解决了该问题。新的网站消除了页面之间的依赖关系，但是它围绕 API 创建了一个新的依赖关系以检索背景色。幸运的是，新的依赖性更加明显：很明显，每个单独的网页都取决于 bannerBg 颜色，并且开发人员可以通过搜索其名称轻松找到使用该变量的所有位置。此外，编译器还有助于管理 API 依赖性：如果共享变量的名称发生变化，任何仍使用旧名称的代码都将发生编译错误。新的网站用一种更简单，更明显的方式代替了一种不明显且难以管理的依赖性。\n\n复杂性的第二个原因是晦涩。当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找使用该变量的位置。晦涩常常与依赖项相关联，在这种情况下，依赖项的存在并不明显。例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。不一致性也是造成不透明性的一个主要原因:如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道某个特定变量的目的是什么。\n\n在许多情况下，由于文档不足而导致模糊不清。第 13 章讨论了这个主题。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是一个警告，即设计不正确。减少模糊性的最佳方法是简化系统设计。\n\n依赖性和模糊性共同构成了第 2.2 节中描述的三种复杂性表现。依赖性导致变化放大和高认知负荷。晦涩会产生未知的未知数，还会增加认知负担。如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。\n\n## 2.4 Complexity is incremental 复杂度是递增的\n\n复杂性不是由单个灾难性错误引起的；它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。\n\n复杂性的增量性质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。为了减缓复杂性的增长，您必须采用第 3 章中讨论的“零容忍”理念。\n\n## 2.5 Conclusion 结论\n\n复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且冒险。\n","source":"_posts/软件设计的哲学-ch2.md","raw":"---\ntitle: 软件设计的哲学 - ch2\ndate: 2021-02-2\ntags: 软件设计的哲学 软件开发 方法论\n---\n复杂性的本质\n<!-- more -->\n# 第 2 章 复杂性的本质\n\n这本书是关于如何设计软件系统以最小化其复杂性。第一步是了解敌人。究竟什么是“复杂性”？您如何判断系统是否过于复杂？是什么导致系统变得复杂？本章将在较高层次上解决这些问题。后续章节将向您展示如何从较低的层次上根据特定的结构特征来识别复杂性。\n\n识别复杂性的能力是至关重要的设计技能。它使您可以先找出问题，然后再付出大量努力，并可以在其他选择中做出正确的选择。判断一个设计是否简单比创建一个简单的设计要容易得多，但是一旦您认识到一个系统过于复杂，就可以使用该功能指导您的设计哲学走向简单。如果设计看起来很复杂，请尝试其他方法，看看是否更简单。随着时间的流逝，您会注意到某些技术往往会导致设计更简单，而其他技术则与复杂性相关。这将使您更快地制作更简单的设计。\n\n本章还列出了一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节将采用本章的内容，并用其论证各种改进和结论。\n\n## 2.1 Complexity defined 复杂性的定义\n\n出于本书的目的，我以实用的方式定义“复杂性”。复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂。如果很容易理解和修改，那就很简单。\n\n您还可以考虑成本和收益方面的复杂性。在复杂的系统中，要实施甚至很小的改进都需要大量的工作。在一个简单的系统中，可以用更少的精力实现更大的改进。\n\n复杂性是开发人员在尝试实现特定目标时在特定时间点所经历的。它不一定与系统的整体大小或功能有关。人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，那么就本书而言，它并不复杂。当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。\n\n复杂性取决于最常见的活动。如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。为了用粗略的数学方法来表征：\n\n![](../../img/figures/00009.gif)\n\n系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。\n\n读者比作家更容易理解复杂性。如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。当您遇到这种情况时，有必要对其他开发人员进行调查，以找出为什么代码对他们而言似乎很复杂；从您的观点与观点之间的脱节中可能可以学习一些有趣的课程。作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码。\n\n## 2.2 Symptoms of complexity 复杂性的症状\n\n复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。\n\n变更放大：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如图 2.1（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于图 2.1（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。\n\n认知负荷：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。\n\n系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。\n\n![](../../img/figures/00010.jpeg)\n\n图 2.1：网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。\n\n未知的未知:复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。图 2.1(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。\n\n在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。\n\n良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。第 18 章讨论使代码更明显的技术。\n\n## 2.3 Causes of complexity 复杂性的原因\n\n既然您已经了解了复杂性的高级症状以及为什么复杂性会使软件开发变得困难，那么下一步就是了解导致复杂性的原因，以便我们设计系统来避免这些问题。复杂性是由两件事引起的：依赖性和模糊性。本节从高层次讨论这些因素。随后的章节将讨论它们与低级设计决策之间的关系。\n\n就本书而言，当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。在图 2.1（a）的网站示例中，背景色在所有页面之间创建了依赖关系。所有页面都必须具有相同的背景，因此，如果更改一页的背景，则必须更改所有背景。依赖关系的另一个示例发生在网络协议中。通常，协议的发送方和接收方有单独的代码，但是它们必须分别符合协议。更改发送方的代码几乎总是需要在接收方进行相应的更改，反之亦然。\n\n考虑网站示例。在每个页面分别指定背景的旧网站中，所有网页都是相互依赖的。新的网站通过在中心位置指定背景色并提供一个 API，供各个页面在呈现它们时检索该颜色，从而解决了该问题。新的网站消除了页面之间的依赖关系，但是它围绕 API 创建了一个新的依赖关系以检索背景色。幸运的是，新的依赖性更加明显：很明显，每个单独的网页都取决于 bannerBg 颜色，并且开发人员可以通过搜索其名称轻松找到使用该变量的所有位置。此外，编译器还有助于管理 API 依赖性：如果共享变量的名称发生变化，任何仍使用旧名称的代码都将发生编译错误。新的网站用一种更简单，更明显的方式代替了一种不明显且难以管理的依赖性。\n\n复杂性的第二个原因是晦涩。当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找使用该变量的位置。晦涩常常与依赖项相关联，在这种情况下，依赖项的存在并不明显。例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。不一致性也是造成不透明性的一个主要原因:如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道某个特定变量的目的是什么。\n\n在许多情况下，由于文档不足而导致模糊不清。第 13 章讨论了这个主题。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是一个警告，即设计不正确。减少模糊性的最佳方法是简化系统设计。\n\n依赖性和模糊性共同构成了第 2.2 节中描述的三种复杂性表现。依赖性导致变化放大和高认知负荷。晦涩会产生未知的未知数，还会增加认知负担。如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。\n\n## 2.4 Complexity is incremental 复杂度是递增的\n\n复杂性不是由单个灾难性错误引起的；它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。\n\n复杂性的增量性质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。为了减缓复杂性的增长，您必须采用第 3 章中讨论的“零容忍”理念。\n\n## 2.5 Conclusion 结论\n\n复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且冒险。\n","slug":"软件设计的哲学-ch2","published":1,"updated":"2021-02-16T04:49:16.378Z","_id":"ckl6pcc020004s4iy7kxc96qh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>复杂性的本质</p>\n<a id=\"more\"></a>\n<h1 id=\"第-2-章-复杂性的本质\"><a href=\"#第-2-章-复杂性的本质\" class=\"headerlink\" title=\"第 2 章 复杂性的本质\"></a>第 2 章 复杂性的本质</h1><p>这本书是关于如何设计软件系统以最小化其复杂性。第一步是了解敌人。究竟什么是“复杂性”？您如何判断系统是否过于复杂？是什么导致系统变得复杂？本章将在较高层次上解决这些问题。后续章节将向您展示如何从较低的层次上根据特定的结构特征来识别复杂性。</p>\n<p>识别复杂性的能力是至关重要的设计技能。它使您可以先找出问题，然后再付出大量努力，并可以在其他选择中做出正确的选择。判断一个设计是否简单比创建一个简单的设计要容易得多，但是一旦您认识到一个系统过于复杂，就可以使用该功能指导您的设计哲学走向简单。如果设计看起来很复杂，请尝试其他方法，看看是否更简单。随着时间的流逝，您会注意到某些技术往往会导致设计更简单，而其他技术则与复杂性相关。这将使您更快地制作更简单的设计。</p>\n<p>本章还列出了一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节将采用本章的内容，并用其论证各种改进和结论。</p>\n<h2 id=\"2-1-Complexity-defined-复杂性的定义\"><a href=\"#2-1-Complexity-defined-复杂性的定义\" class=\"headerlink\" title=\"2.1 Complexity defined 复杂性的定义\"></a>2.1 Complexity defined 复杂性的定义</h2><p>出于本书的目的，我以实用的方式定义“复杂性”。复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂。如果很容易理解和修改，那就很简单。</p>\n<p>您还可以考虑成本和收益方面的复杂性。在复杂的系统中，要实施甚至很小的改进都需要大量的工作。在一个简单的系统中，可以用更少的精力实现更大的改进。</p>\n<p>复杂性是开发人员在尝试实现特定目标时在特定时间点所经历的。它不一定与系统的整体大小或功能有关。人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，那么就本书而言，它并不复杂。当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。</p>\n<p>复杂性取决于最常见的活动。如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。为了用粗略的数学方法来表征：</p>\n<p><img src=\"../../img/figures/00009.gif\" alt=\"\"></p>\n<p>系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。</p>\n<p>读者比作家更容易理解复杂性。如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。当您遇到这种情况时，有必要对其他开发人员进行调查，以找出为什么代码对他们而言似乎很复杂；从您的观点与观点之间的脱节中可能可以学习一些有趣的课程。作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码。</p>\n<h2 id=\"2-2-Symptoms-of-complexity-复杂性的症状\"><a href=\"#2-2-Symptoms-of-complexity-复杂性的症状\" class=\"headerlink\" title=\"2.2 Symptoms of complexity 复杂性的症状\"></a>2.2 Symptoms of complexity 复杂性的症状</h2><p>复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。</p>\n<p>变更放大：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如图 2.1（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于图 2.1（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。</p>\n<p>认知负荷：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。</p>\n<p>系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。</p>\n<p><img src=\"../../img/figures/00010.jpeg\" alt=\"\"></p>\n<p>图 2.1：网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。</p>\n<p>未知的未知:复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。图 2.1(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。</p>\n<p>在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。</p>\n<p>良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。第 18 章讨论使代码更明显的技术。</p>\n<h2 id=\"2-3-Causes-of-complexity-复杂性的原因\"><a href=\"#2-3-Causes-of-complexity-复杂性的原因\" class=\"headerlink\" title=\"2.3 Causes of complexity 复杂性的原因\"></a>2.3 Causes of complexity 复杂性的原因</h2><p>既然您已经了解了复杂性的高级症状以及为什么复杂性会使软件开发变得困难，那么下一步就是了解导致复杂性的原因，以便我们设计系统来避免这些问题。复杂性是由两件事引起的：依赖性和模糊性。本节从高层次讨论这些因素。随后的章节将讨论它们与低级设计决策之间的关系。</p>\n<p>就本书而言，当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。在图 2.1（a）的网站示例中，背景色在所有页面之间创建了依赖关系。所有页面都必须具有相同的背景，因此，如果更改一页的背景，则必须更改所有背景。依赖关系的另一个示例发生在网络协议中。通常，协议的发送方和接收方有单独的代码，但是它们必须分别符合协议。更改发送方的代码几乎总是需要在接收方进行相应的更改，反之亦然。</p>\n<p>考虑网站示例。在每个页面分别指定背景的旧网站中，所有网页都是相互依赖的。新的网站通过在中心位置指定背景色并提供一个 API，供各个页面在呈现它们时检索该颜色，从而解决了该问题。新的网站消除了页面之间的依赖关系，但是它围绕 API 创建了一个新的依赖关系以检索背景色。幸运的是，新的依赖性更加明显：很明显，每个单独的网页都取决于 bannerBg 颜色，并且开发人员可以通过搜索其名称轻松找到使用该变量的所有位置。此外，编译器还有助于管理 API 依赖性：如果共享变量的名称发生变化，任何仍使用旧名称的代码都将发生编译错误。新的网站用一种更简单，更明显的方式代替了一种不明显且难以管理的依赖性。</p>\n<p>复杂性的第二个原因是晦涩。当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找使用该变量的位置。晦涩常常与依赖项相关联，在这种情况下，依赖项的存在并不明显。例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。不一致性也是造成不透明性的一个主要原因:如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道某个特定变量的目的是什么。</p>\n<p>在许多情况下，由于文档不足而导致模糊不清。第 13 章讨论了这个主题。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是一个警告，即设计不正确。减少模糊性的最佳方法是简化系统设计。</p>\n<p>依赖性和模糊性共同构成了第 2.2 节中描述的三种复杂性表现。依赖性导致变化放大和高认知负荷。晦涩会产生未知的未知数，还会增加认知负担。如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。</p>\n<h2 id=\"2-4-Complexity-is-incremental-复杂度是递增的\"><a href=\"#2-4-Complexity-is-incremental-复杂度是递增的\" class=\"headerlink\" title=\"2.4 Complexity is incremental 复杂度是递增的\"></a>2.4 Complexity is incremental 复杂度是递增的</h2><p>复杂性不是由单个灾难性错误引起的；它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。</p>\n<p>复杂性的增量性质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。为了减缓复杂性的增长，您必须采用第 3 章中讨论的“零容忍”理念。</p>\n<h2 id=\"2-5-Conclusion-结论\"><a href=\"#2-5-Conclusion-结论\" class=\"headerlink\" title=\"2.5 Conclusion 结论\"></a>2.5 Conclusion 结论</h2><p>复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且冒险。</p>\n","site":{"data":{}},"excerpt":"<p>复杂性的本质</p>","more":"<h1 id=\"第-2-章-复杂性的本质\"><a href=\"#第-2-章-复杂性的本质\" class=\"headerlink\" title=\"第 2 章 复杂性的本质\"></a>第 2 章 复杂性的本质</h1><p>这本书是关于如何设计软件系统以最小化其复杂性。第一步是了解敌人。究竟什么是“复杂性”？您如何判断系统是否过于复杂？是什么导致系统变得复杂？本章将在较高层次上解决这些问题。后续章节将向您展示如何从较低的层次上根据特定的结构特征来识别复杂性。</p>\n<p>识别复杂性的能力是至关重要的设计技能。它使您可以先找出问题，然后再付出大量努力，并可以在其他选择中做出正确的选择。判断一个设计是否简单比创建一个简单的设计要容易得多，但是一旦您认识到一个系统过于复杂，就可以使用该功能指导您的设计哲学走向简单。如果设计看起来很复杂，请尝试其他方法，看看是否更简单。随着时间的流逝，您会注意到某些技术往往会导致设计更简单，而其他技术则与复杂性相关。这将使您更快地制作更简单的设计。</p>\n<p>本章还列出了一些基本假设，这些基本假设为本书的其余部分奠定了基础。后面的章节将采用本章的内容，并用其论证各种改进和结论。</p>\n<h2 id=\"2-1-Complexity-defined-复杂性的定义\"><a href=\"#2-1-Complexity-defined-复杂性的定义\" class=\"headerlink\" title=\"2.1 Complexity defined 复杂性的定义\"></a>2.1 Complexity defined 复杂性的定义</h2><p>出于本书的目的，我以实用的方式定义“复杂性”。复杂性与软件系统的结构有关，这使它很难理解和修改系统。复杂性可以采取多种形式。例如，可能很难理解一段代码是如何工作的。可能需要花费很多精力才能实现较小的改进，或者可能不清楚必须修改系统的哪些部分才能进行改进；如果不引入其他错误，可能很难修复。如果一个软件系统难以理解和修改，那就很复杂。如果很容易理解和修改，那就很简单。</p>\n<p>您还可以考虑成本和收益方面的复杂性。在复杂的系统中，要实施甚至很小的改进都需要大量的工作。在一个简单的系统中，可以用更少的精力实现更大的改进。</p>\n<p>复杂性是开发人员在尝试实现特定目标时在特定时间点所经历的。它不一定与系统的整体大小或功能有关。人们通常使用“复杂”一词来描述具有复杂功能的大型系统，但是如果这样的系统易于使用，那么就本书而言，它并不复杂。当然，实际上几乎所有大型复杂的软件系统都很难使用，因此它们也符合我对复杂性的定义，但这不一定是事实。小型而不复杂的系统也可能非常复杂。</p>\n<p>复杂性取决于最常见的活动。如果系统中有一些非常复杂的部分，但是几乎不需要触摸这些部分，那么它们对系统的整体复杂性不会有太大影响。为了用粗略的数学方法来表征：</p>\n<p><img src=\"../../img/figures/00009.gif\" alt=\"\"></p>\n<p>系统的总体复杂度（C）由每个部分的复杂度（cp）乘以开发人员在该部分上花费的时间（tp）加权。在一个永远不会被看到的地方隔离复杂性几乎和完全消除复杂性一样好。</p>\n<p>读者比作家更容易理解复杂性。如果您编写了一段代码，对您来说似乎很简单，但是其他人则认为它很复杂，那么它就是复杂的。当您遇到这种情况时，有必要对其他开发人员进行调查，以找出为什么代码对他们而言似乎很复杂；从您的观点与观点之间的脱节中可能可以学习一些有趣的课程。作为开发人员，您的工作不仅是创建可以轻松使用的代码，而且还要创建其他人也可以轻松使用的代码。</p>\n<h2 id=\"2-2-Symptoms-of-complexity-复杂性的症状\"><a href=\"#2-2-Symptoms-of-complexity-复杂性的症状\" class=\"headerlink\" title=\"2.2 Symptoms of complexity 复杂性的症状\"></a>2.2 Symptoms of complexity 复杂性的症状</h2><p>复杂性通过以下三种段落中描述的三种一般方式体现出来。这些表现形式中的每一个都使执行开发任务变得更加困难。</p>\n<p>变更放大：复杂性的第一个征兆是，看似简单的变更需要在许多不同地方进行代码修改。例如，考虑一个包含几个页面的网站，每个页面显示带有背景色的横幅。在许多早期的网站中，颜色是在每个页面上明确指定的，如图 2.1（a）所示。为了更改此类网站的背景，开发人员可能必须手动修改每个现有页面；对于拥有数千个页面的大型网站而言，这几乎是不可能的。幸运的是，现代网站使用的方法类似于图 2.1（b），其中横幅颜色一次在中心位置指定，并且所有各个页面均引用该共享值。使用这种方法，可以通过一次修改来更改整个网站的标题颜色。</p>\n<p>认知负荷：复杂性的第二个症状是认知负荷，这是指开发人员需要多少知识才能完成一项任务。较高的认知负担意味着开发人员必须花更多的时间来学习所需的信息，并且由于错过了重要的东西而导致错误的风险也更大。例如，假设 C 中的一个函数分配了内存，返回了指向该内存的指针，并假定调用者将释放该内存。这增加了使用该功能的开发人员的认知负担。如果开发人员无法释放内存，则会发生内存泄漏。如果可以对系统进行重组，以使调用者不必担心释放内存（分配内存的同一模块也负责释放内存），它将减少认知负担。</p>\n<p>系统设计人员有时会假设可以通过代码行来衡量复杂性。他们认为，如果一个实现比另一个实现短，那么它必须更简单；如果只需要几行代码就可以进行更改，那么更改必须很容易。但是，这种观点忽略了与认知负荷相关的成本。我已经看到了仅允许使用几行代码编写应用程序的框架，但是要弄清楚这些行是什么极其困难。有时，需要更多代码行的方法实际上更简单，因为它减少了认知负担。</p>\n<p><img src=\"../../img/figures/00010.jpeg\" alt=\"\"></p>\n<p>图 2.1：网站中的每个页面都显示一个彩色横幅。在（a）中，横幅的背景色在每页中都明确指定。在（b）中，共享变量保留背景色，并且每个页面都引用该变量。在（c）中，某些页面会显示其他用于强调的颜色，即横幅背景颜色的暗色；如果背景颜色改变，则强调颜色也必须改变。</p>\n<p>未知的未知:复杂性的第三个症状是，必须修改哪些代码才能完成任务，或者开发人员必须获得哪些信息才能成功地执行任务，这些都是不明显的。图 2.1(c)说明了这个问题。网站使用一个中心变量来确定横幅的背景颜色，所以它看起来很容易改变。但是，一些 Web 页面使用较暗的背景色来强调，并且在各个页面中明确指定了较暗的颜色。如果背景颜色改变，那么强调的颜色必须改变以匹配。不幸的是，开发人员不太可能意识到这一点，所以他们可能会更改中央 bannerBg 变量而不更新强调颜色。即使开发人员意识到这个问题，也不清楚哪些页面使用了强调色，因此开发人员可能必须搜索 Web 站点中的每个页面。</p>\n<p>在复杂性的三种表现形式中，未知的未知是最糟糕的。一个未知的未知意味着你需要知道一些事情，但是你没有办法找到它是什么，甚至是否有一个问题。你不会发现它，直到错误出现后，你做了一个改变。更改放大是令人恼火的，但是只要清楚哪些代码需要修改，一旦更改完成，系统就会工作。同样，高的认知负荷会增加改变的成本，但如果明确要阅读哪些信息，改变仍然可能是正确的。对于未知的未知，不清楚该做什么，或者提出的解决方案是否有效。唯一确定的方法是读取系统中的每一行代码，这对于任何大小的系统都是不可能的。甚至这可能还不够，因为更改可能依赖于一个从未记录的细微设计决策。</p>\n<p>良好设计的最重要目标之一就是使系统显而易见。这与高认知负荷和未知未知数相反。在一个显而易见的系统中，开发人员可以快速了解现有代码的工作方式以及进行更改所需的内容。一个显而易见的系统是，开发人员可以在不费力地思考的情况下快速猜测要做什么，同时又可以确信该猜测是正确的。第 18 章讨论使代码更明显的技术。</p>\n<h2 id=\"2-3-Causes-of-complexity-复杂性的原因\"><a href=\"#2-3-Causes-of-complexity-复杂性的原因\" class=\"headerlink\" title=\"2.3 Causes of complexity 复杂性的原因\"></a>2.3 Causes of complexity 复杂性的原因</h2><p>既然您已经了解了复杂性的高级症状以及为什么复杂性会使软件开发变得困难，那么下一步就是了解导致复杂性的原因，以便我们设计系统来避免这些问题。复杂性是由两件事引起的：依赖性和模糊性。本节从高层次讨论这些因素。随后的章节将讨论它们与低级设计决策之间的关系。</p>\n<p>就本书而言，当无法孤立地理解和修改给定的一段代码时，便存在依赖关系。该代码以某种方式与其他代码相关，如果更改了给定代码，则必须考虑和/或修改其他代码。在图 2.1（a）的网站示例中，背景色在所有页面之间创建了依赖关系。所有页面都必须具有相同的背景，因此，如果更改一页的背景，则必须更改所有背景。依赖关系的另一个示例发生在网络协议中。通常，协议的发送方和接收方有单独的代码，但是它们必须分别符合协议。更改发送方的代码几乎总是需要在接收方进行相应的更改，反之亦然。</p>\n<p>考虑网站示例。在每个页面分别指定背景的旧网站中，所有网页都是相互依赖的。新的网站通过在中心位置指定背景色并提供一个 API，供各个页面在呈现它们时检索该颜色，从而解决了该问题。新的网站消除了页面之间的依赖关系，但是它围绕 API 创建了一个新的依赖关系以检索背景色。幸运的是，新的依赖性更加明显：很明显，每个单独的网页都取决于 bannerBg 颜色，并且开发人员可以通过搜索其名称轻松找到使用该变量的所有位置。此外，编译器还有助于管理 API 依赖性：如果共享变量的名称发生变化，任何仍使用旧名称的代码都将发生编译错误。新的网站用一种更简单，更明显的方式代替了一种不明显且难以管理的依赖性。</p>\n<p>复杂性的第二个原因是晦涩。当重要的信息不明显时，就会发生模糊。一个简单的例子是一个变量名，它是如此的通用，以至于它没有携带太多有用的信息(例如，时间)。或者，一个变量的文档可能没有指定它的单位，所以找到它的惟一方法是扫描代码，查找使用该变量的位置。晦涩常常与依赖项相关联，在这种情况下，依赖项的存在并不明显。例如，如果向系统添加了一个新的错误状态，可能需要向一个包含每个状态的字符串消息的表添加一个条目，但是对于查看状态声明的程序员来说，消息表的存在可能并不明显。不一致性也是造成不透明性的一个主要原因:如果同一个变量名用于两个不同的目的，那么开发人员就无法清楚地知道某个特定变量的目的是什么。</p>\n<p>在许多情况下，由于文档不足而导致模糊不清。第 13 章讨论了这个主题。但是，模糊性也是设计问题。如果系统设计简洁明了，则所需的文档将更少。对大量文档的需求通常是一个警告，即设计不正确。减少模糊性的最佳方法是简化系统设计。</p>\n<p>依赖性和模糊性共同构成了第 2.2 节中描述的三种复杂性表现。依赖性导致变化放大和高认知负荷。晦涩会产生未知的未知数，还会增加认知负担。如果我们找到最小化依赖关系和模糊性的设计技术，那么我们就可以降低软件的复杂性。</p>\n<h2 id=\"2-4-Complexity-is-incremental-复杂度是递增的\"><a href=\"#2-4-Complexity-is-incremental-复杂度是递增的\" class=\"headerlink\" title=\"2.4 Complexity is incremental 复杂度是递增的\"></a>2.4 Complexity is incremental 复杂度是递增的</h2><p>复杂性不是由单个灾难性错误引起的；它堆积成许多小块。单个依赖项或模糊性本身不太可能显着影响软件系统的可维护性。之所以会出现复杂性，是因为随着时间的流逝，成千上万的小依赖性和模糊性逐渐形成。最终，这些小问题太多了，以至于对系统的每次可能更改都会受到其中几个问题的影响。</p>\n<p>复杂性的增量性质使其难以控制。可以很容易地说服自己，当前更改所带来的一点点复杂性没什么大不了的。但是，如果每个开发人员对每种更改都采用这种方法，那么复杂性就会迅速累积。一旦积累了复杂性，就很难消除它，因为修复单个依赖项或模糊性本身不会产生很大的变化。为了减缓复杂性的增长，您必须采用第 3 章中讨论的“零容忍”理念。</p>\n<h2 id=\"2-5-Conclusion-结论\"><a href=\"#2-5-Conclusion-结论\" class=\"headerlink\" title=\"2.5 Conclusion 结论\"></a>2.5 Conclusion 结论</h2><p>复杂性来自于依赖性和模糊性的积累。随着复杂性的增加，它会导致变化放大，高认知负荷和未知的未知数。结果，需要更多的代码修改才能实现每个新功能。此外，开发人员花费更多时间获取足够的信息以安全地进行更改，在最坏的情况下，他们甚至找不到所需的所有信息。最重要的是，复杂性使得修改现有代码库变得困难且冒险。</p>"},{"title":"软件设计的哲学 - ch3","date":"2021-02-02T16:00:00.000Z","_content":"工作代码是不够的\n<!-- more -->\n# 第 3 章 工作代码是不够的\n\n好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。本章讨论了从长远来看，为什么战略方法可以产生更好的设计，而实际上却比战术方法便宜。\n\n## 3.1 Tactical programming 战术编程\n\n大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。\n\n战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。\n\n不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。\n\n如果您从事大型软件项目的时间很长，我怀疑您在工作中已经看到了战术编程，并且遇到了导致的问题。一旦您沿着战术路线走，就很难改变。\n\n几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。\n\n## 3.2 Strategic programming 战略规划\n\n成为一名优秀的软件设计师的第一步是要意识到仅工作代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。\n\n战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度，如图 3.1 所示。\n\n一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。\n\n其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。\n\n## 3.3 How much to invest? 投资多少？\n\n那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。图 3.1 说明了这种现象。\n\n![](../../img/figures/00011.jpeg)\n\n图 3.1：一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。\n\n相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时保存的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。\n\n## 3.4 Startups and investment 创业与投资\n\n在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。\n\n如果您是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。\n\n要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库很残酷，那么单词会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。\n\nFacebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。\n\n为了公平起见，我应该指出，Facebook 的代码可能并不比初创公司的平均水平差很多。战术编程在初创企业中司空见惯。Facebook 恰好是一个特别明显的例子。\n\n幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。\n\n这些例子表明，一家公司可以成功使用任何一种方法。但是，在一家关心软件设计并拥有清晰代码基础的公司中工作会有趣得多。\n\n## 3.5 Conclusion 结论\n\n好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。\n\n始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。\n","source":"_posts/软件设计的哲学-ch3.md","raw":"---\ntitle: 软件设计的哲学 - ch3\ndate: 2021-02-3\ntags: 软件设计的哲学 软件开发 方法论\n---\n工作代码是不够的\n<!-- more -->\n# 第 3 章 工作代码是不够的\n\n好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。本章讨论了从长远来看，为什么战略方法可以产生更好的设计，而实际上却比战术方法便宜。\n\n## 3.1 Tactical programming 战术编程\n\n大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。\n\n战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。\n\n不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。\n\n如果您从事大型软件项目的时间很长，我怀疑您在工作中已经看到了战术编程，并且遇到了导致的问题。一旦您沿着战术路线走，就很难改变。\n\n几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。\n\n## 3.2 Strategic programming 战略规划\n\n成为一名优秀的软件设计师的第一步是要意识到仅工作代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。\n\n战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度，如图 3.1 所示。\n\n一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。\n\n其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。\n\n## 3.3 How much to invest? 投资多少？\n\n那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。图 3.1 说明了这种现象。\n\n![](../../img/figures/00011.jpeg)\n\n图 3.1：一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。\n\n相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时保存的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。\n\n## 3.4 Startups and investment 创业与投资\n\n在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。\n\n如果您是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。\n\n要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库很残酷，那么单词会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。\n\nFacebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。\n\n为了公平起见，我应该指出，Facebook 的代码可能并不比初创公司的平均水平差很多。战术编程在初创企业中司空见惯。Facebook 恰好是一个特别明显的例子。\n\n幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。\n\n这些例子表明，一家公司可以成功使用任何一种方法。但是，在一家关心软件设计并拥有清晰代码基础的公司中工作会有趣得多。\n\n## 3.5 Conclusion 结论\n\n好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。\n\n始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。\n","slug":"软件设计的哲学-ch3","published":1,"updated":"2021-02-16T04:49:33.816Z","_id":"ckl6pcc1h0006s4iy1a6t4xxg","comments":1,"layout":"post","photos":[],"link":"","content":"<p>工作代码是不够的</p>\n<a id=\"more\"></a>\n<h1 id=\"第-3-章-工作代码是不够的\"><a href=\"#第-3-章-工作代码是不够的\" class=\"headerlink\" title=\"第 3 章 工作代码是不够的\"></a>第 3 章 工作代码是不够的</h1><p>好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。本章讨论了从长远来看，为什么战略方法可以产生更好的设计，而实际上却比战术方法便宜。</p>\n<h2 id=\"3-1-Tactical-programming-战术编程\"><a href=\"#3-1-Tactical-programming-战术编程\" class=\"headerlink\" title=\"3.1 Tactical programming 战术编程\"></a>3.1 Tactical programming 战术编程</h2><p>大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。</p>\n<p>战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。</p>\n<p>不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。</p>\n<p>如果您从事大型软件项目的时间很长，我怀疑您在工作中已经看到了战术编程，并且遇到了导致的问题。一旦您沿着战术路线走，就很难改变。</p>\n<p>几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。</p>\n<h2 id=\"3-2-Strategic-programming-战略规划\"><a href=\"#3-2-Strategic-programming-战略规划\" class=\"headerlink\" title=\"3.2 Strategic programming 战略规划\"></a>3.2 Strategic programming 战略规划</h2><p>成为一名优秀的软件设计师的第一步是要意识到仅工作代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。</p>\n<p>战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度，如图 3.1 所示。</p>\n<p>一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。</p>\n<p>其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。</p>\n<h2 id=\"3-3-How-much-to-invest-投资多少？\"><a href=\"#3-3-How-much-to-invest-投资多少？\" class=\"headerlink\" title=\"3.3 How much to invest? 投资多少？\"></a>3.3 How much to invest? 投资多少？</h2><p>那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。图 3.1 说明了这种现象。</p>\n<p><img src=\"../../img/figures/00011.jpeg\" alt=\"\"></p>\n<p>图 3.1：一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。</p>\n<p>相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时保存的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。</p>\n<h2 id=\"3-4-Startups-and-investment-创业与投资\"><a href=\"#3-4-Startups-and-investment-创业与投资\" class=\"headerlink\" title=\"3.4 Startups and investment 创业与投资\"></a>3.4 Startups and investment 创业与投资</h2><p>在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。</p>\n<p>如果您是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。</p>\n<p>要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库很残酷，那么单词会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。</p>\n<p>Facebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。</p>\n<p>为了公平起见，我应该指出，Facebook 的代码可能并不比初创公司的平均水平差很多。战术编程在初创企业中司空见惯。Facebook 恰好是一个特别明显的例子。</p>\n<p>幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。</p>\n<p>这些例子表明，一家公司可以成功使用任何一种方法。但是，在一家关心软件设计并拥有清晰代码基础的公司中工作会有趣得多。</p>\n<h2 id=\"3-5-Conclusion-结论\"><a href=\"#3-5-Conclusion-结论\" class=\"headerlink\" title=\"3.5 Conclusion 结论\"></a>3.5 Conclusion 结论</h2><p>好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。</p>\n<p>始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。</p>\n","site":{"data":{}},"excerpt":"<p>工作代码是不够的</p>","more":"<h1 id=\"第-3-章-工作代码是不够的\"><a href=\"#第-3-章-工作代码是不够的\" class=\"headerlink\" title=\"第 3 章 工作代码是不够的\"></a>第 3 章 工作代码是不够的</h1><p>好的软件设计中最重要的元素之一是您在执行编程任务时所采用的思维方式。许多组织都鼓励采取战术思维方式，着眼于使功能尽快运行。但是，如果您想要一个好的设计，则必须采取更具战略性的方法，在此上花费时间来制作干净的设计并解决问题。本章讨论了从长远来看，为什么战略方法可以产生更好的设计，而实际上却比战术方法便宜。</p>\n<h2 id=\"3-1-Tactical-programming-战术编程\"><a href=\"#3-1-Tactical-programming-战术编程\" class=\"headerlink\" title=\"3.1 Tactical programming 战术编程\"></a>3.1 Tactical programming 战术编程</h2><p>大多数程序员以我称为战术编程的心态来进行软件开发。在战术方法中，您的主要重点是使某些功能正常工作，例如新功能或错误修复。乍一看，这似乎是完全合理的：还有什么比编写有效的代码更重要的呢？但是，战术编程几乎不可能产生出良好的系统设计。</p>\n<p>战术编程的问题是它是短视的。如果您是战术编程人员，那么您将尝试尽快完成任务。也许您有一个艰难的期限。因此，为未来做计划不是优先事项。您不会花费太多时间来寻找最佳设计。您只想尽快使某件事起作用。您告诉自己，可以增加一些复杂性或引入一两个小错误，如果这样可以使当前任务更快地完成，则可以。</p>\n<p>不久之后，某些复杂性将开始引起问题，并且您将开始希望您没有采用这些早期的捷径。但是，您会告诉自己，使下一个功能正常工作比返回并重构现有代码更为重要。从长远来看，重构可能会有所帮助，但是肯定会减慢当前的任务。因此，您需要快速修补程序来解决遇到的任何问题。这只会增加复杂性，然后需要更多补丁。很快代码变得一团糟，但是到现在为止，情况已经很糟糕了，清理它需要花费数月的时间。您的日程安排无法容忍这种延迟，解决一个或两个问题似乎并没有太大的区别，因此您只是在战术上保持编程。</p>\n<p>如果您从事大型软件项目的时间很长，我怀疑您在工作中已经看到了战术编程，并且遇到了导致的问题。一旦您沿着战术路线走，就很难改变。</p>\n<p>几乎每个软件开发组织都有至少一个将战术编程发挥到极致的开发人员：战术龙卷风。战术龙卷风是一位多产的程序员，他抽出代码的速度比其他人快得多，但完全以战术方式工作。实施快速功能时，没有人能比战术龙卷风更快地完成任务。在某些组织中，管理层将战术龙卷风视为英雄。但是，战术龙卷风留下了毁灭的痕迹。他们很少被将来必须使用其代码的工程师视为英雄。通常，其他工程师必须清理战术龙卷风留下的混乱局面，这使得那些工程师（他们是真正的英雄）的进步似乎比战术龙卷风慢。</p>\n<h2 id=\"3-2-Strategic-programming-战略规划\"><a href=\"#3-2-Strategic-programming-战略规划\" class=\"headerlink\" title=\"3.2 Strategic programming 战略规划\"></a>3.2 Strategic programming 战略规划</h2><p>成为一名优秀的软件设计师的第一步是要意识到仅工作代码是不够的。引入不必要的复杂性以更快地完成当前任务是不可接受的。最重要的是系统的长期结构。任何系统中的大多数代码都是通过扩展现有代码库编写的，因此，作为开发人员，最重要的工作就是促进这些将来的扩展。因此，尽管您的代码当然必须工作，但您不应将“工作代码”视为主要目标。您的主要目标必须是制作出出色的设计，并且这种设计也会起作用。这是战略计划。</p>\n<p>战略性编程需要一种投资心态。您必须花费时间来改进系统的设计，而不是采取最快的方式来完成当前的项目。这些投资会在短期内让您放慢脚步，但从长远来看会加快您的速度，如图 3.1 所示。</p>\n<p>一些投资将是积极的。例如，值得花一些时间为每个新类找到一个简单的设计。而不是实施想到的第一个想法，请尝试几种替代设计并选择最简洁的设计。试想一下将来可能需要更改系统的几种方式，并确保设计容易。编写好的文档是主动投资的另一个例子。</p>\n<p>其他投资将是被动的。无论您预先投入多少，设计决策中都不可避免地会出现错误。随着时间的流逝，这些错误将变得显而易见。发现设计问题时，不要只是忽略它或对其进行修补。花一些额外的时间来修复它。如果您进行战略性编程，则将不断对系统设计进行小幅改进。这与战术编程相反，在战术编程中，您不断增加一些复杂性，这些复杂性将来会引起问题。</p>\n<h2 id=\"3-3-How-much-to-invest-投资多少？\"><a href=\"#3-3-How-much-to-invest-投资多少？\" class=\"headerlink\" title=\"3.3 How much to invest? 投资多少？\"></a>3.3 How much to invest? 投资多少？</h2><p>那么，正确的投资额是多少？大量的前期投资（例如尝试设计整个系统）将不会有效。这是瀑布方法，我们知道它不起作用。随着您对系统的了解，理想的设计趋于零碎出现。因此，最好的方法是连续进行大量小额投资 ​​。我建议您将总开发时间的 10％到 20％用于投资。该金额足够小，不会对您的日程安排产生重大影响，但又足够大，可以随着时间的推移产生重大收益。因此，您的初始项目将比纯战术方法花费 10-20％的时间。额外的时间将带来更好的软件设计，并且您将在几个月内开始体验到这些好处。不久之后，您的开发速度将比战术编程快至少 10–20％。在这一点上，您的投资将免费：您过去投资的收益将节省足够的时间来支付未来投资的费用。您将迅速收回初始投资的成本。图 3.1 说明了这种现象。</p>\n<p><img src=\"../../img/figures/00011.jpeg\" alt=\"\"></p>\n<p>图 3.1：一开始，战术性的编程方法将比战略性方法更快地取得进展。但是，在战术方法下，复杂性积累得更快，从而降低了生产率。随着时间的流逝，战略方针会带来更大的进步。注意：此图仅用于定性说明；我不知道对曲线精确形状的任何经验测量。</p>\n<p>相反，如果您进行战术编程，则可以将第一个项目完成的速度提高 10％到 20％，但是随着时间的推移，复杂性的累积会降低开发速度。不久之后，您的编程速度至少会降低 10–20％。您将很快退回在开始时保存的所有时间，并且在系统的整个生命周期中，与采用策略性方法相比，您的开发速度将更加缓慢。如果您从未使用过严重降级的代码库，请与有经验的人联系。他们会告诉您不良的代码质量会使开发速度至少降低 20％。</p>\n<h2 id=\"3-4-Startups-and-investment-创业与投资\"><a href=\"#3-4-Startups-and-investment-创业与投资\" class=\"headerlink\" title=\"3.4 Startups and investment 创业与投资\"></a>3.4 Startups and investment 创业与投资</h2><p>在某些环境中，强大的力量与战略方法背道而驰。例如，早期的初创公司感到巨大的压力，需要尽快发布其早期版本。在这些公司中，甚至 10％至 20％的投资似乎也负担不起。结果，许多初创公司采取了战术性的方法，在设计上花费了很少的精力，而在问题出现时则花费了更少的精力进行清理。他们认为，如果成功，他们将有足够的钱聘请额外的工程师来清理问题，从而使其合理化。</p>\n<p>如果您是一家朝着这个方向发展的公司，则应该意识到，一旦代码库变成了意大利面条，几乎是不可能修复的。您可能会为产品的使用寿命付出高昂的开发成本。此外，好的（或坏的）设计的回报很快就会到来，因此战术方法很有可能甚至不会加快您的首个产品发布的速度。</p>\n<p>要考虑的另一件事是，公司成功的最重要因素之一就是工程师的素质。降低开发成本的最佳方法是聘请优秀的工程师：他们的成本不会比普通工程师高很多，但生产率却高得多。但是，最好的工程师对良好的设计深感兴趣。如果您的代码库很残酷，那么单词会变得毫无用处，这将使您难以招募。结果，您最终可能会遇到普通的工程师。这将增加您的未来成本，并可能导致系统结构进一步退化。</p>\n<p>Facebook 作为一家公司已经取得了令人瞩目的成功，但是由于该公司的战术方法，其代码库受到了影响。许多代码不稳定且难以理解，几乎没有注释或测试，并且使用起来很痛苦。随着时间的流逝，该公司意识到其文化是不可持续的。最终，Facebook 改变了座右铭，即“以坚实的基础架构快速移动”，以鼓励其工程师在良好的设计上进行更多的投资。Facebook 是否能够成功清除多年来战术编程中积累的问题还有待观察。</p>\n<p>为了公平起见，我应该指出，Facebook 的代码可能并不比初创公司的平均水平差很多。战术编程在初创企业中司空见惯。Facebook 恰好是一个特别明显的例子。</p>\n<p>幸运的是，通过战略方法也有可能在硅谷取得成功。Google 和 VMware 与 Facebook 差不多同时成长，但是这两家公司都采用了更具战略意义的方法。两家公司都非常重视高质量的代码和良好的设计，并且两家公司都开发了复杂的产品，这些产品通过可靠的软件系统解决了复杂的问题。公司的强大技术文化在硅谷广为人知。很少有其他公司可以与他们竞争聘请顶级技术人才。</p>\n<p>这些例子表明，一家公司可以成功使用任何一种方法。但是，在一家关心软件设计并拥有清晰代码基础的公司中工作会有趣得多。</p>\n<h2 id=\"3-5-Conclusion-结论\"><a href=\"#3-5-Conclusion-结论\" class=\"headerlink\" title=\"3.5 Conclusion 结论\"></a>3.5 Conclusion 结论</h2><p>好的设计不是免费的。它必须是您不断投资的东西，这样小问题才不会累积成大问题。幸运的是，好的设计最终会收回成本，而且比您想象的要早。</p>\n<p>始终如一地运用战略方法并将投资视为今天而不是明天要做的事情至关重要。当您陷入危机时，很容易推迟清理，直到危机结束之后。但是，这是一个湿滑的斜坡。在当前紧缩之后，几乎肯定会再出现一次。一旦开始延迟设计改进，就很容易使延迟永久化，并使您的文化陷入战术方法中。您等待解决设计问题的时间越长，问题就会变得越大；解决方案变得更加令人生畏，这使得轻松推迟解决方案变得更加容易。最有效的方法是，每位工程师都对良好的设计进行连续的少量投资。</p>"},{"title":"软件设计的哲学 - ch8","date":"2021-02-07T16:00:00.000Z","_content":"降低复杂性\n<!-- more -->\n# 第 8 章 降低复杂性\n\n> Chapter 8 Pull Complexity Downwards\n\nThis chapter introduces another way of thinking about how to create deeper classes. Suppose that you are developing a new module, and you discover a piece of unavoidable complexity. Which is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have more users than developers, so it is better for the developers to suffer than the users. As a module developer, you should strive to make life as easy as possible for the users of your module, even if that means extra work for you. Another way of expressing this idea is that it is more important for a module to have a simple interface than a simple implementation.\n\n> 本章介绍了有关如何创建更深层类的另一种思考方式。假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。哪个更好：应该让模块用户处理复杂性，还是应该在模块内部处理复杂性？如果复杂度与模块提供的功能有关，则第二个答案通常是正确的答案。大多数模块拥有的用户多于开发人员，因此开发人员遭受的苦难要大于用户。作为模块开发人员，您应该努力使模块用户的生活尽可能轻松，即使这对您来说意味着额外的工作。表达此想法的另一种方法是，模块具有简单的接口比简单的实现更为重要。\n\nAs a developer, it’s tempting to behave in the opposite fashion: solve the easy problems and punt the hard ones to someone else. If a condition arises that you’re not certain how to deal with, the easiest thing is to throw an exception and let the caller handle it. If you are not certain what policy to implement, you can define a few configuration parameters to control the policy and leave it up to the system administrator to figure out the best values for them.\n\n> 作为开发人员，很容易以相反的方式行事：解决简单的问题，然后将困难的问题推给其他人。如果出现不确定如何处理的条件，最简单的方法是引发异常并让调用方处理它。如果不确定要实施什么策略，则可以定义一些配置参数来控制该策略，然后由系统管理员自行确定最佳策略。\n\nApproaches like these will make your life easier in the short term, but they amplify complexity, so that many people must deal with a problem, rather than just one person. For example, if a class throws an exception, every caller of the class will have to deal with it. If a class exports configuration parameters, every system administrator in every installation will have to learn how to set them.\n\n> 这样的方法短期内会使您的生活更轻松，但它们会加剧复杂性，因此许多人必须处理一个问题，而不仅仅是一个人。例如，如果一个类抛出异常，则该类的每个调用者都必须处理该异常。如果一个类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。\n\n## 8.1 Example: editor text class 示例：编辑器文本类\n\nConsider the class that manages the text of a file for a GUI text editor, which was discussed in Chapters 6 and 7. The class provides methods to read a file from disk into memory, query and modify the in-memory copy of the file, and write the modified version back to disk. When students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text. This resulted in a simple implementation for the class, but it created complexity for higher level software. At the level of the user interface, operations rarely involve whole lines. For example, keystrokes cause individual characters to be inserted within an existing line; copying or deleting the selection can modify parts of several different lines. With the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.\n\n> 考虑为 GUI 文本编辑器管理文件文本的类，这在第 6 章和第 7 章中讨论过。该类提供了将文件从磁盘读入内存、查询和修改文件在内存中的副本以及将修改后的版本写回磁盘的方法。当学生必须实现这个类时，他们中的许多人选择了一个面向行的接口，该接口具有读取、插入和删除整行文本的方法。这导致了类的简单实现，但也为更高级别的软件带来了复杂性。在用户界面级别，操作很少涉及整行。例如，击键会导致在现有行中插入单个字符;复制或删除选择项可以修改几个不同行的部分。使用面向行的文本界面，为了实现用户界面，高级软件必须分割和连接行。\n\nA character-oriented interface such as the one described in Section 6.3 pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler. The implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations. This approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.\n\n> 面向字符的界面（如 6.3 节中所述）降低了复杂性。用户界面软件现在可以插入和删除任意范围的文本，而无需分割和合并行，因此变得更加简单。文本类的实现可能会变得更加复杂：如果内部将文本表示为行的集合，则必须拆分和合并行以实现面向字符的操作。这种方法更好，因为它封装了在文本类中拆分和合并的复杂性，从而降低了系统的整体复杂性。\n\n## 8.2 Example: configuration parameters 示例：配置参数\n\nConfiguration parameters are an example of moving complexity upwards instead of down. Rather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up. Users of the class must then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them.\n\n> 配置参数是提高复杂度而不是降低复杂度的一个示例。类可以在内部输出一些控制其行为的参数，而不是在内部确定特定的行为，例如高速缓存的大小或在放弃之前重试请求的次数。然后，该类的用户必须为参数指定适当的值。在当今的系统中，配置参数已变得非常流行。有些系统有数百个。\n\nAdvocates argue that configuration parameters are good because they allow users to tune the system for their particular requirements and workloads. In some situations it is hard for low-level infrastructure code to know the best policy to apply, whereas users are much more familiar with their domains. For instance, a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance across a broader variety of domains.\n\n> 拥护者认为配置参数不错，因为它们允许用户根据他们的特定要求和工作负载来调整系统。在某些情况下，低级基础结构代码很难知道要应用的最佳策略，而用户则对其域更加熟悉。例如，用户可能知道某些请求比其他请求更紧迫，因此用户为这些请求指定更高的优先级是有意义的。在这种情况下，配置参数可以在更广泛的域中带来更好的性能。\n\nHowever, configuration parameters also provide an easy excuse to avoid dealing with important issues and pass them on to someone else. In many cases, it’s difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determined automatically with a little extra work in the system implementation. Consider a network protocol that must deal with lost packets. If it sends a request but doesn’t receive a response within a certain time period, it resends the request. One way to determine the retry interval is to introduce a configuration parameter. However, the transport protocol could compute a reasonable value on its own by measuring the response time for requests that succeed and then using a multiple of this for the retry interval. This approach pulls complexity downward and saves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameters can easily become out of date.\n\n> 但是，配置参数还提供了一个轻松的借口，可以避免处理重要问题并将其传递给其他人。在许多情况下，用户或管理员很难或无法确定参数的正确值。在其他情况下，可以通过在系统实现中进行一些额外的工作来自动确定正确的值。考虑必须处理丢失数据包的网络协议。如果它发送请求但在一定时间内未收到响应，则重新发送该请求。确定重试间隔的一种方法是引入配置参数。但是，传输协议可以通过测量成功请求的响应时间，然后将其倍数用于重试间隔，自己计算出一个合理的值。这种方法降低了复杂性，使用户不必找出正确的重试间隔。它具有动态计算重试间隔的其他优点，因此，如果操作条件发生变化，它将自动进行调整。相反，配置参数很容易过时。\n\nThus, you should avoid configuration parameters as much as possible. Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions. Ideally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.\n\n> 因此，您应尽可能避免使用配置参数。在导出配置参数之前，请问自己：“用户（或更高级别的模块）是否能够确定比我们在此确定的更好的值？” 当您创建配置参数时，请查看是否可以自动计算合理的默认值，因此用户仅需在特殊情况下提供值即可。理想情况下，每个模块都应完全解决问题。配置参数导致解决方案不完整，从而增加了系统复杂性。\n\n## 8.3 Taking it too far 走得太远\n\nUse discretion when pulling complexity downward; this is an idea that can easily be overdone. An extreme approach would be to pull all of the functionality of the entire application down into a single class, which clearly doesn’t make sense. Pulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface. Remember that the goal is to minimize overall system complexity.\n\n> 降低复杂性时要谨慎处理；这个想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能归为一个类，这显然没有意义。如果（a）被降低的复杂度与该类的现有功能密切相关，（b）降低复杂度将导致应用程序中其他地方的许多简化，则降低复杂度最有意义。简化了类的界面。请记住，目标是最大程度地降低整体系统复杂性。\n\nChapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key. It might seem that this is good, since it pulls complexity downward. However, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class. In this case, pulling complexity down just resulted in information leakage.\n\n> 第 6 章介绍了一些学生如何在文本类中定义反映用户界面的方法，例如实现退格键功能的方法。这似乎很好，因为它可以降低复杂性。但是，将用户界面的知识添加到文本类中并不会大大简化高层代码，并且用户界面的知识与文本类的核心功能无关。在这种情况下，降低复杂度只会导致信息泄漏。\n\n## 8.4 Conclusion 结论\n\nWhen developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.\n\n> 在开发模块时，请寻找机会减轻自己的痛苦，以减轻用户的痛苦。\n","source":"_posts/软件设计的哲学-ch8.md","raw":"---\ntitle: 软件设计的哲学 - ch8\ndate: 2021-02-8\ntags: 软件设计的哲学 软件开发 方法论\n---\n降低复杂性\n<!-- more -->\n# 第 8 章 降低复杂性\n\n> Chapter 8 Pull Complexity Downwards\n\nThis chapter introduces another way of thinking about how to create deeper classes. Suppose that you are developing a new module, and you discover a piece of unavoidable complexity. Which is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have more users than developers, so it is better for the developers to suffer than the users. As a module developer, you should strive to make life as easy as possible for the users of your module, even if that means extra work for you. Another way of expressing this idea is that it is more important for a module to have a simple interface than a simple implementation.\n\n> 本章介绍了有关如何创建更深层类的另一种思考方式。假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。哪个更好：应该让模块用户处理复杂性，还是应该在模块内部处理复杂性？如果复杂度与模块提供的功能有关，则第二个答案通常是正确的答案。大多数模块拥有的用户多于开发人员，因此开发人员遭受的苦难要大于用户。作为模块开发人员，您应该努力使模块用户的生活尽可能轻松，即使这对您来说意味着额外的工作。表达此想法的另一种方法是，模块具有简单的接口比简单的实现更为重要。\n\nAs a developer, it’s tempting to behave in the opposite fashion: solve the easy problems and punt the hard ones to someone else. If a condition arises that you’re not certain how to deal with, the easiest thing is to throw an exception and let the caller handle it. If you are not certain what policy to implement, you can define a few configuration parameters to control the policy and leave it up to the system administrator to figure out the best values for them.\n\n> 作为开发人员，很容易以相反的方式行事：解决简单的问题，然后将困难的问题推给其他人。如果出现不确定如何处理的条件，最简单的方法是引发异常并让调用方处理它。如果不确定要实施什么策略，则可以定义一些配置参数来控制该策略，然后由系统管理员自行确定最佳策略。\n\nApproaches like these will make your life easier in the short term, but they amplify complexity, so that many people must deal with a problem, rather than just one person. For example, if a class throws an exception, every caller of the class will have to deal with it. If a class exports configuration parameters, every system administrator in every installation will have to learn how to set them.\n\n> 这样的方法短期内会使您的生活更轻松，但它们会加剧复杂性，因此许多人必须处理一个问题，而不仅仅是一个人。例如，如果一个类抛出异常，则该类的每个调用者都必须处理该异常。如果一个类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。\n\n## 8.1 Example: editor text class 示例：编辑器文本类\n\nConsider the class that manages the text of a file for a GUI text editor, which was discussed in Chapters 6 and 7. The class provides methods to read a file from disk into memory, query and modify the in-memory copy of the file, and write the modified version back to disk. When students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text. This resulted in a simple implementation for the class, but it created complexity for higher level software. At the level of the user interface, operations rarely involve whole lines. For example, keystrokes cause individual characters to be inserted within an existing line; copying or deleting the selection can modify parts of several different lines. With the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.\n\n> 考虑为 GUI 文本编辑器管理文件文本的类，这在第 6 章和第 7 章中讨论过。该类提供了将文件从磁盘读入内存、查询和修改文件在内存中的副本以及将修改后的版本写回磁盘的方法。当学生必须实现这个类时，他们中的许多人选择了一个面向行的接口，该接口具有读取、插入和删除整行文本的方法。这导致了类的简单实现，但也为更高级别的软件带来了复杂性。在用户界面级别，操作很少涉及整行。例如，击键会导致在现有行中插入单个字符;复制或删除选择项可以修改几个不同行的部分。使用面向行的文本界面，为了实现用户界面，高级软件必须分割和连接行。\n\nA character-oriented interface such as the one described in Section 6.3 pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler. The implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations. This approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.\n\n> 面向字符的界面（如 6.3 节中所述）降低了复杂性。用户界面软件现在可以插入和删除任意范围的文本，而无需分割和合并行，因此变得更加简单。文本类的实现可能会变得更加复杂：如果内部将文本表示为行的集合，则必须拆分和合并行以实现面向字符的操作。这种方法更好，因为它封装了在文本类中拆分和合并的复杂性，从而降低了系统的整体复杂性。\n\n## 8.2 Example: configuration parameters 示例：配置参数\n\nConfiguration parameters are an example of moving complexity upwards instead of down. Rather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up. Users of the class must then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them.\n\n> 配置参数是提高复杂度而不是降低复杂度的一个示例。类可以在内部输出一些控制其行为的参数，而不是在内部确定特定的行为，例如高速缓存的大小或在放弃之前重试请求的次数。然后，该类的用户必须为参数指定适当的值。在当今的系统中，配置参数已变得非常流行。有些系统有数百个。\n\nAdvocates argue that configuration parameters are good because they allow users to tune the system for their particular requirements and workloads. In some situations it is hard for low-level infrastructure code to know the best policy to apply, whereas users are much more familiar with their domains. For instance, a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance across a broader variety of domains.\n\n> 拥护者认为配置参数不错，因为它们允许用户根据他们的特定要求和工作负载来调整系统。在某些情况下，低级基础结构代码很难知道要应用的最佳策略，而用户则对其域更加熟悉。例如，用户可能知道某些请求比其他请求更紧迫，因此用户为这些请求指定更高的优先级是有意义的。在这种情况下，配置参数可以在更广泛的域中带来更好的性能。\n\nHowever, configuration parameters also provide an easy excuse to avoid dealing with important issues and pass them on to someone else. In many cases, it’s difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determined automatically with a little extra work in the system implementation. Consider a network protocol that must deal with lost packets. If it sends a request but doesn’t receive a response within a certain time period, it resends the request. One way to determine the retry interval is to introduce a configuration parameter. However, the transport protocol could compute a reasonable value on its own by measuring the response time for requests that succeed and then using a multiple of this for the retry interval. This approach pulls complexity downward and saves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameters can easily become out of date.\n\n> 但是，配置参数还提供了一个轻松的借口，可以避免处理重要问题并将其传递给其他人。在许多情况下，用户或管理员很难或无法确定参数的正确值。在其他情况下，可以通过在系统实现中进行一些额外的工作来自动确定正确的值。考虑必须处理丢失数据包的网络协议。如果它发送请求但在一定时间内未收到响应，则重新发送该请求。确定重试间隔的一种方法是引入配置参数。但是，传输协议可以通过测量成功请求的响应时间，然后将其倍数用于重试间隔，自己计算出一个合理的值。这种方法降低了复杂性，使用户不必找出正确的重试间隔。它具有动态计算重试间隔的其他优点，因此，如果操作条件发生变化，它将自动进行调整。相反，配置参数很容易过时。\n\nThus, you should avoid configuration parameters as much as possible. Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions. Ideally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.\n\n> 因此，您应尽可能避免使用配置参数。在导出配置参数之前，请问自己：“用户（或更高级别的模块）是否能够确定比我们在此确定的更好的值？” 当您创建配置参数时，请查看是否可以自动计算合理的默认值，因此用户仅需在特殊情况下提供值即可。理想情况下，每个模块都应完全解决问题。配置参数导致解决方案不完整，从而增加了系统复杂性。\n\n## 8.3 Taking it too far 走得太远\n\nUse discretion when pulling complexity downward; this is an idea that can easily be overdone. An extreme approach would be to pull all of the functionality of the entire application down into a single class, which clearly doesn’t make sense. Pulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface. Remember that the goal is to minimize overall system complexity.\n\n> 降低复杂性时要谨慎处理；这个想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能归为一个类，这显然没有意义。如果（a）被降低的复杂度与该类的现有功能密切相关，（b）降低复杂度将导致应用程序中其他地方的许多简化，则降低复杂度最有意义。简化了类的界面。请记住，目标是最大程度地降低整体系统复杂性。\n\nChapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key. It might seem that this is good, since it pulls complexity downward. However, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class. In this case, pulling complexity down just resulted in information leakage.\n\n> 第 6 章介绍了一些学生如何在文本类中定义反映用户界面的方法，例如实现退格键功能的方法。这似乎很好，因为它可以降低复杂性。但是，将用户界面的知识添加到文本类中并不会大大简化高层代码，并且用户界面的知识与文本类的核心功能无关。在这种情况下，降低复杂度只会导致信息泄漏。\n\n## 8.4 Conclusion 结论\n\nWhen developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.\n\n> 在开发模块时，请寻找机会减轻自己的痛苦，以减轻用户的痛苦。\n","slug":"软件设计的哲学-ch8","published":1,"updated":"2021-02-16T04:51:58.634Z","_id":"ckl6pcc1j0007s4iycvgue5zo","comments":1,"layout":"post","photos":[],"link":"","content":"<p>降低复杂性</p>\n<a id=\"more\"></a>\n<h1 id=\"第-8-章-降低复杂性\"><a href=\"#第-8-章-降低复杂性\" class=\"headerlink\" title=\"第 8 章 降低复杂性\"></a>第 8 章 降低复杂性</h1><blockquote>\n<p>Chapter 8 Pull Complexity Downwards</p>\n</blockquote>\n<p>This chapter introduces another way of thinking about how to create deeper classes. Suppose that you are developing a new module, and you discover a piece of unavoidable complexity. Which is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have more users than developers, so it is better for the developers to suffer than the users. As a module developer, you should strive to make life as easy as possible for the users of your module, even if that means extra work for you. Another way of expressing this idea is that it is more important for a module to have a simple interface than a simple implementation.</p>\n<blockquote>\n<p>本章介绍了有关如何创建更深层类的另一种思考方式。假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。哪个更好：应该让模块用户处理复杂性，还是应该在模块内部处理复杂性？如果复杂度与模块提供的功能有关，则第二个答案通常是正确的答案。大多数模块拥有的用户多于开发人员，因此开发人员遭受的苦难要大于用户。作为模块开发人员，您应该努力使模块用户的生活尽可能轻松，即使这对您来说意味着额外的工作。表达此想法的另一种方法是，模块具有简单的接口比简单的实现更为重要。</p>\n</blockquote>\n<p>As a developer, it’s tempting to behave in the opposite fashion: solve the easy problems and punt the hard ones to someone else. If a condition arises that you’re not certain how to deal with, the easiest thing is to throw an exception and let the caller handle it. If you are not certain what policy to implement, you can define a few configuration parameters to control the policy and leave it up to the system administrator to figure out the best values for them.</p>\n<blockquote>\n<p>作为开发人员，很容易以相反的方式行事：解决简单的问题，然后将困难的问题推给其他人。如果出现不确定如何处理的条件，最简单的方法是引发异常并让调用方处理它。如果不确定要实施什么策略，则可以定义一些配置参数来控制该策略，然后由系统管理员自行确定最佳策略。</p>\n</blockquote>\n<p>Approaches like these will make your life easier in the short term, but they amplify complexity, so that many people must deal with a problem, rather than just one person. For example, if a class throws an exception, every caller of the class will have to deal with it. If a class exports configuration parameters, every system administrator in every installation will have to learn how to set them.</p>\n<blockquote>\n<p>这样的方法短期内会使您的生活更轻松，但它们会加剧复杂性，因此许多人必须处理一个问题，而不仅仅是一个人。例如，如果一个类抛出异常，则该类的每个调用者都必须处理该异常。如果一个类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。</p>\n</blockquote>\n<h2 id=\"8-1-Example-editor-text-class-示例：编辑器文本类\"><a href=\"#8-1-Example-editor-text-class-示例：编辑器文本类\" class=\"headerlink\" title=\"8.1 Example: editor text class 示例：编辑器文本类\"></a>8.1 Example: editor text class 示例：编辑器文本类</h2><p>Consider the class that manages the text of a file for a GUI text editor, which was discussed in Chapters 6 and 7. The class provides methods to read a file from disk into memory, query and modify the in-memory copy of the file, and write the modified version back to disk. When students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text. This resulted in a simple implementation for the class, but it created complexity for higher level software. At the level of the user interface, operations rarely involve whole lines. For example, keystrokes cause individual characters to be inserted within an existing line; copying or deleting the selection can modify parts of several different lines. With the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.</p>\n<blockquote>\n<p>考虑为 GUI 文本编辑器管理文件文本的类，这在第 6 章和第 7 章中讨论过。该类提供了将文件从磁盘读入内存、查询和修改文件在内存中的副本以及将修改后的版本写回磁盘的方法。当学生必须实现这个类时，他们中的许多人选择了一个面向行的接口，该接口具有读取、插入和删除整行文本的方法。这导致了类的简单实现，但也为更高级别的软件带来了复杂性。在用户界面级别，操作很少涉及整行。例如，击键会导致在现有行中插入单个字符;复制或删除选择项可以修改几个不同行的部分。使用面向行的文本界面，为了实现用户界面，高级软件必须分割和连接行。</p>\n</blockquote>\n<p>A character-oriented interface such as the one described in Section 6.3 pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler. The implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations. This approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.</p>\n<blockquote>\n<p>面向字符的界面（如 6.3 节中所述）降低了复杂性。用户界面软件现在可以插入和删除任意范围的文本，而无需分割和合并行，因此变得更加简单。文本类的实现可能会变得更加复杂：如果内部将文本表示为行的集合，则必须拆分和合并行以实现面向字符的操作。这种方法更好，因为它封装了在文本类中拆分和合并的复杂性，从而降低了系统的整体复杂性。</p>\n</blockquote>\n<h2 id=\"8-2-Example-configuration-parameters-示例：配置参数\"><a href=\"#8-2-Example-configuration-parameters-示例：配置参数\" class=\"headerlink\" title=\"8.2 Example: configuration parameters 示例：配置参数\"></a>8.2 Example: configuration parameters 示例：配置参数</h2><p>Configuration parameters are an example of moving complexity upwards instead of down. Rather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up. Users of the class must then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them.</p>\n<blockquote>\n<p>配置参数是提高复杂度而不是降低复杂度的一个示例。类可以在内部输出一些控制其行为的参数，而不是在内部确定特定的行为，例如高速缓存的大小或在放弃之前重试请求的次数。然后，该类的用户必须为参数指定适当的值。在当今的系统中，配置参数已变得非常流行。有些系统有数百个。</p>\n</blockquote>\n<p>Advocates argue that configuration parameters are good because they allow users to tune the system for their particular requirements and workloads. In some situations it is hard for low-level infrastructure code to know the best policy to apply, whereas users are much more familiar with their domains. For instance, a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance across a broader variety of domains.</p>\n<blockquote>\n<p>拥护者认为配置参数不错，因为它们允许用户根据他们的特定要求和工作负载来调整系统。在某些情况下，低级基础结构代码很难知道要应用的最佳策略，而用户则对其域更加熟悉。例如，用户可能知道某些请求比其他请求更紧迫，因此用户为这些请求指定更高的优先级是有意义的。在这种情况下，配置参数可以在更广泛的域中带来更好的性能。</p>\n</blockquote>\n<p>However, configuration parameters also provide an easy excuse to avoid dealing with important issues and pass them on to someone else. In many cases, it’s difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determined automatically with a little extra work in the system implementation. Consider a network protocol that must deal with lost packets. If it sends a request but doesn’t receive a response within a certain time period, it resends the request. One way to determine the retry interval is to introduce a configuration parameter. However, the transport protocol could compute a reasonable value on its own by measuring the response time for requests that succeed and then using a multiple of this for the retry interval. This approach pulls complexity downward and saves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameters can easily become out of date.</p>\n<blockquote>\n<p>但是，配置参数还提供了一个轻松的借口，可以避免处理重要问题并将其传递给其他人。在许多情况下，用户或管理员很难或无法确定参数的正确值。在其他情况下，可以通过在系统实现中进行一些额外的工作来自动确定正确的值。考虑必须处理丢失数据包的网络协议。如果它发送请求但在一定时间内未收到响应，则重新发送该请求。确定重试间隔的一种方法是引入配置参数。但是，传输协议可以通过测量成功请求的响应时间，然后将其倍数用于重试间隔，自己计算出一个合理的值。这种方法降低了复杂性，使用户不必找出正确的重试间隔。它具有动态计算重试间隔的其他优点，因此，如果操作条件发生变化，它将自动进行调整。相反，配置参数很容易过时。</p>\n</blockquote>\n<p>Thus, you should avoid configuration parameters as much as possible. Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions. Ideally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.</p>\n<blockquote>\n<p>因此，您应尽可能避免使用配置参数。在导出配置参数之前，请问自己：“用户（或更高级别的模块）是否能够确定比我们在此确定的更好的值？” 当您创建配置参数时，请查看是否可以自动计算合理的默认值，因此用户仅需在特殊情况下提供值即可。理想情况下，每个模块都应完全解决问题。配置参数导致解决方案不完整，从而增加了系统复杂性。</p>\n</blockquote>\n<h2 id=\"8-3-Taking-it-too-far-走得太远\"><a href=\"#8-3-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"8.3 Taking it too far 走得太远\"></a>8.3 Taking it too far 走得太远</h2><p>Use discretion when pulling complexity downward; this is an idea that can easily be overdone. An extreme approach would be to pull all of the functionality of the entire application down into a single class, which clearly doesn’t make sense. Pulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface. Remember that the goal is to minimize overall system complexity.</p>\n<blockquote>\n<p>降低复杂性时要谨慎处理；这个想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能归为一个类，这显然没有意义。如果（a）被降低的复杂度与该类的现有功能密切相关，（b）降低复杂度将导致应用程序中其他地方的许多简化，则降低复杂度最有意义。简化了类的界面。请记住，目标是最大程度地降低整体系统复杂性。</p>\n</blockquote>\n<p>Chapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key. It might seem that this is good, since it pulls complexity downward. However, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class. In this case, pulling complexity down just resulted in information leakage.</p>\n<blockquote>\n<p>第 6 章介绍了一些学生如何在文本类中定义反映用户界面的方法，例如实现退格键功能的方法。这似乎很好，因为它可以降低复杂性。但是，将用户界面的知识添加到文本类中并不会大大简化高层代码，并且用户界面的知识与文本类的核心功能无关。在这种情况下，降低复杂度只会导致信息泄漏。</p>\n</blockquote>\n<h2 id=\"8-4-Conclusion-结论\"><a href=\"#8-4-Conclusion-结论\" class=\"headerlink\" title=\"8.4 Conclusion 结论\"></a>8.4 Conclusion 结论</h2><p>When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.</p>\n<blockquote>\n<p>在开发模块时，请寻找机会减轻自己的痛苦，以减轻用户的痛苦。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>降低复杂性</p>","more":"<h1 id=\"第-8-章-降低复杂性\"><a href=\"#第-8-章-降低复杂性\" class=\"headerlink\" title=\"第 8 章 降低复杂性\"></a>第 8 章 降低复杂性</h1><blockquote>\n<p>Chapter 8 Pull Complexity Downwards</p>\n</blockquote>\n<p>This chapter introduces another way of thinking about how to create deeper classes. Suppose that you are developing a new module, and you discover a piece of unavoidable complexity. Which is better: should you let users of the module deal with the complexity, or should you handle the complexity internally within the module? If the complexity is related to the functionality provided by the module, then the second answer is usually the right one. Most modules have more users than developers, so it is better for the developers to suffer than the users. As a module developer, you should strive to make life as easy as possible for the users of your module, even if that means extra work for you. Another way of expressing this idea is that it is more important for a module to have a simple interface than a simple implementation.</p>\n<blockquote>\n<p>本章介绍了有关如何创建更深层类的另一种思考方式。假设您正在开发一个新模块，并且发现了一个不可避免的复杂性。哪个更好：应该让模块用户处理复杂性，还是应该在模块内部处理复杂性？如果复杂度与模块提供的功能有关，则第二个答案通常是正确的答案。大多数模块拥有的用户多于开发人员，因此开发人员遭受的苦难要大于用户。作为模块开发人员，您应该努力使模块用户的生活尽可能轻松，即使这对您来说意味着额外的工作。表达此想法的另一种方法是，模块具有简单的接口比简单的实现更为重要。</p>\n</blockquote>\n<p>As a developer, it’s tempting to behave in the opposite fashion: solve the easy problems and punt the hard ones to someone else. If a condition arises that you’re not certain how to deal with, the easiest thing is to throw an exception and let the caller handle it. If you are not certain what policy to implement, you can define a few configuration parameters to control the policy and leave it up to the system administrator to figure out the best values for them.</p>\n<blockquote>\n<p>作为开发人员，很容易以相反的方式行事：解决简单的问题，然后将困难的问题推给其他人。如果出现不确定如何处理的条件，最简单的方法是引发异常并让调用方处理它。如果不确定要实施什么策略，则可以定义一些配置参数来控制该策略，然后由系统管理员自行确定最佳策略。</p>\n</blockquote>\n<p>Approaches like these will make your life easier in the short term, but they amplify complexity, so that many people must deal with a problem, rather than just one person. For example, if a class throws an exception, every caller of the class will have to deal with it. If a class exports configuration parameters, every system administrator in every installation will have to learn how to set them.</p>\n<blockquote>\n<p>这样的方法短期内会使您的生活更轻松，但它们会加剧复杂性，因此许多人必须处理一个问题，而不仅仅是一个人。例如，如果一个类抛出异常，则该类的每个调用者都必须处理该异常。如果一个类导出配置参数，则每个安装中的每个系统管理员都必须学习如何设置它们。</p>\n</blockquote>\n<h2 id=\"8-1-Example-editor-text-class-示例：编辑器文本类\"><a href=\"#8-1-Example-editor-text-class-示例：编辑器文本类\" class=\"headerlink\" title=\"8.1 Example: editor text class 示例：编辑器文本类\"></a>8.1 Example: editor text class 示例：编辑器文本类</h2><p>Consider the class that manages the text of a file for a GUI text editor, which was discussed in Chapters 6 and 7. The class provides methods to read a file from disk into memory, query and modify the in-memory copy of the file, and write the modified version back to disk. When students had to implement this class, many of them chose a line-oriented interface, with methods to read, insert, and delete whole lines of text. This resulted in a simple implementation for the class, but it created complexity for higher level software. At the level of the user interface, operations rarely involve whole lines. For example, keystrokes cause individual characters to be inserted within an existing line; copying or deleting the selection can modify parts of several different lines. With the line-oriented text interface, higher-level software had to split and join lines in order to implement the user interface.</p>\n<blockquote>\n<p>考虑为 GUI 文本编辑器管理文件文本的类，这在第 6 章和第 7 章中讨论过。该类提供了将文件从磁盘读入内存、查询和修改文件在内存中的副本以及将修改后的版本写回磁盘的方法。当学生必须实现这个类时，他们中的许多人选择了一个面向行的接口，该接口具有读取、插入和删除整行文本的方法。这导致了类的简单实现，但也为更高级别的软件带来了复杂性。在用户界面级别，操作很少涉及整行。例如，击键会导致在现有行中插入单个字符;复制或删除选择项可以修改几个不同行的部分。使用面向行的文本界面，为了实现用户界面，高级软件必须分割和连接行。</p>\n</blockquote>\n<p>A character-oriented interface such as the one described in Section 6.3 pulls complexity downward. The user interface software can now insert and delete arbitrary ranges of text without splitting and merging lines, so it becomes simpler. The implementation of the text class probably becomes more complex: if it represents the text internally as a collection of lines, it will have to split and merge lines to implement the character-oriented operations. This approach is better because it encapsulates the complexity of splitting and merging within the text class, which reduces the overall complexity of the system.</p>\n<blockquote>\n<p>面向字符的界面（如 6.3 节中所述）降低了复杂性。用户界面软件现在可以插入和删除任意范围的文本，而无需分割和合并行，因此变得更加简单。文本类的实现可能会变得更加复杂：如果内部将文本表示为行的集合，则必须拆分和合并行以实现面向字符的操作。这种方法更好，因为它封装了在文本类中拆分和合并的复杂性，从而降低了系统的整体复杂性。</p>\n</blockquote>\n<h2 id=\"8-2-Example-configuration-parameters-示例：配置参数\"><a href=\"#8-2-Example-configuration-parameters-示例：配置参数\" class=\"headerlink\" title=\"8.2 Example: configuration parameters 示例：配置参数\"></a>8.2 Example: configuration parameters 示例：配置参数</h2><p>Configuration parameters are an example of moving complexity upwards instead of down. Rather than determining a particular behavior internally, a class can export a few parameters that control its behavior, such as the size of a cache or the number of times to retry a request before giving up. Users of the class must then specify appropriate values for the parameters. Configuration parameters have become very popular in systems today; some systems have hundreds of them.</p>\n<blockquote>\n<p>配置参数是提高复杂度而不是降低复杂度的一个示例。类可以在内部输出一些控制其行为的参数，而不是在内部确定特定的行为，例如高速缓存的大小或在放弃之前重试请求的次数。然后，该类的用户必须为参数指定适当的值。在当今的系统中，配置参数已变得非常流行。有些系统有数百个。</p>\n</blockquote>\n<p>Advocates argue that configuration parameters are good because they allow users to tune the system for their particular requirements and workloads. In some situations it is hard for low-level infrastructure code to know the best policy to apply, whereas users are much more familiar with their domains. For instance, a user might know that some requests are more time-critical than others, so it makes sense for the user to specify a higher priority for those requests. In situations like this, configuration parameters can result in better performance across a broader variety of domains.</p>\n<blockquote>\n<p>拥护者认为配置参数不错，因为它们允许用户根据他们的特定要求和工作负载来调整系统。在某些情况下，低级基础结构代码很难知道要应用的最佳策略，而用户则对其域更加熟悉。例如，用户可能知道某些请求比其他请求更紧迫，因此用户为这些请求指定更高的优先级是有意义的。在这种情况下，配置参数可以在更广泛的域中带来更好的性能。</p>\n</blockquote>\n<p>However, configuration parameters also provide an easy excuse to avoid dealing with important issues and pass them on to someone else. In many cases, it’s difficult or impossible for users or administrators to determine the right values for the parameters. In other cases, the right values could have been determined automatically with a little extra work in the system implementation. Consider a network protocol that must deal with lost packets. If it sends a request but doesn’t receive a response within a certain time period, it resends the request. One way to determine the retry interval is to introduce a configuration parameter. However, the transport protocol could compute a reasonable value on its own by measuring the response time for requests that succeed and then using a multiple of this for the retry interval. This approach pulls complexity downward and saves users from having to figure out the right retry interval. It has the additional advantage of computing the retry interval dynamically, so it will adjust automatically if operating conditions change. In contrast, configuration parameters can easily become out of date.</p>\n<blockquote>\n<p>但是，配置参数还提供了一个轻松的借口，可以避免处理重要问题并将其传递给其他人。在许多情况下，用户或管理员很难或无法确定参数的正确值。在其他情况下，可以通过在系统实现中进行一些额外的工作来自动确定正确的值。考虑必须处理丢失数据包的网络协议。如果它发送请求但在一定时间内未收到响应，则重新发送该请求。确定重试间隔的一种方法是引入配置参数。但是，传输协议可以通过测量成功请求的响应时间，然后将其倍数用于重试间隔，自己计算出一个合理的值。这种方法降低了复杂性，使用户不必找出正确的重试间隔。它具有动态计算重试间隔的其他优点，因此，如果操作条件发生变化，它将自动进行调整。相反，配置参数很容易过时。</p>\n</blockquote>\n<p>Thus, you should avoid configuration parameters as much as possible. Before exporting a configuration parameter, ask yourself: “will users (or higher-level modules) be able to determine a better value than we can determine here?” When you do create configuration parameters, see if you can compute reasonable defaults automatically, so users will only need to provide values under exceptional conditions. Ideally, each module should solve a problem completely; configuration parameters result in an incomplete solution, which adds to system complexity.</p>\n<blockquote>\n<p>因此，您应尽可能避免使用配置参数。在导出配置参数之前，请问自己：“用户（或更高级别的模块）是否能够确定比我们在此确定的更好的值？” 当您创建配置参数时，请查看是否可以自动计算合理的默认值，因此用户仅需在特殊情况下提供值即可。理想情况下，每个模块都应完全解决问题。配置参数导致解决方案不完整，从而增加了系统复杂性。</p>\n</blockquote>\n<h2 id=\"8-3-Taking-it-too-far-走得太远\"><a href=\"#8-3-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"8.3 Taking it too far 走得太远\"></a>8.3 Taking it too far 走得太远</h2><p>Use discretion when pulling complexity downward; this is an idea that can easily be overdone. An extreme approach would be to pull all of the functionality of the entire application down into a single class, which clearly doesn’t make sense. Pulling complexity down makes the most sense if (a) the complexity being pulled down is closely related to the class’s existing functionality, (b) pulling the complexity down will result in many simplifications elsewhere in the application, and (c) pulling the complexity down simplifies the class’s interface. Remember that the goal is to minimize overall system complexity.</p>\n<blockquote>\n<p>降低复杂性时要谨慎处理；这个想法很容易被夸大。一种极端的方法是将整个应用程序的所有功能归为一个类，这显然没有意义。如果（a）被降低的复杂度与该类的现有功能密切相关，（b）降低复杂度将导致应用程序中其他地方的许多简化，则降低复杂度最有意义。简化了类的界面。请记住，目标是最大程度地降低整体系统复杂性。</p>\n</blockquote>\n<p>Chapter 6 described how some students defined methods in the text class that reflected the user interface, such as a method that implements the functionality of the backspace key. It might seem that this is good, since it pulls complexity downward. However, adding knowledge of the user interface to the text class doesn’t simplify higher-level code very much, and the user-interface knowledge doesn’t relate to the core functions of the text class. In this case, pulling complexity down just resulted in information leakage.</p>\n<blockquote>\n<p>第 6 章介绍了一些学生如何在文本类中定义反映用户界面的方法，例如实现退格键功能的方法。这似乎很好，因为它可以降低复杂性。但是，将用户界面的知识添加到文本类中并不会大大简化高层代码，并且用户界面的知识与文本类的核心功能无关。在这种情况下，降低复杂度只会导致信息泄漏。</p>\n</blockquote>\n<h2 id=\"8-4-Conclusion-结论\"><a href=\"#8-4-Conclusion-结论\" class=\"headerlink\" title=\"8.4 Conclusion 结论\"></a>8.4 Conclusion 结论</h2><p>When developing a module, look for opportunities to take a little bit of extra suffering upon yourself in order to reduce the suffering of your users.</p>\n<blockquote>\n<p>在开发模块时，请寻找机会减轻自己的痛苦，以减轻用户的痛苦。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch16","date":"2021-02-15T16:00:00.000Z","_content":"修改现有的代码\n<!-- more -->\n# 第 16 章 修改现有的代码\n\n> Chapter 16 Modifying Existing Code\n\nChapter 1 described how software development is iterative and incremental. A large software system develops through a series of evolutionary stages, where each stage adds new capabilities and modifies existing modules. This means that a system’s design is constantly evolving. It isn’t possible to conceive the right design for a system at the outset; the design of a mature system is determined more by changes made during the system’s evolution than by any initial conception. Previous chapters described how to squeeze out complexity during the initial design and implementation; this chapter discusses how to keep complexity from creeping in as the system evolves.\n\n> 第 1 章介绍了软件开发是如何迭代和增量的。大型软件系统是通过一系列演化阶段开发的，其中每个阶段都添加了新功能并修改了现有模块。这意味着系统的设计在不断发展。一开始就不可能为系统设计正确的设计。一个成熟的系统的设计更多地取决于系统演化过程中所做的更改，而不是任何初始概念。前面的章节描述了如何在初始设计和实现过程中降低复杂性。本章讨论如何防止随着系统的发展而增加复杂性。\n\n## 16.1 Stay strategic 保持战略\n\nChapter 3 introduced the distinction between tactical programming and strategic programming: in tactical programming, the primary goal is to get something working quickly, even if that results in additional complexity; in strategic programming, the most important goal is to produce a great system design. The tactical approach very quickly leads to a messy system design. If you want to have a system that is easy to maintain and enhance, then “working” isn’t a high enough standard; you have to prioritize design and think strategically. This idea also applies when you are modifying existing code.\n\n> 第 3 章介绍了战术编程和战略编程之间的区别：在战术编程中，主要目标是使某些事物快速工作，即使这会导致额外的复杂性；在战略编程中，最重要的目标是进行出色的系统设计。战术方法很快导致系统设计混乱。如果您想要一个易于维护和增强的系统，那么“工作”还不够高。您必须优先考虑设计并进行战略思考。当您修改现有代码时，此想法也适用。\n\nUnfortunately, when developers go into existing code to make changes such as bug fixes or new features, they don’t usually think strategically. A typical mindset is “what is the smallest possible change I can make that does what I need?” Sometimes developers justify this because they are not comfortable with the code being modified; they worry that larger changes carry a greater risk of introducing new bugs. However, this results in tactical programming. Each one of these minimal changes introduces a few special cases, dependencies, or other forms of complexity. As a result, the system design gets just a bit worse, and the problems accumulate with each step in the system’s evolution.\n\n> 不幸的是，当开发人员进入现有代码以进行更改（例如错误修复或新功能）时，他们通常不会从战略角度进行思考。一个典型的心态是“我能做出我需要做的最小的改变是什么？” 有时，开发人员证明这是合理的，因为他们对修改的代码不满意。他们担心较大的更改会带来更大的引入新错误的风险。但是，这导致了战术编程。这些最小的变化中的每一个都会引入一些特殊情况，依赖性或其他形式的复杂性。结果，系统设计变得更糟，并且问题随着系统发展的每个步骤而累积。\n\nIf you want to maintain a clean design for a system, you must take a strategic approach when modifying existing code. Ideally, when you have finished with each change, the system will have the structure it would have had if you had designed it from the start with that change in mind. To achieve this goal, you must resist the temptation to make a quick fix. Instead, think about whether the current system design is still the best one, in light of the desired change. If not, refactor the system so that you end up with the best possible design. With this approach, the system design improves with every modification.\n\n> 如果要维护系统的简洁设计，则在修改现有代码时必须采取战略性方法。理想情况下，当您完成每次更改时，如果您从一开始就考虑到更改就设计了系统，那么系统将具有它应该具有的结构。为了实现此目标，您必须抵制诱惑以快速解决问题。相反，请根据所需的更改来考虑当前的系统设计是否仍然是最佳的。如果不是，请重构系统，以便最终获得最佳设计。通过这种方法，每次修改都会改善系统设计。\n\nThis is also an example of the investment mindset introduced on page 15: if you invest a little extra time to refactor and improve the system design, you’ll end up with a cleaner system. This will speed up development, and you will recoup the effort that you invested in the refactoring. Even if your particular change doesn’t require refactoring, you should still be on the lookout for design imperfections that you can fix while you’re in the code. Whenever you modify any code, try to find a way to improve the system design at least a little bit in the process. If you’re not making the design better, you are probably making it worse.\n\n> 这也是第 15 页介绍的投资心态的一个示例：如果您花费一些额外的时间来重构和改善系统设计，您将得到一个更干净的系统。这将加快开发速度，您将收回在重构方面投入的精力。即使您的特定更改不需要重构，您仍然应该注意在代码中可以修复的设计缺陷。每当您修改任何代码时，都尝试在该过程中至少找到一点方法来改进系统设计。如果您没有使设计更好，则可能会使它变得更糟。\n\nAs discussed in Chapter 3, an investment mindset sometimes conflicts with the realities of commercial software development. If refactoring the system “the right way” would take three months but a quick and dirty fix would take only two hours, you may have to take the quick and dirty approach, particularly if you are working against a tight deadline. Or, if refactoring the system would create incompatibilities that affect many other people and teams, then the refactoring may not be practical.\n\n> 如第 3 章所述，投资心态有时与商业软件开发的现实相冲突。如果“正确的方式”重构系统需要三个月，而快速且肮脏的修复仅需两个小时，则您可能必须采取快速而肮脏的方法，尤其是在紧迫的期限内工作时。或者，如果重构系统会造成影响许多其他人员和团队的不兼容性，则重构可能不切实际。\n\nNonetheless, you should resist these compromises as much as possible. Ask yourself “Is this the best I can possibly do to create a clean system design, given my current constraints?” Perhaps there’s an alternative approach that would be almost as clean as the 3-month refactoring but could be done in a couple of days? Or, if you can’t afford to do a large refactoring now, get your boss to allocate time for you to come back to it after the current deadline. Every development organization should plan to spend a small fraction of its total effort on cleanup and refactoring; this work will pay for itself over the long run.\n\n> 但是，您应尽可能抵制这些妥协。问问自己：“考虑到我目前的限制，这是否是我能做的最好的工作来创建一个干净的系统设计？” 也许有一种替代方法几乎可以像 3 个月的重构一样干净，但是可以在几天内完成？或者，如果您现在负担不起大型重构，请让您的老板为您分配时间，让您在当前截止日期之后恢复到原来的水平。每个开发组织都应计划将其全部工作的一小部分用于清理和重构；从长远来看，这项工作将收回成本。\n\n## 16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近\n\nWhen you change existing code, there’s a good chance that the changes will invalidate some of the existing comments. It’s easy to forget to update comments when you modify code, which results in comments that are no longer accurate. Inaccurate comments are frustrating to readers, and if there are very many of them, readers begin to distrust all of the comments. Fortunately, with a little discipline and a couple of guiding rules, it’s possible to keep comments up-to-date without a huge effort. This section and the following ones put forth some specific techniques.\n\n> 当您更改现有代码时，更改很有可能会使某些现有注释无效。修改代码时，很容易忘记更新注释，从而导致注释不再准确。不准确的评论使读者感到沮丧，如果评论太多，读者就会开始不信任所有评论。幸运的是，只要有一点纪律和一些指导规则，就可以在不付出巨大努力的情况下使评论保持最新。本节及随后的部分提出了一些特定的技术。\n\nThe best way to ensure that comments get updated is to position them close to the code they describe, so developers will see them when they change the code. The farther a comment is from its associated code, the less likely it is that it will be updated properly. For example, the best place for a method’s interface comment is in the code file, right next to the body of the method. Any changes to the method will involve this code, so the developer is likely to see the interface comments and update them if needed.\n\n> 确保注释更新的最佳方法是将注释放置在它们描述的代码附近，以便开发人员在更改代码时可以看到它们。注释离其关联的代码越远，正确更新的可能性就越小。例如，方法界面注释的最佳位置是在代码文件中，紧靠该方法主体的位置。对方法的任何更改都将涉及此代码，因此开发人员很可能会看到界面注释，并在需要时进行更新。\n\nAn alternative for languages like C and C++ that have separate code and header files, is to place the interface comments next to the method’s declaration in the .h file. However, this is a long way from the code; developers won’t see those comments when modifying the method’s body, and it takes additional work to open a different file and find the interface comments to update them. Some might argue that interface comments should go in header files so that users can learn how to use an abstraction without having to look at the code file. However, users should not need to read either code or header files; they should get their information from documentation compiled by tools such as Doxygen or Javadoc. In addition, many IDEs will extract and present documentation to users, such as by displaying a method’s documentation when the method’s name is typed. Given tools such as these, the documentation should be located in the place that is most convenient for developers working on the code.\n\n> 对于 C 和 C ++等具有单独的代码和头文件的语言，一种替代方法是将接口注释放在.h 文件中方法声明的旁边。但是，这距离代码还有很长的路要走。开发人员在修改方法的主体时将看不到这些注释，因此需要打开其他文件并查找接口注释来更新它们，这需要额外的工作。有人可能会争辩说接口注释应该放在头文件中，以便用户可以不必看代码文件就可以学习如何使用抽象。但是，用户无需读取代码或头文件；他们应该从由 Doxygen 或 Javadoc 等工具编译的文档中获取信息。此外，许多 IDE 都会提取文档并将其呈现给用户，例如在键入方法名称时显示方法的文档。给定诸如此类的工具，文档应位于对开发人员进行代码开发最方便的位置。\n\nWhen writing implementation comments, don’t put all the comments for an entire method at the top of the method. Spread them out, pushing each comment down to the narrowest scope that includes all of the code referred to by the comment. For example, if a method has three major phases, don’t write one comment at the top of the method that describes all of the phases in detail. Instead, write a separate comment for each phase and position that comment just above the first line of code in that phase. On the other hand, it can also be helpful to have a comment at the top of a method’s implementation that describes the overall strategy, like this:\n\n> 在编写实现注释时，不要将整个方法的所有注释放在方法的顶部。展开它们，将每个注释推到最狭窄的范围，其中包括该注释所引用的所有代码。例如，如果一种方法具有三个主要阶段，则不要在方法的顶部写一个详细描述所有阶段的注释。而是为每个阶段编写一个单独的注释，并将该注释放置在该阶段的第一行代码的正上方。另一方面，在描述总体策略的方法实现的顶部添加注释也可能会有所帮助，例如：\n\n```java\n//  We proceed in three phases:\n//  Phase 1: Find feasible candidates\n//  Phase 2: Assign each candidate a score\n//  Phase 3: Choose the best, and remove it\n```\n\nAdditional details can be documented just above the code for each phase.\n\n> 每个阶段的代码上方都可以记录其他详细信息。\n\nIn general, the farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidated by code changes).\n\n> 通常，注释离描述的代码越远，注释应该越抽象（这减少了注释因代码更改而无效的可能性）。\n\n## 16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志\n\nA common mistake when modifying code is to put detailed information about the change in the commit message for the source code repository, but then not to document it in the code. Although commit messages can be browsed in the future by scanning the repository’s log, a developer who needs the information is unlikely to think of scanning the repository log. Even if they do scan the log, it will be tedious to find the right log message.\n\n> 修改代码时，常见的错误是将有关更改的详细信息放入源代码存储库的提交消息中，而不是将其记录在代码中。尽管将来可以通过扫描存储库的日志来浏览提交消息，但是需要该信息的开发人员不太可能考虑扫描存储库的日志。即使他们确实扫描了日志，也很难找到正确的日志消息。\n\nWhen writing a commit message, ask yourself whether developers will need to use that information in the future. If so, then document this information in the code. An example is a commit message describing a subtle problem that motivated a code change. If this isn’t documented in the code, then a developer might come along later and undo the change without realizing that they have re-created a bug. If you want to include a copy of this information in the commit message as well, that’s fine, but the most important thing is to get it in the code. This illustrates the principle of placing documentation in the place where developers are most likely to see it; the commit log is rarely that place.\n\n> 在编写提交消息时，请问自己将来开发人员是否需要使用该信息。如果是这样，则在代码中记录此信息。一个示例是提交消息，描述了导致代码更改的细微问题。如果代码中未对此进行记录，则开发人员可能会稍后再提出并撤消更改，而不会意识到他们已经重新创建了错误。如果您也想在提交消息中包含此信息的副本，那很好，但是最重要的是在代码中获取它。这说明了将文档放置在开发人员最有可能看到它的地方的原理；提交日志很少在那个地方。\n\n## 16.4 Maintaining comments: avoid duplication 维护注释：避免重复\n\nThe second technique for keeping comments up to date is to avoid duplication. If documentation is duplicated, it is more difficult for developers to find and update all of the relevant copies. Instead, try to document each design decision exactly once. If there are multiple places in the code that are affected by a particular decision, don’t repeat the documentation at each of these points. Instead, find the most obvious single place to put the documentation. For example, suppose there is tricky behavior related to a variable, which affects several different places where the variable is used. You can document that behavior in the comment next to the variable’s declaration. This is a natural place that developers are likely to check if they’re having trouble understanding code that uses the variable.\n\n> 保持评论最新的第二种技术是避免重复。如果文档重复，那么开发人员将很难找到并更新所有相关副本。相反，请尝试仅一次记录每个设计决策。如果代码中有多个地方受某个特定决定的影响，请不要在所有这些地方重复文档。相反，找到放置文档最明显的位置。例如，假设存在与变量相关的棘手行为，这会影响使用变量的几个不同位置。您可以在变量声明旁边的注释中记录该行为。这是很自然的地方，开发人员可能会检查他们是否在理解使用该变量的代码时遇到麻烦。\n\nIf there is no “obvious” single place to put a particular piece of documentation where developers will find it, create a designNotes file as described in Section 13.7. Or, pick the best of the available places and put the documentation there. In addition, add short comments in the other places that refer to the central location: “See the comment in xyz for an explanation of the code below.” If the reference becomes obsolete because the master comment was moved or deleted, this inconsistency will be self-evident because developers won’t find the comment at the indicated place; they can use revision control history to find out what happened to the comment and then update the reference. In contrast, if the documentation is duplicated and some of the copies don’t get updated, there will be no indication to developers that they are using stale information.\n\n> 如果没有一个“明显的”地方来放置特定的文档，开发人员可以找到它，那么创建一个 designNotes 文件，如第 13.7 节所述。或者，选择最好的地方，把文档放在那里。另外，在引用中心位置的其他地方添加简短的注释:“查看 xyz 中的注释以了解下面代码的解释。“如果引用因为主注释被移动或删除而变得过时，这种不一致性将是不言而喻的，因为开发人员将无法在指定的位置找到注释;他们可以使用修订控制历史记录来查找注释发生了什么，然后更新引用。相反，如果文档是重复的，并且一些副本没有得到更新，那么开发人员就不会知道他们使用的是陈旧的信息。\n\nDon’t redocument one module’s design decisions in another module. For example, don’t put comments before a method call that explain what happens in the called method. If readers want to know, they should look at the interface comments for the method. Good development tools will usually provide this information automatically, for example, by displaying the interface comments for a method if you select the method’s name or hover the mouse over it. Try to make it easy for developers to find appropriate documentation, but don’t do it by repeating the documentation.\n\n> 不要在另一个模块中记录一个模块的设计决策。例如，不要在方法调用前添加注释，以解释被调用方法中发生的情况。如果读者想知道，他们应该查看该方法的界面注释。好的开发工具通常会自动提供此信息，例如，如果您选择了方法的名称或将鼠标悬停在该方法的名称上，则将显示该方法的界面注释。尝试使开发人员容易找到合适的文档，但是不要重复文档。\n\nIf information is already documented someplace outside your program, don’t repeat the documentation inside the program; just reference the external documentation. For example, if you write a class that implements the HTTP protocol, there’s no need for you to describe the HTTP protocol inside your code. There are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources. Another example is features that are already documented in a user manual. Suppose you are writing a program that implements a collection of commands, with one method responsible for implementing each command. If there is a user manual that describes those commands, there’s no need to duplicate this information in the code. Instead, include a short note like the following in the interface comment for each command method:\n\n> 如果信息已经在程序之外的某个地方记录了，不要在程序内部重复记录;只需参考外部文档。例如，如果您编写一个实现 HTTP 协议的类，那么就不需要在代码中描述 HTTP 协议。在网上已经有很多关于这个文档的来源;只需在您的代码中添加一个简短的注释，并为其中一个源添加一个 URL。另一个例子是已经在用户手册中记录的特性。假设您正在编写一个实现命令集合的程序，其中有一个负责实现每个命令的方法。如果有描述这些命令的用户手册，就不需要在代码中重复这些信息。相反，在每个命令方法的接口注释中包含如下简短说明:\n\n```java\n// Implements the Foo command; see the user manual for details.\n```\n\nIt’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.\n\n> 读者可以轻松找到理解代码所需的所有文档，这一点很重要，但这并不意味着您必须编写所有这些文档。\n\n## 16.5 Maintaining comments: check the diffs 维护注释：检查差异\n\nOne good way to make sure documentation stays up to date is to take a few minutes before committing a change to your revision control system to scan over all the changes for that commit; make sure that each change is properly reflected in the documentation. These pre-commit scans will also detect several other problems, such as accidentally leaving debugging code in the system or failing to fix TODO items.\n\n> 确保文档保持最新状态的一种好方法是，在将更改提交到修订控制系统之前需要花费几分钟，以扫描该提交的所有更改。确保文档中正确反映了每个更改。这些预先提交的扫描还将检测其他一些问题，例如意外地将调试代码留在系统中或无法修复 TODO 项目。\n\n## 16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护\n\nOne final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code. These comments do not reflect the details of the code, so they will not be affected by minor code changes; only changes in overall behavior will affect these comments. Of course, as discussed in Chapter 13, some comments do need to be detailed and precise. But in general, the comments that are most useful (they don’t simply repeat the code) are also easiest to maintain.\n\n> 关于维护文档的最后一个想法：如果注释比代码更高级，更抽象，则注释更易于维护。这些注释不反映代码的详细信息，因此它们不会受到代码更改的影响；只有整体行为的变化才会影响这些评论。当然，正如第 13 章所讨论的那样，某些注释的确需要详细和精确。但总的来说，最有用的注释（它们不只是重复代码）也最容易维护。\n","source":"_posts/软件设计的哲学-ch16.md","raw":"---\ntitle: 软件设计的哲学 - ch16\ndate: 2021-02-16\ntags: 软件设计的哲学 软件开发 方法论\n---\n修改现有的代码\n<!-- more -->\n# 第 16 章 修改现有的代码\n\n> Chapter 16 Modifying Existing Code\n\nChapter 1 described how software development is iterative and incremental. A large software system develops through a series of evolutionary stages, where each stage adds new capabilities and modifies existing modules. This means that a system’s design is constantly evolving. It isn’t possible to conceive the right design for a system at the outset; the design of a mature system is determined more by changes made during the system’s evolution than by any initial conception. Previous chapters described how to squeeze out complexity during the initial design and implementation; this chapter discusses how to keep complexity from creeping in as the system evolves.\n\n> 第 1 章介绍了软件开发是如何迭代和增量的。大型软件系统是通过一系列演化阶段开发的，其中每个阶段都添加了新功能并修改了现有模块。这意味着系统的设计在不断发展。一开始就不可能为系统设计正确的设计。一个成熟的系统的设计更多地取决于系统演化过程中所做的更改，而不是任何初始概念。前面的章节描述了如何在初始设计和实现过程中降低复杂性。本章讨论如何防止随着系统的发展而增加复杂性。\n\n## 16.1 Stay strategic 保持战略\n\nChapter 3 introduced the distinction between tactical programming and strategic programming: in tactical programming, the primary goal is to get something working quickly, even if that results in additional complexity; in strategic programming, the most important goal is to produce a great system design. The tactical approach very quickly leads to a messy system design. If you want to have a system that is easy to maintain and enhance, then “working” isn’t a high enough standard; you have to prioritize design and think strategically. This idea also applies when you are modifying existing code.\n\n> 第 3 章介绍了战术编程和战略编程之间的区别：在战术编程中，主要目标是使某些事物快速工作，即使这会导致额外的复杂性；在战略编程中，最重要的目标是进行出色的系统设计。战术方法很快导致系统设计混乱。如果您想要一个易于维护和增强的系统，那么“工作”还不够高。您必须优先考虑设计并进行战略思考。当您修改现有代码时，此想法也适用。\n\nUnfortunately, when developers go into existing code to make changes such as bug fixes or new features, they don’t usually think strategically. A typical mindset is “what is the smallest possible change I can make that does what I need?” Sometimes developers justify this because they are not comfortable with the code being modified; they worry that larger changes carry a greater risk of introducing new bugs. However, this results in tactical programming. Each one of these minimal changes introduces a few special cases, dependencies, or other forms of complexity. As a result, the system design gets just a bit worse, and the problems accumulate with each step in the system’s evolution.\n\n> 不幸的是，当开发人员进入现有代码以进行更改（例如错误修复或新功能）时，他们通常不会从战略角度进行思考。一个典型的心态是“我能做出我需要做的最小的改变是什么？” 有时，开发人员证明这是合理的，因为他们对修改的代码不满意。他们担心较大的更改会带来更大的引入新错误的风险。但是，这导致了战术编程。这些最小的变化中的每一个都会引入一些特殊情况，依赖性或其他形式的复杂性。结果，系统设计变得更糟，并且问题随着系统发展的每个步骤而累积。\n\nIf you want to maintain a clean design for a system, you must take a strategic approach when modifying existing code. Ideally, when you have finished with each change, the system will have the structure it would have had if you had designed it from the start with that change in mind. To achieve this goal, you must resist the temptation to make a quick fix. Instead, think about whether the current system design is still the best one, in light of the desired change. If not, refactor the system so that you end up with the best possible design. With this approach, the system design improves with every modification.\n\n> 如果要维护系统的简洁设计，则在修改现有代码时必须采取战略性方法。理想情况下，当您完成每次更改时，如果您从一开始就考虑到更改就设计了系统，那么系统将具有它应该具有的结构。为了实现此目标，您必须抵制诱惑以快速解决问题。相反，请根据所需的更改来考虑当前的系统设计是否仍然是最佳的。如果不是，请重构系统，以便最终获得最佳设计。通过这种方法，每次修改都会改善系统设计。\n\nThis is also an example of the investment mindset introduced on page 15: if you invest a little extra time to refactor and improve the system design, you’ll end up with a cleaner system. This will speed up development, and you will recoup the effort that you invested in the refactoring. Even if your particular change doesn’t require refactoring, you should still be on the lookout for design imperfections that you can fix while you’re in the code. Whenever you modify any code, try to find a way to improve the system design at least a little bit in the process. If you’re not making the design better, you are probably making it worse.\n\n> 这也是第 15 页介绍的投资心态的一个示例：如果您花费一些额外的时间来重构和改善系统设计，您将得到一个更干净的系统。这将加快开发速度，您将收回在重构方面投入的精力。即使您的特定更改不需要重构，您仍然应该注意在代码中可以修复的设计缺陷。每当您修改任何代码时，都尝试在该过程中至少找到一点方法来改进系统设计。如果您没有使设计更好，则可能会使它变得更糟。\n\nAs discussed in Chapter 3, an investment mindset sometimes conflicts with the realities of commercial software development. If refactoring the system “the right way” would take three months but a quick and dirty fix would take only two hours, you may have to take the quick and dirty approach, particularly if you are working against a tight deadline. Or, if refactoring the system would create incompatibilities that affect many other people and teams, then the refactoring may not be practical.\n\n> 如第 3 章所述，投资心态有时与商业软件开发的现实相冲突。如果“正确的方式”重构系统需要三个月，而快速且肮脏的修复仅需两个小时，则您可能必须采取快速而肮脏的方法，尤其是在紧迫的期限内工作时。或者，如果重构系统会造成影响许多其他人员和团队的不兼容性，则重构可能不切实际。\n\nNonetheless, you should resist these compromises as much as possible. Ask yourself “Is this the best I can possibly do to create a clean system design, given my current constraints?” Perhaps there’s an alternative approach that would be almost as clean as the 3-month refactoring but could be done in a couple of days? Or, if you can’t afford to do a large refactoring now, get your boss to allocate time for you to come back to it after the current deadline. Every development organization should plan to spend a small fraction of its total effort on cleanup and refactoring; this work will pay for itself over the long run.\n\n> 但是，您应尽可能抵制这些妥协。问问自己：“考虑到我目前的限制，这是否是我能做的最好的工作来创建一个干净的系统设计？” 也许有一种替代方法几乎可以像 3 个月的重构一样干净，但是可以在几天内完成？或者，如果您现在负担不起大型重构，请让您的老板为您分配时间，让您在当前截止日期之后恢复到原来的水平。每个开发组织都应计划将其全部工作的一小部分用于清理和重构；从长远来看，这项工作将收回成本。\n\n## 16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近\n\nWhen you change existing code, there’s a good chance that the changes will invalidate some of the existing comments. It’s easy to forget to update comments when you modify code, which results in comments that are no longer accurate. Inaccurate comments are frustrating to readers, and if there are very many of them, readers begin to distrust all of the comments. Fortunately, with a little discipline and a couple of guiding rules, it’s possible to keep comments up-to-date without a huge effort. This section and the following ones put forth some specific techniques.\n\n> 当您更改现有代码时，更改很有可能会使某些现有注释无效。修改代码时，很容易忘记更新注释，从而导致注释不再准确。不准确的评论使读者感到沮丧，如果评论太多，读者就会开始不信任所有评论。幸运的是，只要有一点纪律和一些指导规则，就可以在不付出巨大努力的情况下使评论保持最新。本节及随后的部分提出了一些特定的技术。\n\nThe best way to ensure that comments get updated is to position them close to the code they describe, so developers will see them when they change the code. The farther a comment is from its associated code, the less likely it is that it will be updated properly. For example, the best place for a method’s interface comment is in the code file, right next to the body of the method. Any changes to the method will involve this code, so the developer is likely to see the interface comments and update them if needed.\n\n> 确保注释更新的最佳方法是将注释放置在它们描述的代码附近，以便开发人员在更改代码时可以看到它们。注释离其关联的代码越远，正确更新的可能性就越小。例如，方法界面注释的最佳位置是在代码文件中，紧靠该方法主体的位置。对方法的任何更改都将涉及此代码，因此开发人员很可能会看到界面注释，并在需要时进行更新。\n\nAn alternative for languages like C and C++ that have separate code and header files, is to place the interface comments next to the method’s declaration in the .h file. However, this is a long way from the code; developers won’t see those comments when modifying the method’s body, and it takes additional work to open a different file and find the interface comments to update them. Some might argue that interface comments should go in header files so that users can learn how to use an abstraction without having to look at the code file. However, users should not need to read either code or header files; they should get their information from documentation compiled by tools such as Doxygen or Javadoc. In addition, many IDEs will extract and present documentation to users, such as by displaying a method’s documentation when the method’s name is typed. Given tools such as these, the documentation should be located in the place that is most convenient for developers working on the code.\n\n> 对于 C 和 C ++等具有单独的代码和头文件的语言，一种替代方法是将接口注释放在.h 文件中方法声明的旁边。但是，这距离代码还有很长的路要走。开发人员在修改方法的主体时将看不到这些注释，因此需要打开其他文件并查找接口注释来更新它们，这需要额外的工作。有人可能会争辩说接口注释应该放在头文件中，以便用户可以不必看代码文件就可以学习如何使用抽象。但是，用户无需读取代码或头文件；他们应该从由 Doxygen 或 Javadoc 等工具编译的文档中获取信息。此外，许多 IDE 都会提取文档并将其呈现给用户，例如在键入方法名称时显示方法的文档。给定诸如此类的工具，文档应位于对开发人员进行代码开发最方便的位置。\n\nWhen writing implementation comments, don’t put all the comments for an entire method at the top of the method. Spread them out, pushing each comment down to the narrowest scope that includes all of the code referred to by the comment. For example, if a method has three major phases, don’t write one comment at the top of the method that describes all of the phases in detail. Instead, write a separate comment for each phase and position that comment just above the first line of code in that phase. On the other hand, it can also be helpful to have a comment at the top of a method’s implementation that describes the overall strategy, like this:\n\n> 在编写实现注释时，不要将整个方法的所有注释放在方法的顶部。展开它们，将每个注释推到最狭窄的范围，其中包括该注释所引用的所有代码。例如，如果一种方法具有三个主要阶段，则不要在方法的顶部写一个详细描述所有阶段的注释。而是为每个阶段编写一个单独的注释，并将该注释放置在该阶段的第一行代码的正上方。另一方面，在描述总体策略的方法实现的顶部添加注释也可能会有所帮助，例如：\n\n```java\n//  We proceed in three phases:\n//  Phase 1: Find feasible candidates\n//  Phase 2: Assign each candidate a score\n//  Phase 3: Choose the best, and remove it\n```\n\nAdditional details can be documented just above the code for each phase.\n\n> 每个阶段的代码上方都可以记录其他详细信息。\n\nIn general, the farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidated by code changes).\n\n> 通常，注释离描述的代码越远，注释应该越抽象（这减少了注释因代码更改而无效的可能性）。\n\n## 16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志\n\nA common mistake when modifying code is to put detailed information about the change in the commit message for the source code repository, but then not to document it in the code. Although commit messages can be browsed in the future by scanning the repository’s log, a developer who needs the information is unlikely to think of scanning the repository log. Even if they do scan the log, it will be tedious to find the right log message.\n\n> 修改代码时，常见的错误是将有关更改的详细信息放入源代码存储库的提交消息中，而不是将其记录在代码中。尽管将来可以通过扫描存储库的日志来浏览提交消息，但是需要该信息的开发人员不太可能考虑扫描存储库的日志。即使他们确实扫描了日志，也很难找到正确的日志消息。\n\nWhen writing a commit message, ask yourself whether developers will need to use that information in the future. If so, then document this information in the code. An example is a commit message describing a subtle problem that motivated a code change. If this isn’t documented in the code, then a developer might come along later and undo the change without realizing that they have re-created a bug. If you want to include a copy of this information in the commit message as well, that’s fine, but the most important thing is to get it in the code. This illustrates the principle of placing documentation in the place where developers are most likely to see it; the commit log is rarely that place.\n\n> 在编写提交消息时，请问自己将来开发人员是否需要使用该信息。如果是这样，则在代码中记录此信息。一个示例是提交消息，描述了导致代码更改的细微问题。如果代码中未对此进行记录，则开发人员可能会稍后再提出并撤消更改，而不会意识到他们已经重新创建了错误。如果您也想在提交消息中包含此信息的副本，那很好，但是最重要的是在代码中获取它。这说明了将文档放置在开发人员最有可能看到它的地方的原理；提交日志很少在那个地方。\n\n## 16.4 Maintaining comments: avoid duplication 维护注释：避免重复\n\nThe second technique for keeping comments up to date is to avoid duplication. If documentation is duplicated, it is more difficult for developers to find and update all of the relevant copies. Instead, try to document each design decision exactly once. If there are multiple places in the code that are affected by a particular decision, don’t repeat the documentation at each of these points. Instead, find the most obvious single place to put the documentation. For example, suppose there is tricky behavior related to a variable, which affects several different places where the variable is used. You can document that behavior in the comment next to the variable’s declaration. This is a natural place that developers are likely to check if they’re having trouble understanding code that uses the variable.\n\n> 保持评论最新的第二种技术是避免重复。如果文档重复，那么开发人员将很难找到并更新所有相关副本。相反，请尝试仅一次记录每个设计决策。如果代码中有多个地方受某个特定决定的影响，请不要在所有这些地方重复文档。相反，找到放置文档最明显的位置。例如，假设存在与变量相关的棘手行为，这会影响使用变量的几个不同位置。您可以在变量声明旁边的注释中记录该行为。这是很自然的地方，开发人员可能会检查他们是否在理解使用该变量的代码时遇到麻烦。\n\nIf there is no “obvious” single place to put a particular piece of documentation where developers will find it, create a designNotes file as described in Section 13.7. Or, pick the best of the available places and put the documentation there. In addition, add short comments in the other places that refer to the central location: “See the comment in xyz for an explanation of the code below.” If the reference becomes obsolete because the master comment was moved or deleted, this inconsistency will be self-evident because developers won’t find the comment at the indicated place; they can use revision control history to find out what happened to the comment and then update the reference. In contrast, if the documentation is duplicated and some of the copies don’t get updated, there will be no indication to developers that they are using stale information.\n\n> 如果没有一个“明显的”地方来放置特定的文档，开发人员可以找到它，那么创建一个 designNotes 文件，如第 13.7 节所述。或者，选择最好的地方，把文档放在那里。另外，在引用中心位置的其他地方添加简短的注释:“查看 xyz 中的注释以了解下面代码的解释。“如果引用因为主注释被移动或删除而变得过时，这种不一致性将是不言而喻的，因为开发人员将无法在指定的位置找到注释;他们可以使用修订控制历史记录来查找注释发生了什么，然后更新引用。相反，如果文档是重复的，并且一些副本没有得到更新，那么开发人员就不会知道他们使用的是陈旧的信息。\n\nDon’t redocument one module’s design decisions in another module. For example, don’t put comments before a method call that explain what happens in the called method. If readers want to know, they should look at the interface comments for the method. Good development tools will usually provide this information automatically, for example, by displaying the interface comments for a method if you select the method’s name or hover the mouse over it. Try to make it easy for developers to find appropriate documentation, but don’t do it by repeating the documentation.\n\n> 不要在另一个模块中记录一个模块的设计决策。例如，不要在方法调用前添加注释，以解释被调用方法中发生的情况。如果读者想知道，他们应该查看该方法的界面注释。好的开发工具通常会自动提供此信息，例如，如果您选择了方法的名称或将鼠标悬停在该方法的名称上，则将显示该方法的界面注释。尝试使开发人员容易找到合适的文档，但是不要重复文档。\n\nIf information is already documented someplace outside your program, don’t repeat the documentation inside the program; just reference the external documentation. For example, if you write a class that implements the HTTP protocol, there’s no need for you to describe the HTTP protocol inside your code. There are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources. Another example is features that are already documented in a user manual. Suppose you are writing a program that implements a collection of commands, with one method responsible for implementing each command. If there is a user manual that describes those commands, there’s no need to duplicate this information in the code. Instead, include a short note like the following in the interface comment for each command method:\n\n> 如果信息已经在程序之外的某个地方记录了，不要在程序内部重复记录;只需参考外部文档。例如，如果您编写一个实现 HTTP 协议的类，那么就不需要在代码中描述 HTTP 协议。在网上已经有很多关于这个文档的来源;只需在您的代码中添加一个简短的注释，并为其中一个源添加一个 URL。另一个例子是已经在用户手册中记录的特性。假设您正在编写一个实现命令集合的程序，其中有一个负责实现每个命令的方法。如果有描述这些命令的用户手册，就不需要在代码中重复这些信息。相反，在每个命令方法的接口注释中包含如下简短说明:\n\n```java\n// Implements the Foo command; see the user manual for details.\n```\n\nIt’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.\n\n> 读者可以轻松找到理解代码所需的所有文档，这一点很重要，但这并不意味着您必须编写所有这些文档。\n\n## 16.5 Maintaining comments: check the diffs 维护注释：检查差异\n\nOne good way to make sure documentation stays up to date is to take a few minutes before committing a change to your revision control system to scan over all the changes for that commit; make sure that each change is properly reflected in the documentation. These pre-commit scans will also detect several other problems, such as accidentally leaving debugging code in the system or failing to fix TODO items.\n\n> 确保文档保持最新状态的一种好方法是，在将更改提交到修订控制系统之前需要花费几分钟，以扫描该提交的所有更改。确保文档中正确反映了每个更改。这些预先提交的扫描还将检测其他一些问题，例如意外地将调试代码留在系统中或无法修复 TODO 项目。\n\n## 16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护\n\nOne final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code. These comments do not reflect the details of the code, so they will not be affected by minor code changes; only changes in overall behavior will affect these comments. Of course, as discussed in Chapter 13, some comments do need to be detailed and precise. But in general, the comments that are most useful (they don’t simply repeat the code) are also easiest to maintain.\n\n> 关于维护文档的最后一个想法：如果注释比代码更高级，更抽象，则注释更易于维护。这些注释不反映代码的详细信息，因此它们不会受到代码更改的影响；只有整体行为的变化才会影响这些评论。当然，正如第 13 章所讨论的那样，某些注释的确需要详细和精确。但总的来说，最有用的注释（它们不只是重复代码）也最容易维护。\n","slug":"软件设计的哲学-ch16","published":1,"updated":"2021-02-16T04:53:15.271Z","_id":"ckl6pcc1r0008s4iy6afe3r69","comments":1,"layout":"post","photos":[],"link":"","content":"<p>修改现有的代码</p>\n<a id=\"more\"></a>\n<h1 id=\"第-16-章-修改现有的代码\"><a href=\"#第-16-章-修改现有的代码\" class=\"headerlink\" title=\"第 16 章 修改现有的代码\"></a>第 16 章 修改现有的代码</h1><blockquote>\n<p>Chapter 16 Modifying Existing Code</p>\n</blockquote>\n<p>Chapter 1 described how software development is iterative and incremental. A large software system develops through a series of evolutionary stages, where each stage adds new capabilities and modifies existing modules. This means that a system’s design is constantly evolving. It isn’t possible to conceive the right design for a system at the outset; the design of a mature system is determined more by changes made during the system’s evolution than by any initial conception. Previous chapters described how to squeeze out complexity during the initial design and implementation; this chapter discusses how to keep complexity from creeping in as the system evolves.</p>\n<blockquote>\n<p>第 1 章介绍了软件开发是如何迭代和增量的。大型软件系统是通过一系列演化阶段开发的，其中每个阶段都添加了新功能并修改了现有模块。这意味着系统的设计在不断发展。一开始就不可能为系统设计正确的设计。一个成熟的系统的设计更多地取决于系统演化过程中所做的更改，而不是任何初始概念。前面的章节描述了如何在初始设计和实现过程中降低复杂性。本章讨论如何防止随着系统的发展而增加复杂性。</p>\n</blockquote>\n<h2 id=\"16-1-Stay-strategic-保持战略\"><a href=\"#16-1-Stay-strategic-保持战略\" class=\"headerlink\" title=\"16.1 Stay strategic 保持战略\"></a>16.1 Stay strategic 保持战略</h2><p>Chapter 3 introduced the distinction between tactical programming and strategic programming: in tactical programming, the primary goal is to get something working quickly, even if that results in additional complexity; in strategic programming, the most important goal is to produce a great system design. The tactical approach very quickly leads to a messy system design. If you want to have a system that is easy to maintain and enhance, then “working” isn’t a high enough standard; you have to prioritize design and think strategically. This idea also applies when you are modifying existing code.</p>\n<blockquote>\n<p>第 3 章介绍了战术编程和战略编程之间的区别：在战术编程中，主要目标是使某些事物快速工作，即使这会导致额外的复杂性；在战略编程中，最重要的目标是进行出色的系统设计。战术方法很快导致系统设计混乱。如果您想要一个易于维护和增强的系统，那么“工作”还不够高。您必须优先考虑设计并进行战略思考。当您修改现有代码时，此想法也适用。</p>\n</blockquote>\n<p>Unfortunately, when developers go into existing code to make changes such as bug fixes or new features, they don’t usually think strategically. A typical mindset is “what is the smallest possible change I can make that does what I need?” Sometimes developers justify this because they are not comfortable with the code being modified; they worry that larger changes carry a greater risk of introducing new bugs. However, this results in tactical programming. Each one of these minimal changes introduces a few special cases, dependencies, or other forms of complexity. As a result, the system design gets just a bit worse, and the problems accumulate with each step in the system’s evolution.</p>\n<blockquote>\n<p>不幸的是，当开发人员进入现有代码以进行更改（例如错误修复或新功能）时，他们通常不会从战略角度进行思考。一个典型的心态是“我能做出我需要做的最小的改变是什么？” 有时，开发人员证明这是合理的，因为他们对修改的代码不满意。他们担心较大的更改会带来更大的引入新错误的风险。但是，这导致了战术编程。这些最小的变化中的每一个都会引入一些特殊情况，依赖性或其他形式的复杂性。结果，系统设计变得更糟，并且问题随着系统发展的每个步骤而累积。</p>\n</blockquote>\n<p>If you want to maintain a clean design for a system, you must take a strategic approach when modifying existing code. Ideally, when you have finished with each change, the system will have the structure it would have had if you had designed it from the start with that change in mind. To achieve this goal, you must resist the temptation to make a quick fix. Instead, think about whether the current system design is still the best one, in light of the desired change. If not, refactor the system so that you end up with the best possible design. With this approach, the system design improves with every modification.</p>\n<blockquote>\n<p>如果要维护系统的简洁设计，则在修改现有代码时必须采取战略性方法。理想情况下，当您完成每次更改时，如果您从一开始就考虑到更改就设计了系统，那么系统将具有它应该具有的结构。为了实现此目标，您必须抵制诱惑以快速解决问题。相反，请根据所需的更改来考虑当前的系统设计是否仍然是最佳的。如果不是，请重构系统，以便最终获得最佳设计。通过这种方法，每次修改都会改善系统设计。</p>\n</blockquote>\n<p>This is also an example of the investment mindset introduced on page 15: if you invest a little extra time to refactor and improve the system design, you’ll end up with a cleaner system. This will speed up development, and you will recoup the effort that you invested in the refactoring. Even if your particular change doesn’t require refactoring, you should still be on the lookout for design imperfections that you can fix while you’re in the code. Whenever you modify any code, try to find a way to improve the system design at least a little bit in the process. If you’re not making the design better, you are probably making it worse.</p>\n<blockquote>\n<p>这也是第 15 页介绍的投资心态的一个示例：如果您花费一些额外的时间来重构和改善系统设计，您将得到一个更干净的系统。这将加快开发速度，您将收回在重构方面投入的精力。即使您的特定更改不需要重构，您仍然应该注意在代码中可以修复的设计缺陷。每当您修改任何代码时，都尝试在该过程中至少找到一点方法来改进系统设计。如果您没有使设计更好，则可能会使它变得更糟。</p>\n</blockquote>\n<p>As discussed in Chapter 3, an investment mindset sometimes conflicts with the realities of commercial software development. If refactoring the system “the right way” would take three months but a quick and dirty fix would take only two hours, you may have to take the quick and dirty approach, particularly if you are working against a tight deadline. Or, if refactoring the system would create incompatibilities that affect many other people and teams, then the refactoring may not be practical.</p>\n<blockquote>\n<p>如第 3 章所述，投资心态有时与商业软件开发的现实相冲突。如果“正确的方式”重构系统需要三个月，而快速且肮脏的修复仅需两个小时，则您可能必须采取快速而肮脏的方法，尤其是在紧迫的期限内工作时。或者，如果重构系统会造成影响许多其他人员和团队的不兼容性，则重构可能不切实际。</p>\n</blockquote>\n<p>Nonetheless, you should resist these compromises as much as possible. Ask yourself “Is this the best I can possibly do to create a clean system design, given my current constraints?” Perhaps there’s an alternative approach that would be almost as clean as the 3-month refactoring but could be done in a couple of days? Or, if you can’t afford to do a large refactoring now, get your boss to allocate time for you to come back to it after the current deadline. Every development organization should plan to spend a small fraction of its total effort on cleanup and refactoring; this work will pay for itself over the long run.</p>\n<blockquote>\n<p>但是，您应尽可能抵制这些妥协。问问自己：“考虑到我目前的限制，这是否是我能做的最好的工作来创建一个干净的系统设计？” 也许有一种替代方法几乎可以像 3 个月的重构一样干净，但是可以在几天内完成？或者，如果您现在负担不起大型重构，请让您的老板为您分配时间，让您在当前截止日期之后恢复到原来的水平。每个开发组织都应计划将其全部工作的一小部分用于清理和重构；从长远来看，这项工作将收回成本。</p>\n</blockquote>\n<h2 id=\"16-2-Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近\"><a href=\"#16-2-Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近\" class=\"headerlink\" title=\"16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近\"></a>16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近</h2><p>When you change existing code, there’s a good chance that the changes will invalidate some of the existing comments. It’s easy to forget to update comments when you modify code, which results in comments that are no longer accurate. Inaccurate comments are frustrating to readers, and if there are very many of them, readers begin to distrust all of the comments. Fortunately, with a little discipline and a couple of guiding rules, it’s possible to keep comments up-to-date without a huge effort. This section and the following ones put forth some specific techniques.</p>\n<blockquote>\n<p>当您更改现有代码时，更改很有可能会使某些现有注释无效。修改代码时，很容易忘记更新注释，从而导致注释不再准确。不准确的评论使读者感到沮丧，如果评论太多，读者就会开始不信任所有评论。幸运的是，只要有一点纪律和一些指导规则，就可以在不付出巨大努力的情况下使评论保持最新。本节及随后的部分提出了一些特定的技术。</p>\n</blockquote>\n<p>The best way to ensure that comments get updated is to position them close to the code they describe, so developers will see them when they change the code. The farther a comment is from its associated code, the less likely it is that it will be updated properly. For example, the best place for a method’s interface comment is in the code file, right next to the body of the method. Any changes to the method will involve this code, so the developer is likely to see the interface comments and update them if needed.</p>\n<blockquote>\n<p>确保注释更新的最佳方法是将注释放置在它们描述的代码附近，以便开发人员在更改代码时可以看到它们。注释离其关联的代码越远，正确更新的可能性就越小。例如，方法界面注释的最佳位置是在代码文件中，紧靠该方法主体的位置。对方法的任何更改都将涉及此代码，因此开发人员很可能会看到界面注释，并在需要时进行更新。</p>\n</blockquote>\n<p>An alternative for languages like C and C++ that have separate code and header files, is to place the interface comments next to the method’s declaration in the .h file. However, this is a long way from the code; developers won’t see those comments when modifying the method’s body, and it takes additional work to open a different file and find the interface comments to update them. Some might argue that interface comments should go in header files so that users can learn how to use an abstraction without having to look at the code file. However, users should not need to read either code or header files; they should get their information from documentation compiled by tools such as Doxygen or Javadoc. In addition, many IDEs will extract and present documentation to users, such as by displaying a method’s documentation when the method’s name is typed. Given tools such as these, the documentation should be located in the place that is most convenient for developers working on the code.</p>\n<blockquote>\n<p>对于 C 和 C ++等具有单独的代码和头文件的语言，一种替代方法是将接口注释放在.h 文件中方法声明的旁边。但是，这距离代码还有很长的路要走。开发人员在修改方法的主体时将看不到这些注释，因此需要打开其他文件并查找接口注释来更新它们，这需要额外的工作。有人可能会争辩说接口注释应该放在头文件中，以便用户可以不必看代码文件就可以学习如何使用抽象。但是，用户无需读取代码或头文件；他们应该从由 Doxygen 或 Javadoc 等工具编译的文档中获取信息。此外，许多 IDE 都会提取文档并将其呈现给用户，例如在键入方法名称时显示方法的文档。给定诸如此类的工具，文档应位于对开发人员进行代码开发最方便的位置。</p>\n</blockquote>\n<p>When writing implementation comments, don’t put all the comments for an entire method at the top of the method. Spread them out, pushing each comment down to the narrowest scope that includes all of the code referred to by the comment. For example, if a method has three major phases, don’t write one comment at the top of the method that describes all of the phases in detail. Instead, write a separate comment for each phase and position that comment just above the first line of code in that phase. On the other hand, it can also be helpful to have a comment at the top of a method’s implementation that describes the overall strategy, like this:</p>\n<blockquote>\n<p>在编写实现注释时，不要将整个方法的所有注释放在方法的顶部。展开它们，将每个注释推到最狭窄的范围，其中包括该注释所引用的所有代码。例如，如果一种方法具有三个主要阶段，则不要在方法的顶部写一个详细描述所有阶段的注释。而是为每个阶段编写一个单独的注释，并将该注释放置在该阶段的第一行代码的正上方。另一方面，在描述总体策略的方法实现的顶部添加注释也可能会有所帮助，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  We proceed in three phases:</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 1: Find feasible candidates</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 2: Assign each candidate a score</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 3: Choose the best, and remove it</span></span><br></pre></td></tr></table></figure>\n\n<p>Additional details can be documented just above the code for each phase.</p>\n<blockquote>\n<p>每个阶段的代码上方都可以记录其他详细信息。</p>\n</blockquote>\n<p>In general, the farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidated by code changes).</p>\n<blockquote>\n<p>通常，注释离描述的代码越远，注释应该越抽象（这减少了注释因代码更改而无效的可能性）。</p>\n</blockquote>\n<h2 id=\"16-3-Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志\"><a href=\"#16-3-Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志\" class=\"headerlink\" title=\"16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志\"></a>16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志</h2><p>A common mistake when modifying code is to put detailed information about the change in the commit message for the source code repository, but then not to document it in the code. Although commit messages can be browsed in the future by scanning the repository’s log, a developer who needs the information is unlikely to think of scanning the repository log. Even if they do scan the log, it will be tedious to find the right log message.</p>\n<blockquote>\n<p>修改代码时，常见的错误是将有关更改的详细信息放入源代码存储库的提交消息中，而不是将其记录在代码中。尽管将来可以通过扫描存储库的日志来浏览提交消息，但是需要该信息的开发人员不太可能考虑扫描存储库的日志。即使他们确实扫描了日志，也很难找到正确的日志消息。</p>\n</blockquote>\n<p>When writing a commit message, ask yourself whether developers will need to use that information in the future. If so, then document this information in the code. An example is a commit message describing a subtle problem that motivated a code change. If this isn’t documented in the code, then a developer might come along later and undo the change without realizing that they have re-created a bug. If you want to include a copy of this information in the commit message as well, that’s fine, but the most important thing is to get it in the code. This illustrates the principle of placing documentation in the place where developers are most likely to see it; the commit log is rarely that place.</p>\n<blockquote>\n<p>在编写提交消息时，请问自己将来开发人员是否需要使用该信息。如果是这样，则在代码中记录此信息。一个示例是提交消息，描述了导致代码更改的细微问题。如果代码中未对此进行记录，则开发人员可能会稍后再提出并撤消更改，而不会意识到他们已经重新创建了错误。如果您也想在提交消息中包含此信息的副本，那很好，但是最重要的是在代码中获取它。这说明了将文档放置在开发人员最有可能看到它的地方的原理；提交日志很少在那个地方。</p>\n</blockquote>\n<h2 id=\"16-4-Maintaining-comments-avoid-duplication-维护注释：避免重复\"><a href=\"#16-4-Maintaining-comments-avoid-duplication-维护注释：避免重复\" class=\"headerlink\" title=\"16.4 Maintaining comments: avoid duplication 维护注释：避免重复\"></a>16.4 Maintaining comments: avoid duplication 维护注释：避免重复</h2><p>The second technique for keeping comments up to date is to avoid duplication. If documentation is duplicated, it is more difficult for developers to find and update all of the relevant copies. Instead, try to document each design decision exactly once. If there are multiple places in the code that are affected by a particular decision, don’t repeat the documentation at each of these points. Instead, find the most obvious single place to put the documentation. For example, suppose there is tricky behavior related to a variable, which affects several different places where the variable is used. You can document that behavior in the comment next to the variable’s declaration. This is a natural place that developers are likely to check if they’re having trouble understanding code that uses the variable.</p>\n<blockquote>\n<p>保持评论最新的第二种技术是避免重复。如果文档重复，那么开发人员将很难找到并更新所有相关副本。相反，请尝试仅一次记录每个设计决策。如果代码中有多个地方受某个特定决定的影响，请不要在所有这些地方重复文档。相反，找到放置文档最明显的位置。例如，假设存在与变量相关的棘手行为，这会影响使用变量的几个不同位置。您可以在变量声明旁边的注释中记录该行为。这是很自然的地方，开发人员可能会检查他们是否在理解使用该变量的代码时遇到麻烦。</p>\n</blockquote>\n<p>If there is no “obvious” single place to put a particular piece of documentation where developers will find it, create a designNotes file as described in Section 13.7. Or, pick the best of the available places and put the documentation there. In addition, add short comments in the other places that refer to the central location: “See the comment in xyz for an explanation of the code below.” If the reference becomes obsolete because the master comment was moved or deleted, this inconsistency will be self-evident because developers won’t find the comment at the indicated place; they can use revision control history to find out what happened to the comment and then update the reference. In contrast, if the documentation is duplicated and some of the copies don’t get updated, there will be no indication to developers that they are using stale information.</p>\n<blockquote>\n<p>如果没有一个“明显的”地方来放置特定的文档，开发人员可以找到它，那么创建一个 designNotes 文件，如第 13.7 节所述。或者，选择最好的地方，把文档放在那里。另外，在引用中心位置的其他地方添加简短的注释:“查看 xyz 中的注释以了解下面代码的解释。“如果引用因为主注释被移动或删除而变得过时，这种不一致性将是不言而喻的，因为开发人员将无法在指定的位置找到注释;他们可以使用修订控制历史记录来查找注释发生了什么，然后更新引用。相反，如果文档是重复的，并且一些副本没有得到更新，那么开发人员就不会知道他们使用的是陈旧的信息。</p>\n</blockquote>\n<p>Don’t redocument one module’s design decisions in another module. For example, don’t put comments before a method call that explain what happens in the called method. If readers want to know, they should look at the interface comments for the method. Good development tools will usually provide this information automatically, for example, by displaying the interface comments for a method if you select the method’s name or hover the mouse over it. Try to make it easy for developers to find appropriate documentation, but don’t do it by repeating the documentation.</p>\n<blockquote>\n<p>不要在另一个模块中记录一个模块的设计决策。例如，不要在方法调用前添加注释，以解释被调用方法中发生的情况。如果读者想知道，他们应该查看该方法的界面注释。好的开发工具通常会自动提供此信息，例如，如果您选择了方法的名称或将鼠标悬停在该方法的名称上，则将显示该方法的界面注释。尝试使开发人员容易找到合适的文档，但是不要重复文档。</p>\n</blockquote>\n<p>If information is already documented someplace outside your program, don’t repeat the documentation inside the program; just reference the external documentation. For example, if you write a class that implements the HTTP protocol, there’s no need for you to describe the HTTP protocol inside your code. There are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources. Another example is features that are already documented in a user manual. Suppose you are writing a program that implements a collection of commands, with one method responsible for implementing each command. If there is a user manual that describes those commands, there’s no need to duplicate this information in the code. Instead, include a short note like the following in the interface comment for each command method:</p>\n<blockquote>\n<p>如果信息已经在程序之外的某个地方记录了，不要在程序内部重复记录;只需参考外部文档。例如，如果您编写一个实现 HTTP 协议的类，那么就不需要在代码中描述 HTTP 协议。在网上已经有很多关于这个文档的来源;只需在您的代码中添加一个简短的注释，并为其中一个源添加一个 URL。另一个例子是已经在用户手册中记录的特性。假设您正在编写一个实现命令集合的程序，其中有一个负责实现每个命令的方法。如果有描述这些命令的用户手册，就不需要在代码中重复这些信息。相反，在每个命令方法的接口注释中包含如下简短说明:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Implements the Foo command; see the user manual for details.</span></span><br></pre></td></tr></table></figure>\n\n<p>It’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.</p>\n<blockquote>\n<p>读者可以轻松找到理解代码所需的所有文档，这一点很重要，但这并不意味着您必须编写所有这些文档。</p>\n</blockquote>\n<h2 id=\"16-5-Maintaining-comments-check-the-diffs-维护注释：检查差异\"><a href=\"#16-5-Maintaining-comments-check-the-diffs-维护注释：检查差异\" class=\"headerlink\" title=\"16.5 Maintaining comments: check the diffs 维护注释：检查差异\"></a>16.5 Maintaining comments: check the diffs 维护注释：检查差异</h2><p>One good way to make sure documentation stays up to date is to take a few minutes before committing a change to your revision control system to scan over all the changes for that commit; make sure that each change is properly reflected in the documentation. These pre-commit scans will also detect several other problems, such as accidentally leaving debugging code in the system or failing to fix TODO items.</p>\n<blockquote>\n<p>确保文档保持最新状态的一种好方法是，在将更改提交到修订控制系统之前需要花费几分钟，以扫描该提交的所有更改。确保文档中正确反映了每个更改。这些预先提交的扫描还将检测其他一些问题，例如意外地将调试代码留在系统中或无法修复 TODO 项目。</p>\n</blockquote>\n<h2 id=\"16-6-Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护\"><a href=\"#16-6-Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护\" class=\"headerlink\" title=\"16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护\"></a>16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护</h2><p>One final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code. These comments do not reflect the details of the code, so they will not be affected by minor code changes; only changes in overall behavior will affect these comments. Of course, as discussed in Chapter 13, some comments do need to be detailed and precise. But in general, the comments that are most useful (they don’t simply repeat the code) are also easiest to maintain.</p>\n<blockquote>\n<p>关于维护文档的最后一个想法：如果注释比代码更高级，更抽象，则注释更易于维护。这些注释不反映代码的详细信息，因此它们不会受到代码更改的影响；只有整体行为的变化才会影响这些评论。当然，正如第 13 章所讨论的那样，某些注释的确需要详细和精确。但总的来说，最有用的注释（它们不只是重复代码）也最容易维护。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>修改现有的代码</p>","more":"<h1 id=\"第-16-章-修改现有的代码\"><a href=\"#第-16-章-修改现有的代码\" class=\"headerlink\" title=\"第 16 章 修改现有的代码\"></a>第 16 章 修改现有的代码</h1><blockquote>\n<p>Chapter 16 Modifying Existing Code</p>\n</blockquote>\n<p>Chapter 1 described how software development is iterative and incremental. A large software system develops through a series of evolutionary stages, where each stage adds new capabilities and modifies existing modules. This means that a system’s design is constantly evolving. It isn’t possible to conceive the right design for a system at the outset; the design of a mature system is determined more by changes made during the system’s evolution than by any initial conception. Previous chapters described how to squeeze out complexity during the initial design and implementation; this chapter discusses how to keep complexity from creeping in as the system evolves.</p>\n<blockquote>\n<p>第 1 章介绍了软件开发是如何迭代和增量的。大型软件系统是通过一系列演化阶段开发的，其中每个阶段都添加了新功能并修改了现有模块。这意味着系统的设计在不断发展。一开始就不可能为系统设计正确的设计。一个成熟的系统的设计更多地取决于系统演化过程中所做的更改，而不是任何初始概念。前面的章节描述了如何在初始设计和实现过程中降低复杂性。本章讨论如何防止随着系统的发展而增加复杂性。</p>\n</blockquote>\n<h2 id=\"16-1-Stay-strategic-保持战略\"><a href=\"#16-1-Stay-strategic-保持战略\" class=\"headerlink\" title=\"16.1 Stay strategic 保持战略\"></a>16.1 Stay strategic 保持战略</h2><p>Chapter 3 introduced the distinction between tactical programming and strategic programming: in tactical programming, the primary goal is to get something working quickly, even if that results in additional complexity; in strategic programming, the most important goal is to produce a great system design. The tactical approach very quickly leads to a messy system design. If you want to have a system that is easy to maintain and enhance, then “working” isn’t a high enough standard; you have to prioritize design and think strategically. This idea also applies when you are modifying existing code.</p>\n<blockquote>\n<p>第 3 章介绍了战术编程和战略编程之间的区别：在战术编程中，主要目标是使某些事物快速工作，即使这会导致额外的复杂性；在战略编程中，最重要的目标是进行出色的系统设计。战术方法很快导致系统设计混乱。如果您想要一个易于维护和增强的系统，那么“工作”还不够高。您必须优先考虑设计并进行战略思考。当您修改现有代码时，此想法也适用。</p>\n</blockquote>\n<p>Unfortunately, when developers go into existing code to make changes such as bug fixes or new features, they don’t usually think strategically. A typical mindset is “what is the smallest possible change I can make that does what I need?” Sometimes developers justify this because they are not comfortable with the code being modified; they worry that larger changes carry a greater risk of introducing new bugs. However, this results in tactical programming. Each one of these minimal changes introduces a few special cases, dependencies, or other forms of complexity. As a result, the system design gets just a bit worse, and the problems accumulate with each step in the system’s evolution.</p>\n<blockquote>\n<p>不幸的是，当开发人员进入现有代码以进行更改（例如错误修复或新功能）时，他们通常不会从战略角度进行思考。一个典型的心态是“我能做出我需要做的最小的改变是什么？” 有时，开发人员证明这是合理的，因为他们对修改的代码不满意。他们担心较大的更改会带来更大的引入新错误的风险。但是，这导致了战术编程。这些最小的变化中的每一个都会引入一些特殊情况，依赖性或其他形式的复杂性。结果，系统设计变得更糟，并且问题随着系统发展的每个步骤而累积。</p>\n</blockquote>\n<p>If you want to maintain a clean design for a system, you must take a strategic approach when modifying existing code. Ideally, when you have finished with each change, the system will have the structure it would have had if you had designed it from the start with that change in mind. To achieve this goal, you must resist the temptation to make a quick fix. Instead, think about whether the current system design is still the best one, in light of the desired change. If not, refactor the system so that you end up with the best possible design. With this approach, the system design improves with every modification.</p>\n<blockquote>\n<p>如果要维护系统的简洁设计，则在修改现有代码时必须采取战略性方法。理想情况下，当您完成每次更改时，如果您从一开始就考虑到更改就设计了系统，那么系统将具有它应该具有的结构。为了实现此目标，您必须抵制诱惑以快速解决问题。相反，请根据所需的更改来考虑当前的系统设计是否仍然是最佳的。如果不是，请重构系统，以便最终获得最佳设计。通过这种方法，每次修改都会改善系统设计。</p>\n</blockquote>\n<p>This is also an example of the investment mindset introduced on page 15: if you invest a little extra time to refactor and improve the system design, you’ll end up with a cleaner system. This will speed up development, and you will recoup the effort that you invested in the refactoring. Even if your particular change doesn’t require refactoring, you should still be on the lookout for design imperfections that you can fix while you’re in the code. Whenever you modify any code, try to find a way to improve the system design at least a little bit in the process. If you’re not making the design better, you are probably making it worse.</p>\n<blockquote>\n<p>这也是第 15 页介绍的投资心态的一个示例：如果您花费一些额外的时间来重构和改善系统设计，您将得到一个更干净的系统。这将加快开发速度，您将收回在重构方面投入的精力。即使您的特定更改不需要重构，您仍然应该注意在代码中可以修复的设计缺陷。每当您修改任何代码时，都尝试在该过程中至少找到一点方法来改进系统设计。如果您没有使设计更好，则可能会使它变得更糟。</p>\n</blockquote>\n<p>As discussed in Chapter 3, an investment mindset sometimes conflicts with the realities of commercial software development. If refactoring the system “the right way” would take three months but a quick and dirty fix would take only two hours, you may have to take the quick and dirty approach, particularly if you are working against a tight deadline. Or, if refactoring the system would create incompatibilities that affect many other people and teams, then the refactoring may not be practical.</p>\n<blockquote>\n<p>如第 3 章所述，投资心态有时与商业软件开发的现实相冲突。如果“正确的方式”重构系统需要三个月，而快速且肮脏的修复仅需两个小时，则您可能必须采取快速而肮脏的方法，尤其是在紧迫的期限内工作时。或者，如果重构系统会造成影响许多其他人员和团队的不兼容性，则重构可能不切实际。</p>\n</blockquote>\n<p>Nonetheless, you should resist these compromises as much as possible. Ask yourself “Is this the best I can possibly do to create a clean system design, given my current constraints?” Perhaps there’s an alternative approach that would be almost as clean as the 3-month refactoring but could be done in a couple of days? Or, if you can’t afford to do a large refactoring now, get your boss to allocate time for you to come back to it after the current deadline. Every development organization should plan to spend a small fraction of its total effort on cleanup and refactoring; this work will pay for itself over the long run.</p>\n<blockquote>\n<p>但是，您应尽可能抵制这些妥协。问问自己：“考虑到我目前的限制，这是否是我能做的最好的工作来创建一个干净的系统设计？” 也许有一种替代方法几乎可以像 3 个月的重构一样干净，但是可以在几天内完成？或者，如果您现在负担不起大型重构，请让您的老板为您分配时间，让您在当前截止日期之后恢复到原来的水平。每个开发组织都应计划将其全部工作的一小部分用于清理和重构；从长远来看，这项工作将收回成本。</p>\n</blockquote>\n<h2 id=\"16-2-Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近\"><a href=\"#16-2-Maintaining-comments-keep-the-comments-near-the-code-维护注释：将注释保留在代码附近\" class=\"headerlink\" title=\"16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近\"></a>16.2 Maintaining comments: keep the comments near the code 维护注释：将注释保留在代码附近</h2><p>When you change existing code, there’s a good chance that the changes will invalidate some of the existing comments. It’s easy to forget to update comments when you modify code, which results in comments that are no longer accurate. Inaccurate comments are frustrating to readers, and if there are very many of them, readers begin to distrust all of the comments. Fortunately, with a little discipline and a couple of guiding rules, it’s possible to keep comments up-to-date without a huge effort. This section and the following ones put forth some specific techniques.</p>\n<blockquote>\n<p>当您更改现有代码时，更改很有可能会使某些现有注释无效。修改代码时，很容易忘记更新注释，从而导致注释不再准确。不准确的评论使读者感到沮丧，如果评论太多，读者就会开始不信任所有评论。幸运的是，只要有一点纪律和一些指导规则，就可以在不付出巨大努力的情况下使评论保持最新。本节及随后的部分提出了一些特定的技术。</p>\n</blockquote>\n<p>The best way to ensure that comments get updated is to position them close to the code they describe, so developers will see them when they change the code. The farther a comment is from its associated code, the less likely it is that it will be updated properly. For example, the best place for a method’s interface comment is in the code file, right next to the body of the method. Any changes to the method will involve this code, so the developer is likely to see the interface comments and update them if needed.</p>\n<blockquote>\n<p>确保注释更新的最佳方法是将注释放置在它们描述的代码附近，以便开发人员在更改代码时可以看到它们。注释离其关联的代码越远，正确更新的可能性就越小。例如，方法界面注释的最佳位置是在代码文件中，紧靠该方法主体的位置。对方法的任何更改都将涉及此代码，因此开发人员很可能会看到界面注释，并在需要时进行更新。</p>\n</blockquote>\n<p>An alternative for languages like C and C++ that have separate code and header files, is to place the interface comments next to the method’s declaration in the .h file. However, this is a long way from the code; developers won’t see those comments when modifying the method’s body, and it takes additional work to open a different file and find the interface comments to update them. Some might argue that interface comments should go in header files so that users can learn how to use an abstraction without having to look at the code file. However, users should not need to read either code or header files; they should get their information from documentation compiled by tools such as Doxygen or Javadoc. In addition, many IDEs will extract and present documentation to users, such as by displaying a method’s documentation when the method’s name is typed. Given tools such as these, the documentation should be located in the place that is most convenient for developers working on the code.</p>\n<blockquote>\n<p>对于 C 和 C ++等具有单独的代码和头文件的语言，一种替代方法是将接口注释放在.h 文件中方法声明的旁边。但是，这距离代码还有很长的路要走。开发人员在修改方法的主体时将看不到这些注释，因此需要打开其他文件并查找接口注释来更新它们，这需要额外的工作。有人可能会争辩说接口注释应该放在头文件中，以便用户可以不必看代码文件就可以学习如何使用抽象。但是，用户无需读取代码或头文件；他们应该从由 Doxygen 或 Javadoc 等工具编译的文档中获取信息。此外，许多 IDE 都会提取文档并将其呈现给用户，例如在键入方法名称时显示方法的文档。给定诸如此类的工具，文档应位于对开发人员进行代码开发最方便的位置。</p>\n</blockquote>\n<p>When writing implementation comments, don’t put all the comments for an entire method at the top of the method. Spread them out, pushing each comment down to the narrowest scope that includes all of the code referred to by the comment. For example, if a method has three major phases, don’t write one comment at the top of the method that describes all of the phases in detail. Instead, write a separate comment for each phase and position that comment just above the first line of code in that phase. On the other hand, it can also be helpful to have a comment at the top of a method’s implementation that describes the overall strategy, like this:</p>\n<blockquote>\n<p>在编写实现注释时，不要将整个方法的所有注释放在方法的顶部。展开它们，将每个注释推到最狭窄的范围，其中包括该注释所引用的所有代码。例如，如果一种方法具有三个主要阶段，则不要在方法的顶部写一个详细描述所有阶段的注释。而是为每个阶段编写一个单独的注释，并将该注释放置在该阶段的第一行代码的正上方。另一方面，在描述总体策略的方法实现的顶部添加注释也可能会有所帮助，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  We proceed in three phases:</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 1: Find feasible candidates</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 2: Assign each candidate a score</span></span><br><span class=\"line\"><span class=\"comment\">//  Phase 3: Choose the best, and remove it</span></span><br></pre></td></tr></table></figure>\n\n<p>Additional details can be documented just above the code for each phase.</p>\n<blockquote>\n<p>每个阶段的代码上方都可以记录其他详细信息。</p>\n</blockquote>\n<p>In general, the farther a comment is from the code it describes, the more abstract it should be (this reduces the likelihood that the comment will be invalidated by code changes).</p>\n<blockquote>\n<p>通常，注释离描述的代码越远，注释应该越抽象（这减少了注释因代码更改而无效的可能性）。</p>\n</blockquote>\n<h2 id=\"16-3-Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志\"><a href=\"#16-3-Comments-belong-in-the-code-not-the-commit-log-注释属于代码，而不是提交日志\" class=\"headerlink\" title=\"16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志\"></a>16.3 Comments belong in the code, not the commit log 注释属于代码，而不是提交日志</h2><p>A common mistake when modifying code is to put detailed information about the change in the commit message for the source code repository, but then not to document it in the code. Although commit messages can be browsed in the future by scanning the repository’s log, a developer who needs the information is unlikely to think of scanning the repository log. Even if they do scan the log, it will be tedious to find the right log message.</p>\n<blockquote>\n<p>修改代码时，常见的错误是将有关更改的详细信息放入源代码存储库的提交消息中，而不是将其记录在代码中。尽管将来可以通过扫描存储库的日志来浏览提交消息，但是需要该信息的开发人员不太可能考虑扫描存储库的日志。即使他们确实扫描了日志，也很难找到正确的日志消息。</p>\n</blockquote>\n<p>When writing a commit message, ask yourself whether developers will need to use that information in the future. If so, then document this information in the code. An example is a commit message describing a subtle problem that motivated a code change. If this isn’t documented in the code, then a developer might come along later and undo the change without realizing that they have re-created a bug. If you want to include a copy of this information in the commit message as well, that’s fine, but the most important thing is to get it in the code. This illustrates the principle of placing documentation in the place where developers are most likely to see it; the commit log is rarely that place.</p>\n<blockquote>\n<p>在编写提交消息时，请问自己将来开发人员是否需要使用该信息。如果是这样，则在代码中记录此信息。一个示例是提交消息，描述了导致代码更改的细微问题。如果代码中未对此进行记录，则开发人员可能会稍后再提出并撤消更改，而不会意识到他们已经重新创建了错误。如果您也想在提交消息中包含此信息的副本，那很好，但是最重要的是在代码中获取它。这说明了将文档放置在开发人员最有可能看到它的地方的原理；提交日志很少在那个地方。</p>\n</blockquote>\n<h2 id=\"16-4-Maintaining-comments-avoid-duplication-维护注释：避免重复\"><a href=\"#16-4-Maintaining-comments-avoid-duplication-维护注释：避免重复\" class=\"headerlink\" title=\"16.4 Maintaining comments: avoid duplication 维护注释：避免重复\"></a>16.4 Maintaining comments: avoid duplication 维护注释：避免重复</h2><p>The second technique for keeping comments up to date is to avoid duplication. If documentation is duplicated, it is more difficult for developers to find and update all of the relevant copies. Instead, try to document each design decision exactly once. If there are multiple places in the code that are affected by a particular decision, don’t repeat the documentation at each of these points. Instead, find the most obvious single place to put the documentation. For example, suppose there is tricky behavior related to a variable, which affects several different places where the variable is used. You can document that behavior in the comment next to the variable’s declaration. This is a natural place that developers are likely to check if they’re having trouble understanding code that uses the variable.</p>\n<blockquote>\n<p>保持评论最新的第二种技术是避免重复。如果文档重复，那么开发人员将很难找到并更新所有相关副本。相反，请尝试仅一次记录每个设计决策。如果代码中有多个地方受某个特定决定的影响，请不要在所有这些地方重复文档。相反，找到放置文档最明显的位置。例如，假设存在与变量相关的棘手行为，这会影响使用变量的几个不同位置。您可以在变量声明旁边的注释中记录该行为。这是很自然的地方，开发人员可能会检查他们是否在理解使用该变量的代码时遇到麻烦。</p>\n</blockquote>\n<p>If there is no “obvious” single place to put a particular piece of documentation where developers will find it, create a designNotes file as described in Section 13.7. Or, pick the best of the available places and put the documentation there. In addition, add short comments in the other places that refer to the central location: “See the comment in xyz for an explanation of the code below.” If the reference becomes obsolete because the master comment was moved or deleted, this inconsistency will be self-evident because developers won’t find the comment at the indicated place; they can use revision control history to find out what happened to the comment and then update the reference. In contrast, if the documentation is duplicated and some of the copies don’t get updated, there will be no indication to developers that they are using stale information.</p>\n<blockquote>\n<p>如果没有一个“明显的”地方来放置特定的文档，开发人员可以找到它，那么创建一个 designNotes 文件，如第 13.7 节所述。或者，选择最好的地方，把文档放在那里。另外，在引用中心位置的其他地方添加简短的注释:“查看 xyz 中的注释以了解下面代码的解释。“如果引用因为主注释被移动或删除而变得过时，这种不一致性将是不言而喻的，因为开发人员将无法在指定的位置找到注释;他们可以使用修订控制历史记录来查找注释发生了什么，然后更新引用。相反，如果文档是重复的，并且一些副本没有得到更新，那么开发人员就不会知道他们使用的是陈旧的信息。</p>\n</blockquote>\n<p>Don’t redocument one module’s design decisions in another module. For example, don’t put comments before a method call that explain what happens in the called method. If readers want to know, they should look at the interface comments for the method. Good development tools will usually provide this information automatically, for example, by displaying the interface comments for a method if you select the method’s name or hover the mouse over it. Try to make it easy for developers to find appropriate documentation, but don’t do it by repeating the documentation.</p>\n<blockquote>\n<p>不要在另一个模块中记录一个模块的设计决策。例如，不要在方法调用前添加注释，以解释被调用方法中发生的情况。如果读者想知道，他们应该查看该方法的界面注释。好的开发工具通常会自动提供此信息，例如，如果您选择了方法的名称或将鼠标悬停在该方法的名称上，则将显示该方法的界面注释。尝试使开发人员容易找到合适的文档，但是不要重复文档。</p>\n</blockquote>\n<p>If information is already documented someplace outside your program, don’t repeat the documentation inside the program; just reference the external documentation. For example, if you write a class that implements the HTTP protocol, there’s no need for you to describe the HTTP protocol inside your code. There are already numerous sources for this documentation on the Web; just add a short comment to your code with a URL for one of these sources. Another example is features that are already documented in a user manual. Suppose you are writing a program that implements a collection of commands, with one method responsible for implementing each command. If there is a user manual that describes those commands, there’s no need to duplicate this information in the code. Instead, include a short note like the following in the interface comment for each command method:</p>\n<blockquote>\n<p>如果信息已经在程序之外的某个地方记录了，不要在程序内部重复记录;只需参考外部文档。例如，如果您编写一个实现 HTTP 协议的类，那么就不需要在代码中描述 HTTP 协议。在网上已经有很多关于这个文档的来源;只需在您的代码中添加一个简短的注释，并为其中一个源添加一个 URL。另一个例子是已经在用户手册中记录的特性。假设您正在编写一个实现命令集合的程序，其中有一个负责实现每个命令的方法。如果有描述这些命令的用户手册，就不需要在代码中重复这些信息。相反，在每个命令方法的接口注释中包含如下简短说明:</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Implements the Foo command; see the user manual for details.</span></span><br></pre></td></tr></table></figure>\n\n<p>It’s important that readers can easily find all the documentation needed to understand your code, but that doesn’t mean you have to write all of that documentation.</p>\n<blockquote>\n<p>读者可以轻松找到理解代码所需的所有文档，这一点很重要，但这并不意味着您必须编写所有这些文档。</p>\n</blockquote>\n<h2 id=\"16-5-Maintaining-comments-check-the-diffs-维护注释：检查差异\"><a href=\"#16-5-Maintaining-comments-check-the-diffs-维护注释：检查差异\" class=\"headerlink\" title=\"16.5 Maintaining comments: check the diffs 维护注释：检查差异\"></a>16.5 Maintaining comments: check the diffs 维护注释：检查差异</h2><p>One good way to make sure documentation stays up to date is to take a few minutes before committing a change to your revision control system to scan over all the changes for that commit; make sure that each change is properly reflected in the documentation. These pre-commit scans will also detect several other problems, such as accidentally leaving debugging code in the system or failing to fix TODO items.</p>\n<blockquote>\n<p>确保文档保持最新状态的一种好方法是，在将更改提交到修订控制系统之前需要花费几分钟，以扫描该提交的所有更改。确保文档中正确反映了每个更改。这些预先提交的扫描还将检测其他一些问题，例如意外地将调试代码留在系统中或无法修复 TODO 项目。</p>\n</blockquote>\n<h2 id=\"16-6-Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护\"><a href=\"#16-6-Higher-level-comments-are-easier-to-maintain-更高级的注释更易于维护\" class=\"headerlink\" title=\"16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护\"></a>16.6 Higher-level comments are easier to maintain 更高级的注释更易于维护</h2><p>One final thought on maintaining documentation: comments are easier to maintain if they are higher-level and more abstract than the code. These comments do not reflect the details of the code, so they will not be affected by minor code changes; only changes in overall behavior will affect these comments. Of course, as discussed in Chapter 13, some comments do need to be detailed and precise. But in general, the comments that are most useful (they don’t simply repeat the code) are also easiest to maintain.</p>\n<blockquote>\n<p>关于维护文档的最后一个想法：如果注释比代码更高级，更抽象，则注释更易于维护。这些注释不反映代码的详细信息，因此它们不会受到代码更改的影响；只有整体行为的变化才会影响这些评论。当然，正如第 13 章所讨论的那样，某些注释的确需要详细和精确。但总的来说，最有用的注释（它们不只是重复代码）也最容易维护。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch18","date":"2021-02-17T16:00:00.000Z","_content":"代码应该是显而易见的\n<!-- more -->\n# 第 18 章 代码应该是显而易见的\n\n> Chapter 18 Code Should be Obvious\n\nObscurity is one of the two main causes of complexity described in Section 2.3. Obscurity occurs when important information about a system is not obvious to new developers. The solution to the obscurity problem is to write code in a way that makes it obvious; this chapter discusses some of the factors that make code more or less obvious.\n\n> 晦涩难懂是第 2.3 节中描述的导致复杂性的两个主要原因之一。当有关系统的重要信息对于新开发人员而言并不明显时，就会发生模糊。解决晦涩问题的方法是以显而易见的方式编写代码。本章讨论使代码或多或少变得显而易见的一些因素。\n\nIf code is obvious, it means that someone can read the code quickly, without much thought, and their first guesses about the behavior or meaning of the code will be correct. If code is obvious, a reader doesn’t need to spend much time or effort to gather all the information they need to work with the code. If code is not obvious, then a reader must expend a lot of time and energy to understand it. Not only does this reduce their efficiency, but it also increases the likelihood of misunderstanding and bugs. Obvious code needs fewer comments than nonobvious code.\n\n> 如果代码很明显，则意味着某人可以不加思索地快速阅读该代码，并且他们对代码的行为或含义的最初猜测将是正确的。如果代码很明显，那么读者就不需要花费很多时间或精力来收集他们使用代码所需的所有信息。如果代码不明显，那么读者必须花费大量时间和精力来理解它。这不仅降低了它们的效率，而且还增加了误解和错误的可能性。明显的代码比不明显的代码需要更少的注释。\n\n“Obvious” is in the mind of the reader: it’s easier to notice that someone else’s code is nonobvious than to see problems with your own code. Thus, the best way to determine the obviousness of code is through code reviews. If someone reading your code says it’s not obvious, then it’s not obvious, no matter how clear it may seem to you. By trying to understand what made the code nonobvious, you will learn how to write better code in the future.\n\n> 读者的想法是“显而易见”：注意到别人的代码不明显比发现自己的代码有问题要容易得多。因此，确定代码是否显而易见的最佳方法是通过代码审查。如果有人在阅读您的代码时说它并不明显，那么无论您看起来多么清晰，它也不是显而易见。通过尝试理解什么使代码变得不明显，您将学习如何在将来编写更好的代码。\n\n## 18.1 Things that make code more obvious\n\nTwo of the most important techniques for making code obvious have already been discussed in previous chapters. The first is choosing good names (Chapter 14). Precise and meaningful names clarify the behavior of the code and reduce the need for documentation. If a name is vague or ambiguous, then readers will have read through the code in order to deduce the meaning of the named entity; this is time-consuming and error-prone. The second technique is consistency (Chapter 17). If similar things are always done in similar ways, then readers can recognize patterns they have seen before and immediately draw (safe) conclusions without analyzing the code in detail.\n\n> 在前面的章节中已经讨论了使代码显而易见的两种最重要的技术。首先是选择好名字（第 14 章）。精确而有意义的名称可以阐明代码的行为，并减少对文档的需求。如果名称含糊不清或含糊不清，那么读者将通读代码以推论命名实体的含义；这既费时又容易出错。第二种技术是一致性（第 17 章）。如果总是以相似的方式完成相似的事情，那么读者可以识别出他们以前所见过的模式，并立即得出（安全）结论，而无需详细分析代码。\n\nHere are a few other general-purpose techniques for making code more obvious:\n\n> 以下是使代码更明显的其他一些通用技术：\n\nJudicious use of white space. The way code is formatted can impact how easy it is to understand. Consider the following parameter documentation, in which whitespace has been squeezed out:\n\n> 明智地使用空白。代码格式化的方式会影响其理解的容易程度。考虑以下参数文档，其中空格已被压缩：\n\n```java\n/**\n *  ...\n *  @param numThreads The number of threads that this manager should\n *  spin up in order to manage ongoing connections. The MessageManager\n *  spins up at least one thread for every open connection, so this\n *  should be at least equal to the number of connections you expect\n *  to be open at once. This should be a multiple of that number if\n *  you expect to send a lot of messages in a short amount of time.\n *  @param handler Used as a callback in order to handle incoming\n *  messages on this MessageManager's open connections. See\n *  {@code MessageHandler} and {@code handleMessage} for details.\n */\n```\n\nIt’s hard to see where the documentation for one parameter ends and the next begins. It’s not even obvious how many parameters there are, or what their names are. If a little whitespace is added, the structure suddenly becomes clear and the documentation is easier to scan:\n\n> 很难看到一个参数的文档在哪里结束而下一个参数的文档在哪里开始。甚至不知道有多少个参数或它们的名称是什么。如果添加了一些空白，结构会突然变得清晰，文档也更容易扫描：\n\n```java\n/**\n *  @param numThreads\n *           The number of threads that this manager should spin up in\n *           order to manage ongoing connections. The MessageManager spins\n *           up at least one thread for every open connection, so this\n *           should be at least equal to the number of connections you\n *           expect to be open at once. This should be a multiple of that\n *           number if you expect to send a lot of messages in a short\n *           amount of time.\n *  @param handler\n *           Used as a callback in order to handle incoming messages on\n *           this MessageManager's open connections. See\n *           {@code MessageHandler} and {@code handleMessage} for details.\n */\n```\n\nBlank lines are also useful to separate major blocks of code within a method, such as in the following example:\n\n> 空行也可用于分隔方法中的主要代码块，例如以下示例：\n\n```cpp\nvoid* Buffer::allocAux(size_t numBytes) {\n    //  Round up the length to a multiple of 8 bytes, to ensure alignment.\n    uint32_t numBytes32 =  (downCast<uint32_t>(numBytes) + 7) & ~0x7;\n    assert(numBytes32 != 0);\n\n    //  If there is enough memory at firstAvailable, use that. Work down\n    //  from the top, because this memory is guaranteed to be aligned\n    //  (memory at the bottom may have been used for variable-size chunks).\n    if  (availableLength >= numBytes32) {\n        availableLength -= numBytes32;\n        return firstAvailable + availableLength;\n    }\n\n    //  Next, see if there is extra space at the end of the last chunk.\n    if  (extraAppendBytes >= numBytes32) {\n        extraAppendBytes -= numBytes32;\n        return lastChunk->data + lastChunk->length + extraAppendBytes;\n    }\n\n    //  Must create a new space allocation; allocate space within it.\n    uint32_t allocatedLength;\n    firstAvailable = getNewAllocation(numBytes32, &allocatedLength);\n    availableLength = allocatedLength numBytes32;\n    return firstAvailable + availableLength;\n}\n```\n\nThis approach works particularly well if the first line after each blank line is a comment describing the next block of code: the blank lines make the comments more visible.\n\n> 如果每个空白行之后的第一行是描述下一个代码块的注释，则此方法特别有效：空白行使注释更可见。\n\nWhite space within a statement helps to clarify the structure of the statement. Compare the following two statements, one of which has whitespace and one of which doesn’t:\n\n> 语句中的空白有助于阐明语句的结构。比较以下两个语句，其中之一具有空格，而其中一个没有空格：\n\n```java\nfor(int pass=1;pass>=0&&!empty;pass--) {\n\nfor (int pass = 1; pass >= 0 && !empty; pass--) {\n```\n\nComments. Sometimes it isn’t possible to avoid code that is nonobvious. When this happens, it’s important to use comments to compensate by providing the missing information. To do this well, you must put yourself in the position of the reader and figure out what is likely to confuse them, and what information will clear up that confusion. The next section shows a few examples.\n\n> 注释。有时无法避免非显而易见的代码。发生这种情况时，重要的是使用注释来提供缺少的信息以进行补偿。要做到这一点，您必须使自己处于读者的位置，弄清楚什么可能会使他们感到困惑，以及哪些信息可以消除这种混乱。下一部分显示了一些示例。\n\n## 18.2 Things that make code less obvious 使代码不那么明显的事情\n\nThere are many things that can make code nonobvious; this section provides a few examples. Some of these, such as event-driven programming, are useful in some situations, so you may end up using them anyway. When this happens, extra documentation can help to minimize reader confusion.\n\n> 有很多事情可以使代码变得不明显。本节提供了一些示例。其中某些功能（例如事件驱动的编程）在某些情况下很有用，因此您可能最终还是要使用它们。发生这种情况时，额外的文档可以帮助最大程度地减少读者的困惑。\n\nEvent-driven programming. In event-driven programming, an application responds to external occurrences, such as the arrival of a network packet or the press of a mouse button. One module is responsible for reporting incoming events. Other parts of the application register interest in certain events by asking the event module to invoke a given function or method when those events occur.\n\n> 事件驱动的编程。在事件驱动的编程中，应用程序对外部事件做出响应，例如网络数据包的到来或按下鼠标按钮。一个模块负责报告传入事件。应用程序的其他部分通过在事件发生时要求事件模块调用给定的函数或方法来注册对某些事件的兴趣。\n\nEvent-driven programming makes it hard to follow the flow of control. The event handler functions are never invoked directly; they are invoked indirectly by the event module, typically using a function pointer or interface. Even if you find the point of invocation in the event module, it still isn’t possible to tell which specific function will be invoked: this will depend on which handlers were registered at runtime. Because of this, it’s hard to reason about event-driven code or convince yourself that it works.\n\n> 事件驱动的编程使其很难遵循控制流程。永远不要直接调用事件处理函数。它们是由事件模块间接调用的，通常使用函数指针或接口。即使您在事件模块中找到了调用点，也仍然无法确定将调用哪个特定功能：这将取决于在运行时注册了哪些处理程序。因此，很难推理事件驱动的代码或说服自己相信它是可行的。\n\nTo compensate for this obscurity, use the interface comment for each handler function to indicate when it is invoked, as in this example:\n\n> 为了弥补这种模糊性，请为每个处理程序函数使用接口注释，以指示何时调用该函数，如以下示例所示：\n\n```java\n/**\n * This method is invoked in the dispatch thread by a transport if a\n * transport-level error prevents an RPC from completing.\n */\nvoid Transport::RpcNotifier::failed() {\n    ...\n}\n```\n\nimg Red Flag: Nonobvious Code img\n\nIf the meaning and behavior of code cannot be understood with a quick reading, it is a red flag. Often this means that there is important information that is not immediately clear to someone reading the code.\n\n> 如果无法通过快速阅读来理解代码的含义和行为，则它是一个危险标记。通常，这意味着有些重要的信息对于阅读代码的人来说并不能立即清除。\n\nGeneric containers. Many languages provide generic classes for grouping two or more items into a single object, such as Pair in Java or std::pair in C++. These classes are tempting because they make it easy to pass around several objects with a single variable. One of the most common uses is to return multiple values from a method, as in this Java example:\n\n> 通用容器。许多语言提供了用于将两个或多个项目组合到一个对象中的通用类，例如 Java 中的 Pair 或 C ++中的 std :: pair。这些类很诱人，因为它们使使用单个变量轻松传递多个对象变得容易。最常见的用途之一是从一个方法返回多个值，如以下 Java 示例所示：\n\n```java\nreturn new Pair<Integer, Boolean>(currentTerm, false);\n```\n\nUnfortunately, generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning. In the example above, the caller must reference the two returned values with result.getKey() and result.getValue(), which give no clue about the actual meaning of the values.\n\n> 不幸的是，通用容器导致代码不清晰，因为分组后的元素的通用名称模糊了它们的含义。在上面的示例中，调用者必须使用 result.getKey（）和 result.getValue（）引用两个返回的值，而这两个值都不提供这些值的实际含义。\n\nThus, it’s better not to use generic containers. If you need a container, define a new class or structure that is specialized for the particular use. You can then use meaningful names for the elements, and you can provide additional documentation in the declaration, which is not possible with the generic container.\n\n> 因此，最好不要使用通用容器。如果需要容器，请定义专门用于特定用途的新类或结构。然后，您可以为元素使用有意义的名称，并且可以在声明中提供其他文档，而对于常规容器而言，这是不可能的。\n\nThis example illustrates a general rule: software should be designed for ease of reading, not ease of writing. Generic containers are expedient for the person writing the code, but they create confusion for all the readers that follow. It’s better for the person writing the code to spend a few extra minutes to define a specific container structure, so that the resulting code is more obvious.\n\n> 此示例说明了一条通用规则：软件应设计为易于阅读而不是易于编写。通用容器对于编写代码的人来说是很方便的，但是它们会使随后的所有读者感到困惑。对于编写代码的人来说，花一些额外的时间来定义特定的容器结构是更好的选择，以便使生成的代码更加明显。\n\nDifferent types for declaration and allocation. Consider the following Java example:\n\n> 不同类型的声明和分配。考虑以下 Java 示例：\n\n```java\nprivate List<Message> incomingMessageList;\n...\nincomingMessageList = new ArrayList<Message>();\n```\n\nThe variable is declared as a List, but the actual value is an ArrayList. This code is legal, since List is a superclass of ArrayList, but it can mislead a reader who sees the declaration but not the actual allocation. The actual type may impact how the variable is used (ArrayLists have different performance and thread-safety properties than other subclasses of List), so it is better to match the declaration with the allocation.\n\n> 将该变量声明为 List，但实际值为 ArrayList。这段代码是合法的，因为 List 是 ArrayList 的超类，但是它会误导看到声明但不是实际分配的读者。实际类型可能会影响变量的使用方式（ArrayList 与 List 的其他子类相比，具有不同的性能和线程安全属性），因此最好将声明与分配匹配。\n\nCode that violates reader expectations. Consider the following code, which is the main program for a Java application\n\n> 违反读者期望的代码。考虑以下代码，这是 Java 应用程序的主程序\n\n```java\npublic static void main(String[] args) {\n    ...\n    new RaftClient(myAddress, serverAddresses);\n}\n```\n\nMost applications exit when their main programs return, so readers are likely to assume that will happen here. However, that is not the case. The constructor for RaftClient creates additional threads, which continue to operate even though the application’s main thread finishes. This behavior should be documented in the interface comment for the RaftClient constructor, but the behavior is nonobvious enough that it’s worth putting a short comment at the end of main as well. The comment should indicate that the application will continue executing in other threads. Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesn’t, then it’s important to document the behavior so readers aren’t confused.\n\n> 大多数应用程序在其主程序返回时退出，因此读者可能会认为这将在此处发生。但是，事实并非如此。RaftClient 的构造函数创建其他线程，即使应用程序的主线程完成，该线程仍可继续运行。应该在 RaftClient 构造函数的接口注释中记录此行为，但是该行为不够明显，因此值得在 main 末尾添加简短注释。该注释应指示该应用程序将继续在其他线程中执行。如果代码符合读者期望的惯例，那么它是最明显的。如果没有，那么记录该行为很重要，以免使读者感到困惑。\n\n## 18.3 Conclusion 结论\n\nAnother way of thinking about obviousness is in terms of information. If code is nonobvious, that usually means there is important information about the code that the reader does not have: in the RaftClient example, the reader might not know that the RaftClient constructor created new threads; in the Pair example, the reader might not know that result.getKey() returns the number of the current term.\n\n> 关于显而易见性的另一种思考方式是信息。如果代码不是显而易见的，则通常意味着存在有关读者所不具备的代码的重要信息：在 RaftClient 示例中，读者可能不知道 RaftClient 构造函数创建了新线程；在“配对”示例中，读者可能不知道 result.getKey（）返回当前项的编号。\n\nTo make code obvious, you must ensure that readers always have the information they need to understand it. You can do this in three ways. The best way is to reduce the amount of information that is needed, using design techniques such as abstraction and eliminating special cases. Second, you can take advantage of information that readers have already acquired in other contexts (for example, by following conventions and conforming to expectations) so readers don’t have to learn new information for your code. Third, you can present the important information to them in the code, using techniques such as good names and strategic comments.\n\n> 为了使代码清晰可见，您必须确保读者始终拥有理解它们所需的信息。您可以通过三种方式执行此操作。最好的方法是使用抽象等设计技术并消除特殊情况，以减少所需的信息量。其次，您可以利用读者在其他情况下已经获得的信息（例如，通过遵循约定并符合期望），从而使读者不必为代码学习新的信息。第三，您可以使用诸如好名和战略注释之类的技术在代码中向他们提供重要信息。\n","source":"_posts/软件设计的哲学-ch18.md","raw":"---\ntitle: 软件设计的哲学 - ch18\ndate: 2021-02-18\n---\n代码应该是显而易见的\n<!-- more -->\n# 第 18 章 代码应该是显而易见的\n\n> Chapter 18 Code Should be Obvious\n\nObscurity is one of the two main causes of complexity described in Section 2.3. Obscurity occurs when important information about a system is not obvious to new developers. The solution to the obscurity problem is to write code in a way that makes it obvious; this chapter discusses some of the factors that make code more or less obvious.\n\n> 晦涩难懂是第 2.3 节中描述的导致复杂性的两个主要原因之一。当有关系统的重要信息对于新开发人员而言并不明显时，就会发生模糊。解决晦涩问题的方法是以显而易见的方式编写代码。本章讨论使代码或多或少变得显而易见的一些因素。\n\nIf code is obvious, it means that someone can read the code quickly, without much thought, and their first guesses about the behavior or meaning of the code will be correct. If code is obvious, a reader doesn’t need to spend much time or effort to gather all the information they need to work with the code. If code is not obvious, then a reader must expend a lot of time and energy to understand it. Not only does this reduce their efficiency, but it also increases the likelihood of misunderstanding and bugs. Obvious code needs fewer comments than nonobvious code.\n\n> 如果代码很明显，则意味着某人可以不加思索地快速阅读该代码，并且他们对代码的行为或含义的最初猜测将是正确的。如果代码很明显，那么读者就不需要花费很多时间或精力来收集他们使用代码所需的所有信息。如果代码不明显，那么读者必须花费大量时间和精力来理解它。这不仅降低了它们的效率，而且还增加了误解和错误的可能性。明显的代码比不明显的代码需要更少的注释。\n\n“Obvious” is in the mind of the reader: it’s easier to notice that someone else’s code is nonobvious than to see problems with your own code. Thus, the best way to determine the obviousness of code is through code reviews. If someone reading your code says it’s not obvious, then it’s not obvious, no matter how clear it may seem to you. By trying to understand what made the code nonobvious, you will learn how to write better code in the future.\n\n> 读者的想法是“显而易见”：注意到别人的代码不明显比发现自己的代码有问题要容易得多。因此，确定代码是否显而易见的最佳方法是通过代码审查。如果有人在阅读您的代码时说它并不明显，那么无论您看起来多么清晰，它也不是显而易见。通过尝试理解什么使代码变得不明显，您将学习如何在将来编写更好的代码。\n\n## 18.1 Things that make code more obvious\n\nTwo of the most important techniques for making code obvious have already been discussed in previous chapters. The first is choosing good names (Chapter 14). Precise and meaningful names clarify the behavior of the code and reduce the need for documentation. If a name is vague or ambiguous, then readers will have read through the code in order to deduce the meaning of the named entity; this is time-consuming and error-prone. The second technique is consistency (Chapter 17). If similar things are always done in similar ways, then readers can recognize patterns they have seen before and immediately draw (safe) conclusions without analyzing the code in detail.\n\n> 在前面的章节中已经讨论了使代码显而易见的两种最重要的技术。首先是选择好名字（第 14 章）。精确而有意义的名称可以阐明代码的行为，并减少对文档的需求。如果名称含糊不清或含糊不清，那么读者将通读代码以推论命名实体的含义；这既费时又容易出错。第二种技术是一致性（第 17 章）。如果总是以相似的方式完成相似的事情，那么读者可以识别出他们以前所见过的模式，并立即得出（安全）结论，而无需详细分析代码。\n\nHere are a few other general-purpose techniques for making code more obvious:\n\n> 以下是使代码更明显的其他一些通用技术：\n\nJudicious use of white space. The way code is formatted can impact how easy it is to understand. Consider the following parameter documentation, in which whitespace has been squeezed out:\n\n> 明智地使用空白。代码格式化的方式会影响其理解的容易程度。考虑以下参数文档，其中空格已被压缩：\n\n```java\n/**\n *  ...\n *  @param numThreads The number of threads that this manager should\n *  spin up in order to manage ongoing connections. The MessageManager\n *  spins up at least one thread for every open connection, so this\n *  should be at least equal to the number of connections you expect\n *  to be open at once. This should be a multiple of that number if\n *  you expect to send a lot of messages in a short amount of time.\n *  @param handler Used as a callback in order to handle incoming\n *  messages on this MessageManager's open connections. See\n *  {@code MessageHandler} and {@code handleMessage} for details.\n */\n```\n\nIt’s hard to see where the documentation for one parameter ends and the next begins. It’s not even obvious how many parameters there are, or what their names are. If a little whitespace is added, the structure suddenly becomes clear and the documentation is easier to scan:\n\n> 很难看到一个参数的文档在哪里结束而下一个参数的文档在哪里开始。甚至不知道有多少个参数或它们的名称是什么。如果添加了一些空白，结构会突然变得清晰，文档也更容易扫描：\n\n```java\n/**\n *  @param numThreads\n *           The number of threads that this manager should spin up in\n *           order to manage ongoing connections. The MessageManager spins\n *           up at least one thread for every open connection, so this\n *           should be at least equal to the number of connections you\n *           expect to be open at once. This should be a multiple of that\n *           number if you expect to send a lot of messages in a short\n *           amount of time.\n *  @param handler\n *           Used as a callback in order to handle incoming messages on\n *           this MessageManager's open connections. See\n *           {@code MessageHandler} and {@code handleMessage} for details.\n */\n```\n\nBlank lines are also useful to separate major blocks of code within a method, such as in the following example:\n\n> 空行也可用于分隔方法中的主要代码块，例如以下示例：\n\n```cpp\nvoid* Buffer::allocAux(size_t numBytes) {\n    //  Round up the length to a multiple of 8 bytes, to ensure alignment.\n    uint32_t numBytes32 =  (downCast<uint32_t>(numBytes) + 7) & ~0x7;\n    assert(numBytes32 != 0);\n\n    //  If there is enough memory at firstAvailable, use that. Work down\n    //  from the top, because this memory is guaranteed to be aligned\n    //  (memory at the bottom may have been used for variable-size chunks).\n    if  (availableLength >= numBytes32) {\n        availableLength -= numBytes32;\n        return firstAvailable + availableLength;\n    }\n\n    //  Next, see if there is extra space at the end of the last chunk.\n    if  (extraAppendBytes >= numBytes32) {\n        extraAppendBytes -= numBytes32;\n        return lastChunk->data + lastChunk->length + extraAppendBytes;\n    }\n\n    //  Must create a new space allocation; allocate space within it.\n    uint32_t allocatedLength;\n    firstAvailable = getNewAllocation(numBytes32, &allocatedLength);\n    availableLength = allocatedLength numBytes32;\n    return firstAvailable + availableLength;\n}\n```\n\nThis approach works particularly well if the first line after each blank line is a comment describing the next block of code: the blank lines make the comments more visible.\n\n> 如果每个空白行之后的第一行是描述下一个代码块的注释，则此方法特别有效：空白行使注释更可见。\n\nWhite space within a statement helps to clarify the structure of the statement. Compare the following two statements, one of which has whitespace and one of which doesn’t:\n\n> 语句中的空白有助于阐明语句的结构。比较以下两个语句，其中之一具有空格，而其中一个没有空格：\n\n```java\nfor(int pass=1;pass>=0&&!empty;pass--) {\n\nfor (int pass = 1; pass >= 0 && !empty; pass--) {\n```\n\nComments. Sometimes it isn’t possible to avoid code that is nonobvious. When this happens, it’s important to use comments to compensate by providing the missing information. To do this well, you must put yourself in the position of the reader and figure out what is likely to confuse them, and what information will clear up that confusion. The next section shows a few examples.\n\n> 注释。有时无法避免非显而易见的代码。发生这种情况时，重要的是使用注释来提供缺少的信息以进行补偿。要做到这一点，您必须使自己处于读者的位置，弄清楚什么可能会使他们感到困惑，以及哪些信息可以消除这种混乱。下一部分显示了一些示例。\n\n## 18.2 Things that make code less obvious 使代码不那么明显的事情\n\nThere are many things that can make code nonobvious; this section provides a few examples. Some of these, such as event-driven programming, are useful in some situations, so you may end up using them anyway. When this happens, extra documentation can help to minimize reader confusion.\n\n> 有很多事情可以使代码变得不明显。本节提供了一些示例。其中某些功能（例如事件驱动的编程）在某些情况下很有用，因此您可能最终还是要使用它们。发生这种情况时，额外的文档可以帮助最大程度地减少读者的困惑。\n\nEvent-driven programming. In event-driven programming, an application responds to external occurrences, such as the arrival of a network packet or the press of a mouse button. One module is responsible for reporting incoming events. Other parts of the application register interest in certain events by asking the event module to invoke a given function or method when those events occur.\n\n> 事件驱动的编程。在事件驱动的编程中，应用程序对外部事件做出响应，例如网络数据包的到来或按下鼠标按钮。一个模块负责报告传入事件。应用程序的其他部分通过在事件发生时要求事件模块调用给定的函数或方法来注册对某些事件的兴趣。\n\nEvent-driven programming makes it hard to follow the flow of control. The event handler functions are never invoked directly; they are invoked indirectly by the event module, typically using a function pointer or interface. Even if you find the point of invocation in the event module, it still isn’t possible to tell which specific function will be invoked: this will depend on which handlers were registered at runtime. Because of this, it’s hard to reason about event-driven code or convince yourself that it works.\n\n> 事件驱动的编程使其很难遵循控制流程。永远不要直接调用事件处理函数。它们是由事件模块间接调用的，通常使用函数指针或接口。即使您在事件模块中找到了调用点，也仍然无法确定将调用哪个特定功能：这将取决于在运行时注册了哪些处理程序。因此，很难推理事件驱动的代码或说服自己相信它是可行的。\n\nTo compensate for this obscurity, use the interface comment for each handler function to indicate when it is invoked, as in this example:\n\n> 为了弥补这种模糊性，请为每个处理程序函数使用接口注释，以指示何时调用该函数，如以下示例所示：\n\n```java\n/**\n * This method is invoked in the dispatch thread by a transport if a\n * transport-level error prevents an RPC from completing.\n */\nvoid Transport::RpcNotifier::failed() {\n    ...\n}\n```\n\nimg Red Flag: Nonobvious Code img\n\nIf the meaning and behavior of code cannot be understood with a quick reading, it is a red flag. Often this means that there is important information that is not immediately clear to someone reading the code.\n\n> 如果无法通过快速阅读来理解代码的含义和行为，则它是一个危险标记。通常，这意味着有些重要的信息对于阅读代码的人来说并不能立即清除。\n\nGeneric containers. Many languages provide generic classes for grouping two or more items into a single object, such as Pair in Java or std::pair in C++. These classes are tempting because they make it easy to pass around several objects with a single variable. One of the most common uses is to return multiple values from a method, as in this Java example:\n\n> 通用容器。许多语言提供了用于将两个或多个项目组合到一个对象中的通用类，例如 Java 中的 Pair 或 C ++中的 std :: pair。这些类很诱人，因为它们使使用单个变量轻松传递多个对象变得容易。最常见的用途之一是从一个方法返回多个值，如以下 Java 示例所示：\n\n```java\nreturn new Pair<Integer, Boolean>(currentTerm, false);\n```\n\nUnfortunately, generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning. In the example above, the caller must reference the two returned values with result.getKey() and result.getValue(), which give no clue about the actual meaning of the values.\n\n> 不幸的是，通用容器导致代码不清晰，因为分组后的元素的通用名称模糊了它们的含义。在上面的示例中，调用者必须使用 result.getKey（）和 result.getValue（）引用两个返回的值，而这两个值都不提供这些值的实际含义。\n\nThus, it’s better not to use generic containers. If you need a container, define a new class or structure that is specialized for the particular use. You can then use meaningful names for the elements, and you can provide additional documentation in the declaration, which is not possible with the generic container.\n\n> 因此，最好不要使用通用容器。如果需要容器，请定义专门用于特定用途的新类或结构。然后，您可以为元素使用有意义的名称，并且可以在声明中提供其他文档，而对于常规容器而言，这是不可能的。\n\nThis example illustrates a general rule: software should be designed for ease of reading, not ease of writing. Generic containers are expedient for the person writing the code, but they create confusion for all the readers that follow. It’s better for the person writing the code to spend a few extra minutes to define a specific container structure, so that the resulting code is more obvious.\n\n> 此示例说明了一条通用规则：软件应设计为易于阅读而不是易于编写。通用容器对于编写代码的人来说是很方便的，但是它们会使随后的所有读者感到困惑。对于编写代码的人来说，花一些额外的时间来定义特定的容器结构是更好的选择，以便使生成的代码更加明显。\n\nDifferent types for declaration and allocation. Consider the following Java example:\n\n> 不同类型的声明和分配。考虑以下 Java 示例：\n\n```java\nprivate List<Message> incomingMessageList;\n...\nincomingMessageList = new ArrayList<Message>();\n```\n\nThe variable is declared as a List, but the actual value is an ArrayList. This code is legal, since List is a superclass of ArrayList, but it can mislead a reader who sees the declaration but not the actual allocation. The actual type may impact how the variable is used (ArrayLists have different performance and thread-safety properties than other subclasses of List), so it is better to match the declaration with the allocation.\n\n> 将该变量声明为 List，但实际值为 ArrayList。这段代码是合法的，因为 List 是 ArrayList 的超类，但是它会误导看到声明但不是实际分配的读者。实际类型可能会影响变量的使用方式（ArrayList 与 List 的其他子类相比，具有不同的性能和线程安全属性），因此最好将声明与分配匹配。\n\nCode that violates reader expectations. Consider the following code, which is the main program for a Java application\n\n> 违反读者期望的代码。考虑以下代码，这是 Java 应用程序的主程序\n\n```java\npublic static void main(String[] args) {\n    ...\n    new RaftClient(myAddress, serverAddresses);\n}\n```\n\nMost applications exit when their main programs return, so readers are likely to assume that will happen here. However, that is not the case. The constructor for RaftClient creates additional threads, which continue to operate even though the application’s main thread finishes. This behavior should be documented in the interface comment for the RaftClient constructor, but the behavior is nonobvious enough that it’s worth putting a short comment at the end of main as well. The comment should indicate that the application will continue executing in other threads. Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesn’t, then it’s important to document the behavior so readers aren’t confused.\n\n> 大多数应用程序在其主程序返回时退出，因此读者可能会认为这将在此处发生。但是，事实并非如此。RaftClient 的构造函数创建其他线程，即使应用程序的主线程完成，该线程仍可继续运行。应该在 RaftClient 构造函数的接口注释中记录此行为，但是该行为不够明显，因此值得在 main 末尾添加简短注释。该注释应指示该应用程序将继续在其他线程中执行。如果代码符合读者期望的惯例，那么它是最明显的。如果没有，那么记录该行为很重要，以免使读者感到困惑。\n\n## 18.3 Conclusion 结论\n\nAnother way of thinking about obviousness is in terms of information. If code is nonobvious, that usually means there is important information about the code that the reader does not have: in the RaftClient example, the reader might not know that the RaftClient constructor created new threads; in the Pair example, the reader might not know that result.getKey() returns the number of the current term.\n\n> 关于显而易见性的另一种思考方式是信息。如果代码不是显而易见的，则通常意味着存在有关读者所不具备的代码的重要信息：在 RaftClient 示例中，读者可能不知道 RaftClient 构造函数创建了新线程；在“配对”示例中，读者可能不知道 result.getKey（）返回当前项的编号。\n\nTo make code obvious, you must ensure that readers always have the information they need to understand it. You can do this in three ways. The best way is to reduce the amount of information that is needed, using design techniques such as abstraction and eliminating special cases. Second, you can take advantage of information that readers have already acquired in other contexts (for example, by following conventions and conforming to expectations) so readers don’t have to learn new information for your code. Third, you can present the important information to them in the code, using techniques such as good names and strategic comments.\n\n> 为了使代码清晰可见，您必须确保读者始终拥有理解它们所需的信息。您可以通过三种方式执行此操作。最好的方法是使用抽象等设计技术并消除特殊情况，以减少所需的信息量。其次，您可以利用读者在其他情况下已经获得的信息（例如，通过遵循约定并符合期望），从而使读者不必为代码学习新的信息。第三，您可以使用诸如好名和战略注释之类的技术在代码中向他们提供重要信息。\n","slug":"软件设计的哲学-ch18","published":1,"updated":"2021-02-16T04:53:05.167Z","_id":"ckl6pcc29000as4iyeiee6ye3","comments":1,"layout":"post","photos":[],"link":"","content":"<p>代码应该是显而易见的</p>\n<a id=\"more\"></a>\n<h1 id=\"第-18-章-代码应该是显而易见的\"><a href=\"#第-18-章-代码应该是显而易见的\" class=\"headerlink\" title=\"第 18 章 代码应该是显而易见的\"></a>第 18 章 代码应该是显而易见的</h1><blockquote>\n<p>Chapter 18 Code Should be Obvious</p>\n</blockquote>\n<p>Obscurity is one of the two main causes of complexity described in Section 2.3. Obscurity occurs when important information about a system is not obvious to new developers. The solution to the obscurity problem is to write code in a way that makes it obvious; this chapter discusses some of the factors that make code more or less obvious.</p>\n<blockquote>\n<p>晦涩难懂是第 2.3 节中描述的导致复杂性的两个主要原因之一。当有关系统的重要信息对于新开发人员而言并不明显时，就会发生模糊。解决晦涩问题的方法是以显而易见的方式编写代码。本章讨论使代码或多或少变得显而易见的一些因素。</p>\n</blockquote>\n<p>If code is obvious, it means that someone can read the code quickly, without much thought, and their first guesses about the behavior or meaning of the code will be correct. If code is obvious, a reader doesn’t need to spend much time or effort to gather all the information they need to work with the code. If code is not obvious, then a reader must expend a lot of time and energy to understand it. Not only does this reduce their efficiency, but it also increases the likelihood of misunderstanding and bugs. Obvious code needs fewer comments than nonobvious code.</p>\n<blockquote>\n<p>如果代码很明显，则意味着某人可以不加思索地快速阅读该代码，并且他们对代码的行为或含义的最初猜测将是正确的。如果代码很明显，那么读者就不需要花费很多时间或精力来收集他们使用代码所需的所有信息。如果代码不明显，那么读者必须花费大量时间和精力来理解它。这不仅降低了它们的效率，而且还增加了误解和错误的可能性。明显的代码比不明显的代码需要更少的注释。</p>\n</blockquote>\n<p>“Obvious” is in the mind of the reader: it’s easier to notice that someone else’s code is nonobvious than to see problems with your own code. Thus, the best way to determine the obviousness of code is through code reviews. If someone reading your code says it’s not obvious, then it’s not obvious, no matter how clear it may seem to you. By trying to understand what made the code nonobvious, you will learn how to write better code in the future.</p>\n<blockquote>\n<p>读者的想法是“显而易见”：注意到别人的代码不明显比发现自己的代码有问题要容易得多。因此，确定代码是否显而易见的最佳方法是通过代码审查。如果有人在阅读您的代码时说它并不明显，那么无论您看起来多么清晰，它也不是显而易见。通过尝试理解什么使代码变得不明显，您将学习如何在将来编写更好的代码。</p>\n</blockquote>\n<h2 id=\"18-1-Things-that-make-code-more-obvious\"><a href=\"#18-1-Things-that-make-code-more-obvious\" class=\"headerlink\" title=\"18.1 Things that make code more obvious\"></a>18.1 Things that make code more obvious</h2><p>Two of the most important techniques for making code obvious have already been discussed in previous chapters. The first is choosing good names (Chapter 14). Precise and meaningful names clarify the behavior of the code and reduce the need for documentation. If a name is vague or ambiguous, then readers will have read through the code in order to deduce the meaning of the named entity; this is time-consuming and error-prone. The second technique is consistency (Chapter 17). If similar things are always done in similar ways, then readers can recognize patterns they have seen before and immediately draw (safe) conclusions without analyzing the code in detail.</p>\n<blockquote>\n<p>在前面的章节中已经讨论了使代码显而易见的两种最重要的技术。首先是选择好名字（第 14 章）。精确而有意义的名称可以阐明代码的行为，并减少对文档的需求。如果名称含糊不清或含糊不清，那么读者将通读代码以推论命名实体的含义；这既费时又容易出错。第二种技术是一致性（第 17 章）。如果总是以相似的方式完成相似的事情，那么读者可以识别出他们以前所见过的模式，并立即得出（安全）结论，而无需详细分析代码。</p>\n</blockquote>\n<p>Here are a few other general-purpose techniques for making code more obvious:</p>\n<blockquote>\n<p>以下是使代码更明显的其他一些通用技术：</p>\n</blockquote>\n<p>Judicious use of white space. The way code is formatted can impact how easy it is to understand. Consider the following parameter documentation, in which whitespace has been squeezed out:</p>\n<blockquote>\n<p>明智地使用空白。代码格式化的方式会影响其理解的容易程度。考虑以下参数文档，其中空格已被压缩：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  ...</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> numThreads The number of threads that this manager should</span></span><br><span class=\"line\"><span class=\"comment\"> *  spin up in order to manage ongoing connections. The MessageManager</span></span><br><span class=\"line\"><span class=\"comment\"> *  spins up at least one thread for every open connection, so this</span></span><br><span class=\"line\"><span class=\"comment\"> *  should be at least equal to the number of connections you expect</span></span><br><span class=\"line\"><span class=\"comment\"> *  to be open at once. This should be a multiple of that number if</span></span><br><span class=\"line\"><span class=\"comment\"> *  you expect to send a lot of messages in a short amount of time.</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> handler Used as a callback in order to handle incoming</span></span><br><span class=\"line\"><span class=\"comment\"> *  messages on this MessageManager's open connections. See</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#123;<span class=\"doctag\">@code</span> MessageHandler&#125; and &#123;<span class=\"doctag\">@code</span> handleMessage&#125; for details.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>It’s hard to see where the documentation for one parameter ends and the next begins. It’s not even obvious how many parameters there are, or what their names are. If a little whitespace is added, the structure suddenly becomes clear and the documentation is easier to scan:</p>\n<blockquote>\n<p>很难看到一个参数的文档在哪里结束而下一个参数的文档在哪里开始。甚至不知道有多少个参数或它们的名称是什么。如果添加了一些空白，结构会突然变得清晰，文档也更容易扫描：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> numThreads</span></span><br><span class=\"line\"><span class=\"comment\"> *           The number of threads that this manager should spin up in</span></span><br><span class=\"line\"><span class=\"comment\"> *           order to manage ongoing connections. The MessageManager spins</span></span><br><span class=\"line\"><span class=\"comment\"> *           up at least one thread for every open connection, so this</span></span><br><span class=\"line\"><span class=\"comment\"> *           should be at least equal to the number of connections you</span></span><br><span class=\"line\"><span class=\"comment\"> *           expect to be open at once. This should be a multiple of that</span></span><br><span class=\"line\"><span class=\"comment\"> *           number if you expect to send a lot of messages in a short</span></span><br><span class=\"line\"><span class=\"comment\"> *           amount of time.</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\"> *           Used as a callback in order to handle incoming messages on</span></span><br><span class=\"line\"><span class=\"comment\"> *           this MessageManager's open connections. See</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#123;<span class=\"doctag\">@code</span> MessageHandler&#125; and &#123;<span class=\"doctag\">@code</span> handleMessage&#125; for details.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>Blank lines are also useful to separate major blocks of code within a method, such as in the following example:</p>\n<blockquote>\n<p>空行也可用于分隔方法中的主要代码块，例如以下示例：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Buffer::allocAux</span><span class=\"params\">(<span class=\"keyword\">size_t</span> numBytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  Round up the length to a multiple of 8 bytes, to ensure alignment.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> numBytes32 =  (downCast&lt;<span class=\"keyword\">uint32_t</span>&gt;(numBytes) + <span class=\"number\">7</span>) &amp; ~<span class=\"number\">0x7</span>;</span><br><span class=\"line\">    assert(numBytes32 != <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  If there is enough memory at firstAvailable, use that. Work down</span></span><br><span class=\"line\">    <span class=\"comment\">//  from the top, because this memory is guaranteed to be aligned</span></span><br><span class=\"line\">    <span class=\"comment\">//  (memory at the bottom may have been used for variable-size chunks).</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (availableLength &gt;= numBytes32) &#123;</span><br><span class=\"line\">        availableLength -= numBytes32;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstAvailable + availableLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  Next, see if there is extra space at the end of the last chunk.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (extraAppendBytes &gt;= numBytes32) &#123;</span><br><span class=\"line\">        extraAppendBytes -= numBytes32;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastChunk-&gt;data + lastChunk-&gt;length + extraAppendBytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  Must create a new space allocation; allocate space within it.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> allocatedLength;</span><br><span class=\"line\">    firstAvailable = getNewAllocation(numBytes32, &amp;allocatedLength);</span><br><span class=\"line\">    availableLength = allocatedLength numBytes32;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstAvailable + availableLength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This approach works particularly well if the first line after each blank line is a comment describing the next block of code: the blank lines make the comments more visible.</p>\n<blockquote>\n<p>如果每个空白行之后的第一行是描述下一个代码块的注释，则此方法特别有效：空白行使注释更可见。</p>\n</blockquote>\n<p>White space within a statement helps to clarify the structure of the statement. Compare the following two statements, one of which has whitespace and one of which doesn’t:</p>\n<blockquote>\n<p>语句中的空白有助于阐明语句的结构。比较以下两个语句，其中之一具有空格，而其中一个没有空格：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> pass=<span class=\"number\">1</span>;pass&gt;=<span class=\"number\">0</span>&amp;&amp;!empty;pass--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> pass = <span class=\"number\">1</span>; pass &gt;= <span class=\"number\">0</span> &amp;&amp; !empty; pass--) &#123;</span><br></pre></td></tr></table></figure>\n\n<p>Comments. Sometimes it isn’t possible to avoid code that is nonobvious. When this happens, it’s important to use comments to compensate by providing the missing information. To do this well, you must put yourself in the position of the reader and figure out what is likely to confuse them, and what information will clear up that confusion. The next section shows a few examples.</p>\n<blockquote>\n<p>注释。有时无法避免非显而易见的代码。发生这种情况时，重要的是使用注释来提供缺少的信息以进行补偿。要做到这一点，您必须使自己处于读者的位置，弄清楚什么可能会使他们感到困惑，以及哪些信息可以消除这种混乱。下一部分显示了一些示例。</p>\n</blockquote>\n<h2 id=\"18-2-Things-that-make-code-less-obvious-使代码不那么明显的事情\"><a href=\"#18-2-Things-that-make-code-less-obvious-使代码不那么明显的事情\" class=\"headerlink\" title=\"18.2 Things that make code less obvious 使代码不那么明显的事情\"></a>18.2 Things that make code less obvious 使代码不那么明显的事情</h2><p>There are many things that can make code nonobvious; this section provides a few examples. Some of these, such as event-driven programming, are useful in some situations, so you may end up using them anyway. When this happens, extra documentation can help to minimize reader confusion.</p>\n<blockquote>\n<p>有很多事情可以使代码变得不明显。本节提供了一些示例。其中某些功能（例如事件驱动的编程）在某些情况下很有用，因此您可能最终还是要使用它们。发生这种情况时，额外的文档可以帮助最大程度地减少读者的困惑。</p>\n</blockquote>\n<p>Event-driven programming. In event-driven programming, an application responds to external occurrences, such as the arrival of a network packet or the press of a mouse button. One module is responsible for reporting incoming events. Other parts of the application register interest in certain events by asking the event module to invoke a given function or method when those events occur.</p>\n<blockquote>\n<p>事件驱动的编程。在事件驱动的编程中，应用程序对外部事件做出响应，例如网络数据包的到来或按下鼠标按钮。一个模块负责报告传入事件。应用程序的其他部分通过在事件发生时要求事件模块调用给定的函数或方法来注册对某些事件的兴趣。</p>\n</blockquote>\n<p>Event-driven programming makes it hard to follow the flow of control. The event handler functions are never invoked directly; they are invoked indirectly by the event module, typically using a function pointer or interface. Even if you find the point of invocation in the event module, it still isn’t possible to tell which specific function will be invoked: this will depend on which handlers were registered at runtime. Because of this, it’s hard to reason about event-driven code or convince yourself that it works.</p>\n<blockquote>\n<p>事件驱动的编程使其很难遵循控制流程。永远不要直接调用事件处理函数。它们是由事件模块间接调用的，通常使用函数指针或接口。即使您在事件模块中找到了调用点，也仍然无法确定将调用哪个特定功能：这将取决于在运行时注册了哪些处理程序。因此，很难推理事件驱动的代码或说服自己相信它是可行的。</p>\n</blockquote>\n<p>To compensate for this obscurity, use the interface comment for each handler function to indicate when it is invoked, as in this example:</p>\n<blockquote>\n<p>为了弥补这种模糊性，请为每个处理程序函数使用接口注释，以指示何时调用该函数，如以下示例所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This method is invoked in the dispatch thread by a transport if a</span></span><br><span class=\"line\"><span class=\"comment\"> * transport-level error prevents an RPC from completing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Transport::RpcNotifier::failed() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>img Red Flag: Nonobvious Code img</p>\n<p>If the meaning and behavior of code cannot be understood with a quick reading, it is a red flag. Often this means that there is important information that is not immediately clear to someone reading the code.</p>\n<blockquote>\n<p>如果无法通过快速阅读来理解代码的含义和行为，则它是一个危险标记。通常，这意味着有些重要的信息对于阅读代码的人来说并不能立即清除。</p>\n</blockquote>\n<p>Generic containers. Many languages provide generic classes for grouping two or more items into a single object, such as Pair in Java or std::pair in C++. These classes are tempting because they make it easy to pass around several objects with a single variable. One of the most common uses is to return multiple values from a method, as in this Java example:</p>\n<blockquote>\n<p>通用容器。许多语言提供了用于将两个或多个项目组合到一个对象中的通用类，例如 Java 中的 Pair 或 C ++中的 std :: pair。这些类很诱人，因为它们使使用单个变量轻松传递多个对象变得容易。最常见的用途之一是从一个方法返回多个值，如以下 Java 示例所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;Integer, Boolean&gt;(currentTerm, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Unfortunately, generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning. In the example above, the caller must reference the two returned values with result.getKey() and result.getValue(), which give no clue about the actual meaning of the values.</p>\n<blockquote>\n<p>不幸的是，通用容器导致代码不清晰，因为分组后的元素的通用名称模糊了它们的含义。在上面的示例中，调用者必须使用 result.getKey（）和 result.getValue（）引用两个返回的值，而这两个值都不提供这些值的实际含义。</p>\n</blockquote>\n<p>Thus, it’s better not to use generic containers. If you need a container, define a new class or structure that is specialized for the particular use. You can then use meaningful names for the elements, and you can provide additional documentation in the declaration, which is not possible with the generic container.</p>\n<blockquote>\n<p>因此，最好不要使用通用容器。如果需要容器，请定义专门用于特定用途的新类或结构。然后，您可以为元素使用有意义的名称，并且可以在声明中提供其他文档，而对于常规容器而言，这是不可能的。</p>\n</blockquote>\n<p>This example illustrates a general rule: software should be designed for ease of reading, not ease of writing. Generic containers are expedient for the person writing the code, but they create confusion for all the readers that follow. It’s better for the person writing the code to spend a few extra minutes to define a specific container structure, so that the resulting code is more obvious.</p>\n<blockquote>\n<p>此示例说明了一条通用规则：软件应设计为易于阅读而不是易于编写。通用容器对于编写代码的人来说是很方便的，但是它们会使随后的所有读者感到困惑。对于编写代码的人来说，花一些额外的时间来定义特定的容器结构是更好的选择，以便使生成的代码更加明显。</p>\n</blockquote>\n<p>Different types for declaration and allocation. Consider the following Java example:</p>\n<blockquote>\n<p>不同类型的声明和分配。考虑以下 Java 示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;Message&gt; incomingMessageList;</span><br><span class=\"line\">...</span><br><span class=\"line\">incomingMessageList = <span class=\"keyword\">new</span> ArrayList&lt;Message&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>The variable is declared as a List, but the actual value is an ArrayList. This code is legal, since List is a superclass of ArrayList, but it can mislead a reader who sees the declaration but not the actual allocation. The actual type may impact how the variable is used (ArrayLists have different performance and thread-safety properties than other subclasses of List), so it is better to match the declaration with the allocation.</p>\n<blockquote>\n<p>将该变量声明为 List，但实际值为 ArrayList。这段代码是合法的，因为 List 是 ArrayList 的超类，但是它会误导看到声明但不是实际分配的读者。实际类型可能会影响变量的使用方式（ArrayList 与 List 的其他子类相比，具有不同的性能和线程安全属性），因此最好将声明与分配匹配。</p>\n</blockquote>\n<p>Code that violates reader expectations. Consider the following code, which is the main program for a Java application</p>\n<blockquote>\n<p>违反读者期望的代码。考虑以下代码，这是 Java 应用程序的主程序</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">new</span> RaftClient(myAddress, serverAddresses);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Most applications exit when their main programs return, so readers are likely to assume that will happen here. However, that is not the case. The constructor for RaftClient creates additional threads, which continue to operate even though the application’s main thread finishes. This behavior should be documented in the interface comment for the RaftClient constructor, but the behavior is nonobvious enough that it’s worth putting a short comment at the end of main as well. The comment should indicate that the application will continue executing in other threads. Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesn’t, then it’s important to document the behavior so readers aren’t confused.</p>\n<blockquote>\n<p>大多数应用程序在其主程序返回时退出，因此读者可能会认为这将在此处发生。但是，事实并非如此。RaftClient 的构造函数创建其他线程，即使应用程序的主线程完成，该线程仍可继续运行。应该在 RaftClient 构造函数的接口注释中记录此行为，但是该行为不够明显，因此值得在 main 末尾添加简短注释。该注释应指示该应用程序将继续在其他线程中执行。如果代码符合读者期望的惯例，那么它是最明显的。如果没有，那么记录该行为很重要，以免使读者感到困惑。</p>\n</blockquote>\n<h2 id=\"18-3-Conclusion-结论\"><a href=\"#18-3-Conclusion-结论\" class=\"headerlink\" title=\"18.3 Conclusion 结论\"></a>18.3 Conclusion 结论</h2><p>Another way of thinking about obviousness is in terms of information. If code is nonobvious, that usually means there is important information about the code that the reader does not have: in the RaftClient example, the reader might not know that the RaftClient constructor created new threads; in the Pair example, the reader might not know that result.getKey() returns the number of the current term.</p>\n<blockquote>\n<p>关于显而易见性的另一种思考方式是信息。如果代码不是显而易见的，则通常意味着存在有关读者所不具备的代码的重要信息：在 RaftClient 示例中，读者可能不知道 RaftClient 构造函数创建了新线程；在“配对”示例中，读者可能不知道 result.getKey（）返回当前项的编号。</p>\n</blockquote>\n<p>To make code obvious, you must ensure that readers always have the information they need to understand it. You can do this in three ways. The best way is to reduce the amount of information that is needed, using design techniques such as abstraction and eliminating special cases. Second, you can take advantage of information that readers have already acquired in other contexts (for example, by following conventions and conforming to expectations) so readers don’t have to learn new information for your code. Third, you can present the important information to them in the code, using techniques such as good names and strategic comments.</p>\n<blockquote>\n<p>为了使代码清晰可见，您必须确保读者始终拥有理解它们所需的信息。您可以通过三种方式执行此操作。最好的方法是使用抽象等设计技术并消除特殊情况，以减少所需的信息量。其次，您可以利用读者在其他情况下已经获得的信息（例如，通过遵循约定并符合期望），从而使读者不必为代码学习新的信息。第三，您可以使用诸如好名和战略注释之类的技术在代码中向他们提供重要信息。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>代码应该是显而易见的</p>","more":"<h1 id=\"第-18-章-代码应该是显而易见的\"><a href=\"#第-18-章-代码应该是显而易见的\" class=\"headerlink\" title=\"第 18 章 代码应该是显而易见的\"></a>第 18 章 代码应该是显而易见的</h1><blockquote>\n<p>Chapter 18 Code Should be Obvious</p>\n</blockquote>\n<p>Obscurity is one of the two main causes of complexity described in Section 2.3. Obscurity occurs when important information about a system is not obvious to new developers. The solution to the obscurity problem is to write code in a way that makes it obvious; this chapter discusses some of the factors that make code more or less obvious.</p>\n<blockquote>\n<p>晦涩难懂是第 2.3 节中描述的导致复杂性的两个主要原因之一。当有关系统的重要信息对于新开发人员而言并不明显时，就会发生模糊。解决晦涩问题的方法是以显而易见的方式编写代码。本章讨论使代码或多或少变得显而易见的一些因素。</p>\n</blockquote>\n<p>If code is obvious, it means that someone can read the code quickly, without much thought, and their first guesses about the behavior or meaning of the code will be correct. If code is obvious, a reader doesn’t need to spend much time or effort to gather all the information they need to work with the code. If code is not obvious, then a reader must expend a lot of time and energy to understand it. Not only does this reduce their efficiency, but it also increases the likelihood of misunderstanding and bugs. Obvious code needs fewer comments than nonobvious code.</p>\n<blockquote>\n<p>如果代码很明显，则意味着某人可以不加思索地快速阅读该代码，并且他们对代码的行为或含义的最初猜测将是正确的。如果代码很明显，那么读者就不需要花费很多时间或精力来收集他们使用代码所需的所有信息。如果代码不明显，那么读者必须花费大量时间和精力来理解它。这不仅降低了它们的效率，而且还增加了误解和错误的可能性。明显的代码比不明显的代码需要更少的注释。</p>\n</blockquote>\n<p>“Obvious” is in the mind of the reader: it’s easier to notice that someone else’s code is nonobvious than to see problems with your own code. Thus, the best way to determine the obviousness of code is through code reviews. If someone reading your code says it’s not obvious, then it’s not obvious, no matter how clear it may seem to you. By trying to understand what made the code nonobvious, you will learn how to write better code in the future.</p>\n<blockquote>\n<p>读者的想法是“显而易见”：注意到别人的代码不明显比发现自己的代码有问题要容易得多。因此，确定代码是否显而易见的最佳方法是通过代码审查。如果有人在阅读您的代码时说它并不明显，那么无论您看起来多么清晰，它也不是显而易见。通过尝试理解什么使代码变得不明显，您将学习如何在将来编写更好的代码。</p>\n</blockquote>\n<h2 id=\"18-1-Things-that-make-code-more-obvious\"><a href=\"#18-1-Things-that-make-code-more-obvious\" class=\"headerlink\" title=\"18.1 Things that make code more obvious\"></a>18.1 Things that make code more obvious</h2><p>Two of the most important techniques for making code obvious have already been discussed in previous chapters. The first is choosing good names (Chapter 14). Precise and meaningful names clarify the behavior of the code and reduce the need for documentation. If a name is vague or ambiguous, then readers will have read through the code in order to deduce the meaning of the named entity; this is time-consuming and error-prone. The second technique is consistency (Chapter 17). If similar things are always done in similar ways, then readers can recognize patterns they have seen before and immediately draw (safe) conclusions without analyzing the code in detail.</p>\n<blockquote>\n<p>在前面的章节中已经讨论了使代码显而易见的两种最重要的技术。首先是选择好名字（第 14 章）。精确而有意义的名称可以阐明代码的行为，并减少对文档的需求。如果名称含糊不清或含糊不清，那么读者将通读代码以推论命名实体的含义；这既费时又容易出错。第二种技术是一致性（第 17 章）。如果总是以相似的方式完成相似的事情，那么读者可以识别出他们以前所见过的模式，并立即得出（安全）结论，而无需详细分析代码。</p>\n</blockquote>\n<p>Here are a few other general-purpose techniques for making code more obvious:</p>\n<blockquote>\n<p>以下是使代码更明显的其他一些通用技术：</p>\n</blockquote>\n<p>Judicious use of white space. The way code is formatted can impact how easy it is to understand. Consider the following parameter documentation, in which whitespace has been squeezed out:</p>\n<blockquote>\n<p>明智地使用空白。代码格式化的方式会影响其理解的容易程度。考虑以下参数文档，其中空格已被压缩：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  ...</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> numThreads The number of threads that this manager should</span></span><br><span class=\"line\"><span class=\"comment\"> *  spin up in order to manage ongoing connections. The MessageManager</span></span><br><span class=\"line\"><span class=\"comment\"> *  spins up at least one thread for every open connection, so this</span></span><br><span class=\"line\"><span class=\"comment\"> *  should be at least equal to the number of connections you expect</span></span><br><span class=\"line\"><span class=\"comment\"> *  to be open at once. This should be a multiple of that number if</span></span><br><span class=\"line\"><span class=\"comment\"> *  you expect to send a lot of messages in a short amount of time.</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> handler Used as a callback in order to handle incoming</span></span><br><span class=\"line\"><span class=\"comment\"> *  messages on this MessageManager's open connections. See</span></span><br><span class=\"line\"><span class=\"comment\"> *  &#123;<span class=\"doctag\">@code</span> MessageHandler&#125; and &#123;<span class=\"doctag\">@code</span> handleMessage&#125; for details.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>It’s hard to see where the documentation for one parameter ends and the next begins. It’s not even obvious how many parameters there are, or what their names are. If a little whitespace is added, the structure suddenly becomes clear and the documentation is easier to scan:</p>\n<blockquote>\n<p>很难看到一个参数的文档在哪里结束而下一个参数的文档在哪里开始。甚至不知道有多少个参数或它们的名称是什么。如果添加了一些空白，结构会突然变得清晰，文档也更容易扫描：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> numThreads</span></span><br><span class=\"line\"><span class=\"comment\"> *           The number of threads that this manager should spin up in</span></span><br><span class=\"line\"><span class=\"comment\"> *           order to manage ongoing connections. The MessageManager spins</span></span><br><span class=\"line\"><span class=\"comment\"> *           up at least one thread for every open connection, so this</span></span><br><span class=\"line\"><span class=\"comment\"> *           should be at least equal to the number of connections you</span></span><br><span class=\"line\"><span class=\"comment\"> *           expect to be open at once. This should be a multiple of that</span></span><br><span class=\"line\"><span class=\"comment\"> *           number if you expect to send a lot of messages in a short</span></span><br><span class=\"line\"><span class=\"comment\"> *           amount of time.</span></span><br><span class=\"line\"><span class=\"comment\"> *  <span class=\"doctag\">@param</span> handler</span></span><br><span class=\"line\"><span class=\"comment\"> *           Used as a callback in order to handle incoming messages on</span></span><br><span class=\"line\"><span class=\"comment\"> *           this MessageManager's open connections. See</span></span><br><span class=\"line\"><span class=\"comment\"> *           &#123;<span class=\"doctag\">@code</span> MessageHandler&#125; and &#123;<span class=\"doctag\">@code</span> handleMessage&#125; for details.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>Blank lines are also useful to separate major blocks of code within a method, such as in the following example:</p>\n<blockquote>\n<p>空行也可用于分隔方法中的主要代码块，例如以下示例：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span>* <span class=\"title\">Buffer::allocAux</span><span class=\"params\">(<span class=\"keyword\">size_t</span> numBytes)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//  Round up the length to a multiple of 8 bytes, to ensure alignment.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> numBytes32 =  (downCast&lt;<span class=\"keyword\">uint32_t</span>&gt;(numBytes) + <span class=\"number\">7</span>) &amp; ~<span class=\"number\">0x7</span>;</span><br><span class=\"line\">    assert(numBytes32 != <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  If there is enough memory at firstAvailable, use that. Work down</span></span><br><span class=\"line\">    <span class=\"comment\">//  from the top, because this memory is guaranteed to be aligned</span></span><br><span class=\"line\">    <span class=\"comment\">//  (memory at the bottom may have been used for variable-size chunks).</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (availableLength &gt;= numBytes32) &#123;</span><br><span class=\"line\">        availableLength -= numBytes32;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> firstAvailable + availableLength;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  Next, see if there is extra space at the end of the last chunk.</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (extraAppendBytes &gt;= numBytes32) &#123;</span><br><span class=\"line\">        extraAppendBytes -= numBytes32;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> lastChunk-&gt;data + lastChunk-&gt;length + extraAppendBytes;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//  Must create a new space allocation; allocate space within it.</span></span><br><span class=\"line\">    <span class=\"keyword\">uint32_t</span> allocatedLength;</span><br><span class=\"line\">    firstAvailable = getNewAllocation(numBytes32, &amp;allocatedLength);</span><br><span class=\"line\">    availableLength = allocatedLength numBytes32;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> firstAvailable + availableLength;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This approach works particularly well if the first line after each blank line is a comment describing the next block of code: the blank lines make the comments more visible.</p>\n<blockquote>\n<p>如果每个空白行之后的第一行是描述下一个代码块的注释，则此方法特别有效：空白行使注释更可见。</p>\n</blockquote>\n<p>White space within a statement helps to clarify the structure of the statement. Compare the following two statements, one of which has whitespace and one of which doesn’t:</p>\n<blockquote>\n<p>语句中的空白有助于阐明语句的结构。比较以下两个语句，其中之一具有空格，而其中一个没有空格：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> pass=<span class=\"number\">1</span>;pass&gt;=<span class=\"number\">0</span>&amp;&amp;!empty;pass--) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> pass = <span class=\"number\">1</span>; pass &gt;= <span class=\"number\">0</span> &amp;&amp; !empty; pass--) &#123;</span><br></pre></td></tr></table></figure>\n\n<p>Comments. Sometimes it isn’t possible to avoid code that is nonobvious. When this happens, it’s important to use comments to compensate by providing the missing information. To do this well, you must put yourself in the position of the reader and figure out what is likely to confuse them, and what information will clear up that confusion. The next section shows a few examples.</p>\n<blockquote>\n<p>注释。有时无法避免非显而易见的代码。发生这种情况时，重要的是使用注释来提供缺少的信息以进行补偿。要做到这一点，您必须使自己处于读者的位置，弄清楚什么可能会使他们感到困惑，以及哪些信息可以消除这种混乱。下一部分显示了一些示例。</p>\n</blockquote>\n<h2 id=\"18-2-Things-that-make-code-less-obvious-使代码不那么明显的事情\"><a href=\"#18-2-Things-that-make-code-less-obvious-使代码不那么明显的事情\" class=\"headerlink\" title=\"18.2 Things that make code less obvious 使代码不那么明显的事情\"></a>18.2 Things that make code less obvious 使代码不那么明显的事情</h2><p>There are many things that can make code nonobvious; this section provides a few examples. Some of these, such as event-driven programming, are useful in some situations, so you may end up using them anyway. When this happens, extra documentation can help to minimize reader confusion.</p>\n<blockquote>\n<p>有很多事情可以使代码变得不明显。本节提供了一些示例。其中某些功能（例如事件驱动的编程）在某些情况下很有用，因此您可能最终还是要使用它们。发生这种情况时，额外的文档可以帮助最大程度地减少读者的困惑。</p>\n</blockquote>\n<p>Event-driven programming. In event-driven programming, an application responds to external occurrences, such as the arrival of a network packet or the press of a mouse button. One module is responsible for reporting incoming events. Other parts of the application register interest in certain events by asking the event module to invoke a given function or method when those events occur.</p>\n<blockquote>\n<p>事件驱动的编程。在事件驱动的编程中，应用程序对外部事件做出响应，例如网络数据包的到来或按下鼠标按钮。一个模块负责报告传入事件。应用程序的其他部分通过在事件发生时要求事件模块调用给定的函数或方法来注册对某些事件的兴趣。</p>\n</blockquote>\n<p>Event-driven programming makes it hard to follow the flow of control. The event handler functions are never invoked directly; they are invoked indirectly by the event module, typically using a function pointer or interface. Even if you find the point of invocation in the event module, it still isn’t possible to tell which specific function will be invoked: this will depend on which handlers were registered at runtime. Because of this, it’s hard to reason about event-driven code or convince yourself that it works.</p>\n<blockquote>\n<p>事件驱动的编程使其很难遵循控制流程。永远不要直接调用事件处理函数。它们是由事件模块间接调用的，通常使用函数指针或接口。即使您在事件模块中找到了调用点，也仍然无法确定将调用哪个特定功能：这将取决于在运行时注册了哪些处理程序。因此，很难推理事件驱动的代码或说服自己相信它是可行的。</p>\n</blockquote>\n<p>To compensate for this obscurity, use the interface comment for each handler function to indicate when it is invoked, as in this example:</p>\n<blockquote>\n<p>为了弥补这种模糊性，请为每个处理程序函数使用接口注释，以指示何时调用该函数，如以下示例所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This method is invoked in the dispatch thread by a transport if a</span></span><br><span class=\"line\"><span class=\"comment\"> * transport-level error prevents an RPC from completing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">void</span> Transport::RpcNotifier::failed() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>img Red Flag: Nonobvious Code img</p>\n<p>If the meaning and behavior of code cannot be understood with a quick reading, it is a red flag. Often this means that there is important information that is not immediately clear to someone reading the code.</p>\n<blockquote>\n<p>如果无法通过快速阅读来理解代码的含义和行为，则它是一个危险标记。通常，这意味着有些重要的信息对于阅读代码的人来说并不能立即清除。</p>\n</blockquote>\n<p>Generic containers. Many languages provide generic classes for grouping two or more items into a single object, such as Pair in Java or std::pair in C++. These classes are tempting because they make it easy to pass around several objects with a single variable. One of the most common uses is to return multiple values from a method, as in this Java example:</p>\n<blockquote>\n<p>通用容器。许多语言提供了用于将两个或多个项目组合到一个对象中的通用类，例如 Java 中的 Pair 或 C ++中的 std :: pair。这些类很诱人，因为它们使使用单个变量轻松传递多个对象变得容易。最常见的用途之一是从一个方法返回多个值，如以下 Java 示例所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Pair&lt;Integer, Boolean&gt;(currentTerm, <span class=\"keyword\">false</span>);</span><br></pre></td></tr></table></figure>\n\n<p>Unfortunately, generic containers result in nonobvious code because the grouped elements have generic names that obscure their meaning. In the example above, the caller must reference the two returned values with result.getKey() and result.getValue(), which give no clue about the actual meaning of the values.</p>\n<blockquote>\n<p>不幸的是，通用容器导致代码不清晰，因为分组后的元素的通用名称模糊了它们的含义。在上面的示例中，调用者必须使用 result.getKey（）和 result.getValue（）引用两个返回的值，而这两个值都不提供这些值的实际含义。</p>\n</blockquote>\n<p>Thus, it’s better not to use generic containers. If you need a container, define a new class or structure that is specialized for the particular use. You can then use meaningful names for the elements, and you can provide additional documentation in the declaration, which is not possible with the generic container.</p>\n<blockquote>\n<p>因此，最好不要使用通用容器。如果需要容器，请定义专门用于特定用途的新类或结构。然后，您可以为元素使用有意义的名称，并且可以在声明中提供其他文档，而对于常规容器而言，这是不可能的。</p>\n</blockquote>\n<p>This example illustrates a general rule: software should be designed for ease of reading, not ease of writing. Generic containers are expedient for the person writing the code, but they create confusion for all the readers that follow. It’s better for the person writing the code to spend a few extra minutes to define a specific container structure, so that the resulting code is more obvious.</p>\n<blockquote>\n<p>此示例说明了一条通用规则：软件应设计为易于阅读而不是易于编写。通用容器对于编写代码的人来说是很方便的，但是它们会使随后的所有读者感到困惑。对于编写代码的人来说，花一些额外的时间来定义特定的容器结构是更好的选择，以便使生成的代码更加明显。</p>\n</blockquote>\n<p>Different types for declaration and allocation. Consider the following Java example:</p>\n<blockquote>\n<p>不同类型的声明和分配。考虑以下 Java 示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> List&lt;Message&gt; incomingMessageList;</span><br><span class=\"line\">...</span><br><span class=\"line\">incomingMessageList = <span class=\"keyword\">new</span> ArrayList&lt;Message&gt;();</span><br></pre></td></tr></table></figure>\n\n<p>The variable is declared as a List, but the actual value is an ArrayList. This code is legal, since List is a superclass of ArrayList, but it can mislead a reader who sees the declaration but not the actual allocation. The actual type may impact how the variable is used (ArrayLists have different performance and thread-safety properties than other subclasses of List), so it is better to match the declaration with the allocation.</p>\n<blockquote>\n<p>将该变量声明为 List，但实际值为 ArrayList。这段代码是合法的，因为 List 是 ArrayList 的超类，但是它会误导看到声明但不是实际分配的读者。实际类型可能会影响变量的使用方式（ArrayList 与 List 的其他子类相比，具有不同的性能和线程安全属性），因此最好将声明与分配匹配。</p>\n</blockquote>\n<p>Code that violates reader expectations. Consider the following code, which is the main program for a Java application</p>\n<blockquote>\n<p>违反读者期望的代码。考虑以下代码，这是 Java 应用程序的主程序</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"keyword\">new</span> RaftClient(myAddress, serverAddresses);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Most applications exit when their main programs return, so readers are likely to assume that will happen here. However, that is not the case. The constructor for RaftClient creates additional threads, which continue to operate even though the application’s main thread finishes. This behavior should be documented in the interface comment for the RaftClient constructor, but the behavior is nonobvious enough that it’s worth putting a short comment at the end of main as well. The comment should indicate that the application will continue executing in other threads. Code is most obvious if it conforms to the conventions that readers will be expecting; if it doesn’t, then it’s important to document the behavior so readers aren’t confused.</p>\n<blockquote>\n<p>大多数应用程序在其主程序返回时退出，因此读者可能会认为这将在此处发生。但是，事实并非如此。RaftClient 的构造函数创建其他线程，即使应用程序的主线程完成，该线程仍可继续运行。应该在 RaftClient 构造函数的接口注释中记录此行为，但是该行为不够明显，因此值得在 main 末尾添加简短注释。该注释应指示该应用程序将继续在其他线程中执行。如果代码符合读者期望的惯例，那么它是最明显的。如果没有，那么记录该行为很重要，以免使读者感到困惑。</p>\n</blockquote>\n<h2 id=\"18-3-Conclusion-结论\"><a href=\"#18-3-Conclusion-结论\" class=\"headerlink\" title=\"18.3 Conclusion 结论\"></a>18.3 Conclusion 结论</h2><p>Another way of thinking about obviousness is in terms of information. If code is nonobvious, that usually means there is important information about the code that the reader does not have: in the RaftClient example, the reader might not know that the RaftClient constructor created new threads; in the Pair example, the reader might not know that result.getKey() returns the number of the current term.</p>\n<blockquote>\n<p>关于显而易见性的另一种思考方式是信息。如果代码不是显而易见的，则通常意味着存在有关读者所不具备的代码的重要信息：在 RaftClient 示例中，读者可能不知道 RaftClient 构造函数创建了新线程；在“配对”示例中，读者可能不知道 result.getKey（）返回当前项的编号。</p>\n</blockquote>\n<p>To make code obvious, you must ensure that readers always have the information they need to understand it. You can do this in three ways. The best way is to reduce the amount of information that is needed, using design techniques such as abstraction and eliminating special cases. Second, you can take advantage of information that readers have already acquired in other contexts (for example, by following conventions and conforming to expectations) so readers don’t have to learn new information for your code. Third, you can present the important information to them in the code, using techniques such as good names and strategic comments.</p>\n<blockquote>\n<p>为了使代码清晰可见，您必须确保读者始终拥有理解它们所需的信息。您可以通过三种方式执行此操作。最好的方法是使用抽象等设计技术并消除特殊情况，以减少所需的信息量。其次，您可以利用读者在其他情况下已经获得的信息（例如，通过遵循约定并符合期望），从而使读者不必为代码学习新的信息。第三，您可以使用诸如好名和战略注释之类的技术在代码中向他们提供重要信息。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch4","date":"2021-02-03T16:00:00.000Z","_content":"模块应该是深的\n<!-- more -->\n# 第 4 章 模块应该是深的\n\n管理软件复杂性最重要的技术之一就是设计系统，以便开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为模块化设计，本章介绍其基本原理。\n\n## 4.1 Modular design 模块化设计\n\n在模块化设计中，软件系统被分解为相对独立的模块集合。模块可以采用多种形式，例如类，子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界上，系统的复杂性就是最糟糕的模块的复杂性。\n\n不幸的是，这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在依赖关系：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。例如，方法的参数在方法与调用该方法的任何代码之间创建依赖关系。如果必需的参数更改，则必须修改该方法的所有调用以符合新的签名。依赖关系可以采用许多其他形式，并且它们可能非常微妙。模块化设计的目标是最大程度地减少模块之间的依赖性。\n\n为了管理依赖关系，我们将每个模块分为两个部分：接口和实现。接口包含使用其他模块的开发人员必须知道的所有内容，才能使用给定的模块。通常，界面描述模块的功能，但不描述模块的功能。该实现由执行接口所承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及由给定模块调用的任何其他模块的接口。除了正在使用的模块以外，开发人员无需了解其他模块的实现。\n\n考虑一个实现平衡树的模块。该模块可能包含复杂的代码，以确保树保持平衡。但是，此复杂性对于模块用户而言是不可见的。用户可以看到一个相对简单的界面，用于调用在树中插入，删除和获取节点的操作。要调用插入操作，调用者只需提供新节点的键和值即可。遍历树和拆分节点的机制在界面中不可见。\n\n就本书而言，模块是具有接口和实现的任何代码单元。面向对象编程语言中的每个类都是一个模块。类中的方法或非面向对象语言中的函数也可以视为模块：每个模块都有一个接口和一个实现，并且可以将模块化设计技术应用于它们。更高级别的子系统和服务也是模块。它们的接口可能采用不同的形式，例如内核调用或 HTTP 请求。本书中有关模块化设计的许多讨论都集中在设计类上，但是技术和概念也适用于其他种类的模块。\n\n最好的模块是那些其接口比其实现简单得多的模块。这样的模块具有两个优点。首先，一个简单的接口可以将模块强加于系统其余部分的复杂性降至最低。其次，如果以不更改其接口的方式修改了一个模块，则该修改不会影响其他模块。如果模块的接口比其实现简单得多，则可以在不影响其他模块的情况下更改模块的许多方面。\n\n## 4.2 What’s in an interface? 接口中有什么？\n\n模块的接口包含两种信息：正式信息和非正式信息。接口的形式部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。例如，方法的形式接口是其签名，其中包括其参数的名称和类型，其返回值的类型以及有关该方法引发的异常的信息。大多数编程语言都确保对方法的每次调用都提供正确数量和类型的参数以匹配其签名。类的形式接口包括其所有公共方法的签名以及任何公共变量的名称和类型。\n\n每个界面还包括非正式元素。这些没有以编程语言可以理解或执行的方式指定。接口的非正式部分包括其高级行为，例如，函数删除由其参数之一命名的文件的事实。如果对类的使用存在限制（也许必须先调用一种方法），则这些约束也是类接口的一部分。通常，如果开发人员需要了解特定信息才能使用模块，则该信息是模块界面的一部分。界面的非正式方面只能使用注释来描述，而编程语言不能确保描述是完整或准确的 1。对于大多数界面，非正式方面比正式方面更大，更复杂。\n\n明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。这有助于消除第 2.2 节中描述的“未知未知数”问题。\n\n## 4.3 Abstractions 抽象\n\n术语抽象与模块化设计的思想紧密相关。抽象是实体的简化视图，其中省略了不重要的细节。抽象是有用的，因为它们使我们更容易思考和操纵复杂的事物。\n\n在模块化编程中，每个模块以其接口的形式提供抽象。该界面提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。\n\n在抽象的定义中，“无关紧要”一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，如果细节不重要，则只能将其从抽象中省略。抽象可以通过两种方式出错。首先，它可以包含并非真正重要的细节。当这种情况发生时，它会使抽象变得不必要的复杂，从而增加了使用抽象的开发人员的认知负担。第二个错误是抽象忽略了真正重要的细节。这导致模糊不清：仅查看抽象的开发人员将不会获得正确使用抽象所需的全部信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并非如此。\n\n例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，因此它们可以确保在系统崩溃后将保留数据。因此，将数据刷新到辅助存储的规则必须在文件系统的界面中可见。\n\n我们不仅依靠抽象来管理复杂性，而且不仅在编程中，而且在日常生活中无处不在。微波炉包含复杂的电子设备，可将交流电转换为微波辐射并将该辐射分布到整个烹饪腔中。幸运的是，用户看到了一个简单得多的抽象，它由几个按钮控制微波的定时和强度。汽车提供了一种简单的抽象概念，使我们可以在不了解电动机，电池电源管理，防抱死制动，巡航控制等机制的情况下驾驶它们。\n\n## 4.4 Deep modules 深度模块\n\n最好的模块是那些提供强大功能但具有简单接口的模块。我用“深入”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如图 4.1 所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的界面；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的界面后隐藏了许多功能。深度模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见。\n\n![](../../img/figures/00012.jpeg)\n\n图 4.1：深浅模块。最好的模块很深：它们允许通过简单的界面访问许多功能。浅层模块是具有相对复杂的接口的模块，但功能不多：它不会掩盖太多的复杂性。\n\n模块深度是考虑成本与收益的一种方式。模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。最好的模块是那些收益最大，成本最低的模块。界面不错，但更多或更大的界面不一定更好！\n\nUnix 操作系统及其后代（例如 Linux）提供的文件 I/O 机制是深层接口的一个很好的例子。I/O 只有五个基本系统调用，带有简单签名：\n\n```c\nint open(const char* path, int flags, mode_t permissions);\nssize_t read(int fd, void* buffer, size_t count);\nssize_t write(int fd, const void* buffer, size_t count);\noff_t lseek(int fd, off_t offset, int referencePosition);\nint close(int fd);\n```\n\n开放系统调用采用分层文件名，例如/ a / b / c，并返回一个整数文件描述符，该描述符用于引用打开文件。open 的其他自变量提供可选信息，例如是否正在打开文件以进行读取或写入，如果不存在现有文件则是否应创建新文件，以及如果创建新文件则具有文件的访问权限。读写系统调用在应用程序内存和文件的缓冲区之间传输信息。close 结束对文件的访问。大多数文件是按顺序访问的，因此这是默认设置。但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。\n\nUnix I/O 接口的现代实现需要成千上万行代码，这些代码可以解决诸如以下的复杂问题：\n\n> - 如何在磁盘上表示文件以便有效访问？\n> - 如何存储目录，以及如何处理分层路径名以查找它们所引用的文件？\n> - 如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？\n> - 如何实现文件访问？例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信？\n> - 在同时访问多个文件时使用什么调度策略？\n> - 如何将最近访问的文件数据缓存在内存中以减少磁盘访问次数？\n> - 如何将各种不同的辅助存储设备（例如磁盘和闪存驱动器）合并到单个文件系统中？\n\n所有这些问题，以及更多的问题，都由 Unix 文件系统实现来解决。对于调用系统调用的程序员来说，它们是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的发展，但是五个基本内核调用并没有改变。\n\n深度模块的另一个示例是诸如 Go 或 Java 之类的语言中的垃圾收集器。这个模块根本没有接口。它在后台进行隐形操作以回收未使用的内存。由于将垃圾收集消除了用于释放对象的接口，因此向系统中添加垃圾回收实际上会缩小其总体接口。垃圾收集器的实现非常复杂，但是使用该语言的程序员无法发现这种复杂性。\n\nDeep modules such as Unix I/O and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementation complexity.\n\n> 诸如 Unix I/O 和垃圾收集器之类的深层模块提供了强大的抽象，因为它们易于使用，但隐藏了巨大的实现复杂性。\n\n## 4.5 Shallow modules 浅模块\n\n另一方面，浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链接列表的类很浅。操作链接列表不需要太多代码（插入或删除元素仅需几行），因此链接列表抽象不会隐藏很多细节。链接列表接口的复杂度几乎与其实现的复杂度一样高。浅类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。\n\n从管理复杂性的角度来看，此方法会使情况变得更糟，而不是更好。该方法不提供任何抽象，因为其所有功能都可以通过其接口看到。例如，调用者可能需要知道该属性将存储在 data 变量中。考虑接口并不比考虑完整实现简单。如果正确记录了该方法，则文档将比该方法的代码长。与调用方直接操作数据变量相比，调用该方法所花费的击键甚至更多。该方法增加了复杂性（以供开发人员学习的新界面的形式），但没有提供任何补偿。\n\nimg Red Flag: Shallow Module img\n\n浅层模块是一个界面相对于其提供的功能而言复杂的模块。浅层模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。\n\n## 4.6 Classitis\n\n不幸的是，深度类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该小而不是深。经常告诉学生，班级设计中最重要的事情是将较大的班级分成较小的班级。对于方法，通常会给出相同的建议：“任何长于 N 行的方法都应分为多种方法”（N 可以低至 10）。这种方法导致了大量的浅类和方法，这增加了整体系统的复杂性。\n\n“班级应小”的极端做法是我称之为“类炎”的综合症，这是由于错误地认为“班级好，所以班级越多越好”。在遭受类共患的系统中，鼓励开发人员最小化每个新类的功能：如果您想要更多的功能，请引入更多的类。分类炎可能导致个别地简单的分类，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，每个小类都有自己的接口。这些接口的累积会在系统级别产生巨大的复杂性。小类也导致冗长的编程风格，这是由于每个类都需要样板。\n\n## 4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O\n\n如今，最常见的分类病实例之一是 Java 类库。Java 语言不需要很多小类，但是分类文化似乎已在 Java 编程社区中扎根。例如，要打开文件以便从文件中读取序列化的对象，必须创建三个不同的对象：\n\n```java\nFileInputStream fileStream = new FileInputStream(fileName);\n\nBufferedInputStream bufferedStream = new BufferedInputStream(fileStream);\n\nObjectInputStream objectStream = new ObjectInputStream(bufferedStream);\n```\n\nFileInputStream 对象仅提供基本的 I/O：它不能执行缓冲的 I/O，也不能读取或写入序列化的对象。BufferedInputStream 对象将缓冲添加到 FileInputStream，而 ObjectInputStream 添加了读取和写入序列化对象的功能。一旦文件被打开，上面代码中的前两个对象 fileStream 和 bufferedStream 将永远不会被使用。以后的所有操作都使用 objectStream。\n\n特别令人烦恼（并且容易出错）的是，必须通过创建一个单独的 BufferedInputStream 对象来显式请求缓冲。如果开发人员忘记创建该对象，将没有缓冲，并且 I/O 将变慢。也许 Java 开发人员会争辩说，并不是每个人都希望对文件 I/O 使用缓冲，因此不应将其内置到基本机制中。他们可能会争辩说，最好分开保持缓冲，以便人们可以选择是否使用它。提供选择是好的，但是应该设计接口以使常见情况尽可能简单（请参阅第 6 页的公式）。几乎每个文件 I/O 用户都希望缓冲，因此默认情况下应提供缓冲。对于不需要缓冲的少数情况，该库可以提供一种禁用它的机制。\n\n相反，Unix 系统调用的设计者使常见情况变得简单。例如，他们认识到顺序 I/O 是最常见的，因此他们将其作为默认行为。使用 lseek 系统调用，随机访问仍然相对容易实现，但是仅执行顺序访问的开发人员无需了解该机制。如果一个界面具有许多功能，但是大多数开发人员只需要了解其中的一些功能，那么该界面的有效复杂性就是常用功能的复杂性。\n\n## 4.8 Conclusion 结论\n\n通过将模块的接口与其实现分开，我们可以将实现的复杂性从系统的其余部分中隐藏出来。模块的用户只需要了解其接口提供的抽象。设计类和其他模块时，最重要的问题是使它们更深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这使隐藏的复杂性最大化。\n\n1 存在语言，主要是在研究社区中，在其中可以使用规范语言来正式描述方法或功能的整体行为。可以自动检查该规范以确保它与实现相匹配。一个有趣的问题是，这样的正式规范是否可以代替接口的非正式部分。我目前的观点是，用英语描述的界面比使用正式规范语言编写的界面对开发人员来说更直观和易于理解。\n","source":"_posts/软件设计的哲学-ch4.md","raw":"---\ntitle: 软件设计的哲学 - ch4\ndate: 2021-02-04\ntags: 软件设计的哲学 软件开发 方法论\n---\n模块应该是深的\n<!-- more -->\n# 第 4 章 模块应该是深的\n\n管理软件复杂性最重要的技术之一就是设计系统，以便开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为模块化设计，本章介绍其基本原理。\n\n## 4.1 Modular design 模块化设计\n\n在模块化设计中，软件系统被分解为相对独立的模块集合。模块可以采用多种形式，例如类，子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界上，系统的复杂性就是最糟糕的模块的复杂性。\n\n不幸的是，这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在依赖关系：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。例如，方法的参数在方法与调用该方法的任何代码之间创建依赖关系。如果必需的参数更改，则必须修改该方法的所有调用以符合新的签名。依赖关系可以采用许多其他形式，并且它们可能非常微妙。模块化设计的目标是最大程度地减少模块之间的依赖性。\n\n为了管理依赖关系，我们将每个模块分为两个部分：接口和实现。接口包含使用其他模块的开发人员必须知道的所有内容，才能使用给定的模块。通常，界面描述模块的功能，但不描述模块的功能。该实现由执行接口所承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及由给定模块调用的任何其他模块的接口。除了正在使用的模块以外，开发人员无需了解其他模块的实现。\n\n考虑一个实现平衡树的模块。该模块可能包含复杂的代码，以确保树保持平衡。但是，此复杂性对于模块用户而言是不可见的。用户可以看到一个相对简单的界面，用于调用在树中插入，删除和获取节点的操作。要调用插入操作，调用者只需提供新节点的键和值即可。遍历树和拆分节点的机制在界面中不可见。\n\n就本书而言，模块是具有接口和实现的任何代码单元。面向对象编程语言中的每个类都是一个模块。类中的方法或非面向对象语言中的函数也可以视为模块：每个模块都有一个接口和一个实现，并且可以将模块化设计技术应用于它们。更高级别的子系统和服务也是模块。它们的接口可能采用不同的形式，例如内核调用或 HTTP 请求。本书中有关模块化设计的许多讨论都集中在设计类上，但是技术和概念也适用于其他种类的模块。\n\n最好的模块是那些其接口比其实现简单得多的模块。这样的模块具有两个优点。首先，一个简单的接口可以将模块强加于系统其余部分的复杂性降至最低。其次，如果以不更改其接口的方式修改了一个模块，则该修改不会影响其他模块。如果模块的接口比其实现简单得多，则可以在不影响其他模块的情况下更改模块的许多方面。\n\n## 4.2 What’s in an interface? 接口中有什么？\n\n模块的接口包含两种信息：正式信息和非正式信息。接口的形式部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。例如，方法的形式接口是其签名，其中包括其参数的名称和类型，其返回值的类型以及有关该方法引发的异常的信息。大多数编程语言都确保对方法的每次调用都提供正确数量和类型的参数以匹配其签名。类的形式接口包括其所有公共方法的签名以及任何公共变量的名称和类型。\n\n每个界面还包括非正式元素。这些没有以编程语言可以理解或执行的方式指定。接口的非正式部分包括其高级行为，例如，函数删除由其参数之一命名的文件的事实。如果对类的使用存在限制（也许必须先调用一种方法），则这些约束也是类接口的一部分。通常，如果开发人员需要了解特定信息才能使用模块，则该信息是模块界面的一部分。界面的非正式方面只能使用注释来描述，而编程语言不能确保描述是完整或准确的 1。对于大多数界面，非正式方面比正式方面更大，更复杂。\n\n明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。这有助于消除第 2.2 节中描述的“未知未知数”问题。\n\n## 4.3 Abstractions 抽象\n\n术语抽象与模块化设计的思想紧密相关。抽象是实体的简化视图，其中省略了不重要的细节。抽象是有用的，因为它们使我们更容易思考和操纵复杂的事物。\n\n在模块化编程中，每个模块以其接口的形式提供抽象。该界面提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。\n\n在抽象的定义中，“无关紧要”一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，如果细节不重要，则只能将其从抽象中省略。抽象可以通过两种方式出错。首先，它可以包含并非真正重要的细节。当这种情况发生时，它会使抽象变得不必要的复杂，从而增加了使用抽象的开发人员的认知负担。第二个错误是抽象忽略了真正重要的细节。这导致模糊不清：仅查看抽象的开发人员将不会获得正确使用抽象所需的全部信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并非如此。\n\n例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，因此它们可以确保在系统崩溃后将保留数据。因此，将数据刷新到辅助存储的规则必须在文件系统的界面中可见。\n\n我们不仅依靠抽象来管理复杂性，而且不仅在编程中，而且在日常生活中无处不在。微波炉包含复杂的电子设备，可将交流电转换为微波辐射并将该辐射分布到整个烹饪腔中。幸运的是，用户看到了一个简单得多的抽象，它由几个按钮控制微波的定时和强度。汽车提供了一种简单的抽象概念，使我们可以在不了解电动机，电池电源管理，防抱死制动，巡航控制等机制的情况下驾驶它们。\n\n## 4.4 Deep modules 深度模块\n\n最好的模块是那些提供强大功能但具有简单接口的模块。我用“深入”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如图 4.1 所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的界面；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的界面后隐藏了许多功能。深度模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见。\n\n![](../../img/figures/00012.jpeg)\n\n图 4.1：深浅模块。最好的模块很深：它们允许通过简单的界面访问许多功能。浅层模块是具有相对复杂的接口的模块，但功能不多：它不会掩盖太多的复杂性。\n\n模块深度是考虑成本与收益的一种方式。模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。最好的模块是那些收益最大，成本最低的模块。界面不错，但更多或更大的界面不一定更好！\n\nUnix 操作系统及其后代（例如 Linux）提供的文件 I/O 机制是深层接口的一个很好的例子。I/O 只有五个基本系统调用，带有简单签名：\n\n```c\nint open(const char* path, int flags, mode_t permissions);\nssize_t read(int fd, void* buffer, size_t count);\nssize_t write(int fd, const void* buffer, size_t count);\noff_t lseek(int fd, off_t offset, int referencePosition);\nint close(int fd);\n```\n\n开放系统调用采用分层文件名，例如/ a / b / c，并返回一个整数文件描述符，该描述符用于引用打开文件。open 的其他自变量提供可选信息，例如是否正在打开文件以进行读取或写入，如果不存在现有文件则是否应创建新文件，以及如果创建新文件则具有文件的访问权限。读写系统调用在应用程序内存和文件的缓冲区之间传输信息。close 结束对文件的访问。大多数文件是按顺序访问的，因此这是默认设置。但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。\n\nUnix I/O 接口的现代实现需要成千上万行代码，这些代码可以解决诸如以下的复杂问题：\n\n> - 如何在磁盘上表示文件以便有效访问？\n> - 如何存储目录，以及如何处理分层路径名以查找它们所引用的文件？\n> - 如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？\n> - 如何实现文件访问？例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信？\n> - 在同时访问多个文件时使用什么调度策略？\n> - 如何将最近访问的文件数据缓存在内存中以减少磁盘访问次数？\n> - 如何将各种不同的辅助存储设备（例如磁盘和闪存驱动器）合并到单个文件系统中？\n\n所有这些问题，以及更多的问题，都由 Unix 文件系统实现来解决。对于调用系统调用的程序员来说，它们是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的发展，但是五个基本内核调用并没有改变。\n\n深度模块的另一个示例是诸如 Go 或 Java 之类的语言中的垃圾收集器。这个模块根本没有接口。它在后台进行隐形操作以回收未使用的内存。由于将垃圾收集消除了用于释放对象的接口，因此向系统中添加垃圾回收实际上会缩小其总体接口。垃圾收集器的实现非常复杂，但是使用该语言的程序员无法发现这种复杂性。\n\nDeep modules such as Unix I/O and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementation complexity.\n\n> 诸如 Unix I/O 和垃圾收集器之类的深层模块提供了强大的抽象，因为它们易于使用，但隐藏了巨大的实现复杂性。\n\n## 4.5 Shallow modules 浅模块\n\n另一方面，浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链接列表的类很浅。操作链接列表不需要太多代码（插入或删除元素仅需几行），因此链接列表抽象不会隐藏很多细节。链接列表接口的复杂度几乎与其实现的复杂度一样高。浅类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。\n\n从管理复杂性的角度来看，此方法会使情况变得更糟，而不是更好。该方法不提供任何抽象，因为其所有功能都可以通过其接口看到。例如，调用者可能需要知道该属性将存储在 data 变量中。考虑接口并不比考虑完整实现简单。如果正确记录了该方法，则文档将比该方法的代码长。与调用方直接操作数据变量相比，调用该方法所花费的击键甚至更多。该方法增加了复杂性（以供开发人员学习的新界面的形式），但没有提供任何补偿。\n\nimg Red Flag: Shallow Module img\n\n浅层模块是一个界面相对于其提供的功能而言复杂的模块。浅层模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。\n\n## 4.6 Classitis\n\n不幸的是，深度类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该小而不是深。经常告诉学生，班级设计中最重要的事情是将较大的班级分成较小的班级。对于方法，通常会给出相同的建议：“任何长于 N 行的方法都应分为多种方法”（N 可以低至 10）。这种方法导致了大量的浅类和方法，这增加了整体系统的复杂性。\n\n“班级应小”的极端做法是我称之为“类炎”的综合症，这是由于错误地认为“班级好，所以班级越多越好”。在遭受类共患的系统中，鼓励开发人员最小化每个新类的功能：如果您想要更多的功能，请引入更多的类。分类炎可能导致个别地简单的分类，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，每个小类都有自己的接口。这些接口的累积会在系统级别产生巨大的复杂性。小类也导致冗长的编程风格，这是由于每个类都需要样板。\n\n## 4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O\n\n如今，最常见的分类病实例之一是 Java 类库。Java 语言不需要很多小类，但是分类文化似乎已在 Java 编程社区中扎根。例如，要打开文件以便从文件中读取序列化的对象，必须创建三个不同的对象：\n\n```java\nFileInputStream fileStream = new FileInputStream(fileName);\n\nBufferedInputStream bufferedStream = new BufferedInputStream(fileStream);\n\nObjectInputStream objectStream = new ObjectInputStream(bufferedStream);\n```\n\nFileInputStream 对象仅提供基本的 I/O：它不能执行缓冲的 I/O，也不能读取或写入序列化的对象。BufferedInputStream 对象将缓冲添加到 FileInputStream，而 ObjectInputStream 添加了读取和写入序列化对象的功能。一旦文件被打开，上面代码中的前两个对象 fileStream 和 bufferedStream 将永远不会被使用。以后的所有操作都使用 objectStream。\n\n特别令人烦恼（并且容易出错）的是，必须通过创建一个单独的 BufferedInputStream 对象来显式请求缓冲。如果开发人员忘记创建该对象，将没有缓冲，并且 I/O 将变慢。也许 Java 开发人员会争辩说，并不是每个人都希望对文件 I/O 使用缓冲，因此不应将其内置到基本机制中。他们可能会争辩说，最好分开保持缓冲，以便人们可以选择是否使用它。提供选择是好的，但是应该设计接口以使常见情况尽可能简单（请参阅第 6 页的公式）。几乎每个文件 I/O 用户都希望缓冲，因此默认情况下应提供缓冲。对于不需要缓冲的少数情况，该库可以提供一种禁用它的机制。\n\n相反，Unix 系统调用的设计者使常见情况变得简单。例如，他们认识到顺序 I/O 是最常见的，因此他们将其作为默认行为。使用 lseek 系统调用，随机访问仍然相对容易实现，但是仅执行顺序访问的开发人员无需了解该机制。如果一个界面具有许多功能，但是大多数开发人员只需要了解其中的一些功能，那么该界面的有效复杂性就是常用功能的复杂性。\n\n## 4.8 Conclusion 结论\n\n通过将模块的接口与其实现分开，我们可以将实现的复杂性从系统的其余部分中隐藏出来。模块的用户只需要了解其接口提供的抽象。设计类和其他模块时，最重要的问题是使它们更深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这使隐藏的复杂性最大化。\n\n1 存在语言，主要是在研究社区中，在其中可以使用规范语言来正式描述方法或功能的整体行为。可以自动检查该规范以确保它与实现相匹配。一个有趣的问题是，这样的正式规范是否可以代替接口的非正式部分。我目前的观点是，用英语描述的界面比使用正式规范语言编写的界面对开发人员来说更直观和易于理解。\n","slug":"软件设计的哲学-ch4","published":1,"updated":"2021-02-16T04:49:41.287Z","_id":"ckl6pcc31000cs4iy5clsa5is","comments":1,"layout":"post","photos":[],"link":"","content":"<p>模块应该是深的</p>\n<a id=\"more\"></a>\n<h1 id=\"第-4-章-模块应该是深的\"><a href=\"#第-4-章-模块应该是深的\" class=\"headerlink\" title=\"第 4 章 模块应该是深的\"></a>第 4 章 模块应该是深的</h1><p>管理软件复杂性最重要的技术之一就是设计系统，以便开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为模块化设计，本章介绍其基本原理。</p>\n<h2 id=\"4-1-Modular-design-模块化设计\"><a href=\"#4-1-Modular-design-模块化设计\" class=\"headerlink\" title=\"4.1 Modular design 模块化设计\"></a>4.1 Modular design 模块化设计</h2><p>在模块化设计中，软件系统被分解为相对独立的模块集合。模块可以采用多种形式，例如类，子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界上，系统的复杂性就是最糟糕的模块的复杂性。</p>\n<p>不幸的是，这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在依赖关系：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。例如，方法的参数在方法与调用该方法的任何代码之间创建依赖关系。如果必需的参数更改，则必须修改该方法的所有调用以符合新的签名。依赖关系可以采用许多其他形式，并且它们可能非常微妙。模块化设计的目标是最大程度地减少模块之间的依赖性。</p>\n<p>为了管理依赖关系，我们将每个模块分为两个部分：接口和实现。接口包含使用其他模块的开发人员必须知道的所有内容，才能使用给定的模块。通常，界面描述模块的功能，但不描述模块的功能。该实现由执行接口所承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及由给定模块调用的任何其他模块的接口。除了正在使用的模块以外，开发人员无需了解其他模块的实现。</p>\n<p>考虑一个实现平衡树的模块。该模块可能包含复杂的代码，以确保树保持平衡。但是，此复杂性对于模块用户而言是不可见的。用户可以看到一个相对简单的界面，用于调用在树中插入，删除和获取节点的操作。要调用插入操作，调用者只需提供新节点的键和值即可。遍历树和拆分节点的机制在界面中不可见。</p>\n<p>就本书而言，模块是具有接口和实现的任何代码单元。面向对象编程语言中的每个类都是一个模块。类中的方法或非面向对象语言中的函数也可以视为模块：每个模块都有一个接口和一个实现，并且可以将模块化设计技术应用于它们。更高级别的子系统和服务也是模块。它们的接口可能采用不同的形式，例如内核调用或 HTTP 请求。本书中有关模块化设计的许多讨论都集中在设计类上，但是技术和概念也适用于其他种类的模块。</p>\n<p>最好的模块是那些其接口比其实现简单得多的模块。这样的模块具有两个优点。首先，一个简单的接口可以将模块强加于系统其余部分的复杂性降至最低。其次，如果以不更改其接口的方式修改了一个模块，则该修改不会影响其他模块。如果模块的接口比其实现简单得多，则可以在不影响其他模块的情况下更改模块的许多方面。</p>\n<h2 id=\"4-2-What’s-in-an-interface-接口中有什么？\"><a href=\"#4-2-What’s-in-an-interface-接口中有什么？\" class=\"headerlink\" title=\"4.2 What’s in an interface? 接口中有什么？\"></a>4.2 What’s in an interface? 接口中有什么？</h2><p>模块的接口包含两种信息：正式信息和非正式信息。接口的形式部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。例如，方法的形式接口是其签名，其中包括其参数的名称和类型，其返回值的类型以及有关该方法引发的异常的信息。大多数编程语言都确保对方法的每次调用都提供正确数量和类型的参数以匹配其签名。类的形式接口包括其所有公共方法的签名以及任何公共变量的名称和类型。</p>\n<p>每个界面还包括非正式元素。这些没有以编程语言可以理解或执行的方式指定。接口的非正式部分包括其高级行为，例如，函数删除由其参数之一命名的文件的事实。如果对类的使用存在限制（也许必须先调用一种方法），则这些约束也是类接口的一部分。通常，如果开发人员需要了解特定信息才能使用模块，则该信息是模块界面的一部分。界面的非正式方面只能使用注释来描述，而编程语言不能确保描述是完整或准确的 1。对于大多数界面，非正式方面比正式方面更大，更复杂。</p>\n<p>明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。这有助于消除第 2.2 节中描述的“未知未知数”问题。</p>\n<h2 id=\"4-3-Abstractions-抽象\"><a href=\"#4-3-Abstractions-抽象\" class=\"headerlink\" title=\"4.3 Abstractions 抽象\"></a>4.3 Abstractions 抽象</h2><p>术语抽象与模块化设计的思想紧密相关。抽象是实体的简化视图，其中省略了不重要的细节。抽象是有用的，因为它们使我们更容易思考和操纵复杂的事物。</p>\n<p>在模块化编程中，每个模块以其接口的形式提供抽象。该界面提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。</p>\n<p>在抽象的定义中，“无关紧要”一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，如果细节不重要，则只能将其从抽象中省略。抽象可以通过两种方式出错。首先，它可以包含并非真正重要的细节。当这种情况发生时，它会使抽象变得不必要的复杂，从而增加了使用抽象的开发人员的认知负担。第二个错误是抽象忽略了真正重要的细节。这导致模糊不清：仅查看抽象的开发人员将不会获得正确使用抽象所需的全部信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并非如此。</p>\n<p>例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，因此它们可以确保在系统崩溃后将保留数据。因此，将数据刷新到辅助存储的规则必须在文件系统的界面中可见。</p>\n<p>我们不仅依靠抽象来管理复杂性，而且不仅在编程中，而且在日常生活中无处不在。微波炉包含复杂的电子设备，可将交流电转换为微波辐射并将该辐射分布到整个烹饪腔中。幸运的是，用户看到了一个简单得多的抽象，它由几个按钮控制微波的定时和强度。汽车提供了一种简单的抽象概念，使我们可以在不了解电动机，电池电源管理，防抱死制动，巡航控制等机制的情况下驾驶它们。</p>\n<h2 id=\"4-4-Deep-modules-深度模块\"><a href=\"#4-4-Deep-modules-深度模块\" class=\"headerlink\" title=\"4.4 Deep modules 深度模块\"></a>4.4 Deep modules 深度模块</h2><p>最好的模块是那些提供强大功能但具有简单接口的模块。我用“深入”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如图 4.1 所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的界面；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的界面后隐藏了许多功能。深度模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见。</p>\n<p><img src=\"../../img/figures/00012.jpeg\" alt=\"\"></p>\n<p>图 4.1：深浅模块。最好的模块很深：它们允许通过简单的界面访问许多功能。浅层模块是具有相对复杂的接口的模块，但功能不多：它不会掩盖太多的复杂性。</p>\n<p>模块深度是考虑成本与收益的一种方式。模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。最好的模块是那些收益最大，成本最低的模块。界面不错，但更多或更大的界面不一定更好！</p>\n<p>Unix 操作系统及其后代（例如 Linux）提供的文件 I/O 机制是深层接口的一个很好的例子。I/O 只有五个基本系统调用，带有简单签名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> permissions)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span>* <span class=\"built_in\">buffer</span>, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* <span class=\"built_in\">buffer</span>, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">off_t</span> <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> referencePosition)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>开放系统调用采用分层文件名，例如/ a / b / c，并返回一个整数文件描述符，该描述符用于引用打开文件。open 的其他自变量提供可选信息，例如是否正在打开文件以进行读取或写入，如果不存在现有文件则是否应创建新文件，以及如果创建新文件则具有文件的访问权限。读写系统调用在应用程序内存和文件的缓冲区之间传输信息。close 结束对文件的访问。大多数文件是按顺序访问的，因此这是默认设置。但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。</p>\n<p>Unix I/O 接口的现代实现需要成千上万行代码，这些代码可以解决诸如以下的复杂问题：</p>\n<blockquote>\n<ul>\n<li>如何在磁盘上表示文件以便有效访问？</li>\n<li>如何存储目录，以及如何处理分层路径名以查找它们所引用的文件？</li>\n<li>如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？</li>\n<li>如何实现文件访问？例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信？</li>\n<li>在同时访问多个文件时使用什么调度策略？</li>\n<li>如何将最近访问的文件数据缓存在内存中以减少磁盘访问次数？</li>\n<li>如何将各种不同的辅助存储设备（例如磁盘和闪存驱动器）合并到单个文件系统中？</li>\n</ul>\n</blockquote>\n<p>所有这些问题，以及更多的问题，都由 Unix 文件系统实现来解决。对于调用系统调用的程序员来说，它们是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的发展，但是五个基本内核调用并没有改变。</p>\n<p>深度模块的另一个示例是诸如 Go 或 Java 之类的语言中的垃圾收集器。这个模块根本没有接口。它在后台进行隐形操作以回收未使用的内存。由于将垃圾收集消除了用于释放对象的接口，因此向系统中添加垃圾回收实际上会缩小其总体接口。垃圾收集器的实现非常复杂，但是使用该语言的程序员无法发现这种复杂性。</p>\n<p>Deep modules such as Unix I/O and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementation complexity.</p>\n<blockquote>\n<p>诸如 Unix I/O 和垃圾收集器之类的深层模块提供了强大的抽象，因为它们易于使用，但隐藏了巨大的实现复杂性。</p>\n</blockquote>\n<h2 id=\"4-5-Shallow-modules-浅模块\"><a href=\"#4-5-Shallow-modules-浅模块\" class=\"headerlink\" title=\"4.5 Shallow modules 浅模块\"></a>4.5 Shallow modules 浅模块</h2><p>另一方面，浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链接列表的类很浅。操作链接列表不需要太多代码（插入或删除元素仅需几行），因此链接列表抽象不会隐藏很多细节。链接列表接口的复杂度几乎与其实现的复杂度一样高。浅类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。</p>\n<p>从管理复杂性的角度来看，此方法会使情况变得更糟，而不是更好。该方法不提供任何抽象，因为其所有功能都可以通过其接口看到。例如，调用者可能需要知道该属性将存储在 data 变量中。考虑接口并不比考虑完整实现简单。如果正确记录了该方法，则文档将比该方法的代码长。与调用方直接操作数据变量相比，调用该方法所花费的击键甚至更多。该方法增加了复杂性（以供开发人员学习的新界面的形式），但没有提供任何补偿。</p>\n<p>img Red Flag: Shallow Module img</p>\n<p>浅层模块是一个界面相对于其提供的功能而言复杂的模块。浅层模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。</p>\n<h2 id=\"4-6-Classitis\"><a href=\"#4-6-Classitis\" class=\"headerlink\" title=\"4.6 Classitis\"></a>4.6 Classitis</h2><p>不幸的是，深度类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该小而不是深。经常告诉学生，班级设计中最重要的事情是将较大的班级分成较小的班级。对于方法，通常会给出相同的建议：“任何长于 N 行的方法都应分为多种方法”（N 可以低至 10）。这种方法导致了大量的浅类和方法，这增加了整体系统的复杂性。</p>\n<p>“班级应小”的极端做法是我称之为“类炎”的综合症，这是由于错误地认为“班级好，所以班级越多越好”。在遭受类共患的系统中，鼓励开发人员最小化每个新类的功能：如果您想要更多的功能，请引入更多的类。分类炎可能导致个别地简单的分类，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，每个小类都有自己的接口。这些接口的累积会在系统级别产生巨大的复杂性。小类也导致冗长的编程风格，这是由于每个类都需要样板。</p>\n<h2 id=\"4-7-Examples-Java-and-Unix-I-O-示例：Java-和-Unix-I-O\"><a href=\"#4-7-Examples-Java-and-Unix-I-O-示例：Java-和-Unix-I-O\" class=\"headerlink\" title=\"4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O\"></a>4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O</h2><p>如今，最常见的分类病实例之一是 Java 类库。Java 语言不需要很多小类，但是分类文化似乎已在 Java 编程社区中扎根。例如，要打开文件以便从文件中读取序列化的对象，必须创建三个不同的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream fileStream = <span class=\"keyword\">new</span> FileInputStream(fileName);</span><br><span class=\"line\"></span><br><span class=\"line\">BufferedInputStream bufferedStream = <span class=\"keyword\">new</span> BufferedInputStream(fileStream);</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectInputStream objectStream = <span class=\"keyword\">new</span> ObjectInputStream(bufferedStream);</span><br></pre></td></tr></table></figure>\n\n<p>FileInputStream 对象仅提供基本的 I/O：它不能执行缓冲的 I/O，也不能读取或写入序列化的对象。BufferedInputStream 对象将缓冲添加到 FileInputStream，而 ObjectInputStream 添加了读取和写入序列化对象的功能。一旦文件被打开，上面代码中的前两个对象 fileStream 和 bufferedStream 将永远不会被使用。以后的所有操作都使用 objectStream。</p>\n<p>特别令人烦恼（并且容易出错）的是，必须通过创建一个单独的 BufferedInputStream 对象来显式请求缓冲。如果开发人员忘记创建该对象，将没有缓冲，并且 I/O 将变慢。也许 Java 开发人员会争辩说，并不是每个人都希望对文件 I/O 使用缓冲，因此不应将其内置到基本机制中。他们可能会争辩说，最好分开保持缓冲，以便人们可以选择是否使用它。提供选择是好的，但是应该设计接口以使常见情况尽可能简单（请参阅第 6 页的公式）。几乎每个文件 I/O 用户都希望缓冲，因此默认情况下应提供缓冲。对于不需要缓冲的少数情况，该库可以提供一种禁用它的机制。</p>\n<p>相反，Unix 系统调用的设计者使常见情况变得简单。例如，他们认识到顺序 I/O 是最常见的，因此他们将其作为默认行为。使用 lseek 系统调用，随机访问仍然相对容易实现，但是仅执行顺序访问的开发人员无需了解该机制。如果一个界面具有许多功能，但是大多数开发人员只需要了解其中的一些功能，那么该界面的有效复杂性就是常用功能的复杂性。</p>\n<h2 id=\"4-8-Conclusion-结论\"><a href=\"#4-8-Conclusion-结论\" class=\"headerlink\" title=\"4.8 Conclusion 结论\"></a>4.8 Conclusion 结论</h2><p>通过将模块的接口与其实现分开，我们可以将实现的复杂性从系统的其余部分中隐藏出来。模块的用户只需要了解其接口提供的抽象。设计类和其他模块时，最重要的问题是使它们更深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这使隐藏的复杂性最大化。</p>\n<p>1 存在语言，主要是在研究社区中，在其中可以使用规范语言来正式描述方法或功能的整体行为。可以自动检查该规范以确保它与实现相匹配。一个有趣的问题是，这样的正式规范是否可以代替接口的非正式部分。我目前的观点是，用英语描述的界面比使用正式规范语言编写的界面对开发人员来说更直观和易于理解。</p>\n","site":{"data":{}},"excerpt":"<p>模块应该是深的</p>","more":"<h1 id=\"第-4-章-模块应该是深的\"><a href=\"#第-4-章-模块应该是深的\" class=\"headerlink\" title=\"第 4 章 模块应该是深的\"></a>第 4 章 模块应该是深的</h1><p>管理软件复杂性最重要的技术之一就是设计系统，以便开发人员在任何给定时间只需要面对整体复杂性的一小部分。这种方法称为模块化设计，本章介绍其基本原理。</p>\n<h2 id=\"4-1-Modular-design-模块化设计\"><a href=\"#4-1-Modular-design-模块化设计\" class=\"headerlink\" title=\"4.1 Modular design 模块化设计\"></a>4.1 Modular design 模块化设计</h2><p>在模块化设计中，软件系统被分解为相对独立的模块集合。模块可以采用多种形式，例如类，子系统或服务。在理想的世界中，每个模块都将完全独立于其他模块：开发人员可以在任何模块中工作，而无需了解任何其他模块。在这个世界上，系统的复杂性就是最糟糕的模块的复杂性。</p>\n<p>不幸的是，这种理想是无法实现的。模块必须通过调用彼此的函数或方法来协同工作。结果，模块必须相互了解。模块之间将存在依赖关系：如果一个模块发生更改，则可能需要更改其他模块以进行匹配。例如，方法的参数在方法与调用该方法的任何代码之间创建依赖关系。如果必需的参数更改，则必须修改该方法的所有调用以符合新的签名。依赖关系可以采用许多其他形式，并且它们可能非常微妙。模块化设计的目标是最大程度地减少模块之间的依赖性。</p>\n<p>为了管理依赖关系，我们将每个模块分为两个部分：接口和实现。接口包含使用其他模块的开发人员必须知道的所有内容，才能使用给定的模块。通常，界面描述模块的功能，但不描述模块的功能。该实现由执行接口所承诺的代码组成。在特定模块中工作的开发人员必须了解该模块的接口和实现，以及由给定模块调用的任何其他模块的接口。除了正在使用的模块以外，开发人员无需了解其他模块的实现。</p>\n<p>考虑一个实现平衡树的模块。该模块可能包含复杂的代码，以确保树保持平衡。但是，此复杂性对于模块用户而言是不可见的。用户可以看到一个相对简单的界面，用于调用在树中插入，删除和获取节点的操作。要调用插入操作，调用者只需提供新节点的键和值即可。遍历树和拆分节点的机制在界面中不可见。</p>\n<p>就本书而言，模块是具有接口和实现的任何代码单元。面向对象编程语言中的每个类都是一个模块。类中的方法或非面向对象语言中的函数也可以视为模块：每个模块都有一个接口和一个实现，并且可以将模块化设计技术应用于它们。更高级别的子系统和服务也是模块。它们的接口可能采用不同的形式，例如内核调用或 HTTP 请求。本书中有关模块化设计的许多讨论都集中在设计类上，但是技术和概念也适用于其他种类的模块。</p>\n<p>最好的模块是那些其接口比其实现简单得多的模块。这样的模块具有两个优点。首先，一个简单的接口可以将模块强加于系统其余部分的复杂性降至最低。其次，如果以不更改其接口的方式修改了一个模块，则该修改不会影响其他模块。如果模块的接口比其实现简单得多，则可以在不影响其他模块的情况下更改模块的许多方面。</p>\n<h2 id=\"4-2-What’s-in-an-interface-接口中有什么？\"><a href=\"#4-2-What’s-in-an-interface-接口中有什么？\" class=\"headerlink\" title=\"4.2 What’s in an interface? 接口中有什么？\"></a>4.2 What’s in an interface? 接口中有什么？</h2><p>模块的接口包含两种信息：正式信息和非正式信息。接口的形式部分在代码中明确指定，并且其中一些可以通过编程语言检查其正确性。例如，方法的形式接口是其签名，其中包括其参数的名称和类型，其返回值的类型以及有关该方法引发的异常的信息。大多数编程语言都确保对方法的每次调用都提供正确数量和类型的参数以匹配其签名。类的形式接口包括其所有公共方法的签名以及任何公共变量的名称和类型。</p>\n<p>每个界面还包括非正式元素。这些没有以编程语言可以理解或执行的方式指定。接口的非正式部分包括其高级行为，例如，函数删除由其参数之一命名的文件的事实。如果对类的使用存在限制（也许必须先调用一种方法），则这些约束也是类接口的一部分。通常，如果开发人员需要了解特定信息才能使用模块，则该信息是模块界面的一部分。界面的非正式方面只能使用注释来描述，而编程语言不能确保描述是完整或准确的 1。对于大多数界面，非正式方面比正式方面更大，更复杂。</p>\n<p>明确指定接口的好处之一是，它可以准确指示开发人员使用关联模块所需要知道的内容。这有助于消除第 2.2 节中描述的“未知未知数”问题。</p>\n<h2 id=\"4-3-Abstractions-抽象\"><a href=\"#4-3-Abstractions-抽象\" class=\"headerlink\" title=\"4.3 Abstractions 抽象\"></a>4.3 Abstractions 抽象</h2><p>术语抽象与模块化设计的思想紧密相关。抽象是实体的简化视图，其中省略了不重要的细节。抽象是有用的，因为它们使我们更容易思考和操纵复杂的事物。</p>\n<p>在模块化编程中，每个模块以其接口的形式提供抽象。该界面提供了模块功能的简化视图；从模块抽象的角度来看，实现的细节并不重要，因此在接口中将其省略。</p>\n<p>在抽象的定义中，“无关紧要”一词至关重要。从抽象中忽略的不重要的细节越多越好。但是，如果细节不重要，则只能将其从抽象中省略。抽象可以通过两种方式出错。首先，它可以包含并非真正重要的细节。当这种情况发生时，它会使抽象变得不必要的复杂，从而增加了使用抽象的开发人员的认知负担。第二个错误是抽象忽略了真正重要的细节。这导致模糊不清：仅查看抽象的开发人员将不会获得正确使用抽象所需的全部信息。忽略重要细节的抽象是错误的抽象：它可能看起来很简单，但实际上并非如此。</p>\n<p>例如，考虑一个文件系统。文件系统提供的抽象省略了许多细节，例如用于选择存储设备上的哪些块用于给定文件中的数据的机制。这些详细信息对于文件系统的用户而言并不重要（只要系统提供足够的性能即可）。但是，文件系统实现的一些细节对用户很重要。大多数文件系统将数据缓存在主内存中，并且它们可能会延迟将新数据写入存储设备以提高性能。一些应用程序（例如数据库）需要确切地知道何时将数据写入存储设备，因此它们可以确保在系统崩溃后将保留数据。因此，将数据刷新到辅助存储的规则必须在文件系统的界面中可见。</p>\n<p>我们不仅依靠抽象来管理复杂性，而且不仅在编程中，而且在日常生活中无处不在。微波炉包含复杂的电子设备，可将交流电转换为微波辐射并将该辐射分布到整个烹饪腔中。幸运的是，用户看到了一个简单得多的抽象，它由几个按钮控制微波的定时和强度。汽车提供了一种简单的抽象概念，使我们可以在不了解电动机，电池电源管理，防抱死制动，巡航控制等机制的情况下驾驶它们。</p>\n<h2 id=\"4-4-Deep-modules-深度模块\"><a href=\"#4-4-Deep-modules-深度模块\" class=\"headerlink\" title=\"4.4 Deep modules 深度模块\"></a>4.4 Deep modules 深度模块</h2><p>最好的模块是那些提供强大功能但具有简单接口的模块。我用“深入”一词来描述这样的模块。为了形象化深度的概念，假设每个模块都由一个矩形表示，如图 4.1 所示。每个矩形的面积与模块实现的功能成比例。矩形的顶部边缘代表模块的界面；边缘的长度表示接口的复杂性。最好的模块很深：它们在简单的界面后隐藏了许多功能。深度模块是一个很好的抽象，因为其内部复杂性的很小一部分对其用户可见。</p>\n<p><img src=\"../../img/figures/00012.jpeg\" alt=\"\"></p>\n<p>图 4.1：深浅模块。最好的模块很深：它们允许通过简单的界面访问许多功能。浅层模块是具有相对复杂的接口的模块，但功能不多：它不会掩盖太多的复杂性。</p>\n<p>模块深度是考虑成本与收益的一种方式。模块提供的好处是其功能。模块的成本（就系统复杂性而言）是其接口。模块的接口代表了模块强加给系统其余部分的复杂性：接口越小越简单，引入的复杂性就越小。最好的模块是那些收益最大，成本最低的模块。界面不错，但更多或更大的界面不一定更好！</p>\n<p>Unix 操作系统及其后代（例如 Linux）提供的文件 I/O 机制是深层接口的一个很好的例子。I/O 只有五个基本系统调用，带有简单签名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">open</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span>* path, <span class=\"keyword\">int</span> flags, <span class=\"keyword\">mode_t</span> permissions)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">read</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">void</span>* <span class=\"built_in\">buffer</span>, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">ssize_t</span> <span class=\"title\">write</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">const</span> <span class=\"keyword\">void</span>* <span class=\"built_in\">buffer</span>, <span class=\"keyword\">size_t</span> count)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">off_t</span> <span class=\"title\">lseek</span><span class=\"params\">(<span class=\"keyword\">int</span> fd, <span class=\"keyword\">off_t</span> offset, <span class=\"keyword\">int</span> referencePosition)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">close</span><span class=\"params\">(<span class=\"keyword\">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>开放系统调用采用分层文件名，例如/ a / b / c，并返回一个整数文件描述符，该描述符用于引用打开文件。open 的其他自变量提供可选信息，例如是否正在打开文件以进行读取或写入，如果不存在现有文件则是否应创建新文件，以及如果创建新文件则具有文件的访问权限。读写系统调用在应用程序内存和文件的缓冲区之间传输信息。close 结束对文件的访问。大多数文件是按顺序访问的，因此这是默认设置。但是，可以通过调用 lseek 系统调用来更改当前访问位置来实现随机访问。</p>\n<p>Unix I/O 接口的现代实现需要成千上万行代码，这些代码可以解决诸如以下的复杂问题：</p>\n<blockquote>\n<ul>\n<li>如何在磁盘上表示文件以便有效访问？</li>\n<li>如何存储目录，以及如何处理分层路径名以查找它们所引用的文件？</li>\n<li>如何强制执行权限，以使一个用户无法修改或删除另一用户的文件？</li>\n<li>如何实现文件访问？例如，如何在中断处理程序和后台代码之间划分功能，以及这两个元素如何安全通信？</li>\n<li>在同时访问多个文件时使用什么调度策略？</li>\n<li>如何将最近访问的文件数据缓存在内存中以减少磁盘访问次数？</li>\n<li>如何将各种不同的辅助存储设备（例如磁盘和闪存驱动器）合并到单个文件系统中？</li>\n</ul>\n</blockquote>\n<p>所有这些问题，以及更多的问题，都由 Unix 文件系统实现来解决。对于调用系统调用的程序员来说，它们是不可见的。多年来，Unix I/O 接口的实现已经发生了根本的发展，但是五个基本内核调用并没有改变。</p>\n<p>深度模块的另一个示例是诸如 Go 或 Java 之类的语言中的垃圾收集器。这个模块根本没有接口。它在后台进行隐形操作以回收未使用的内存。由于将垃圾收集消除了用于释放对象的接口，因此向系统中添加垃圾回收实际上会缩小其总体接口。垃圾收集器的实现非常复杂，但是使用该语言的程序员无法发现这种复杂性。</p>\n<p>Deep modules such as Unix I/O and garbage collectors provide powerful abstractions because they are easy to use, yet they hide significant implementation complexity.</p>\n<blockquote>\n<p>诸如 Unix I/O 和垃圾收集器之类的深层模块提供了强大的抽象，因为它们易于使用，但隐藏了巨大的实现复杂性。</p>\n</blockquote>\n<h2 id=\"4-5-Shallow-modules-浅模块\"><a href=\"#4-5-Shallow-modules-浅模块\" class=\"headerlink\" title=\"4.5 Shallow modules 浅模块\"></a>4.5 Shallow modules 浅模块</h2><p>另一方面，浅层模块是其接口与其提供的功能相比相对复杂的模块。例如，实现链接列表的类很浅。操作链接列表不需要太多代码（插入或删除元素仅需几行），因此链接列表抽象不会隐藏很多细节。链接列表接口的复杂度几乎与其实现的复杂度一样高。浅类有时是不可避免的，但是它们在管理复杂性方面没有提供太多帮助。</p>\n<p>从管理复杂性的角度来看，此方法会使情况变得更糟，而不是更好。该方法不提供任何抽象，因为其所有功能都可以通过其接口看到。例如，调用者可能需要知道该属性将存储在 data 变量中。考虑接口并不比考虑完整实现简单。如果正确记录了该方法，则文档将比该方法的代码长。与调用方直接操作数据变量相比，调用该方法所花费的击键甚至更多。该方法增加了复杂性（以供开发人员学习的新界面的形式），但没有提供任何补偿。</p>\n<p>img Red Flag: Shallow Module img</p>\n<p>浅层模块是一个界面相对于其提供的功能而言复杂的模块。浅层模块在对抗复杂性方面无济于事，因为它们提供的好处（不必了解它们在内部如何工作）被学习和使用其接口的成本所抵消。小模块往往很浅。</p>\n<h2 id=\"4-6-Classitis\"><a href=\"#4-6-Classitis\" class=\"headerlink\" title=\"4.6 Classitis\"></a>4.6 Classitis</h2><p>不幸的是，深度类的价值在今天并未得到广泛认可。编程中的传统观点是，类应该小而不是深。经常告诉学生，班级设计中最重要的事情是将较大的班级分成较小的班级。对于方法，通常会给出相同的建议：“任何长于 N 行的方法都应分为多种方法”（N 可以低至 10）。这种方法导致了大量的浅类和方法，这增加了整体系统的复杂性。</p>\n<p>“班级应小”的极端做法是我称之为“类炎”的综合症，这是由于错误地认为“班级好，所以班级越多越好”。在遭受类共患的系统中，鼓励开发人员最小化每个新类的功能：如果您想要更多的功能，请引入更多的类。分类炎可能导致个别地简单的分类，但是却增加了整个系统的复杂性。小类不会贡献太多功能，因此必须有很多小类，每个小类都有自己的接口。这些接口的累积会在系统级别产生巨大的复杂性。小类也导致冗长的编程风格，这是由于每个类都需要样板。</p>\n<h2 id=\"4-7-Examples-Java-and-Unix-I-O-示例：Java-和-Unix-I-O\"><a href=\"#4-7-Examples-Java-and-Unix-I-O-示例：Java-和-Unix-I-O\" class=\"headerlink\" title=\"4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O\"></a>4.7 Examples: Java and Unix I/O 示例：Java 和 Unix I/O</h2><p>如今，最常见的分类病实例之一是 Java 类库。Java 语言不需要很多小类，但是分类文化似乎已在 Java 编程社区中扎根。例如，要打开文件以便从文件中读取序列化的对象，必须创建三个不同的对象：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FileInputStream fileStream = <span class=\"keyword\">new</span> FileInputStream(fileName);</span><br><span class=\"line\"></span><br><span class=\"line\">BufferedInputStream bufferedStream = <span class=\"keyword\">new</span> BufferedInputStream(fileStream);</span><br><span class=\"line\"></span><br><span class=\"line\">ObjectInputStream objectStream = <span class=\"keyword\">new</span> ObjectInputStream(bufferedStream);</span><br></pre></td></tr></table></figure>\n\n<p>FileInputStream 对象仅提供基本的 I/O：它不能执行缓冲的 I/O，也不能读取或写入序列化的对象。BufferedInputStream 对象将缓冲添加到 FileInputStream，而 ObjectInputStream 添加了读取和写入序列化对象的功能。一旦文件被打开，上面代码中的前两个对象 fileStream 和 bufferedStream 将永远不会被使用。以后的所有操作都使用 objectStream。</p>\n<p>特别令人烦恼（并且容易出错）的是，必须通过创建一个单独的 BufferedInputStream 对象来显式请求缓冲。如果开发人员忘记创建该对象，将没有缓冲，并且 I/O 将变慢。也许 Java 开发人员会争辩说，并不是每个人都希望对文件 I/O 使用缓冲，因此不应将其内置到基本机制中。他们可能会争辩说，最好分开保持缓冲，以便人们可以选择是否使用它。提供选择是好的，但是应该设计接口以使常见情况尽可能简单（请参阅第 6 页的公式）。几乎每个文件 I/O 用户都希望缓冲，因此默认情况下应提供缓冲。对于不需要缓冲的少数情况，该库可以提供一种禁用它的机制。</p>\n<p>相反，Unix 系统调用的设计者使常见情况变得简单。例如，他们认识到顺序 I/O 是最常见的，因此他们将其作为默认行为。使用 lseek 系统调用，随机访问仍然相对容易实现，但是仅执行顺序访问的开发人员无需了解该机制。如果一个界面具有许多功能，但是大多数开发人员只需要了解其中的一些功能，那么该界面的有效复杂性就是常用功能的复杂性。</p>\n<h2 id=\"4-8-Conclusion-结论\"><a href=\"#4-8-Conclusion-结论\" class=\"headerlink\" title=\"4.8 Conclusion 结论\"></a>4.8 Conclusion 结论</h2><p>通过将模块的接口与其实现分开，我们可以将实现的复杂性从系统的其余部分中隐藏出来。模块的用户只需要了解其接口提供的抽象。设计类和其他模块时，最重要的问题是使它们更深，以使它们具有适用于常见用例的简单接口，但仍提供重要的功能。这使隐藏的复杂性最大化。</p>\n<p>1 存在语言，主要是在研究社区中，在其中可以使用规范语言来正式描述方法或功能的整体行为。可以自动检查该规范以确保它与实现相匹配。一个有趣的问题是，这样的正式规范是否可以代替接口的非正式部分。我目前的观点是，用英语描述的界面比使用正式规范语言编写的界面对开发人员来说更直观和易于理解。</p>"},{"title":"软件设计的哲学 - ch6","date":"2021-02-05T16:00:00.000Z","_content":"通用模块更深入\n<!-- more -->\n# 第 6 章 通用模块更深入\n\n> Chapter 6 General-Purpose Modules are Deeper\n\nOne of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion. Some might argue that you should take a general-purpose approach, in which you implement a mechanism that can be used to address a broad range of problems, not just the ones that are important today. In this case, the new mechanism may find unanticipated uses in the future, thereby saving time. The general-purpose approach seems consistent with the investment mindset discussed in Chapter 3, where you spend a bit more time up front to save time later on.\n\n> 设计新模块时，您将面临的最普遍的决定之一就是是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方法，在这种方法中，您将实现一种可用于解决广泛问题的机制，而不仅是当今重要的问题。在这种情况下，新机制可能会在将来发现意外用途，从而节省时间。通用方法似乎与第 3 章中讨论的投资思路一致，在这里您花了更多时间在前面，以节省以后的时间。\n\nOn the other hand, we know that it’s hard to predict the future needs of a software system, so a general-purpose solution might include facilities that are never actually needed. Furthermore, if you implement something that is too general-purpose, it might not do a good job of solving the particular problem you have today. As a result, some might argue that it’s better to focus on today’s needs, building just what you know you need, and specializing it for the way you plan to use it today. If you take the special-purpose approach and discover additional uses later, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.\n\n> 另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用特殊用途的方法并在以后发现更多用途，则始终可以对其进行重构以使其通用。专用方法似乎与软件开发的增量方法一致。\n\n## 6.1 Make classes somewhat general-purpose 使类变得通用\n\nIn my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.\n\n> 以我的经验，最有效的方法是以某种通用的方式实现新模块。短语“有点通用”表示该模块的功能应反映您当前的需求，但其接口则不应。相反，该接口应该足够通用以支持多种用途。该界面应易于使用，以满足当今的需求，而不必专门与它们联系在一起。“有点”这个词很重要：不要被带走并建造通用的东西，以致于很难满足当前的需求。\n\nThe most important (and perhaps surprising) benefit of the general-purpose approach is that it results in simpler and deeper interfaces than a special-purpose approach. The general-purpose approach can also save you time in the future, if you reuse the class for other purposes. However, even if the module is only used for its original purpose, the general-purpose approach is still better because of its simplicity.\n\n> 通用方法最重要的（也许是令人惊讶的）好处是，与专用方法相比，它导致更简单，更深入的界面。如果您将该类用于其他目的，则通用方法还可以节省将来的时间。但是，即使该模块仅用于其原始用途，由于其简单性，通用方法仍然更好。\n\n## 6.2 Example: storing text for an editor 示例：为编辑器存储文本\n\nLet’s consider an example from a software design class in which students were asked to build simple GUI text editors. The editors had to display a file and allow users to point, click, and type to edit the file. The editors had to support multiple simultaneous views of the same file in different windows; they also had to support multi-level undo and redo for modifications to the file.\n\n> 让我们考虑一个软件设计课程的示例，其中要求学生构建简单的 GUI 文本编辑器。编辑器必须显示一个文件，并允许用户指向，单击并键入以编辑该文件。编辑者必须在不同的窗口中支持同一文件的多个同时视图。他们还必须支持多级撤消和重做以修改文件。\n\nEach of the student projects included a class that managed the underlying text of the file. The text classes typically provided methods for loading a file into memory, reading and modifying the text of the file, and writing the modified text back to a file.\n\n> 每个学生项目都包括一个管理文件的基础文本的类。文本类通常提供以下方法：将文件加载到内存，读取和修改文件的文本以及将修改后的文本写回到文件。\n\nMany of the student teams implemented special-purpose APIs for the text class. They knew that the class was going to be used in an interactive editor, so they thought about the features that the editor had to provide and tailored the API of the text class to those specific features. For example, if a user of the editor typed the backspace key, the editor deleted the character immediately to the left of the cursor; if the user typed the delete key, the editor deleted the character immediately to the right of the cursor. Knowing this, some of the teams created one method in the text class to support each of these specific features:\n\n> 许多学生团队为文本课实现了专用的 API。他们知道该类将在交互式编辑器中使用，因此他们考虑了编辑器必须提供的功能，并针对这些特定功能定制了文本类的 API。例如，如果编辑者的用户键入了退格键，则编辑者会立即删除光标左侧的字符；如果用户键入删除键，则编辑器立即删除光标右侧的字符。知道这一点后，一些团队在文本类中创建了一个方法来支持以下每个特定功能：\n\n```java\nvoid backspace(Cursor cursor);\n\nvoid delete(Cursor cursor);\n```\n\nEach of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:\n\n> 这些方法中的每一个都以光标位置作为参数。特殊类型的光标表示此位置。编辑器还必须支持可以复制或删除的选择。学生通过定义选择类并在删除过程中将该类的对象传递给文本类来解决此问题：\n\n```java\nvoid deleteSelection(Selection selection);\n```\n\nThe students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users. In reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class. The text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation. Many of the methods, such as delete, were only invoked in a single place. As a result, a developer working on the user interface had to learn about a large number of methods for the text class.\n\n> 学生们可能认为，如果文本类的方法与用户可见的功能相对应，则将更易于实现用户界面。但是，实际上，这种专业化对用户界面代码几乎没有好处，并且为使用用户界面或文本类的开发人员带来了很高的认知负担。文本类以大量浅层方法结束，每种浅层方法仅适用于一个用户界面操作。许多方法（例如 delete）仅在单个位置调用。结果，在用户界面上工作的开发人员必须学习大量有关文本类的方法。\n\nThis approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well. One of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.\n\n> 这种方法在用户界面和文本类之间造成了信息泄漏。与用户界面有关的抽象（例如选择或退格键）反映在文本类中；这增加了从事文本课的开发人员的认知负担。每个新的用户界面操作都需要在文本类中定义一个新方法，因此使用该用户界面的开发人员也可能最终也要使用该文本类。类设计的目标之一是允许每个类独立开发，但是专用方法将用户界面和文本类联系在一起。\n\n## 6.3 A more general-purpose API 更通用的 API\n\nA better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text:\n\n> 更好的方法是使文本类更通用。仅应根据基本文本功能定义其 API，而不应反映将用其实现的更高级别的操作。例如，只需两种方法即可修改文本：\n\n```java\nvoid insert(Position position, String newText);\n\nvoid delete(Position start, Position end);\n```\n\nThe first method inserts an arbitrary string at an arbitrary position within the text, and the second method deletes all of the characters at positions greater than or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions within the text, such as the following:\n\n> 第一种方法在文本内的任意位置插入任意字符串，第二种方法删除大于或等于开始但小于结束的位置处的所有字符。此 API 还使用了更通用的 Position 类型来代替 Cursor，它反映了特定的用户界面。文本类还应该提供用于操纵文本中位置的通用工具，例如：\n\n```java\nPosition changePosition(Position position, int numChars);\n```\n\nThis method returns a new position that is a given number of characters away from a given position. If the numChars argument is positive, the new position is later in the file than position; if numChars is negative, the new position is before position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the following code (assuming the cursor variable holds the current cursor position):\n\n> 此方法返回一个新位置，该位置与给定位置相距给定字符数。如果 numChars 参数为正，则新位置在文件中比位置晚；如果 numChars 为负，则新位置在位置之前。必要时，该方法会自动跳到下一行或上一行。使用这些方法，可以使用以下代码来实现删除键（假定 cursor 变量保留当前光标的位置）：\n\n```java\ntext.delete(cursor, text.changePosition(cursor, 1));\n```\n\nSimilarly, the backspace key can be implemented as follows:\n\n> 同样，可以按以下方式实现退格键：\n\n```java\ntext.delete(text.changePosition(cursor, -1), cursor);\n```\n\nWith the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API. However, the new code is more obvious than the old code. A developer working in the user interface module probably cares about which characters are deleted by the backspace key. With the new code, this is obvious. With the old code, the developer had to go to the text class and read the documentation and/or code of the backspace method to verify the behavior. Furthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.\n\n> 使用通用文本 API，实现用户界面功能（如删除和退格）的代码比使用专用文本 API 的原始方法要长一些。但是，新代码比旧代码更明显。在用户界面模块中工作的开发人员可能会关心由 Backspace 键删除哪些字符。使用新代码，这是显而易见的。使用旧代码，开发人员必须转到文本类并阅读退格方法的文档和/或代码以验证行为。此外，通用方法总体上比专用方法具有更少的代码，因为它用较少数量的通用方法代替了文本类中的大量专用方法。\n\nA text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor. As one example, suppose you were building an application that modified a specified file by replacing all occurrences of a particular string with another string. Methods from the specialized text class, such as backspace and delete, would have little value for this application. However, the general-purpose text class would already have most of the functionality needed for the new application. All that is missing is a method to search for the next occurrence of a given string, such as this:\n\n> 使用通用接口实现的文本类除交互式编辑器外，还可以用于其他目的。作为一个示例，假设您正在构建一个应用程序，该应用程序通过将所有出现的特定字符串替换为另一个字符串来修改指定文件。专用文本类中的方法（例如，退格键和 Delete）对于此应用程序几乎没有价值。但是，通用文本类已经具有新应用程序所需的大多数功能。缺少的只是一种搜索给定字符串的下一个匹配项的方法，例如：\n\n```java\nPosition findNext(Position start, String string);\n```\n\nOf course, an interactive text editor is likely to have a mechanism for searching and replacing, in which case the text class would already include this method.\n\n> 当然，交互式文本编辑器可能具有搜索和替换的机制，在这种情况下，文本类将已经包含此方法。\n\n## 6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息\n\nThe general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding. The text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functions in the text class. The general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.\n\n> 通用方法在文本和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。可以添加新的用户界面功能，而无需在文本类中创建新的支持功能。通用界面还减轻了认知负担：使用用户界面的开发人员只需要学习一些简单的方法，就可以将其重复用于各种目的。\n\nThe backspace method in the original version of the text class was a false abstraction. It purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior. Putting the method in the text class just makes it harder for user interface developers to get the information they need. One of the most important elements of software design is determining who needs to know what, and when. When the details are important, it is better to make them explicit and as obvious as possible, such as the revised implementation of the backspace operation. Hiding this information behind an interface just creates obscurity.\n\n> 文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会阅读退格方法的代码，以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的 Backspace 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。\n\n## 6.5 Questions to ask yourself 问自己的问题\n\nIt is easier to recognize a clean general-purpose class design than it is to create one. Here are some questions you can ask yourself, which will help you to find the right balance between general-purpose and special-purpose for an interface.\n\n> 识别干净的通用类设计要比创建一个简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。\n\nWhat is the simplest interface that will cover all my current needs? If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things.\n\n> 满足我当前所有需求的最简单的界面是什么？如果减少 API 中的方法数量而不降低其整体功能，则可能正在创建更多通用的方法。专用文本 API 至少具有三种删除文本的方法：退格，删除和 deleteSelection。通用性更强的 API 只有一种删除文本的方法，可同时满足所有三个目的。仅在每种方法的 API 保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多其他参数以减少方法数量，那么您可能并没有真正简化事情。\n\nIn how many situations will this method be used? If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method.\n\n> 在多少情况下会使用此方法？如果一种方法是为特定用途而设计的，例如退格方法，那是一个危险信号，它可能太特殊了。看看是否可以用一个通用方法替换几种专用方法。\n\nIs this API easy to use for my current needs? This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.\n\n> 这个 API 是否易于使用以满足我当前的需求？这个问题可以帮助您确定何时使 API 变得简单而通用。如果您必须编写许多其他代码才能将类用于当前用途，那么这是一个危险信号，即该接口未提供正确的功能。例如，针对文本类的一种方法是围绕单字符操作进行设计：insert 插入单个字符，而 delete 删除单个字符。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高级别的代码将包含许多循环，用于插入或删除字符范围。单字符方法对于大型操作也将是低效的。\n\n## 6.6 Conclusion 结论\n\nGeneral-purpose interfaces have many advantages over special-purpose ones. They tend to be simpler, with fewer methods that are deeper. They also provide a cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes. Making your modules somewhat general-purpose is one of the best ways to reduce overall system complexity.\n\n> 通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。它们还提供了类之间的更清晰的分隔，而专用接口则倾向于在类之间泄漏信息。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一。\n","source":"_posts/软件设计的哲学-ch6.md","raw":"---\ntitle: 软件设计的哲学 - ch6\ndate: 2021-02-6\ntags: 软件设计的哲学 软件开发 方法论\n---\n通用模块更深入\n<!-- more -->\n# 第 6 章 通用模块更深入\n\n> Chapter 6 General-Purpose Modules are Deeper\n\nOne of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion. Some might argue that you should take a general-purpose approach, in which you implement a mechanism that can be used to address a broad range of problems, not just the ones that are important today. In this case, the new mechanism may find unanticipated uses in the future, thereby saving time. The general-purpose approach seems consistent with the investment mindset discussed in Chapter 3, where you spend a bit more time up front to save time later on.\n\n> 设计新模块时，您将面临的最普遍的决定之一就是是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方法，在这种方法中，您将实现一种可用于解决广泛问题的机制，而不仅是当今重要的问题。在这种情况下，新机制可能会在将来发现意外用途，从而节省时间。通用方法似乎与第 3 章中讨论的投资思路一致，在这里您花了更多时间在前面，以节省以后的时间。\n\nOn the other hand, we know that it’s hard to predict the future needs of a software system, so a general-purpose solution might include facilities that are never actually needed. Furthermore, if you implement something that is too general-purpose, it might not do a good job of solving the particular problem you have today. As a result, some might argue that it’s better to focus on today’s needs, building just what you know you need, and specializing it for the way you plan to use it today. If you take the special-purpose approach and discover additional uses later, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.\n\n> 另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用特殊用途的方法并在以后发现更多用途，则始终可以对其进行重构以使其通用。专用方法似乎与软件开发的增量方法一致。\n\n## 6.1 Make classes somewhat general-purpose 使类变得通用\n\nIn my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.\n\n> 以我的经验，最有效的方法是以某种通用的方式实现新模块。短语“有点通用”表示该模块的功能应反映您当前的需求，但其接口则不应。相反，该接口应该足够通用以支持多种用途。该界面应易于使用，以满足当今的需求，而不必专门与它们联系在一起。“有点”这个词很重要：不要被带走并建造通用的东西，以致于很难满足当前的需求。\n\nThe most important (and perhaps surprising) benefit of the general-purpose approach is that it results in simpler and deeper interfaces than a special-purpose approach. The general-purpose approach can also save you time in the future, if you reuse the class for other purposes. However, even if the module is only used for its original purpose, the general-purpose approach is still better because of its simplicity.\n\n> 通用方法最重要的（也许是令人惊讶的）好处是，与专用方法相比，它导致更简单，更深入的界面。如果您将该类用于其他目的，则通用方法还可以节省将来的时间。但是，即使该模块仅用于其原始用途，由于其简单性，通用方法仍然更好。\n\n## 6.2 Example: storing text for an editor 示例：为编辑器存储文本\n\nLet’s consider an example from a software design class in which students were asked to build simple GUI text editors. The editors had to display a file and allow users to point, click, and type to edit the file. The editors had to support multiple simultaneous views of the same file in different windows; they also had to support multi-level undo and redo for modifications to the file.\n\n> 让我们考虑一个软件设计课程的示例，其中要求学生构建简单的 GUI 文本编辑器。编辑器必须显示一个文件，并允许用户指向，单击并键入以编辑该文件。编辑者必须在不同的窗口中支持同一文件的多个同时视图。他们还必须支持多级撤消和重做以修改文件。\n\nEach of the student projects included a class that managed the underlying text of the file. The text classes typically provided methods for loading a file into memory, reading and modifying the text of the file, and writing the modified text back to a file.\n\n> 每个学生项目都包括一个管理文件的基础文本的类。文本类通常提供以下方法：将文件加载到内存，读取和修改文件的文本以及将修改后的文本写回到文件。\n\nMany of the student teams implemented special-purpose APIs for the text class. They knew that the class was going to be used in an interactive editor, so they thought about the features that the editor had to provide and tailored the API of the text class to those specific features. For example, if a user of the editor typed the backspace key, the editor deleted the character immediately to the left of the cursor; if the user typed the delete key, the editor deleted the character immediately to the right of the cursor. Knowing this, some of the teams created one method in the text class to support each of these specific features:\n\n> 许多学生团队为文本课实现了专用的 API。他们知道该类将在交互式编辑器中使用，因此他们考虑了编辑器必须提供的功能，并针对这些特定功能定制了文本类的 API。例如，如果编辑者的用户键入了退格键，则编辑者会立即删除光标左侧的字符；如果用户键入删除键，则编辑器立即删除光标右侧的字符。知道这一点后，一些团队在文本类中创建了一个方法来支持以下每个特定功能：\n\n```java\nvoid backspace(Cursor cursor);\n\nvoid delete(Cursor cursor);\n```\n\nEach of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:\n\n> 这些方法中的每一个都以光标位置作为参数。特殊类型的光标表示此位置。编辑器还必须支持可以复制或删除的选择。学生通过定义选择类并在删除过程中将该类的对象传递给文本类来解决此问题：\n\n```java\nvoid deleteSelection(Selection selection);\n```\n\nThe students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users. In reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class. The text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation. Many of the methods, such as delete, were only invoked in a single place. As a result, a developer working on the user interface had to learn about a large number of methods for the text class.\n\n> 学生们可能认为，如果文本类的方法与用户可见的功能相对应，则将更易于实现用户界面。但是，实际上，这种专业化对用户界面代码几乎没有好处，并且为使用用户界面或文本类的开发人员带来了很高的认知负担。文本类以大量浅层方法结束，每种浅层方法仅适用于一个用户界面操作。许多方法（例如 delete）仅在单个位置调用。结果，在用户界面上工作的开发人员必须学习大量有关文本类的方法。\n\nThis approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well. One of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.\n\n> 这种方法在用户界面和文本类之间造成了信息泄漏。与用户界面有关的抽象（例如选择或退格键）反映在文本类中；这增加了从事文本课的开发人员的认知负担。每个新的用户界面操作都需要在文本类中定义一个新方法，因此使用该用户界面的开发人员也可能最终也要使用该文本类。类设计的目标之一是允许每个类独立开发，但是专用方法将用户界面和文本类联系在一起。\n\n## 6.3 A more general-purpose API 更通用的 API\n\nA better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text:\n\n> 更好的方法是使文本类更通用。仅应根据基本文本功能定义其 API，而不应反映将用其实现的更高级别的操作。例如，只需两种方法即可修改文本：\n\n```java\nvoid insert(Position position, String newText);\n\nvoid delete(Position start, Position end);\n```\n\nThe first method inserts an arbitrary string at an arbitrary position within the text, and the second method deletes all of the characters at positions greater than or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions within the text, such as the following:\n\n> 第一种方法在文本内的任意位置插入任意字符串，第二种方法删除大于或等于开始但小于结束的位置处的所有字符。此 API 还使用了更通用的 Position 类型来代替 Cursor，它反映了特定的用户界面。文本类还应该提供用于操纵文本中位置的通用工具，例如：\n\n```java\nPosition changePosition(Position position, int numChars);\n```\n\nThis method returns a new position that is a given number of characters away from a given position. If the numChars argument is positive, the new position is later in the file than position; if numChars is negative, the new position is before position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the following code (assuming the cursor variable holds the current cursor position):\n\n> 此方法返回一个新位置，该位置与给定位置相距给定字符数。如果 numChars 参数为正，则新位置在文件中比位置晚；如果 numChars 为负，则新位置在位置之前。必要时，该方法会自动跳到下一行或上一行。使用这些方法，可以使用以下代码来实现删除键（假定 cursor 变量保留当前光标的位置）：\n\n```java\ntext.delete(cursor, text.changePosition(cursor, 1));\n```\n\nSimilarly, the backspace key can be implemented as follows:\n\n> 同样，可以按以下方式实现退格键：\n\n```java\ntext.delete(text.changePosition(cursor, -1), cursor);\n```\n\nWith the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API. However, the new code is more obvious than the old code. A developer working in the user interface module probably cares about which characters are deleted by the backspace key. With the new code, this is obvious. With the old code, the developer had to go to the text class and read the documentation and/or code of the backspace method to verify the behavior. Furthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.\n\n> 使用通用文本 API，实现用户界面功能（如删除和退格）的代码比使用专用文本 API 的原始方法要长一些。但是，新代码比旧代码更明显。在用户界面模块中工作的开发人员可能会关心由 Backspace 键删除哪些字符。使用新代码，这是显而易见的。使用旧代码，开发人员必须转到文本类并阅读退格方法的文档和/或代码以验证行为。此外，通用方法总体上比专用方法具有更少的代码，因为它用较少数量的通用方法代替了文本类中的大量专用方法。\n\nA text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor. As one example, suppose you were building an application that modified a specified file by replacing all occurrences of a particular string with another string. Methods from the specialized text class, such as backspace and delete, would have little value for this application. However, the general-purpose text class would already have most of the functionality needed for the new application. All that is missing is a method to search for the next occurrence of a given string, such as this:\n\n> 使用通用接口实现的文本类除交互式编辑器外，还可以用于其他目的。作为一个示例，假设您正在构建一个应用程序，该应用程序通过将所有出现的特定字符串替换为另一个字符串来修改指定文件。专用文本类中的方法（例如，退格键和 Delete）对于此应用程序几乎没有价值。但是，通用文本类已经具有新应用程序所需的大多数功能。缺少的只是一种搜索给定字符串的下一个匹配项的方法，例如：\n\n```java\nPosition findNext(Position start, String string);\n```\n\nOf course, an interactive text editor is likely to have a mechanism for searching and replacing, in which case the text class would already include this method.\n\n> 当然，交互式文本编辑器可能具有搜索和替换的机制，在这种情况下，文本类将已经包含此方法。\n\n## 6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息\n\nThe general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding. The text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functions in the text class. The general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.\n\n> 通用方法在文本和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。可以添加新的用户界面功能，而无需在文本类中创建新的支持功能。通用界面还减轻了认知负担：使用用户界面的开发人员只需要学习一些简单的方法，就可以将其重复用于各种目的。\n\nThe backspace method in the original version of the text class was a false abstraction. It purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior. Putting the method in the text class just makes it harder for user interface developers to get the information they need. One of the most important elements of software design is determining who needs to know what, and when. When the details are important, it is better to make them explicit and as obvious as possible, such as the revised implementation of the backspace operation. Hiding this information behind an interface just creates obscurity.\n\n> 文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会阅读退格方法的代码，以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的 Backspace 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。\n\n## 6.5 Questions to ask yourself 问自己的问题\n\nIt is easier to recognize a clean general-purpose class design than it is to create one. Here are some questions you can ask yourself, which will help you to find the right balance between general-purpose and special-purpose for an interface.\n\n> 识别干净的通用类设计要比创建一个简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。\n\nWhat is the simplest interface that will cover all my current needs? If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things.\n\n> 满足我当前所有需求的最简单的界面是什么？如果减少 API 中的方法数量而不降低其整体功能，则可能正在创建更多通用的方法。专用文本 API 至少具有三种删除文本的方法：退格，删除和 deleteSelection。通用性更强的 API 只有一种删除文本的方法，可同时满足所有三个目的。仅在每种方法的 API 保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多其他参数以减少方法数量，那么您可能并没有真正简化事情。\n\nIn how many situations will this method be used? If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method.\n\n> 在多少情况下会使用此方法？如果一种方法是为特定用途而设计的，例如退格方法，那是一个危险信号，它可能太特殊了。看看是否可以用一个通用方法替换几种专用方法。\n\nIs this API easy to use for my current needs? This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.\n\n> 这个 API 是否易于使用以满足我当前的需求？这个问题可以帮助您确定何时使 API 变得简单而通用。如果您必须编写许多其他代码才能将类用于当前用途，那么这是一个危险信号，即该接口未提供正确的功能。例如，针对文本类的一种方法是围绕单字符操作进行设计：insert 插入单个字符，而 delete 删除单个字符。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高级别的代码将包含许多循环，用于插入或删除字符范围。单字符方法对于大型操作也将是低效的。\n\n## 6.6 Conclusion 结论\n\nGeneral-purpose interfaces have many advantages over special-purpose ones. They tend to be simpler, with fewer methods that are deeper. They also provide a cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes. Making your modules somewhat general-purpose is one of the best ways to reduce overall system complexity.\n\n> 通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。它们还提供了类之间的更清晰的分隔，而专用接口则倾向于在类之间泄漏信息。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一。\n","slug":"软件设计的哲学-ch6","published":1,"updated":"2021-02-16T04:54:08.262Z","_id":"ckl6pcc33000es4iy9zu41ucr","comments":1,"layout":"post","photos":[],"link":"","content":"<p>通用模块更深入</p>\n<a id=\"more\"></a>\n<h1 id=\"第-6-章-通用模块更深入\"><a href=\"#第-6-章-通用模块更深入\" class=\"headerlink\" title=\"第 6 章 通用模块更深入\"></a>第 6 章 通用模块更深入</h1><blockquote>\n<p>Chapter 6 General-Purpose Modules are Deeper</p>\n</blockquote>\n<p>One of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion. Some might argue that you should take a general-purpose approach, in which you implement a mechanism that can be used to address a broad range of problems, not just the ones that are important today. In this case, the new mechanism may find unanticipated uses in the future, thereby saving time. The general-purpose approach seems consistent with the investment mindset discussed in Chapter 3, where you spend a bit more time up front to save time later on.</p>\n<blockquote>\n<p>设计新模块时，您将面临的最普遍的决定之一就是是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方法，在这种方法中，您将实现一种可用于解决广泛问题的机制，而不仅是当今重要的问题。在这种情况下，新机制可能会在将来发现意外用途，从而节省时间。通用方法似乎与第 3 章中讨论的投资思路一致，在这里您花了更多时间在前面，以节省以后的时间。</p>\n</blockquote>\n<p>On the other hand, we know that it’s hard to predict the future needs of a software system, so a general-purpose solution might include facilities that are never actually needed. Furthermore, if you implement something that is too general-purpose, it might not do a good job of solving the particular problem you have today. As a result, some might argue that it’s better to focus on today’s needs, building just what you know you need, and specializing it for the way you plan to use it today. If you take the special-purpose approach and discover additional uses later, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.</p>\n<blockquote>\n<p>另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用特殊用途的方法并在以后发现更多用途，则始终可以对其进行重构以使其通用。专用方法似乎与软件开发的增量方法一致。</p>\n</blockquote>\n<h2 id=\"6-1-Make-classes-somewhat-general-purpose-使类变得通用\"><a href=\"#6-1-Make-classes-somewhat-general-purpose-使类变得通用\" class=\"headerlink\" title=\"6.1 Make classes somewhat general-purpose 使类变得通用\"></a>6.1 Make classes somewhat general-purpose 使类变得通用</h2><p>In my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.</p>\n<blockquote>\n<p>以我的经验，最有效的方法是以某种通用的方式实现新模块。短语“有点通用”表示该模块的功能应反映您当前的需求，但其接口则不应。相反，该接口应该足够通用以支持多种用途。该界面应易于使用，以满足当今的需求，而不必专门与它们联系在一起。“有点”这个词很重要：不要被带走并建造通用的东西，以致于很难满足当前的需求。</p>\n</blockquote>\n<p>The most important (and perhaps surprising) benefit of the general-purpose approach is that it results in simpler and deeper interfaces than a special-purpose approach. The general-purpose approach can also save you time in the future, if you reuse the class for other purposes. However, even if the module is only used for its original purpose, the general-purpose approach is still better because of its simplicity.</p>\n<blockquote>\n<p>通用方法最重要的（也许是令人惊讶的）好处是，与专用方法相比，它导致更简单，更深入的界面。如果您将该类用于其他目的，则通用方法还可以节省将来的时间。但是，即使该模块仅用于其原始用途，由于其简单性，通用方法仍然更好。</p>\n</blockquote>\n<h2 id=\"6-2-Example-storing-text-for-an-editor-示例：为编辑器存储文本\"><a href=\"#6-2-Example-storing-text-for-an-editor-示例：为编辑器存储文本\" class=\"headerlink\" title=\"6.2 Example: storing text for an editor 示例：为编辑器存储文本\"></a>6.2 Example: storing text for an editor 示例：为编辑器存储文本</h2><p>Let’s consider an example from a software design class in which students were asked to build simple GUI text editors. The editors had to display a file and allow users to point, click, and type to edit the file. The editors had to support multiple simultaneous views of the same file in different windows; they also had to support multi-level undo and redo for modifications to the file.</p>\n<blockquote>\n<p>让我们考虑一个软件设计课程的示例，其中要求学生构建简单的 GUI 文本编辑器。编辑器必须显示一个文件，并允许用户指向，单击并键入以编辑该文件。编辑者必须在不同的窗口中支持同一文件的多个同时视图。他们还必须支持多级撤消和重做以修改文件。</p>\n</blockquote>\n<p>Each of the student projects included a class that managed the underlying text of the file. The text classes typically provided methods for loading a file into memory, reading and modifying the text of the file, and writing the modified text back to a file.</p>\n<blockquote>\n<p>每个学生项目都包括一个管理文件的基础文本的类。文本类通常提供以下方法：将文件加载到内存，读取和修改文件的文本以及将修改后的文本写回到文件。</p>\n</blockquote>\n<p>Many of the student teams implemented special-purpose APIs for the text class. They knew that the class was going to be used in an interactive editor, so they thought about the features that the editor had to provide and tailored the API of the text class to those specific features. For example, if a user of the editor typed the backspace key, the editor deleted the character immediately to the left of the cursor; if the user typed the delete key, the editor deleted the character immediately to the right of the cursor. Knowing this, some of the teams created one method in the text class to support each of these specific features:</p>\n<blockquote>\n<p>许多学生团队为文本课实现了专用的 API。他们知道该类将在交互式编辑器中使用，因此他们考虑了编辑器必须提供的功能，并针对这些特定功能定制了文本类的 API。例如，如果编辑者的用户键入了退格键，则编辑者会立即删除光标左侧的字符；如果用户键入删除键，则编辑器立即删除光标右侧的字符。知道这一点后，一些团队在文本类中创建了一个方法来支持以下每个特定功能：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backspace</span><span class=\"params\">(Cursor cursor)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Cursor cursor)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Each of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:</p>\n<blockquote>\n<p>这些方法中的每一个都以光标位置作为参数。特殊类型的光标表示此位置。编辑器还必须支持可以复制或删除的选择。学生通过定义选择类并在删除过程中将该类的对象传递给文本类来解决此问题：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteSelection</span><span class=\"params\">(Selection selection)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>The students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users. In reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class. The text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation. Many of the methods, such as delete, were only invoked in a single place. As a result, a developer working on the user interface had to learn about a large number of methods for the text class.</p>\n<blockquote>\n<p>学生们可能认为，如果文本类的方法与用户可见的功能相对应，则将更易于实现用户界面。但是，实际上，这种专业化对用户界面代码几乎没有好处，并且为使用用户界面或文本类的开发人员带来了很高的认知负担。文本类以大量浅层方法结束，每种浅层方法仅适用于一个用户界面操作。许多方法（例如 delete）仅在单个位置调用。结果，在用户界面上工作的开发人员必须学习大量有关文本类的方法。</p>\n</blockquote>\n<p>This approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well. One of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.</p>\n<blockquote>\n<p>这种方法在用户界面和文本类之间造成了信息泄漏。与用户界面有关的抽象（例如选择或退格键）反映在文本类中；这增加了从事文本课的开发人员的认知负担。每个新的用户界面操作都需要在文本类中定义一个新方法，因此使用该用户界面的开发人员也可能最终也要使用该文本类。类设计的目标之一是允许每个类独立开发，但是专用方法将用户界面和文本类联系在一起。</p>\n</blockquote>\n<h2 id=\"6-3-A-more-general-purpose-API-更通用的-API\"><a href=\"#6-3-A-more-general-purpose-API-更通用的-API\" class=\"headerlink\" title=\"6.3 A more general-purpose API 更通用的 API\"></a>6.3 A more general-purpose API 更通用的 API</h2><p>A better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text:</p>\n<blockquote>\n<p>更好的方法是使文本类更通用。仅应根据基本文本功能定义其 API，而不应反映将用其实现的更高级别的操作。例如，只需两种方法即可修改文本：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Position position, String newText)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Position start, Position end)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>The first method inserts an arbitrary string at an arbitrary position within the text, and the second method deletes all of the characters at positions greater than or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions within the text, such as the following:</p>\n<blockquote>\n<p>第一种方法在文本内的任意位置插入任意字符串，第二种方法删除大于或等于开始但小于结束的位置处的所有字符。此 API 还使用了更通用的 Position 类型来代替 Cursor，它反映了特定的用户界面。文本类还应该提供用于操纵文本中位置的通用工具，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Position <span class=\"title\">changePosition</span><span class=\"params\">(Position position, <span class=\"keyword\">int</span> numChars)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>This method returns a new position that is a given number of characters away from a given position. If the numChars argument is positive, the new position is later in the file than position; if numChars is negative, the new position is before position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the following code (assuming the cursor variable holds the current cursor position):</p>\n<blockquote>\n<p>此方法返回一个新位置，该位置与给定位置相距给定字符数。如果 numChars 参数为正，则新位置在文件中比位置晚；如果 numChars 为负，则新位置在位置之前。必要时，该方法会自动跳到下一行或上一行。使用这些方法，可以使用以下代码来实现删除键（假定 cursor 变量保留当前光标的位置）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.delete(cursor, text.changePosition(cursor, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<p>Similarly, the backspace key can be implemented as follows:</p>\n<blockquote>\n<p>同样，可以按以下方式实现退格键：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.delete(text.changePosition(cursor, -<span class=\"number\">1</span>), cursor);</span><br></pre></td></tr></table></figure>\n\n<p>With the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API. However, the new code is more obvious than the old code. A developer working in the user interface module probably cares about which characters are deleted by the backspace key. With the new code, this is obvious. With the old code, the developer had to go to the text class and read the documentation and/or code of the backspace method to verify the behavior. Furthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.</p>\n<blockquote>\n<p>使用通用文本 API，实现用户界面功能（如删除和退格）的代码比使用专用文本 API 的原始方法要长一些。但是，新代码比旧代码更明显。在用户界面模块中工作的开发人员可能会关心由 Backspace 键删除哪些字符。使用新代码，这是显而易见的。使用旧代码，开发人员必须转到文本类并阅读退格方法的文档和/或代码以验证行为。此外，通用方法总体上比专用方法具有更少的代码，因为它用较少数量的通用方法代替了文本类中的大量专用方法。</p>\n</blockquote>\n<p>A text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor. As one example, suppose you were building an application that modified a specified file by replacing all occurrences of a particular string with another string. Methods from the specialized text class, such as backspace and delete, would have little value for this application. However, the general-purpose text class would already have most of the functionality needed for the new application. All that is missing is a method to search for the next occurrence of a given string, such as this:</p>\n<blockquote>\n<p>使用通用接口实现的文本类除交互式编辑器外，还可以用于其他目的。作为一个示例，假设您正在构建一个应用程序，该应用程序通过将所有出现的特定字符串替换为另一个字符串来修改指定文件。专用文本类中的方法（例如，退格键和 Delete）对于此应用程序几乎没有价值。但是，通用文本类已经具有新应用程序所需的大多数功能。缺少的只是一种搜索给定字符串的下一个匹配项的方法，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Position <span class=\"title\">findNext</span><span class=\"params\">(Position start, String string)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Of course, an interactive text editor is likely to have a mechanism for searching and replacing, in which case the text class would already include this method.</p>\n<blockquote>\n<p>当然，交互式文本编辑器可能具有搜索和替换的机制，在这种情况下，文本类将已经包含此方法。</p>\n</blockquote>\n<h2 id=\"6-4-Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息\"><a href=\"#6-4-Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息\" class=\"headerlink\" title=\"6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息\"></a>6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息</h2><p>The general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding. The text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functions in the text class. The general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.</p>\n<blockquote>\n<p>通用方法在文本和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。可以添加新的用户界面功能，而无需在文本类中创建新的支持功能。通用界面还减轻了认知负担：使用用户界面的开发人员只需要学习一些简单的方法，就可以将其重复用于各种目的。</p>\n</blockquote>\n<p>The backspace method in the original version of the text class was a false abstraction. It purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior. Putting the method in the text class just makes it harder for user interface developers to get the information they need. One of the most important elements of software design is determining who needs to know what, and when. When the details are important, it is better to make them explicit and as obvious as possible, such as the revised implementation of the backspace operation. Hiding this information behind an interface just creates obscurity.</p>\n<blockquote>\n<p>文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会阅读退格方法的代码，以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的 Backspace 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。</p>\n</blockquote>\n<h2 id=\"6-5-Questions-to-ask-yourself-问自己的问题\"><a href=\"#6-5-Questions-to-ask-yourself-问自己的问题\" class=\"headerlink\" title=\"6.5 Questions to ask yourself 问自己的问题\"></a>6.5 Questions to ask yourself 问自己的问题</h2><p>It is easier to recognize a clean general-purpose class design than it is to create one. Here are some questions you can ask yourself, which will help you to find the right balance between general-purpose and special-purpose for an interface.</p>\n<blockquote>\n<p>识别干净的通用类设计要比创建一个简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。</p>\n</blockquote>\n<p>What is the simplest interface that will cover all my current needs? If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things.</p>\n<blockquote>\n<p>满足我当前所有需求的最简单的界面是什么？如果减少 API 中的方法数量而不降低其整体功能，则可能正在创建更多通用的方法。专用文本 API 至少具有三种删除文本的方法：退格，删除和 deleteSelection。通用性更强的 API 只有一种删除文本的方法，可同时满足所有三个目的。仅在每种方法的 API 保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多其他参数以减少方法数量，那么您可能并没有真正简化事情。</p>\n</blockquote>\n<p>In how many situations will this method be used? If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method.</p>\n<blockquote>\n<p>在多少情况下会使用此方法？如果一种方法是为特定用途而设计的，例如退格方法，那是一个危险信号，它可能太特殊了。看看是否可以用一个通用方法替换几种专用方法。</p>\n</blockquote>\n<p>Is this API easy to use for my current needs? This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.</p>\n<blockquote>\n<p>这个 API 是否易于使用以满足我当前的需求？这个问题可以帮助您确定何时使 API 变得简单而通用。如果您必须编写许多其他代码才能将类用于当前用途，那么这是一个危险信号，即该接口未提供正确的功能。例如，针对文本类的一种方法是围绕单字符操作进行设计：insert 插入单个字符，而 delete 删除单个字符。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高级别的代码将包含许多循环，用于插入或删除字符范围。单字符方法对于大型操作也将是低效的。</p>\n</blockquote>\n<h2 id=\"6-6-Conclusion-结论\"><a href=\"#6-6-Conclusion-结论\" class=\"headerlink\" title=\"6.6 Conclusion 结论\"></a>6.6 Conclusion 结论</h2><p>General-purpose interfaces have many advantages over special-purpose ones. They tend to be simpler, with fewer methods that are deeper. They also provide a cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes. Making your modules somewhat general-purpose is one of the best ways to reduce overall system complexity.</p>\n<blockquote>\n<p>通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。它们还提供了类之间的更清晰的分隔，而专用接口则倾向于在类之间泄漏信息。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>通用模块更深入</p>","more":"<h1 id=\"第-6-章-通用模块更深入\"><a href=\"#第-6-章-通用模块更深入\" class=\"headerlink\" title=\"第 6 章 通用模块更深入\"></a>第 6 章 通用模块更深入</h1><blockquote>\n<p>Chapter 6 General-Purpose Modules are Deeper</p>\n</blockquote>\n<p>One of the most common decisions that you will face when designing a new module is whether to implement it in a general-purpose or special-purpose fashion. Some might argue that you should take a general-purpose approach, in which you implement a mechanism that can be used to address a broad range of problems, not just the ones that are important today. In this case, the new mechanism may find unanticipated uses in the future, thereby saving time. The general-purpose approach seems consistent with the investment mindset discussed in Chapter 3, where you spend a bit more time up front to save time later on.</p>\n<blockquote>\n<p>设计新模块时，您将面临的最普遍的决定之一就是是以通用还是专用方式实现它。有人可能会争辩说，您应该采用通用方法，在这种方法中，您将实现一种可用于解决广泛问题的机制，而不仅是当今重要的问题。在这种情况下，新机制可能会在将来发现意外用途，从而节省时间。通用方法似乎与第 3 章中讨论的投资思路一致，在这里您花了更多时间在前面，以节省以后的时间。</p>\n</blockquote>\n<p>On the other hand, we know that it’s hard to predict the future needs of a software system, so a general-purpose solution might include facilities that are never actually needed. Furthermore, if you implement something that is too general-purpose, it might not do a good job of solving the particular problem you have today. As a result, some might argue that it’s better to focus on today’s needs, building just what you know you need, and specializing it for the way you plan to use it today. If you take the special-purpose approach and discover additional uses later, you can always refactor it to make it general-purpose. The special-purpose approach seems consistent with an incremental approach to software development.</p>\n<blockquote>\n<p>另一方面，我们知道很难预测软件系统的未来需求，因此通用解决方案可能包含从未真正需要的功能。此外，如果您实现的东西过于通用，那么可能无法很好地解决您今天遇到的特定问题。结果，有些人可能会争辩说，最好只关注当今的需求，构建您所知道的需求，并针对您今天打算使用的方式进行专门化处理。如果您采用特殊用途的方法并在以后发现更多用途，则始终可以对其进行重构以使其通用。专用方法似乎与软件开发的增量方法一致。</p>\n</blockquote>\n<h2 id=\"6-1-Make-classes-somewhat-general-purpose-使类变得通用\"><a href=\"#6-1-Make-classes-somewhat-general-purpose-使类变得通用\" class=\"headerlink\" title=\"6.1 Make classes somewhat general-purpose 使类变得通用\"></a>6.1 Make classes somewhat general-purpose 使类变得通用</h2><p>In my experience, the sweet spot is to implement new modules in a somewhat general-purpose fashion. The phrase “somewhat general-purpose” means that the module’s functionality should reflect your current needs, but its interface should not. Instead, the interface should be general enough to support multiple uses. The interface should be easy to use for today’s needs without being tied specifically to them. The word “somewhat” is important: don’t get carried away and build something so general-purpose that it is difficult to use for your current needs.</p>\n<blockquote>\n<p>以我的经验，最有效的方法是以某种通用的方式实现新模块。短语“有点通用”表示该模块的功能应反映您当前的需求，但其接口则不应。相反，该接口应该足够通用以支持多种用途。该界面应易于使用，以满足当今的需求，而不必专门与它们联系在一起。“有点”这个词很重要：不要被带走并建造通用的东西，以致于很难满足当前的需求。</p>\n</blockquote>\n<p>The most important (and perhaps surprising) benefit of the general-purpose approach is that it results in simpler and deeper interfaces than a special-purpose approach. The general-purpose approach can also save you time in the future, if you reuse the class for other purposes. However, even if the module is only used for its original purpose, the general-purpose approach is still better because of its simplicity.</p>\n<blockquote>\n<p>通用方法最重要的（也许是令人惊讶的）好处是，与专用方法相比，它导致更简单，更深入的界面。如果您将该类用于其他目的，则通用方法还可以节省将来的时间。但是，即使该模块仅用于其原始用途，由于其简单性，通用方法仍然更好。</p>\n</blockquote>\n<h2 id=\"6-2-Example-storing-text-for-an-editor-示例：为编辑器存储文本\"><a href=\"#6-2-Example-storing-text-for-an-editor-示例：为编辑器存储文本\" class=\"headerlink\" title=\"6.2 Example: storing text for an editor 示例：为编辑器存储文本\"></a>6.2 Example: storing text for an editor 示例：为编辑器存储文本</h2><p>Let’s consider an example from a software design class in which students were asked to build simple GUI text editors. The editors had to display a file and allow users to point, click, and type to edit the file. The editors had to support multiple simultaneous views of the same file in different windows; they also had to support multi-level undo and redo for modifications to the file.</p>\n<blockquote>\n<p>让我们考虑一个软件设计课程的示例，其中要求学生构建简单的 GUI 文本编辑器。编辑器必须显示一个文件，并允许用户指向，单击并键入以编辑该文件。编辑者必须在不同的窗口中支持同一文件的多个同时视图。他们还必须支持多级撤消和重做以修改文件。</p>\n</blockquote>\n<p>Each of the student projects included a class that managed the underlying text of the file. The text classes typically provided methods for loading a file into memory, reading and modifying the text of the file, and writing the modified text back to a file.</p>\n<blockquote>\n<p>每个学生项目都包括一个管理文件的基础文本的类。文本类通常提供以下方法：将文件加载到内存，读取和修改文件的文本以及将修改后的文本写回到文件。</p>\n</blockquote>\n<p>Many of the student teams implemented special-purpose APIs for the text class. They knew that the class was going to be used in an interactive editor, so they thought about the features that the editor had to provide and tailored the API of the text class to those specific features. For example, if a user of the editor typed the backspace key, the editor deleted the character immediately to the left of the cursor; if the user typed the delete key, the editor deleted the character immediately to the right of the cursor. Knowing this, some of the teams created one method in the text class to support each of these specific features:</p>\n<blockquote>\n<p>许多学生团队为文本课实现了专用的 API。他们知道该类将在交互式编辑器中使用，因此他们考虑了编辑器必须提供的功能，并针对这些特定功能定制了文本类的 API。例如，如果编辑者的用户键入了退格键，则编辑者会立即删除光标左侧的字符；如果用户键入删除键，则编辑器立即删除光标右侧的字符。知道这一点后，一些团队在文本类中创建了一个方法来支持以下每个特定功能：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">backspace</span><span class=\"params\">(Cursor cursor)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Cursor cursor)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Each of these methods takes the cursor position as its argument; a special type Cursor represents this position. The editor also had to support a selection that could be copied or deleted. The students handled this by defining a Selection class and passing an object of this class to the text class during deletions:</p>\n<blockquote>\n<p>这些方法中的每一个都以光标位置作为参数。特殊类型的光标表示此位置。编辑器还必须支持可以复制或删除的选择。学生通过定义选择类并在删除过程中将该类的对象传递给文本类来解决此问题：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">deleteSelection</span><span class=\"params\">(Selection selection)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>The students probably thought that it would be easier to implement the user interface if the methods of the text class corresponded to the features visible to users. In reality, however, this specialization provided little benefit for the user interface code, and it created a high cognitive load for developers working on either the user interface or the text class. The text class ended up with a large number of shallow methods, each of which was only suitable for one user interface operation. Many of the methods, such as delete, were only invoked in a single place. As a result, a developer working on the user interface had to learn about a large number of methods for the text class.</p>\n<blockquote>\n<p>学生们可能认为，如果文本类的方法与用户可见的功能相对应，则将更易于实现用户界面。但是，实际上，这种专业化对用户界面代码几乎没有好处，并且为使用用户界面或文本类的开发人员带来了很高的认知负担。文本类以大量浅层方法结束，每种浅层方法仅适用于一个用户界面操作。许多方法（例如 delete）仅在单个位置调用。结果，在用户界面上工作的开发人员必须学习大量有关文本类的方法。</p>\n</blockquote>\n<p>This approach created information leakage between the user interface and the text class. Abstractions related to the user interface, such as the selection or the backspace key, were reflected in the text class; this increased the cognitive load for developers working on the text class. Each new user interface operation required a new method to be defined in the text class, so a developer working on the user interface was likely to end up working on the text class as well. One of the goals in class design is to allow each class to be developed independently, but the specialized approach tied the user interface and text classes together.</p>\n<blockquote>\n<p>这种方法在用户界面和文本类之间造成了信息泄漏。与用户界面有关的抽象（例如选择或退格键）反映在文本类中；这增加了从事文本课的开发人员的认知负担。每个新的用户界面操作都需要在文本类中定义一个新方法，因此使用该用户界面的开发人员也可能最终也要使用该文本类。类设计的目标之一是允许每个类独立开发，但是专用方法将用户界面和文本类联系在一起。</p>\n</blockquote>\n<h2 id=\"6-3-A-more-general-purpose-API-更通用的-API\"><a href=\"#6-3-A-more-general-purpose-API-更通用的-API\" class=\"headerlink\" title=\"6.3 A more general-purpose API 更通用的 API\"></a>6.3 A more general-purpose API 更通用的 API</h2><p>A better approach is to make the text class more generic. Its API should be defined only in terms of basic text features, without reflecting the higher-level operations that will be implemented with it. For example, only two methods are needed for modifying text:</p>\n<blockquote>\n<p>更好的方法是使文本类更通用。仅应根据基本文本功能定义其 API，而不应反映将用其实现的更高级别的操作。例如，只需两种方法即可修改文本：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">insert</span><span class=\"params\">(Position position, String newText)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Position start, Position end)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>The first method inserts an arbitrary string at an arbitrary position within the text, and the second method deletes all of the characters at positions greater than or equal to start but less than end. This API also uses a more generic type Position instead of Cursor, which reflects a specific user interface. The text class should also provide general-purpose facilities for manipulating positions within the text, such as the following:</p>\n<blockquote>\n<p>第一种方法在文本内的任意位置插入任意字符串，第二种方法删除大于或等于开始但小于结束的位置处的所有字符。此 API 还使用了更通用的 Position 类型来代替 Cursor，它反映了特定的用户界面。文本类还应该提供用于操纵文本中位置的通用工具，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Position <span class=\"title\">changePosition</span><span class=\"params\">(Position position, <span class=\"keyword\">int</span> numChars)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>This method returns a new position that is a given number of characters away from a given position. If the numChars argument is positive, the new position is later in the file than position; if numChars is negative, the new position is before position. The method automatically skips to the next or previous line when necessary. With these methods, the delete key can be implemented with the following code (assuming the cursor variable holds the current cursor position):</p>\n<blockquote>\n<p>此方法返回一个新位置，该位置与给定位置相距给定字符数。如果 numChars 参数为正，则新位置在文件中比位置晚；如果 numChars 为负，则新位置在位置之前。必要时，该方法会自动跳到下一行或上一行。使用这些方法，可以使用以下代码来实现删除键（假定 cursor 变量保留当前光标的位置）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.delete(cursor, text.changePosition(cursor, <span class=\"number\">1</span>));</span><br></pre></td></tr></table></figure>\n\n<p>Similarly, the backspace key can be implemented as follows:</p>\n<blockquote>\n<p>同样，可以按以下方式实现退格键：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">text.delete(text.changePosition(cursor, -<span class=\"number\">1</span>), cursor);</span><br></pre></td></tr></table></figure>\n\n<p>With the general-purpose text API, the code to implement user interface functions such as delete and backspace is a bit longer than with the original approach using a specialized text API. However, the new code is more obvious than the old code. A developer working in the user interface module probably cares about which characters are deleted by the backspace key. With the new code, this is obvious. With the old code, the developer had to go to the text class and read the documentation and/or code of the backspace method to verify the behavior. Furthermore, the general-purpose approach has less code overall than the specialized approach, since it replaces a large number of special-purpose methods in the text class with a smaller number of general-purpose ones.</p>\n<blockquote>\n<p>使用通用文本 API，实现用户界面功能（如删除和退格）的代码比使用专用文本 API 的原始方法要长一些。但是，新代码比旧代码更明显。在用户界面模块中工作的开发人员可能会关心由 Backspace 键删除哪些字符。使用新代码，这是显而易见的。使用旧代码，开发人员必须转到文本类并阅读退格方法的文档和/或代码以验证行为。此外，通用方法总体上比专用方法具有更少的代码，因为它用较少数量的通用方法代替了文本类中的大量专用方法。</p>\n</blockquote>\n<p>A text class implemented with the general-purpose interface could potentially be used for other purposes besides an interactive editor. As one example, suppose you were building an application that modified a specified file by replacing all occurrences of a particular string with another string. Methods from the specialized text class, such as backspace and delete, would have little value for this application. However, the general-purpose text class would already have most of the functionality needed for the new application. All that is missing is a method to search for the next occurrence of a given string, such as this:</p>\n<blockquote>\n<p>使用通用接口实现的文本类除交互式编辑器外，还可以用于其他目的。作为一个示例，假设您正在构建一个应用程序，该应用程序通过将所有出现的特定字符串替换为另一个字符串来修改指定文件。专用文本类中的方法（例如，退格键和 Delete）对于此应用程序几乎没有价值。但是，通用文本类已经具有新应用程序所需的大多数功能。缺少的只是一种搜索给定字符串的下一个匹配项的方法，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Position <span class=\"title\">findNext</span><span class=\"params\">(Position start, String string)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>Of course, an interactive text editor is likely to have a mechanism for searching and replacing, in which case the text class would already include this method.</p>\n<blockquote>\n<p>当然，交互式文本编辑器可能具有搜索和替换的机制，在这种情况下，文本类将已经包含此方法。</p>\n</blockquote>\n<h2 id=\"6-4-Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息\"><a href=\"#6-4-Generality-leads-to-better-information-hiding-通用性可以更好地隐藏信息\" class=\"headerlink\" title=\"6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息\"></a>6.4 Generality leads to better information hiding 通用性可以更好地隐藏信息</h2><p>The general-purpose approach provides a cleaner separation between the text and user interface classes, which results in better information hiding. The text class need not be aware of specifics of the user interface, such as how the backspace key is handled; these details are now encapsulated in the user interface class. New user interface features can be added without creating new supporting functions in the text class. The general-purpose interface also reduces cognitive load: a developer working on the user interface only needs to learn a few simple methods, which can be reused for a variety of purposes.</p>\n<blockquote>\n<p>通用方法在文本和用户界面类之间提供了更清晰的分隔，从而可以更好地隐藏信息。文本类不需要知道用户界面的详细信息，例如如何处理退格键。这些细节现在封装在用户界面类中。可以添加新的用户界面功能，而无需在文本类中创建新的支持功能。通用界面还减轻了认知负担：使用用户界面的开发人员只需要学习一些简单的方法，就可以将其重复用于各种目的。</p>\n</blockquote>\n<p>The backspace method in the original version of the text class was a false abstraction. It purported to hide information about which characters are deleted, but the user interface module really needs to know this; user interface developers are likely to read the code of the backspace method in order to confirm its precise behavior. Putting the method in the text class just makes it harder for user interface developers to get the information they need. One of the most important elements of software design is determining who needs to know what, and when. When the details are important, it is better to make them explicit and as obvious as possible, such as the revised implementation of the backspace operation. Hiding this information behind an interface just creates obscurity.</p>\n<blockquote>\n<p>文本类原始版本中的 backspace 方法是错误的抽象。它旨在隐藏有关删除哪些字符的信息，但是用户界面模块确实需要知道这一点。用户界面开发人员可能会阅读退格方法的代码，以确认其精确的行为。将方法放在文本类中只会使用户界面开发人员更难获得所需的信息。软件设计最重要的元素之一就是确定谁需要知道什么以及何时知道。当细节很重要时，最好使它们明确且尽可能明显，例如修订的 Backspace 操作实现。将这些信息隐藏在界面后面只会产生晦涩感。</p>\n</blockquote>\n<h2 id=\"6-5-Questions-to-ask-yourself-问自己的问题\"><a href=\"#6-5-Questions-to-ask-yourself-问自己的问题\" class=\"headerlink\" title=\"6.5 Questions to ask yourself 问自己的问题\"></a>6.5 Questions to ask yourself 问自己的问题</h2><p>It is easier to recognize a clean general-purpose class design than it is to create one. Here are some questions you can ask yourself, which will help you to find the right balance between general-purpose and special-purpose for an interface.</p>\n<blockquote>\n<p>识别干净的通用类设计要比创建一个简单。您可以问自己一些问题，这将帮助您在接口的通用和专用之间找到适当的平衡。</p>\n</blockquote>\n<p>What is the simplest interface that will cover all my current needs? If you reduce the number of methods in an API without reducing its overall capabilities, then you are probably creating more general-purpose methods. The special-purpose text API had at least three methods for deleting text: backspace, delete, and deleteSelection. The more general-purpose API had only one method for deleting text, which served all three purposes. Reducing the number of methods makes sense only as long as the API for each individual method stays simple; if you have to introduce lots of additional arguments in order to reduce the number of methods, then you may not really be simplifying things.</p>\n<blockquote>\n<p>满足我当前所有需求的最简单的界面是什么？如果减少 API 中的方法数量而不降低其整体功能，则可能正在创建更多通用的方法。专用文本 API 至少具有三种删除文本的方法：退格，删除和 deleteSelection。通用性更强的 API 只有一种删除文本的方法，可同时满足所有三个目的。仅在每种方法的 API 保持简单的前提下，减少方法的数量才有意义。如果您必须引入许多其他参数以减少方法数量，那么您可能并没有真正简化事情。</p>\n</blockquote>\n<p>In how many situations will this method be used? If a method is designed for one particular use, such as the backspace method, that is a red flag that it may be too special-purpose. See if you can replace several special-purpose methods with a single general-purpose method.</p>\n<blockquote>\n<p>在多少情况下会使用此方法？如果一种方法是为特定用途而设计的，例如退格方法，那是一个危险信号，它可能太特殊了。看看是否可以用一个通用方法替换几种专用方法。</p>\n</blockquote>\n<p>Is this API easy to use for my current needs? This question can help you to determine when you have gone too far in making an API simple and general-purpose. If you have to write a lot of additional code to use a class for your current purpose, that’s a red flag that the interface doesn’t provide the right functionality. For example, one approach for the text class would be to design it around single-character operations: insert inserts a single character and delete deletes a single character. This API is both simple and general-purpose. However, it would not be particularly easy to use for a text editor: higher-level code would contain lots of loops to insert or delete ranges of characters. The single-character approach would also be inefficient for large operations. Thus it’s better for the text class to have built-in support for operations on ranges of characters.</p>\n<blockquote>\n<p>这个 API 是否易于使用以满足我当前的需求？这个问题可以帮助您确定何时使 API 变得简单而通用。如果您必须编写许多其他代码才能将类用于当前用途，那么这是一个危险信号，即该接口未提供正确的功能。例如，针对文本类的一种方法是围绕单字符操作进行设计：insert 插入单个字符，而 delete 删除单个字符。该 API 既简单又通用。但是，对于文本编辑器来说并不是特别容易使用：更高级别的代码将包含许多循环，用于插入或删除字符范围。单字符方法对于大型操作也将是低效的。</p>\n</blockquote>\n<h2 id=\"6-6-Conclusion-结论\"><a href=\"#6-6-Conclusion-结论\" class=\"headerlink\" title=\"6.6 Conclusion 结论\"></a>6.6 Conclusion 结论</h2><p>General-purpose interfaces have many advantages over special-purpose ones. They tend to be simpler, with fewer methods that are deeper. They also provide a cleaner separation between classes, whereas special-purpose interfaces tend to leak information between classes. Making your modules somewhat general-purpose is one of the best ways to reduce overall system complexity.</p>\n<blockquote>\n<p>通用接口比专用接口具有许多优点。它们往往更简单，使用的方法更少。它们还提供了类之间的更清晰的分隔，而专用接口则倾向于在类之间泄漏信息。使模块具有某种通用性是降低整体系统复杂性的最佳方法之一。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch14","date":"2021-02-13T16:00:00.000Z","_content":"选择的名字\n<!-- more -->\n# 第 14 章 选择的名字\n\n> Chapter 14 Choosing Names\n\nSelecting names for variables, methods, and other entities is one of the most underrated aspects of software design. Good names are a form of documentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particular variable, as opposed to the best possible name, probably won’t have much impact on the overall complexity of a system. However, software systems have thousands of variables; choosing good names for all of these will have a significant impact on complexity and manageability.\n\n> 为变量，方法和其他实体选择名称是软件设计中被低估的方面之一。良好的名字是一种文档形式：它们使代码更易于理解。它们减少了对其他文档的需求，并使检测错误更加容易。相反，名称选择不当会增加代码的复杂性，并造成可能导致错误的歧义和误解。名称选择是复杂度是递增的原理的一个示例。为特定变量选择一个平庸的名称，而不是最好的名称，这可能不会对系统的整体复杂性产生太大影响。但是，软件系统具有数千个变量。为所有这些选择好名字将对复杂性和可管理性产生重大影响。\n\n## 14.1 Example: bad names cause bugs 示例：名称错误会导致错误\n\nSometimes even a single poorly named variable can have severe consequences. The most challenging bug I ever fixed came about because of a poor name choice. In the late 1980’s and early 1990’s my graduate students and I created a distributed operating system called Sprite. At some point we noticed that files would occasionally lose data: one of the data blocks suddenly became all zeroes, even though the file had not been modified by a user. The problem didn’t happen very often, so it was exceptionally difficult to track down. A few of the graduate students tried to find the bug, but they were unable to make progress and eventually gave up. However, I consider any unsolved bug to be an intolerable personal insult, so I decided to track it down.\n\n> 有时，即使是一个名称不正确的变量也会产生严重的后果。我曾经修复过的最具挑战性的错误是由于名称选择不当造成的。在 1980 年代末和 1990 年代初，我的研究生和我创建了一个名为 Sprite 的分布式操作系统。在某个时候，我们注意到文件偶尔会丢失数据：即使用户未修改文件，数据块之一突然变为全零。该问题并不经常发生，因此很难追踪。一些研究生试图找到该错误，但他们未能取得进展，最终放弃了。但是，我认为任何未解决的错误都是无法忍受的个人侮辱，因此我决定对其进行跟踪。\n\nIt took six months, but I eventually found and fixed the bug. The problem was actually quite simple (as are most bugs, once you figure them out). The file system code used the variable name block for two different purposes. In some situations, block referred to a physical block number on disk; in other situations, block referred to a logical block number within a file. Unfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.\n\n> 花了六个月的时间，但我最终找到并修复了该错误。这个问题实际上很简单（就像大多数错误一样，一旦找出它们）。文件系统代码将变量名块用于两个不同的目的。在某些情况下，块是指磁盘上的物理块号。在其他情况下，块是指文件中的逻辑块号。不幸的是，在代码的某一点上有一个包含逻辑块号的块变量，但是在需要物理块号的情况下意外地使用了它。结果，磁盘上无关的块被零覆盖。\n\nWhile tracking down the bug, several people, including myself, read over the faulty code, but we never noticed the problem. When we saw the variable block used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of instrumentation, which eventually showed that the corruption must be happening in a particular statement, before I was able to get past the mental block created by the name and check to see exactly where its value came from. If different variable names had been used for the different kinds of blocks, such as fileBlock and diskBlock, it’s unlikely that the error would have happened; the programmer would have known that fileBlock couldn’t be used in that situation.\n\n> 在跟踪该错误时，包括我自己在内的几个人阅读了错误的代码，但我们从未注意到问题所在。当我们看到可变块用作物理块号时，我们反身地假设它确实拥有物理块号。经过很长时间的检测，最终显示出腐败一定是在特定的语句中发生的，然后我才能越过该名称所创建的思维障碍，并查看其价值的确切来源。如果对不同种类的块（例如 fileBlock 和 diskBlock）使用了不同的变量名，则错误不太可能发生；程序员会知道在那种情况下不能使用 fileBlock。\n\nUnfortunately, most developers don’t spend much time thinking about names. They tend to use the first name that comes to mind, as long as it’s reasonably close to matching the thing it names. For example, block is a pretty close match for both a physical block on disk and a logical block within a file; it’s certainly not a horrible name. Even so, it resulted in a huge expenditure of time to track down a subtle bug. Thus, you shouldn’t settle for names that are just “reasonably close”. Take a bit of extra time to choose great names, which are precise, unambiguous, and intuitive. The extra attention will pay for itself quickly, and over time you’ll learn to choose good names quickly.\n\n> 不幸的是，大多数开发人员没有花太多时间在思考名字。他们倾向于使用想到的名字，只要它与匹配的名字相当接近即可。例如，块与磁盘上的物理块和文件内的逻辑块非常接近；这肯定不是一个可怕的名字。即使这样，它仍然要花费大量时间来查找一个细微的错误。因此，您不应该只选择“合理接近”的名称。花一些额外的时间来选择准确，明确且直观的好名字。额外的注意力将很快收回成本，随着时间的流逝，您将学会快速选择好名字。\n\n## 14.2 Create an image 创建图像\n\nWhen choosing a name, the goal is to create an image in the mind of the reader about the nature of the thing being named. A good name conveys a lot of information about what the underlying entity is, and, just as important, what it is not. When considering a particular name, ask yourself: “If someone sees this name in isolation, without seeing its declaration, its documentation, or any code that uses the name, how closely will they be able to guess what the name refers to? Is there some other name that will paint a clearer picture?” Of course, there is a limit to how much information you can put in a single name; names become unwieldy if they contain more than two or three words. Thus, the challenge is to find just a few words that capture the most important aspects of the entity.\n\n> 选择名称时，目标是在读者的脑海中创建一幅关于被命名事物的性质的图像。一个好名字传达了很多有关底层实体是什么，以及同样重要的是，不是什么的信息。在考虑特定名称时，请问自己：“如果有人孤立地看到该名称，而没有看到其声明，文档或使用该名称的任何代码，他们将能够猜到该名称指的是什么？还有其他名称可以使画面更清晰吗？” 当然，一个名字可以输入多少信息是有限制的。如果名称包含两个或三个以上的单词，则会变得笨拙。因此，面临的挑战是仅找到捕获实体最重要方面的几个单词。\n\nNames are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity. Like other forms of abstraction, the best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.\n\n> 名称是一种抽象形式：名称提供了一种简化的方式来考虑更复杂的基础实体。像其他形式的抽象一样，最好的名字是那些将注意力集中在对底层实体最重要的东西上，而忽略那些次要的细节。\n\n## 14.3 Names should be precise 名称应准确\n\nGood names have two properties: precision and consistency. Let’s start with precision. The most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above. Consider the following method declaration:\n\n> 良好名称具有两个属性：精度和一致性。让我们从精度开始。名称最常见的问题是名称太笼统或含糊不清。结果，读者很难说出这个名字指的是什么。读者可能会认为该名称所指的是与现实不符的事物，如上面的代码错误所示。考虑以下方法声明：\n\n```java\n/**\n * Returns the total number of indexlets this object is managing.\n */\nint IndexletManager::getCount() {...}\n```\n\nThe term “count” is too generic: count of what? If someone sees an invocation of this method, they are unlikely to know what it does unless they read its documentation. A more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.\n\n> 术语“计数”太笼统了：计数什么？如果有人看到此方法的调用，除非他们阅读了它的文档，否则他们不太可能知道它的作用。像 getActiveIndexlets 或 numIndexlets 这样的更精确的名称会更好：使用这些名称之一，读者可能无需查看其文档就能猜测该方法返回的内容。\n\nHere are some other examples of names that aren’t precise enough, taken from various student projects:\n\n> 以下是来自其他学生项目的一些名称不够精确的示例：\n\n- A project building a GUI text editor used the names x and y to refer to the position of a character in the file. These names are too generic. They could mean many things; for example, they might also represent the coordinates (in pixels) of a character on the screen. Someone seeing the name x in isolation is unlikely to think that it refers to the position of a character within a line of text. The code would be clearer if it used names such as charIndex and lineIndex, which reflect the specific abstractions that the code implements.\n  > 建立 GUI 文本编辑器的项目使用名称 x 和 y 来引用字符在文件中的位置。这些名称太笼统了。他们可能意味着很多事情；例如，它们也可能代表屏幕上字符的坐标（以像素为单位）。单独看到名称 x 的人不太可能会认为它是指字符在一行文本中的位置。如果使用诸如 charIndex 和 lineIndex 之类的名称来反映代码实现的特定抽象，该代码将更加清晰。\n- Another editor project contained the following code:\n\n  > 另一个编辑器项目包含以下代码：\n\n  ```java\n  // Blink state: true when cursor visible.\n  private boolean blinkStatus = true;\n  ```\n\n  The name blinkStatus doesn’t convey enough information. The word “status” is too vague for a boolean value: it gives no clue about what a true or false value means. The word “blink” is also vague, since it doesn’t indicate what is blinking. The following alternative is better:\n\n  > 名称 blinkStatus 无法传达足够的信息。“状态”一词对于布尔值来说太含糊了：它不提供关于真值或假值含义的任何线索。“闪烁”一词也含糊不清，因为它并不表示闪烁的内容。以下替代方法更好：\n\n  ```java\n  // Controls cursor blinking: true means the cursor is visible,\n  // false means the cursor is not displayed.\n  private boolean cursorVisible = true;\n  ```\n\n  The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word “blink” is no longer in the name, so readers will have to consult the documentation if they want to know why the cursor isn’t always visible; this information is less important.\n\n  > 名称 cursorVisible 传达了更多信息；例如，它允许读者猜测一个真值的含义（通常，布尔变量的名称应始终为谓词）。名称中不再包含“ blink”一词，因此，如果读者想知道为什么光标不总是可见，则必须查阅文档。此信息不太重要。\n\n- A project implementing a consensus protocol contained the following code:\n\n  > 一个实施共识协议的项目包含以下代码：\n\n  ```java\n  // Value representing that the server has not voted (yet) for\n  // anyone for the current election term.\n  private static final String VOTED_FOR_SENTINEL_VALUE = \"null\";\n  ```\n\n  The name for this value indicates that it’s special but it doesn’t say what the special meaning is. A more specific name such as NOT_YET_VOTED would be better.\n\n  > 此值的名称表示它是特殊的，但没有说明特殊含义是什么。使用更具体的名称（例如 NOT_YET_VOTED）会更好。\n\n- A variable named result was used in a method with no return value. This name has multiple problems. First, it creates the misleading impression that it will be the return value of the method. Second, it provides essentially no information about what it actually holds, except that it is some computed value. The name should provide information about what the result actually is, such as mergedLine or totalChars. In methods that do actually have return values, then using the name result is reasonable. This name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.\n\n  > 在没有返回值的方法中使用了名为 result 的变量。这个名字有多个问题。首先，它会产生误导性的印象，即它将作为方法的返回值。其次，除了它是一些计算值外，它实际上不提供有关其实际持有内容的任何信息。该名称应提供有关实际结果是什么的信息，例如 mergedLine 或 totalChars。在实际上确实具有返回值的方法中，使用名称结果是合理的。该名称仍然有点通用，但是读者可以查看方法文档以了解其含义，这有助于知道该值最终将成为返回值。\n\nimg Red Flag: Vague Name img\n\nIf a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.\n\n> 如果变量或方法的名称足够广泛，可以引用许多不同的事物，那么它不会向开发人员传达太多信息，因此底层实体很可能会被滥用。\n\nLike all rules, the rule about choosing precise names has a few exceptions. For example, it’s fine to use generic names like i and j as loop iteration variables, as long as the loops only span a few lines of code. If you can see the entire range of usage of a variable, then the meaning of the variable will probably be obvious from the code so you don’t need a long name. For example, consider the following code:\n\n> 像所有规则一样，有关选择精确名称的规则也有一些例外。例如，只要循环仅跨越几行代码，就可以将通用名称（如 i 和 j）用作循环迭代变量。如果您可以看到一个变量的整个用法范围，那么该变量的含义在代码中就很明显了，因此您不需要长名称。例如，考虑以下代码：\n\n```java\nfor  (i = 0; i < numLines; i++) {\n    ...\n}\n```\n\nIt’s clear from this code that i is being used to iterate over each of the lines in some entity. If the loop gets so long that you can’t see it all at once, or if the meaning of the iteration variable is harder to figure out from the code, then a more descriptive name is in order.\n\n> 从这段代码中很明显，我正被用来迭代某个实体中的每一行。如果循环时间太长，以至于您无法一次看到全部内容，或者如果很难从代码中找出迭代变量的含义，那么应该使用更具描述性的名称。\n\nIt’s also possible for a name to be too specific, such as in this declaration for a method that deletes a range of text:\n\n> 名称也可能太具体，例如在此声明中删除一个文本范围的方法：\n\n```java\nvoid delete(Range selection) {...}\n```\n\nThe argument name selection is too specific, since it suggests that the text being deleted is always selected in the user interface. However, this method can be invoked on any range of text, selected or not. Thus, the argument name should be more generic, such as range.\n\n> 参数名称的选择过于具体，因为它建议始终在用户界面中选择要删除的文本。但是，可以在任意范围的文本（无论是否选中）上调用此方法。因此，参数名称应更通用，例如范围。\n\nIf you find it difficult to come up with a name for a particular variable that is precise, intuitive, and not too long, this is a red flag. It suggests that the variable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can improve your design by identifying weaknesses.\n\n> 如果您发现很难为精确，直观且时间不长的特定变量命名，那么这是一个危险信号。这表明该变量可能没有明确的定义或目的。发生这种情况时，请考虑其他因素。例如，也许您正在尝试使用单个变量来表示几件事；如果是这样，将表示形式分成多个变量可能会导致每个变量的定义更简单。选择好名字的过程可以通过识别弱点来改善您的设计。\n\nimg Red Flag: Hard to Pick Name img\n\nIf it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.\n\n> 如果很难为创建基础对象清晰图像的变量或方法找到简单的名称，则表明基础对象可能没有简洁的设计。\n\n## 14.4 Use names consistently 一致使用名称\n\nThe second important property of good names is consistency. In any program there are certain variables that are used over and over again. For example, a file system manipulates block numbers repeatedly. For each of these common usages, pick a name to use for that purpose, and use the same name everywhere. For example, a file system might always use fileBlock to hold the index of a block within a file. Consistent naming reduces cognitive load in much the same way as reusing a common class: once the reader has seen the name in one context, they can reuse their knowledge and instantly make assumptions when they see the name in a different context.\n\n> 名誉的第二个重要属性是一致性。在任何程序中，都会反复使用某些变量。例如，文件系统反复操作块号。对于每种常见用法，请选择一个用于该目的的名称，并在各处使用相同的名称。例如，文件系统可能总是使用 fileBlock 来保存文件中块的索引。一致的命名方式与重用普通类的方式一样，可以减轻认知负担：一旦读者在一个上下文中看到了该名称，他们就可以重用其知识并在不同上下文中看到该名称时立即做出假设。\n\nConsistency has three requirements: first, always use the common name for the given purpose; second, never use the common name for anything other than the given purpose; third, make sure that the purpose is narrow enough that all variables with the name have the same behavior. This third requirement was violated in the file system bug at the beginning of the chapter. The file system used block for variables with two different behaviors (file blocks and disk blocks); this led to a false assumption about the meaning of a variable, which in turn resulted in a bug.\n\n> 一致性具有三个要求：首先，始终将通用名称用于给定目的；第二，除了给定目的外，切勿使用通用名称；第三，确保目的足够狭窄，以使所有具有名称的变量都具有相同的行为。在本章开头的文件系统错误中违反了此第三项要求。文件系统使用块来表示具有两种不同行为的变量（文件块和磁盘块）；这导致对变量含义的错误假设，进而导致错误。\n\nSometimes you will need multiple variables that refer to the same general sort of thing. For example, a method that copies file data will need two block numbers, one for the source and one for the destination. When this happens, use the common name for each variable but add a distinguishing prefix, such as srcFileBlock and dstFileBlock.\n\n> 有时您将需要多个变量来引用相同的一般事物。例如，一种复制文件数据的方法将需要两个块号，一个为源，一个为目标。发生这种情况时，请对每个变量使用通用名称，但要添加一个可区分的前缀，例如 srcFileBlock 和 dstFileBlock。\n\nLoops are another area where consistent naming can help. If you use names such as i and j for loop variables, always use i in outermost loops and j for nested loops. This allows readers to make instant (safe) assumptions about what’s happening in the code when they see a given name.\n\n> 循环是一致性命名可以提供帮助的另一个领域。如果将诸如 i 和 j 之类的名称用于循环变量，则始终在最外层循环中使用 i，而在嵌套循环中始终使用 j。这使读者可以在看到给定名称时对代码中发生的事情做出即时（安全）假设。\n\n## 14.5 A different opinion: Go style guide 不同的意见：转到样式指南\n\nNot everyone shares my views about naming. Some of the developers of the Go language argue that names should be very short, often only a single character. In a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”1 He presents this code sample, which uses single-letter variable names:\n\n> 并非所有人都同意我对命名的看法。一些使用 Go 语言的开发人员认为，名称应该非常简短，通常只能是一个字符。在关于 Go 的名称选择的演示中，Andrew Gerrand 指出“长名称模糊了代码的作用。” 1 他介绍了此代码示例，该示例使用单字母变量名：\n\n```go\nfunc RuneCount(b []byte) int {\n    i, n := 0, 0\n    for i < len(b) {\n        if b[i] < RuneSelf {\n            i++\n        } else {\n            _, size := DecodeRune(b[i:])\n            i += size\n        }\n        n++\n    }\n    return n\n}\n```\n\nand argues that it is more readable than the following version, which uses longer names:\n\n> 并认为它比以下使用更长名称的版本更具可读性：\n\n```go\nfunc RuneCount(buffer []byte) int {\n    index, count := 0, 0\n    for index < len(buffer) {\n        if buffer[index] < RuneSelf {\n            index++\n        } else {\n            _, size := DecodeRune(buffer[index:])\n            index += size\n        }\n        count++\n    }\n    return count\n}\n```\n\nPersonally, I don’t find the second version any more difficult to read than the first. If anything, the name count gives a slightly better clue to the behavior of the variable than n. With the first version I ended up reading through the code trying to figure out what n means, whereas I didn’t feel that need with the second version. But, if n is used consistently throughout the system to refer to counts (and nothing else), then the short name will probably be clear to other developers.\n\n> 就个人而言，我发现第二版本比第一版本更难阅读。如果有的话，与 n 相比，名称计数为变量的行为提供了更好的线索。在第一个版本中，我最终通读了代码，试图弄清楚 n 的含义，而第二个版本中我并没有这种需要。但是，如果在整个系统中一致地使用 n 来引用计数（而没有其他内容），那么其他开发人员可能会清楚知道该短名称。\n\nThe Go culture encourages the use of the same short name for multiple different things: ch for character or channel, d for data, difference, or distance, and so on. To me, ambiguous names like these are likely to result in confusion and error, just as in the block example.\n\n> Go 文化鼓励在多个不同的事物上使用相同的短名称：ch 用于字符或通道，d 用于数据，差异或距离，等等。对我来说，像这样的模棱两可的名称很可能导致混乱和错误，就像在示例中一样。\n\nOverall, I would argue that readability must be determined by readers, not writers. If you write code with short variable names and the people who read it find it easy to understand, then that’s fine. If you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints). Similarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.\n\n> 总的来说，我认为可读性必须由读者而不是作家来决定。如果您使用简短的变量名编写代码，并且阅读该代码的人很容易理解，那么很好。如果您开始抱怨代码很含糊，那么您应该考虑使用更长的名称（在网络上搜索“ go language short name”（使用语言简称）会识别出几种此类抱怨）。同样，如果我开始抱怨长变量名使我的代码难以阅读，那么我会考虑使用较短的变量名。\n\nGerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name should be.” The earlier discussion about using loop variables named i and j is an example of this rule.\n\n> Gerrand 发表一个我同意的评论：“名称声明与使用之间的距离越大，名称就应该越长。” 前面有关使用名为 i 和 j 的循环变量的讨论是此规则的示例。\n\n## 14.6 Conclusion 结论\n\nWell chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct. Choosing good names is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future. In addition, you will be less likely to introduce bugs. Developing a skill for naming is also an investment. When you first decide to stop settling for mediocre names, you may find it frustrating and time-consuming to come up with good names. However, as you get more experience you’ll find that it becomes easier; eventually, you’ll get to the point where it takes almost no extra time to choose good names, so you will get the benefits almost for free.\n\n> 精心选择的名称有助于使代码更明显。当某人第一次遇到该变量时，他们对行为的第一次猜测是正确的。选择好名字是第 3 章讨论的投资思维方式的一个示例：如果您花一些额外的时间来选择好名字，那么将来您将更容易处理代码。此外，您不太可能引入错误。培养命名技巧也是一项投资。当您第一次决定停止为平庸的名字定居时，您会发现想出好名字的过程既令人沮丧又耗时。但是，随着您获得更多的经验，您会发现它变得更加容易。最终，您将几乎不需要花费额外的时间来选择好名字，因此您几乎可以免费获得好处。\n\n1https://talks.golang.org/2014/names.slide#1\n","source":"_posts/软件设计的哲学-ch14.md","raw":"---\ntitle: 软件设计的哲学 - ch14\ndate: 2021-02-14\ntags: 软件设计的哲学 软件开发 方法论\n---\n选择的名字\n<!-- more -->\n# 第 14 章 选择的名字\n\n> Chapter 14 Choosing Names\n\nSelecting names for variables, methods, and other entities is one of the most underrated aspects of software design. Good names are a form of documentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particular variable, as opposed to the best possible name, probably won’t have much impact on the overall complexity of a system. However, software systems have thousands of variables; choosing good names for all of these will have a significant impact on complexity and manageability.\n\n> 为变量，方法和其他实体选择名称是软件设计中被低估的方面之一。良好的名字是一种文档形式：它们使代码更易于理解。它们减少了对其他文档的需求，并使检测错误更加容易。相反，名称选择不当会增加代码的复杂性，并造成可能导致错误的歧义和误解。名称选择是复杂度是递增的原理的一个示例。为特定变量选择一个平庸的名称，而不是最好的名称，这可能不会对系统的整体复杂性产生太大影响。但是，软件系统具有数千个变量。为所有这些选择好名字将对复杂性和可管理性产生重大影响。\n\n## 14.1 Example: bad names cause bugs 示例：名称错误会导致错误\n\nSometimes even a single poorly named variable can have severe consequences. The most challenging bug I ever fixed came about because of a poor name choice. In the late 1980’s and early 1990’s my graduate students and I created a distributed operating system called Sprite. At some point we noticed that files would occasionally lose data: one of the data blocks suddenly became all zeroes, even though the file had not been modified by a user. The problem didn’t happen very often, so it was exceptionally difficult to track down. A few of the graduate students tried to find the bug, but they were unable to make progress and eventually gave up. However, I consider any unsolved bug to be an intolerable personal insult, so I decided to track it down.\n\n> 有时，即使是一个名称不正确的变量也会产生严重的后果。我曾经修复过的最具挑战性的错误是由于名称选择不当造成的。在 1980 年代末和 1990 年代初，我的研究生和我创建了一个名为 Sprite 的分布式操作系统。在某个时候，我们注意到文件偶尔会丢失数据：即使用户未修改文件，数据块之一突然变为全零。该问题并不经常发生，因此很难追踪。一些研究生试图找到该错误，但他们未能取得进展，最终放弃了。但是，我认为任何未解决的错误都是无法忍受的个人侮辱，因此我决定对其进行跟踪。\n\nIt took six months, but I eventually found and fixed the bug. The problem was actually quite simple (as are most bugs, once you figure them out). The file system code used the variable name block for two different purposes. In some situations, block referred to a physical block number on disk; in other situations, block referred to a logical block number within a file. Unfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.\n\n> 花了六个月的时间，但我最终找到并修复了该错误。这个问题实际上很简单（就像大多数错误一样，一旦找出它们）。文件系统代码将变量名块用于两个不同的目的。在某些情况下，块是指磁盘上的物理块号。在其他情况下，块是指文件中的逻辑块号。不幸的是，在代码的某一点上有一个包含逻辑块号的块变量，但是在需要物理块号的情况下意外地使用了它。结果，磁盘上无关的块被零覆盖。\n\nWhile tracking down the bug, several people, including myself, read over the faulty code, but we never noticed the problem. When we saw the variable block used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of instrumentation, which eventually showed that the corruption must be happening in a particular statement, before I was able to get past the mental block created by the name and check to see exactly where its value came from. If different variable names had been used for the different kinds of blocks, such as fileBlock and diskBlock, it’s unlikely that the error would have happened; the programmer would have known that fileBlock couldn’t be used in that situation.\n\n> 在跟踪该错误时，包括我自己在内的几个人阅读了错误的代码，但我们从未注意到问题所在。当我们看到可变块用作物理块号时，我们反身地假设它确实拥有物理块号。经过很长时间的检测，最终显示出腐败一定是在特定的语句中发生的，然后我才能越过该名称所创建的思维障碍，并查看其价值的确切来源。如果对不同种类的块（例如 fileBlock 和 diskBlock）使用了不同的变量名，则错误不太可能发生；程序员会知道在那种情况下不能使用 fileBlock。\n\nUnfortunately, most developers don’t spend much time thinking about names. They tend to use the first name that comes to mind, as long as it’s reasonably close to matching the thing it names. For example, block is a pretty close match for both a physical block on disk and a logical block within a file; it’s certainly not a horrible name. Even so, it resulted in a huge expenditure of time to track down a subtle bug. Thus, you shouldn’t settle for names that are just “reasonably close”. Take a bit of extra time to choose great names, which are precise, unambiguous, and intuitive. The extra attention will pay for itself quickly, and over time you’ll learn to choose good names quickly.\n\n> 不幸的是，大多数开发人员没有花太多时间在思考名字。他们倾向于使用想到的名字，只要它与匹配的名字相当接近即可。例如，块与磁盘上的物理块和文件内的逻辑块非常接近；这肯定不是一个可怕的名字。即使这样，它仍然要花费大量时间来查找一个细微的错误。因此，您不应该只选择“合理接近”的名称。花一些额外的时间来选择准确，明确且直观的好名字。额外的注意力将很快收回成本，随着时间的流逝，您将学会快速选择好名字。\n\n## 14.2 Create an image 创建图像\n\nWhen choosing a name, the goal is to create an image in the mind of the reader about the nature of the thing being named. A good name conveys a lot of information about what the underlying entity is, and, just as important, what it is not. When considering a particular name, ask yourself: “If someone sees this name in isolation, without seeing its declaration, its documentation, or any code that uses the name, how closely will they be able to guess what the name refers to? Is there some other name that will paint a clearer picture?” Of course, there is a limit to how much information you can put in a single name; names become unwieldy if they contain more than two or three words. Thus, the challenge is to find just a few words that capture the most important aspects of the entity.\n\n> 选择名称时，目标是在读者的脑海中创建一幅关于被命名事物的性质的图像。一个好名字传达了很多有关底层实体是什么，以及同样重要的是，不是什么的信息。在考虑特定名称时，请问自己：“如果有人孤立地看到该名称，而没有看到其声明，文档或使用该名称的任何代码，他们将能够猜到该名称指的是什么？还有其他名称可以使画面更清晰吗？” 当然，一个名字可以输入多少信息是有限制的。如果名称包含两个或三个以上的单词，则会变得笨拙。因此，面临的挑战是仅找到捕获实体最重要方面的几个单词。\n\nNames are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity. Like other forms of abstraction, the best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.\n\n> 名称是一种抽象形式：名称提供了一种简化的方式来考虑更复杂的基础实体。像其他形式的抽象一样，最好的名字是那些将注意力集中在对底层实体最重要的东西上，而忽略那些次要的细节。\n\n## 14.3 Names should be precise 名称应准确\n\nGood names have two properties: precision and consistency. Let’s start with precision. The most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above. Consider the following method declaration:\n\n> 良好名称具有两个属性：精度和一致性。让我们从精度开始。名称最常见的问题是名称太笼统或含糊不清。结果，读者很难说出这个名字指的是什么。读者可能会认为该名称所指的是与现实不符的事物，如上面的代码错误所示。考虑以下方法声明：\n\n```java\n/**\n * Returns the total number of indexlets this object is managing.\n */\nint IndexletManager::getCount() {...}\n```\n\nThe term “count” is too generic: count of what? If someone sees an invocation of this method, they are unlikely to know what it does unless they read its documentation. A more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.\n\n> 术语“计数”太笼统了：计数什么？如果有人看到此方法的调用，除非他们阅读了它的文档，否则他们不太可能知道它的作用。像 getActiveIndexlets 或 numIndexlets 这样的更精确的名称会更好：使用这些名称之一，读者可能无需查看其文档就能猜测该方法返回的内容。\n\nHere are some other examples of names that aren’t precise enough, taken from various student projects:\n\n> 以下是来自其他学生项目的一些名称不够精确的示例：\n\n- A project building a GUI text editor used the names x and y to refer to the position of a character in the file. These names are too generic. They could mean many things; for example, they might also represent the coordinates (in pixels) of a character on the screen. Someone seeing the name x in isolation is unlikely to think that it refers to the position of a character within a line of text. The code would be clearer if it used names such as charIndex and lineIndex, which reflect the specific abstractions that the code implements.\n  > 建立 GUI 文本编辑器的项目使用名称 x 和 y 来引用字符在文件中的位置。这些名称太笼统了。他们可能意味着很多事情；例如，它们也可能代表屏幕上字符的坐标（以像素为单位）。单独看到名称 x 的人不太可能会认为它是指字符在一行文本中的位置。如果使用诸如 charIndex 和 lineIndex 之类的名称来反映代码实现的特定抽象，该代码将更加清晰。\n- Another editor project contained the following code:\n\n  > 另一个编辑器项目包含以下代码：\n\n  ```java\n  // Blink state: true when cursor visible.\n  private boolean blinkStatus = true;\n  ```\n\n  The name blinkStatus doesn’t convey enough information. The word “status” is too vague for a boolean value: it gives no clue about what a true or false value means. The word “blink” is also vague, since it doesn’t indicate what is blinking. The following alternative is better:\n\n  > 名称 blinkStatus 无法传达足够的信息。“状态”一词对于布尔值来说太含糊了：它不提供关于真值或假值含义的任何线索。“闪烁”一词也含糊不清，因为它并不表示闪烁的内容。以下替代方法更好：\n\n  ```java\n  // Controls cursor blinking: true means the cursor is visible,\n  // false means the cursor is not displayed.\n  private boolean cursorVisible = true;\n  ```\n\n  The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word “blink” is no longer in the name, so readers will have to consult the documentation if they want to know why the cursor isn’t always visible; this information is less important.\n\n  > 名称 cursorVisible 传达了更多信息；例如，它允许读者猜测一个真值的含义（通常，布尔变量的名称应始终为谓词）。名称中不再包含“ blink”一词，因此，如果读者想知道为什么光标不总是可见，则必须查阅文档。此信息不太重要。\n\n- A project implementing a consensus protocol contained the following code:\n\n  > 一个实施共识协议的项目包含以下代码：\n\n  ```java\n  // Value representing that the server has not voted (yet) for\n  // anyone for the current election term.\n  private static final String VOTED_FOR_SENTINEL_VALUE = \"null\";\n  ```\n\n  The name for this value indicates that it’s special but it doesn’t say what the special meaning is. A more specific name such as NOT_YET_VOTED would be better.\n\n  > 此值的名称表示它是特殊的，但没有说明特殊含义是什么。使用更具体的名称（例如 NOT_YET_VOTED）会更好。\n\n- A variable named result was used in a method with no return value. This name has multiple problems. First, it creates the misleading impression that it will be the return value of the method. Second, it provides essentially no information about what it actually holds, except that it is some computed value. The name should provide information about what the result actually is, such as mergedLine or totalChars. In methods that do actually have return values, then using the name result is reasonable. This name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.\n\n  > 在没有返回值的方法中使用了名为 result 的变量。这个名字有多个问题。首先，它会产生误导性的印象，即它将作为方法的返回值。其次，除了它是一些计算值外，它实际上不提供有关其实际持有内容的任何信息。该名称应提供有关实际结果是什么的信息，例如 mergedLine 或 totalChars。在实际上确实具有返回值的方法中，使用名称结果是合理的。该名称仍然有点通用，但是读者可以查看方法文档以了解其含义，这有助于知道该值最终将成为返回值。\n\nimg Red Flag: Vague Name img\n\nIf a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.\n\n> 如果变量或方法的名称足够广泛，可以引用许多不同的事物，那么它不会向开发人员传达太多信息，因此底层实体很可能会被滥用。\n\nLike all rules, the rule about choosing precise names has a few exceptions. For example, it’s fine to use generic names like i and j as loop iteration variables, as long as the loops only span a few lines of code. If you can see the entire range of usage of a variable, then the meaning of the variable will probably be obvious from the code so you don’t need a long name. For example, consider the following code:\n\n> 像所有规则一样，有关选择精确名称的规则也有一些例外。例如，只要循环仅跨越几行代码，就可以将通用名称（如 i 和 j）用作循环迭代变量。如果您可以看到一个变量的整个用法范围，那么该变量的含义在代码中就很明显了，因此您不需要长名称。例如，考虑以下代码：\n\n```java\nfor  (i = 0; i < numLines; i++) {\n    ...\n}\n```\n\nIt’s clear from this code that i is being used to iterate over each of the lines in some entity. If the loop gets so long that you can’t see it all at once, or if the meaning of the iteration variable is harder to figure out from the code, then a more descriptive name is in order.\n\n> 从这段代码中很明显，我正被用来迭代某个实体中的每一行。如果循环时间太长，以至于您无法一次看到全部内容，或者如果很难从代码中找出迭代变量的含义，那么应该使用更具描述性的名称。\n\nIt’s also possible for a name to be too specific, such as in this declaration for a method that deletes a range of text:\n\n> 名称也可能太具体，例如在此声明中删除一个文本范围的方法：\n\n```java\nvoid delete(Range selection) {...}\n```\n\nThe argument name selection is too specific, since it suggests that the text being deleted is always selected in the user interface. However, this method can be invoked on any range of text, selected or not. Thus, the argument name should be more generic, such as range.\n\n> 参数名称的选择过于具体，因为它建议始终在用户界面中选择要删除的文本。但是，可以在任意范围的文本（无论是否选中）上调用此方法。因此，参数名称应更通用，例如范围。\n\nIf you find it difficult to come up with a name for a particular variable that is precise, intuitive, and not too long, this is a red flag. It suggests that the variable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can improve your design by identifying weaknesses.\n\n> 如果您发现很难为精确，直观且时间不长的特定变量命名，那么这是一个危险信号。这表明该变量可能没有明确的定义或目的。发生这种情况时，请考虑其他因素。例如，也许您正在尝试使用单个变量来表示几件事；如果是这样，将表示形式分成多个变量可能会导致每个变量的定义更简单。选择好名字的过程可以通过识别弱点来改善您的设计。\n\nimg Red Flag: Hard to Pick Name img\n\nIf it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.\n\n> 如果很难为创建基础对象清晰图像的变量或方法找到简单的名称，则表明基础对象可能没有简洁的设计。\n\n## 14.4 Use names consistently 一致使用名称\n\nThe second important property of good names is consistency. In any program there are certain variables that are used over and over again. For example, a file system manipulates block numbers repeatedly. For each of these common usages, pick a name to use for that purpose, and use the same name everywhere. For example, a file system might always use fileBlock to hold the index of a block within a file. Consistent naming reduces cognitive load in much the same way as reusing a common class: once the reader has seen the name in one context, they can reuse their knowledge and instantly make assumptions when they see the name in a different context.\n\n> 名誉的第二个重要属性是一致性。在任何程序中，都会反复使用某些变量。例如，文件系统反复操作块号。对于每种常见用法，请选择一个用于该目的的名称，并在各处使用相同的名称。例如，文件系统可能总是使用 fileBlock 来保存文件中块的索引。一致的命名方式与重用普通类的方式一样，可以减轻认知负担：一旦读者在一个上下文中看到了该名称，他们就可以重用其知识并在不同上下文中看到该名称时立即做出假设。\n\nConsistency has three requirements: first, always use the common name for the given purpose; second, never use the common name for anything other than the given purpose; third, make sure that the purpose is narrow enough that all variables with the name have the same behavior. This third requirement was violated in the file system bug at the beginning of the chapter. The file system used block for variables with two different behaviors (file blocks and disk blocks); this led to a false assumption about the meaning of a variable, which in turn resulted in a bug.\n\n> 一致性具有三个要求：首先，始终将通用名称用于给定目的；第二，除了给定目的外，切勿使用通用名称；第三，确保目的足够狭窄，以使所有具有名称的变量都具有相同的行为。在本章开头的文件系统错误中违反了此第三项要求。文件系统使用块来表示具有两种不同行为的变量（文件块和磁盘块）；这导致对变量含义的错误假设，进而导致错误。\n\nSometimes you will need multiple variables that refer to the same general sort of thing. For example, a method that copies file data will need two block numbers, one for the source and one for the destination. When this happens, use the common name for each variable but add a distinguishing prefix, such as srcFileBlock and dstFileBlock.\n\n> 有时您将需要多个变量来引用相同的一般事物。例如，一种复制文件数据的方法将需要两个块号，一个为源，一个为目标。发生这种情况时，请对每个变量使用通用名称，但要添加一个可区分的前缀，例如 srcFileBlock 和 dstFileBlock。\n\nLoops are another area where consistent naming can help. If you use names such as i and j for loop variables, always use i in outermost loops and j for nested loops. This allows readers to make instant (safe) assumptions about what’s happening in the code when they see a given name.\n\n> 循环是一致性命名可以提供帮助的另一个领域。如果将诸如 i 和 j 之类的名称用于循环变量，则始终在最外层循环中使用 i，而在嵌套循环中始终使用 j。这使读者可以在看到给定名称时对代码中发生的事情做出即时（安全）假设。\n\n## 14.5 A different opinion: Go style guide 不同的意见：转到样式指南\n\nNot everyone shares my views about naming. Some of the developers of the Go language argue that names should be very short, often only a single character. In a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”1 He presents this code sample, which uses single-letter variable names:\n\n> 并非所有人都同意我对命名的看法。一些使用 Go 语言的开发人员认为，名称应该非常简短，通常只能是一个字符。在关于 Go 的名称选择的演示中，Andrew Gerrand 指出“长名称模糊了代码的作用。” 1 他介绍了此代码示例，该示例使用单字母变量名：\n\n```go\nfunc RuneCount(b []byte) int {\n    i, n := 0, 0\n    for i < len(b) {\n        if b[i] < RuneSelf {\n            i++\n        } else {\n            _, size := DecodeRune(b[i:])\n            i += size\n        }\n        n++\n    }\n    return n\n}\n```\n\nand argues that it is more readable than the following version, which uses longer names:\n\n> 并认为它比以下使用更长名称的版本更具可读性：\n\n```go\nfunc RuneCount(buffer []byte) int {\n    index, count := 0, 0\n    for index < len(buffer) {\n        if buffer[index] < RuneSelf {\n            index++\n        } else {\n            _, size := DecodeRune(buffer[index:])\n            index += size\n        }\n        count++\n    }\n    return count\n}\n```\n\nPersonally, I don’t find the second version any more difficult to read than the first. If anything, the name count gives a slightly better clue to the behavior of the variable than n. With the first version I ended up reading through the code trying to figure out what n means, whereas I didn’t feel that need with the second version. But, if n is used consistently throughout the system to refer to counts (and nothing else), then the short name will probably be clear to other developers.\n\n> 就个人而言，我发现第二版本比第一版本更难阅读。如果有的话，与 n 相比，名称计数为变量的行为提供了更好的线索。在第一个版本中，我最终通读了代码，试图弄清楚 n 的含义，而第二个版本中我并没有这种需要。但是，如果在整个系统中一致地使用 n 来引用计数（而没有其他内容），那么其他开发人员可能会清楚知道该短名称。\n\nThe Go culture encourages the use of the same short name for multiple different things: ch for character or channel, d for data, difference, or distance, and so on. To me, ambiguous names like these are likely to result in confusion and error, just as in the block example.\n\n> Go 文化鼓励在多个不同的事物上使用相同的短名称：ch 用于字符或通道，d 用于数据，差异或距离，等等。对我来说，像这样的模棱两可的名称很可能导致混乱和错误，就像在示例中一样。\n\nOverall, I would argue that readability must be determined by readers, not writers. If you write code with short variable names and the people who read it find it easy to understand, then that’s fine. If you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints). Similarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.\n\n> 总的来说，我认为可读性必须由读者而不是作家来决定。如果您使用简短的变量名编写代码，并且阅读该代码的人很容易理解，那么很好。如果您开始抱怨代码很含糊，那么您应该考虑使用更长的名称（在网络上搜索“ go language short name”（使用语言简称）会识别出几种此类抱怨）。同样，如果我开始抱怨长变量名使我的代码难以阅读，那么我会考虑使用较短的变量名。\n\nGerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name should be.” The earlier discussion about using loop variables named i and j is an example of this rule.\n\n> Gerrand 发表一个我同意的评论：“名称声明与使用之间的距离越大，名称就应该越长。” 前面有关使用名为 i 和 j 的循环变量的讨论是此规则的示例。\n\n## 14.6 Conclusion 结论\n\nWell chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct. Choosing good names is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future. In addition, you will be less likely to introduce bugs. Developing a skill for naming is also an investment. When you first decide to stop settling for mediocre names, you may find it frustrating and time-consuming to come up with good names. However, as you get more experience you’ll find that it becomes easier; eventually, you’ll get to the point where it takes almost no extra time to choose good names, so you will get the benefits almost for free.\n\n> 精心选择的名称有助于使代码更明显。当某人第一次遇到该变量时，他们对行为的第一次猜测是正确的。选择好名字是第 3 章讨论的投资思维方式的一个示例：如果您花一些额外的时间来选择好名字，那么将来您将更容易处理代码。此外，您不太可能引入错误。培养命名技巧也是一项投资。当您第一次决定停止为平庸的名字定居时，您会发现想出好名字的过程既令人沮丧又耗时。但是，随着您获得更多的经验，您会发现它变得更加容易。最终，您将几乎不需要花费额外的时间来选择好名字，因此您几乎可以免费获得好处。\n\n1https://talks.golang.org/2014/names.slide#1\n","slug":"软件设计的哲学-ch14","published":1,"updated":"2021-02-16T04:53:26.183Z","_id":"ckl6pcc3k000fs4iyhqo79y5e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>选择的名字</p>\n<a id=\"more\"></a>\n<h1 id=\"第-14-章-选择的名字\"><a href=\"#第-14-章-选择的名字\" class=\"headerlink\" title=\"第 14 章 选择的名字\"></a>第 14 章 选择的名字</h1><blockquote>\n<p>Chapter 14 Choosing Names</p>\n</blockquote>\n<p>Selecting names for variables, methods, and other entities is one of the most underrated aspects of software design. Good names are a form of documentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particular variable, as opposed to the best possible name, probably won’t have much impact on the overall complexity of a system. However, software systems have thousands of variables; choosing good names for all of these will have a significant impact on complexity and manageability.</p>\n<blockquote>\n<p>为变量，方法和其他实体选择名称是软件设计中被低估的方面之一。良好的名字是一种文档形式：它们使代码更易于理解。它们减少了对其他文档的需求，并使检测错误更加容易。相反，名称选择不当会增加代码的复杂性，并造成可能导致错误的歧义和误解。名称选择是复杂度是递增的原理的一个示例。为特定变量选择一个平庸的名称，而不是最好的名称，这可能不会对系统的整体复杂性产生太大影响。但是，软件系统具有数千个变量。为所有这些选择好名字将对复杂性和可管理性产生重大影响。</p>\n</blockquote>\n<h2 id=\"14-1-Example-bad-names-cause-bugs-示例：名称错误会导致错误\"><a href=\"#14-1-Example-bad-names-cause-bugs-示例：名称错误会导致错误\" class=\"headerlink\" title=\"14.1 Example: bad names cause bugs 示例：名称错误会导致错误\"></a>14.1 Example: bad names cause bugs 示例：名称错误会导致错误</h2><p>Sometimes even a single poorly named variable can have severe consequences. The most challenging bug I ever fixed came about because of a poor name choice. In the late 1980’s and early 1990’s my graduate students and I created a distributed operating system called Sprite. At some point we noticed that files would occasionally lose data: one of the data blocks suddenly became all zeroes, even though the file had not been modified by a user. The problem didn’t happen very often, so it was exceptionally difficult to track down. A few of the graduate students tried to find the bug, but they were unable to make progress and eventually gave up. However, I consider any unsolved bug to be an intolerable personal insult, so I decided to track it down.</p>\n<blockquote>\n<p>有时，即使是一个名称不正确的变量也会产生严重的后果。我曾经修复过的最具挑战性的错误是由于名称选择不当造成的。在 1980 年代末和 1990 年代初，我的研究生和我创建了一个名为 Sprite 的分布式操作系统。在某个时候，我们注意到文件偶尔会丢失数据：即使用户未修改文件，数据块之一突然变为全零。该问题并不经常发生，因此很难追踪。一些研究生试图找到该错误，但他们未能取得进展，最终放弃了。但是，我认为任何未解决的错误都是无法忍受的个人侮辱，因此我决定对其进行跟踪。</p>\n</blockquote>\n<p>It took six months, but I eventually found and fixed the bug. The problem was actually quite simple (as are most bugs, once you figure them out). The file system code used the variable name block for two different purposes. In some situations, block referred to a physical block number on disk; in other situations, block referred to a logical block number within a file. Unfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.</p>\n<blockquote>\n<p>花了六个月的时间，但我最终找到并修复了该错误。这个问题实际上很简单（就像大多数错误一样，一旦找出它们）。文件系统代码将变量名块用于两个不同的目的。在某些情况下，块是指磁盘上的物理块号。在其他情况下，块是指文件中的逻辑块号。不幸的是，在代码的某一点上有一个包含逻辑块号的块变量，但是在需要物理块号的情况下意外地使用了它。结果，磁盘上无关的块被零覆盖。</p>\n</blockquote>\n<p>While tracking down the bug, several people, including myself, read over the faulty code, but we never noticed the problem. When we saw the variable block used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of instrumentation, which eventually showed that the corruption must be happening in a particular statement, before I was able to get past the mental block created by the name and check to see exactly where its value came from. If different variable names had been used for the different kinds of blocks, such as fileBlock and diskBlock, it’s unlikely that the error would have happened; the programmer would have known that fileBlock couldn’t be used in that situation.</p>\n<blockquote>\n<p>在跟踪该错误时，包括我自己在内的几个人阅读了错误的代码，但我们从未注意到问题所在。当我们看到可变块用作物理块号时，我们反身地假设它确实拥有物理块号。经过很长时间的检测，最终显示出腐败一定是在特定的语句中发生的，然后我才能越过该名称所创建的思维障碍，并查看其价值的确切来源。如果对不同种类的块（例如 fileBlock 和 diskBlock）使用了不同的变量名，则错误不太可能发生；程序员会知道在那种情况下不能使用 fileBlock。</p>\n</blockquote>\n<p>Unfortunately, most developers don’t spend much time thinking about names. They tend to use the first name that comes to mind, as long as it’s reasonably close to matching the thing it names. For example, block is a pretty close match for both a physical block on disk and a logical block within a file; it’s certainly not a horrible name. Even so, it resulted in a huge expenditure of time to track down a subtle bug. Thus, you shouldn’t settle for names that are just “reasonably close”. Take a bit of extra time to choose great names, which are precise, unambiguous, and intuitive. The extra attention will pay for itself quickly, and over time you’ll learn to choose good names quickly.</p>\n<blockquote>\n<p>不幸的是，大多数开发人员没有花太多时间在思考名字。他们倾向于使用想到的名字，只要它与匹配的名字相当接近即可。例如，块与磁盘上的物理块和文件内的逻辑块非常接近；这肯定不是一个可怕的名字。即使这样，它仍然要花费大量时间来查找一个细微的错误。因此，您不应该只选择“合理接近”的名称。花一些额外的时间来选择准确，明确且直观的好名字。额外的注意力将很快收回成本，随着时间的流逝，您将学会快速选择好名字。</p>\n</blockquote>\n<h2 id=\"14-2-Create-an-image-创建图像\"><a href=\"#14-2-Create-an-image-创建图像\" class=\"headerlink\" title=\"14.2 Create an image 创建图像\"></a>14.2 Create an image 创建图像</h2><p>When choosing a name, the goal is to create an image in the mind of the reader about the nature of the thing being named. A good name conveys a lot of information about what the underlying entity is, and, just as important, what it is not. When considering a particular name, ask yourself: “If someone sees this name in isolation, without seeing its declaration, its documentation, or any code that uses the name, how closely will they be able to guess what the name refers to? Is there some other name that will paint a clearer picture?” Of course, there is a limit to how much information you can put in a single name; names become unwieldy if they contain more than two or three words. Thus, the challenge is to find just a few words that capture the most important aspects of the entity.</p>\n<blockquote>\n<p>选择名称时，目标是在读者的脑海中创建一幅关于被命名事物的性质的图像。一个好名字传达了很多有关底层实体是什么，以及同样重要的是，不是什么的信息。在考虑特定名称时，请问自己：“如果有人孤立地看到该名称，而没有看到其声明，文档或使用该名称的任何代码，他们将能够猜到该名称指的是什么？还有其他名称可以使画面更清晰吗？” 当然，一个名字可以输入多少信息是有限制的。如果名称包含两个或三个以上的单词，则会变得笨拙。因此，面临的挑战是仅找到捕获实体最重要方面的几个单词。</p>\n</blockquote>\n<p>Names are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity. Like other forms of abstraction, the best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.</p>\n<blockquote>\n<p>名称是一种抽象形式：名称提供了一种简化的方式来考虑更复杂的基础实体。像其他形式的抽象一样，最好的名字是那些将注意力集中在对底层实体最重要的东西上，而忽略那些次要的细节。</p>\n</blockquote>\n<h2 id=\"14-3-Names-should-be-precise-名称应准确\"><a href=\"#14-3-Names-should-be-precise-名称应准确\" class=\"headerlink\" title=\"14.3 Names should be precise 名称应准确\"></a>14.3 Names should be precise 名称应准确</h2><p>Good names have two properties: precision and consistency. Let’s start with precision. The most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above. Consider the following method declaration:</p>\n<blockquote>\n<p>良好名称具有两个属性：精度和一致性。让我们从精度开始。名称最常见的问题是名称太笼统或含糊不清。结果，读者很难说出这个名字指的是什么。读者可能会认为该名称所指的是与现实不符的事物，如上面的代码错误所示。考虑以下方法声明：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the total number of indexlets this object is managing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IndexletManager::getCount() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The term “count” is too generic: count of what? If someone sees an invocation of this method, they are unlikely to know what it does unless they read its documentation. A more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.</p>\n<blockquote>\n<p>术语“计数”太笼统了：计数什么？如果有人看到此方法的调用，除非他们阅读了它的文档，否则他们不太可能知道它的作用。像 getActiveIndexlets 或 numIndexlets 这样的更精确的名称会更好：使用这些名称之一，读者可能无需查看其文档就能猜测该方法返回的内容。</p>\n</blockquote>\n<p>Here are some other examples of names that aren’t precise enough, taken from various student projects:</p>\n<blockquote>\n<p>以下是来自其他学生项目的一些名称不够精确的示例：</p>\n</blockquote>\n<ul>\n<li><p>A project building a GUI text editor used the names x and y to refer to the position of a character in the file. These names are too generic. They could mean many things; for example, they might also represent the coordinates (in pixels) of a character on the screen. Someone seeing the name x in isolation is unlikely to think that it refers to the position of a character within a line of text. The code would be clearer if it used names such as charIndex and lineIndex, which reflect the specific abstractions that the code implements.</p>\n<blockquote>\n<p>建立 GUI 文本编辑器的项目使用名称 x 和 y 来引用字符在文件中的位置。这些名称太笼统了。他们可能意味着很多事情；例如，它们也可能代表屏幕上字符的坐标（以像素为单位）。单独看到名称 x 的人不太可能会认为它是指字符在一行文本中的位置。如果使用诸如 charIndex 和 lineIndex 之类的名称来反映代码实现的特定抽象，该代码将更加清晰。</p>\n</blockquote>\n</li>\n<li><p>Another editor project contained the following code:</p>\n<blockquote>\n<p>另一个编辑器项目包含以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Blink state: true when cursor visible.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> blinkStatus = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name blinkStatus doesn’t convey enough information. The word “status” is too vague for a boolean value: it gives no clue about what a true or false value means. The word “blink” is also vague, since it doesn’t indicate what is blinking. The following alternative is better:</p>\n<blockquote>\n<p>名称 blinkStatus 无法传达足够的信息。“状态”一词对于布尔值来说太含糊了：它不提供关于真值或假值含义的任何线索。“闪烁”一词也含糊不清，因为它并不表示闪烁的内容。以下替代方法更好：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controls cursor blinking: true means the cursor is visible,</span></span><br><span class=\"line\"><span class=\"comment\">// false means the cursor is not displayed.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> cursorVisible = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word “blink” is no longer in the name, so readers will have to consult the documentation if they want to know why the cursor isn’t always visible; this information is less important.</p>\n<blockquote>\n<p>名称 cursorVisible 传达了更多信息；例如，它允许读者猜测一个真值的含义（通常，布尔变量的名称应始终为谓词）。名称中不再包含“ blink”一词，因此，如果读者想知道为什么光标不总是可见，则必须查阅文档。此信息不太重要。</p>\n</blockquote>\n</li>\n<li><p>A project implementing a consensus protocol contained the following code:</p>\n<blockquote>\n<p>一个实施共识协议的项目包含以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value representing that the server has not voted (yet) for</span></span><br><span class=\"line\"><span class=\"comment\">// anyone for the current election term.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String VOTED_FOR_SENTINEL_VALUE = <span class=\"string\">\"null\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name for this value indicates that it’s special but it doesn’t say what the special meaning is. A more specific name such as NOT_YET_VOTED would be better.</p>\n<blockquote>\n<p>此值的名称表示它是特殊的，但没有说明特殊含义是什么。使用更具体的名称（例如 NOT_YET_VOTED）会更好。</p>\n</blockquote>\n</li>\n<li><p>A variable named result was used in a method with no return value. This name has multiple problems. First, it creates the misleading impression that it will be the return value of the method. Second, it provides essentially no information about what it actually holds, except that it is some computed value. The name should provide information about what the result actually is, such as mergedLine or totalChars. In methods that do actually have return values, then using the name result is reasonable. This name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.</p>\n<blockquote>\n<p>在没有返回值的方法中使用了名为 result 的变量。这个名字有多个问题。首先，它会产生误导性的印象，即它将作为方法的返回值。其次，除了它是一些计算值外，它实际上不提供有关其实际持有内容的任何信息。该名称应提供有关实际结果是什么的信息，例如 mergedLine 或 totalChars。在实际上确实具有返回值的方法中，使用名称结果是合理的。该名称仍然有点通用，但是读者可以查看方法文档以了解其含义，这有助于知道该值最终将成为返回值。</p>\n</blockquote>\n</li>\n</ul>\n<p>img Red Flag: Vague Name img</p>\n<p>If a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.</p>\n<blockquote>\n<p>如果变量或方法的名称足够广泛，可以引用许多不同的事物，那么它不会向开发人员传达太多信息，因此底层实体很可能会被滥用。</p>\n</blockquote>\n<p>Like all rules, the rule about choosing precise names has a few exceptions. For example, it’s fine to use generic names like i and j as loop iteration variables, as long as the loops only span a few lines of code. If you can see the entire range of usage of a variable, then the meaning of the variable will probably be obvious from the code so you don’t need a long name. For example, consider the following code:</p>\n<blockquote>\n<p>像所有规则一样，有关选择精确名称的规则也有一些例外。例如，只要循环仅跨越几行代码，就可以将通用名称（如 i 和 j）用作循环迭代变量。如果您可以看到一个变量的整个用法范围，那么该变量的含义在代码中就很明显了，因此您不需要长名称。例如，考虑以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>  (i = <span class=\"number\">0</span>; i &lt; numLines; i++) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>It’s clear from this code that i is being used to iterate over each of the lines in some entity. If the loop gets so long that you can’t see it all at once, or if the meaning of the iteration variable is harder to figure out from the code, then a more descriptive name is in order.</p>\n<blockquote>\n<p>从这段代码中很明显，我正被用来迭代某个实体中的每一行。如果循环时间太长，以至于您无法一次看到全部内容，或者如果很难从代码中找出迭代变量的含义，那么应该使用更具描述性的名称。</p>\n</blockquote>\n<p>It’s also possible for a name to be too specific, such as in this declaration for a method that deletes a range of text:</p>\n<blockquote>\n<p>名称也可能太具体，例如在此声明中删除一个文本范围的方法：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Range selection)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The argument name selection is too specific, since it suggests that the text being deleted is always selected in the user interface. However, this method can be invoked on any range of text, selected or not. Thus, the argument name should be more generic, such as range.</p>\n<blockquote>\n<p>参数名称的选择过于具体，因为它建议始终在用户界面中选择要删除的文本。但是，可以在任意范围的文本（无论是否选中）上调用此方法。因此，参数名称应更通用，例如范围。</p>\n</blockquote>\n<p>If you find it difficult to come up with a name for a particular variable that is precise, intuitive, and not too long, this is a red flag. It suggests that the variable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can improve your design by identifying weaknesses.</p>\n<blockquote>\n<p>如果您发现很难为精确，直观且时间不长的特定变量命名，那么这是一个危险信号。这表明该变量可能没有明确的定义或目的。发生这种情况时，请考虑其他因素。例如，也许您正在尝试使用单个变量来表示几件事；如果是这样，将表示形式分成多个变量可能会导致每个变量的定义更简单。选择好名字的过程可以通过识别弱点来改善您的设计。</p>\n</blockquote>\n<p>img Red Flag: Hard to Pick Name img</p>\n<p>If it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.</p>\n<blockquote>\n<p>如果很难为创建基础对象清晰图像的变量或方法找到简单的名称，则表明基础对象可能没有简洁的设计。</p>\n</blockquote>\n<h2 id=\"14-4-Use-names-consistently-一致使用名称\"><a href=\"#14-4-Use-names-consistently-一致使用名称\" class=\"headerlink\" title=\"14.4 Use names consistently 一致使用名称\"></a>14.4 Use names consistently 一致使用名称</h2><p>The second important property of good names is consistency. In any program there are certain variables that are used over and over again. For example, a file system manipulates block numbers repeatedly. For each of these common usages, pick a name to use for that purpose, and use the same name everywhere. For example, a file system might always use fileBlock to hold the index of a block within a file. Consistent naming reduces cognitive load in much the same way as reusing a common class: once the reader has seen the name in one context, they can reuse their knowledge and instantly make assumptions when they see the name in a different context.</p>\n<blockquote>\n<p>名誉的第二个重要属性是一致性。在任何程序中，都会反复使用某些变量。例如，文件系统反复操作块号。对于每种常见用法，请选择一个用于该目的的名称，并在各处使用相同的名称。例如，文件系统可能总是使用 fileBlock 来保存文件中块的索引。一致的命名方式与重用普通类的方式一样，可以减轻认知负担：一旦读者在一个上下文中看到了该名称，他们就可以重用其知识并在不同上下文中看到该名称时立即做出假设。</p>\n</blockquote>\n<p>Consistency has three requirements: first, always use the common name for the given purpose; second, never use the common name for anything other than the given purpose; third, make sure that the purpose is narrow enough that all variables with the name have the same behavior. This third requirement was violated in the file system bug at the beginning of the chapter. The file system used block for variables with two different behaviors (file blocks and disk blocks); this led to a false assumption about the meaning of a variable, which in turn resulted in a bug.</p>\n<blockquote>\n<p>一致性具有三个要求：首先，始终将通用名称用于给定目的；第二，除了给定目的外，切勿使用通用名称；第三，确保目的足够狭窄，以使所有具有名称的变量都具有相同的行为。在本章开头的文件系统错误中违反了此第三项要求。文件系统使用块来表示具有两种不同行为的变量（文件块和磁盘块）；这导致对变量含义的错误假设，进而导致错误。</p>\n</blockquote>\n<p>Sometimes you will need multiple variables that refer to the same general sort of thing. For example, a method that copies file data will need two block numbers, one for the source and one for the destination. When this happens, use the common name for each variable but add a distinguishing prefix, such as srcFileBlock and dstFileBlock.</p>\n<blockquote>\n<p>有时您将需要多个变量来引用相同的一般事物。例如，一种复制文件数据的方法将需要两个块号，一个为源，一个为目标。发生这种情况时，请对每个变量使用通用名称，但要添加一个可区分的前缀，例如 srcFileBlock 和 dstFileBlock。</p>\n</blockquote>\n<p>Loops are another area where consistent naming can help. If you use names such as i and j for loop variables, always use i in outermost loops and j for nested loops. This allows readers to make instant (safe) assumptions about what’s happening in the code when they see a given name.</p>\n<blockquote>\n<p>循环是一致性命名可以提供帮助的另一个领域。如果将诸如 i 和 j 之类的名称用于循环变量，则始终在最外层循环中使用 i，而在嵌套循环中始终使用 j。这使读者可以在看到给定名称时对代码中发生的事情做出即时（安全）假设。</p>\n</blockquote>\n<h2 id=\"14-5-A-different-opinion-Go-style-guide-不同的意见：转到样式指南\"><a href=\"#14-5-A-different-opinion-Go-style-guide-不同的意见：转到样式指南\" class=\"headerlink\" title=\"14.5 A different opinion: Go style guide 不同的意见：转到样式指南\"></a>14.5 A different opinion: Go style guide 不同的意见：转到样式指南</h2><p>Not everyone shares my views about naming. Some of the developers of the Go language argue that names should be very short, often only a single character. In a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”1 He presents this code sample, which uses single-letter variable names:</p>\n<blockquote>\n<p>并非所有人都同意我对命名的看法。一些使用 Go 语言的开发人员认为，名称应该非常简短，通常只能是一个字符。在关于 Go 的名称选择的演示中，Andrew Gerrand 指出“长名称模糊了代码的作用。” 1 他介绍了此代码示例，该示例使用单字母变量名：</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RuneCount</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    i, n := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &lt; <span class=\"built_in\">len</span>(b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b[i] &lt; RuneSelf &#123;</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _, size := DecodeRune(b[i:])</span><br><span class=\"line\">            i += size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>and argues that it is more readable than the following version, which uses longer names:</p>\n<blockquote>\n<p>并认为它比以下使用更长名称的版本更具可读性：</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RuneCount</span><span class=\"params\">(buffer []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    index, count := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index &lt; <span class=\"built_in\">len</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> buffer[index] &lt; RuneSelf &#123;</span><br><span class=\"line\">            index++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _, size := DecodeRune(buffer[index:])</span><br><span class=\"line\">            index += size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Personally, I don’t find the second version any more difficult to read than the first. If anything, the name count gives a slightly better clue to the behavior of the variable than n. With the first version I ended up reading through the code trying to figure out what n means, whereas I didn’t feel that need with the second version. But, if n is used consistently throughout the system to refer to counts (and nothing else), then the short name will probably be clear to other developers.</p>\n<blockquote>\n<p>就个人而言，我发现第二版本比第一版本更难阅读。如果有的话，与 n 相比，名称计数为变量的行为提供了更好的线索。在第一个版本中，我最终通读了代码，试图弄清楚 n 的含义，而第二个版本中我并没有这种需要。但是，如果在整个系统中一致地使用 n 来引用计数（而没有其他内容），那么其他开发人员可能会清楚知道该短名称。</p>\n</blockquote>\n<p>The Go culture encourages the use of the same short name for multiple different things: ch for character or channel, d for data, difference, or distance, and so on. To me, ambiguous names like these are likely to result in confusion and error, just as in the block example.</p>\n<blockquote>\n<p>Go 文化鼓励在多个不同的事物上使用相同的短名称：ch 用于字符或通道，d 用于数据，差异或距离，等等。对我来说，像这样的模棱两可的名称很可能导致混乱和错误，就像在示例中一样。</p>\n</blockquote>\n<p>Overall, I would argue that readability must be determined by readers, not writers. If you write code with short variable names and the people who read it find it easy to understand, then that’s fine. If you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints). Similarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.</p>\n<blockquote>\n<p>总的来说，我认为可读性必须由读者而不是作家来决定。如果您使用简短的变量名编写代码，并且阅读该代码的人很容易理解，那么很好。如果您开始抱怨代码很含糊，那么您应该考虑使用更长的名称（在网络上搜索“ go language short name”（使用语言简称）会识别出几种此类抱怨）。同样，如果我开始抱怨长变量名使我的代码难以阅读，那么我会考虑使用较短的变量名。</p>\n</blockquote>\n<p>Gerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name should be.” The earlier discussion about using loop variables named i and j is an example of this rule.</p>\n<blockquote>\n<p>Gerrand 发表一个我同意的评论：“名称声明与使用之间的距离越大，名称就应该越长。” 前面有关使用名为 i 和 j 的循环变量的讨论是此规则的示例。</p>\n</blockquote>\n<h2 id=\"14-6-Conclusion-结论\"><a href=\"#14-6-Conclusion-结论\" class=\"headerlink\" title=\"14.6 Conclusion 结论\"></a>14.6 Conclusion 结论</h2><p>Well chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct. Choosing good names is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future. In addition, you will be less likely to introduce bugs. Developing a skill for naming is also an investment. When you first decide to stop settling for mediocre names, you may find it frustrating and time-consuming to come up with good names. However, as you get more experience you’ll find that it becomes easier; eventually, you’ll get to the point where it takes almost no extra time to choose good names, so you will get the benefits almost for free.</p>\n<blockquote>\n<p>精心选择的名称有助于使代码更明显。当某人第一次遇到该变量时，他们对行为的第一次猜测是正确的。选择好名字是第 3 章讨论的投资思维方式的一个示例：如果您花一些额外的时间来选择好名字，那么将来您将更容易处理代码。此外，您不太可能引入错误。培养命名技巧也是一项投资。当您第一次决定停止为平庸的名字定居时，您会发现想出好名字的过程既令人沮丧又耗时。但是，随着您获得更多的经验，您会发现它变得更加容易。最终，您将几乎不需要花费额外的时间来选择好名字，因此您几乎可以免费获得好处。</p>\n</blockquote>\n<p>1<a href=\"https://talks.golang.org/2014/names.slide#1\" target=\"_blank\" rel=\"noopener\">https://talks.golang.org/2014/names.slide#1</a></p>\n","site":{"data":{}},"excerpt":"<p>选择的名字</p>","more":"<h1 id=\"第-14-章-选择的名字\"><a href=\"#第-14-章-选择的名字\" class=\"headerlink\" title=\"第 14 章 选择的名字\"></a>第 14 章 选择的名字</h1><blockquote>\n<p>Chapter 14 Choosing Names</p>\n</blockquote>\n<p>Selecting names for variables, methods, and other entities is one of the most underrated aspects of software design. Good names are a form of documentation: they make code easier to understand. They reduce the need for other documentation and make it easier to detect errors. Conversely, poor name choices increase the complexity of code and create ambiguities and misunderstandings that can result in bugs. Name choice is an example of the principle that complexity is incremental. Choosing a mediocre name for a particular variable, as opposed to the best possible name, probably won’t have much impact on the overall complexity of a system. However, software systems have thousands of variables; choosing good names for all of these will have a significant impact on complexity and manageability.</p>\n<blockquote>\n<p>为变量，方法和其他实体选择名称是软件设计中被低估的方面之一。良好的名字是一种文档形式：它们使代码更易于理解。它们减少了对其他文档的需求，并使检测错误更加容易。相反，名称选择不当会增加代码的复杂性，并造成可能导致错误的歧义和误解。名称选择是复杂度是递增的原理的一个示例。为特定变量选择一个平庸的名称，而不是最好的名称，这可能不会对系统的整体复杂性产生太大影响。但是，软件系统具有数千个变量。为所有这些选择好名字将对复杂性和可管理性产生重大影响。</p>\n</blockquote>\n<h2 id=\"14-1-Example-bad-names-cause-bugs-示例：名称错误会导致错误\"><a href=\"#14-1-Example-bad-names-cause-bugs-示例：名称错误会导致错误\" class=\"headerlink\" title=\"14.1 Example: bad names cause bugs 示例：名称错误会导致错误\"></a>14.1 Example: bad names cause bugs 示例：名称错误会导致错误</h2><p>Sometimes even a single poorly named variable can have severe consequences. The most challenging bug I ever fixed came about because of a poor name choice. In the late 1980’s and early 1990’s my graduate students and I created a distributed operating system called Sprite. At some point we noticed that files would occasionally lose data: one of the data blocks suddenly became all zeroes, even though the file had not been modified by a user. The problem didn’t happen very often, so it was exceptionally difficult to track down. A few of the graduate students tried to find the bug, but they were unable to make progress and eventually gave up. However, I consider any unsolved bug to be an intolerable personal insult, so I decided to track it down.</p>\n<blockquote>\n<p>有时，即使是一个名称不正确的变量也会产生严重的后果。我曾经修复过的最具挑战性的错误是由于名称选择不当造成的。在 1980 年代末和 1990 年代初，我的研究生和我创建了一个名为 Sprite 的分布式操作系统。在某个时候，我们注意到文件偶尔会丢失数据：即使用户未修改文件，数据块之一突然变为全零。该问题并不经常发生，因此很难追踪。一些研究生试图找到该错误，但他们未能取得进展，最终放弃了。但是，我认为任何未解决的错误都是无法忍受的个人侮辱，因此我决定对其进行跟踪。</p>\n</blockquote>\n<p>It took six months, but I eventually found and fixed the bug. The problem was actually quite simple (as are most bugs, once you figure them out). The file system code used the variable name block for two different purposes. In some situations, block referred to a physical block number on disk; in other situations, block referred to a logical block number within a file. Unfortunately, at one point in the code there was a block variable containing a logical block number, but it was accidentally used in a context where a physical block number was needed; as a result, an unrelated block on disk got overwritten with zeroes.</p>\n<blockquote>\n<p>花了六个月的时间，但我最终找到并修复了该错误。这个问题实际上很简单（就像大多数错误一样，一旦找出它们）。文件系统代码将变量名块用于两个不同的目的。在某些情况下，块是指磁盘上的物理块号。在其他情况下，块是指文件中的逻辑块号。不幸的是，在代码的某一点上有一个包含逻辑块号的块变量，但是在需要物理块号的情况下意外地使用了它。结果，磁盘上无关的块被零覆盖。</p>\n</blockquote>\n<p>While tracking down the bug, several people, including myself, read over the faulty code, but we never noticed the problem. When we saw the variable block used as a physical block number, we reflexively assumed that it really held a physical block number. It took a long process of instrumentation, which eventually showed that the corruption must be happening in a particular statement, before I was able to get past the mental block created by the name and check to see exactly where its value came from. If different variable names had been used for the different kinds of blocks, such as fileBlock and diskBlock, it’s unlikely that the error would have happened; the programmer would have known that fileBlock couldn’t be used in that situation.</p>\n<blockquote>\n<p>在跟踪该错误时，包括我自己在内的几个人阅读了错误的代码，但我们从未注意到问题所在。当我们看到可变块用作物理块号时，我们反身地假设它确实拥有物理块号。经过很长时间的检测，最终显示出腐败一定是在特定的语句中发生的，然后我才能越过该名称所创建的思维障碍，并查看其价值的确切来源。如果对不同种类的块（例如 fileBlock 和 diskBlock）使用了不同的变量名，则错误不太可能发生；程序员会知道在那种情况下不能使用 fileBlock。</p>\n</blockquote>\n<p>Unfortunately, most developers don’t spend much time thinking about names. They tend to use the first name that comes to mind, as long as it’s reasonably close to matching the thing it names. For example, block is a pretty close match for both a physical block on disk and a logical block within a file; it’s certainly not a horrible name. Even so, it resulted in a huge expenditure of time to track down a subtle bug. Thus, you shouldn’t settle for names that are just “reasonably close”. Take a bit of extra time to choose great names, which are precise, unambiguous, and intuitive. The extra attention will pay for itself quickly, and over time you’ll learn to choose good names quickly.</p>\n<blockquote>\n<p>不幸的是，大多数开发人员没有花太多时间在思考名字。他们倾向于使用想到的名字，只要它与匹配的名字相当接近即可。例如，块与磁盘上的物理块和文件内的逻辑块非常接近；这肯定不是一个可怕的名字。即使这样，它仍然要花费大量时间来查找一个细微的错误。因此，您不应该只选择“合理接近”的名称。花一些额外的时间来选择准确，明确且直观的好名字。额外的注意力将很快收回成本，随着时间的流逝，您将学会快速选择好名字。</p>\n</blockquote>\n<h2 id=\"14-2-Create-an-image-创建图像\"><a href=\"#14-2-Create-an-image-创建图像\" class=\"headerlink\" title=\"14.2 Create an image 创建图像\"></a>14.2 Create an image 创建图像</h2><p>When choosing a name, the goal is to create an image in the mind of the reader about the nature of the thing being named. A good name conveys a lot of information about what the underlying entity is, and, just as important, what it is not. When considering a particular name, ask yourself: “If someone sees this name in isolation, without seeing its declaration, its documentation, or any code that uses the name, how closely will they be able to guess what the name refers to? Is there some other name that will paint a clearer picture?” Of course, there is a limit to how much information you can put in a single name; names become unwieldy if they contain more than two or three words. Thus, the challenge is to find just a few words that capture the most important aspects of the entity.</p>\n<blockquote>\n<p>选择名称时，目标是在读者的脑海中创建一幅关于被命名事物的性质的图像。一个好名字传达了很多有关底层实体是什么，以及同样重要的是，不是什么的信息。在考虑特定名称时，请问自己：“如果有人孤立地看到该名称，而没有看到其声明，文档或使用该名称的任何代码，他们将能够猜到该名称指的是什么？还有其他名称可以使画面更清晰吗？” 当然，一个名字可以输入多少信息是有限制的。如果名称包含两个或三个以上的单词，则会变得笨拙。因此，面临的挑战是仅找到捕获实体最重要方面的几个单词。</p>\n</blockquote>\n<p>Names are a form of abstraction: they provide a simplified way of thinking about a more complex underlying entity. Like other forms of abstraction, the best names are those that focus attention on what is most important about the underlying entity while omitting details that are less important.</p>\n<blockquote>\n<p>名称是一种抽象形式：名称提供了一种简化的方式来考虑更复杂的基础实体。像其他形式的抽象一样，最好的名字是那些将注意力集中在对底层实体最重要的东西上，而忽略那些次要的细节。</p>\n</blockquote>\n<h2 id=\"14-3-Names-should-be-precise-名称应准确\"><a href=\"#14-3-Names-should-be-precise-名称应准确\" class=\"headerlink\" title=\"14.3 Names should be precise 名称应准确\"></a>14.3 Names should be precise 名称应准确</h2><p>Good names have two properties: precision and consistency. Let’s start with precision. The most common problem with names is that they are too generic or vague; as a result, it’s hard for readers to tell what the name refers to; the reader may assume that the name refers to something different from reality, as in the block bug above. Consider the following method declaration:</p>\n<blockquote>\n<p>良好名称具有两个属性：精度和一致性。让我们从精度开始。名称最常见的问题是名称太笼统或含糊不清。结果，读者很难说出这个名字指的是什么。读者可能会认为该名称所指的是与现实不符的事物，如上面的代码错误所示。考虑以下方法声明：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the total number of indexlets this object is managing.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> IndexletManager::getCount() &#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The term “count” is too generic: count of what? If someone sees an invocation of this method, they are unlikely to know what it does unless they read its documentation. A more precise name like getActiveIndexlets or numIndexlets would be better: with one of these names, readers will probably be able to guess what the method returns without having to look at its documentation.</p>\n<blockquote>\n<p>术语“计数”太笼统了：计数什么？如果有人看到此方法的调用，除非他们阅读了它的文档，否则他们不太可能知道它的作用。像 getActiveIndexlets 或 numIndexlets 这样的更精确的名称会更好：使用这些名称之一，读者可能无需查看其文档就能猜测该方法返回的内容。</p>\n</blockquote>\n<p>Here are some other examples of names that aren’t precise enough, taken from various student projects:</p>\n<blockquote>\n<p>以下是来自其他学生项目的一些名称不够精确的示例：</p>\n</blockquote>\n<ul>\n<li><p>A project building a GUI text editor used the names x and y to refer to the position of a character in the file. These names are too generic. They could mean many things; for example, they might also represent the coordinates (in pixels) of a character on the screen. Someone seeing the name x in isolation is unlikely to think that it refers to the position of a character within a line of text. The code would be clearer if it used names such as charIndex and lineIndex, which reflect the specific abstractions that the code implements.</p>\n<blockquote>\n<p>建立 GUI 文本编辑器的项目使用名称 x 和 y 来引用字符在文件中的位置。这些名称太笼统了。他们可能意味着很多事情；例如，它们也可能代表屏幕上字符的坐标（以像素为单位）。单独看到名称 x 的人不太可能会认为它是指字符在一行文本中的位置。如果使用诸如 charIndex 和 lineIndex 之类的名称来反映代码实现的特定抽象，该代码将更加清晰。</p>\n</blockquote>\n</li>\n<li><p>Another editor project contained the following code:</p>\n<blockquote>\n<p>另一个编辑器项目包含以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Blink state: true when cursor visible.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> blinkStatus = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name blinkStatus doesn’t convey enough information. The word “status” is too vague for a boolean value: it gives no clue about what a true or false value means. The word “blink” is also vague, since it doesn’t indicate what is blinking. The following alternative is better:</p>\n<blockquote>\n<p>名称 blinkStatus 无法传达足够的信息。“状态”一词对于布尔值来说太含糊了：它不提供关于真值或假值含义的任何线索。“闪烁”一词也含糊不清，因为它并不表示闪烁的内容。以下替代方法更好：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Controls cursor blinking: true means the cursor is visible,</span></span><br><span class=\"line\"><span class=\"comment\">// false means the cursor is not displayed.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> cursorVisible = <span class=\"keyword\">true</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name cursorVisible conveys more information; for example, it allows readers to guess what a true value means (as a general rule, names of boolean variables should always be predicates). The word “blink” is no longer in the name, so readers will have to consult the documentation if they want to know why the cursor isn’t always visible; this information is less important.</p>\n<blockquote>\n<p>名称 cursorVisible 传达了更多信息；例如，它允许读者猜测一个真值的含义（通常，布尔变量的名称应始终为谓词）。名称中不再包含“ blink”一词，因此，如果读者想知道为什么光标不总是可见，则必须查阅文档。此信息不太重要。</p>\n</blockquote>\n</li>\n<li><p>A project implementing a consensus protocol contained the following code:</p>\n<blockquote>\n<p>一个实施共识协议的项目包含以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Value representing that the server has not voted (yet) for</span></span><br><span class=\"line\"><span class=\"comment\">// anyone for the current election term.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String VOTED_FOR_SENTINEL_VALUE = <span class=\"string\">\"null\"</span>;</span><br></pre></td></tr></table></figure>\n\n<p>The name for this value indicates that it’s special but it doesn’t say what the special meaning is. A more specific name such as NOT_YET_VOTED would be better.</p>\n<blockquote>\n<p>此值的名称表示它是特殊的，但没有说明特殊含义是什么。使用更具体的名称（例如 NOT_YET_VOTED）会更好。</p>\n</blockquote>\n</li>\n<li><p>A variable named result was used in a method with no return value. This name has multiple problems. First, it creates the misleading impression that it will be the return value of the method. Second, it provides essentially no information about what it actually holds, except that it is some computed value. The name should provide information about what the result actually is, such as mergedLine or totalChars. In methods that do actually have return values, then using the name result is reasonable. This name is still a bit generic, but readers can look at the method documentation to see its meaning, and it’s helpful to know that the value will eventually become the return value.</p>\n<blockquote>\n<p>在没有返回值的方法中使用了名为 result 的变量。这个名字有多个问题。首先，它会产生误导性的印象，即它将作为方法的返回值。其次，除了它是一些计算值外，它实际上不提供有关其实际持有内容的任何信息。该名称应提供有关实际结果是什么的信息，例如 mergedLine 或 totalChars。在实际上确实具有返回值的方法中，使用名称结果是合理的。该名称仍然有点通用，但是读者可以查看方法文档以了解其含义，这有助于知道该值最终将成为返回值。</p>\n</blockquote>\n</li>\n</ul>\n<p>img Red Flag: Vague Name img</p>\n<p>If a variable or method name is broad enough to refer to many different things, then it doesn’t convey much information to the developer and the underlying entity is more likely to be misused.</p>\n<blockquote>\n<p>如果变量或方法的名称足够广泛，可以引用许多不同的事物，那么它不会向开发人员传达太多信息，因此底层实体很可能会被滥用。</p>\n</blockquote>\n<p>Like all rules, the rule about choosing precise names has a few exceptions. For example, it’s fine to use generic names like i and j as loop iteration variables, as long as the loops only span a few lines of code. If you can see the entire range of usage of a variable, then the meaning of the variable will probably be obvious from the code so you don’t need a long name. For example, consider the following code:</p>\n<blockquote>\n<p>像所有规则一样，有关选择精确名称的规则也有一些例外。例如，只要循环仅跨越几行代码，就可以将通用名称（如 i 和 j）用作循环迭代变量。如果您可以看到一个变量的整个用法范围，那么该变量的含义在代码中就很明显了，因此您不需要长名称。例如，考虑以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>  (i = <span class=\"number\">0</span>; i &lt; numLines; i++) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>It’s clear from this code that i is being used to iterate over each of the lines in some entity. If the loop gets so long that you can’t see it all at once, or if the meaning of the iteration variable is harder to figure out from the code, then a more descriptive name is in order.</p>\n<blockquote>\n<p>从这段代码中很明显，我正被用来迭代某个实体中的每一行。如果循环时间太长，以至于您无法一次看到全部内容，或者如果很难从代码中找出迭代变量的含义，那么应该使用更具描述性的名称。</p>\n</blockquote>\n<p>It’s also possible for a name to be too specific, such as in this declaration for a method that deletes a range of text:</p>\n<blockquote>\n<p>名称也可能太具体，例如在此声明中删除一个文本范围的方法：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">delete</span><span class=\"params\">(Range selection)</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The argument name selection is too specific, since it suggests that the text being deleted is always selected in the user interface. However, this method can be invoked on any range of text, selected or not. Thus, the argument name should be more generic, such as range.</p>\n<blockquote>\n<p>参数名称的选择过于具体，因为它建议始终在用户界面中选择要删除的文本。但是，可以在任意范围的文本（无论是否选中）上调用此方法。因此，参数名称应更通用，例如范围。</p>\n</blockquote>\n<p>If you find it difficult to come up with a name for a particular variable that is precise, intuitive, and not too long, this is a red flag. It suggests that the variable may not have a clear definition or purpose. When this happens, consider alternative factorings. For example, perhaps you are trying to use a single variable to represent several things; if so, separating the representation into multiple variables may result in a simpler definition for each variable. The process of choosing good names can improve your design by identifying weaknesses.</p>\n<blockquote>\n<p>如果您发现很难为精确，直观且时间不长的特定变量命名，那么这是一个危险信号。这表明该变量可能没有明确的定义或目的。发生这种情况时，请考虑其他因素。例如，也许您正在尝试使用单个变量来表示几件事；如果是这样，将表示形式分成多个变量可能会导致每个变量的定义更简单。选择好名字的过程可以通过识别弱点来改善您的设计。</p>\n</blockquote>\n<p>img Red Flag: Hard to Pick Name img</p>\n<p>If it’s hard to find a simple name for a variable or method that creates a clear image of the underlying object, that’s a hint that the underlying object may not have a clean design.</p>\n<blockquote>\n<p>如果很难为创建基础对象清晰图像的变量或方法找到简单的名称，则表明基础对象可能没有简洁的设计。</p>\n</blockquote>\n<h2 id=\"14-4-Use-names-consistently-一致使用名称\"><a href=\"#14-4-Use-names-consistently-一致使用名称\" class=\"headerlink\" title=\"14.4 Use names consistently 一致使用名称\"></a>14.4 Use names consistently 一致使用名称</h2><p>The second important property of good names is consistency. In any program there are certain variables that are used over and over again. For example, a file system manipulates block numbers repeatedly. For each of these common usages, pick a name to use for that purpose, and use the same name everywhere. For example, a file system might always use fileBlock to hold the index of a block within a file. Consistent naming reduces cognitive load in much the same way as reusing a common class: once the reader has seen the name in one context, they can reuse their knowledge and instantly make assumptions when they see the name in a different context.</p>\n<blockquote>\n<p>名誉的第二个重要属性是一致性。在任何程序中，都会反复使用某些变量。例如，文件系统反复操作块号。对于每种常见用法，请选择一个用于该目的的名称，并在各处使用相同的名称。例如，文件系统可能总是使用 fileBlock 来保存文件中块的索引。一致的命名方式与重用普通类的方式一样，可以减轻认知负担：一旦读者在一个上下文中看到了该名称，他们就可以重用其知识并在不同上下文中看到该名称时立即做出假设。</p>\n</blockquote>\n<p>Consistency has three requirements: first, always use the common name for the given purpose; second, never use the common name for anything other than the given purpose; third, make sure that the purpose is narrow enough that all variables with the name have the same behavior. This third requirement was violated in the file system bug at the beginning of the chapter. The file system used block for variables with two different behaviors (file blocks and disk blocks); this led to a false assumption about the meaning of a variable, which in turn resulted in a bug.</p>\n<blockquote>\n<p>一致性具有三个要求：首先，始终将通用名称用于给定目的；第二，除了给定目的外，切勿使用通用名称；第三，确保目的足够狭窄，以使所有具有名称的变量都具有相同的行为。在本章开头的文件系统错误中违反了此第三项要求。文件系统使用块来表示具有两种不同行为的变量（文件块和磁盘块）；这导致对变量含义的错误假设，进而导致错误。</p>\n</blockquote>\n<p>Sometimes you will need multiple variables that refer to the same general sort of thing. For example, a method that copies file data will need two block numbers, one for the source and one for the destination. When this happens, use the common name for each variable but add a distinguishing prefix, such as srcFileBlock and dstFileBlock.</p>\n<blockquote>\n<p>有时您将需要多个变量来引用相同的一般事物。例如，一种复制文件数据的方法将需要两个块号，一个为源，一个为目标。发生这种情况时，请对每个变量使用通用名称，但要添加一个可区分的前缀，例如 srcFileBlock 和 dstFileBlock。</p>\n</blockquote>\n<p>Loops are another area where consistent naming can help. If you use names such as i and j for loop variables, always use i in outermost loops and j for nested loops. This allows readers to make instant (safe) assumptions about what’s happening in the code when they see a given name.</p>\n<blockquote>\n<p>循环是一致性命名可以提供帮助的另一个领域。如果将诸如 i 和 j 之类的名称用于循环变量，则始终在最外层循环中使用 i，而在嵌套循环中始终使用 j。这使读者可以在看到给定名称时对代码中发生的事情做出即时（安全）假设。</p>\n</blockquote>\n<h2 id=\"14-5-A-different-opinion-Go-style-guide-不同的意见：转到样式指南\"><a href=\"#14-5-A-different-opinion-Go-style-guide-不同的意见：转到样式指南\" class=\"headerlink\" title=\"14.5 A different opinion: Go style guide 不同的意见：转到样式指南\"></a>14.5 A different opinion: Go style guide 不同的意见：转到样式指南</h2><p>Not everyone shares my views about naming. Some of the developers of the Go language argue that names should be very short, often only a single character. In a presentation on name choice for Go, Andrew Gerrand states that “long names obscure what the code does.”1 He presents this code sample, which uses single-letter variable names:</p>\n<blockquote>\n<p>并非所有人都同意我对命名的看法。一些使用 Go 语言的开发人员认为，名称应该非常简短，通常只能是一个字符。在关于 Go 的名称选择的演示中，Andrew Gerrand 指出“长名称模糊了代码的作用。” 1 他介绍了此代码示例，该示例使用单字母变量名：</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RuneCount</span><span class=\"params\">(b []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    i, n := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i &lt; <span class=\"built_in\">len</span>(b) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> b[i] &lt; RuneSelf &#123;</span><br><span class=\"line\">            i++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _, size := DecodeRune(b[i:])</span><br><span class=\"line\">            i += size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        n++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>and argues that it is more readable than the following version, which uses longer names:</p>\n<blockquote>\n<p>并认为它比以下使用更长名称的版本更具可读性：</p>\n</blockquote>\n<figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">func</span> <span class=\"title\">RuneCount</span><span class=\"params\">(buffer []<span class=\"keyword\">byte</span>)</span> <span class=\"title\">int</span></span> &#123;</span><br><span class=\"line\">    index, count := <span class=\"number\">0</span>, <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> index &lt; <span class=\"built_in\">len</span>(buffer) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> buffer[index] &lt; RuneSelf &#123;</span><br><span class=\"line\">            index++</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            _, size := DecodeRune(buffer[index:])</span><br><span class=\"line\">            index += size</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        count++</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> count</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Personally, I don’t find the second version any more difficult to read than the first. If anything, the name count gives a slightly better clue to the behavior of the variable than n. With the first version I ended up reading through the code trying to figure out what n means, whereas I didn’t feel that need with the second version. But, if n is used consistently throughout the system to refer to counts (and nothing else), then the short name will probably be clear to other developers.</p>\n<blockquote>\n<p>就个人而言，我发现第二版本比第一版本更难阅读。如果有的话，与 n 相比，名称计数为变量的行为提供了更好的线索。在第一个版本中，我最终通读了代码，试图弄清楚 n 的含义，而第二个版本中我并没有这种需要。但是，如果在整个系统中一致地使用 n 来引用计数（而没有其他内容），那么其他开发人员可能会清楚知道该短名称。</p>\n</blockquote>\n<p>The Go culture encourages the use of the same short name for multiple different things: ch for character or channel, d for data, difference, or distance, and so on. To me, ambiguous names like these are likely to result in confusion and error, just as in the block example.</p>\n<blockquote>\n<p>Go 文化鼓励在多个不同的事物上使用相同的短名称：ch 用于字符或通道，d 用于数据，差异或距离，等等。对我来说，像这样的模棱两可的名称很可能导致混乱和错误，就像在示例中一样。</p>\n</blockquote>\n<p>Overall, I would argue that readability must be determined by readers, not writers. If you write code with short variable names and the people who read it find it easy to understand, then that’s fine. If you start getting complaints that your code is cryptic, then you should consider using longer names (a Web search for “go language short names” will identify several such complaints). Similarly, if I start getting complaints that long variable names make my code harder to read, then I’ll consider using shorter ones.</p>\n<blockquote>\n<p>总的来说，我认为可读性必须由读者而不是作家来决定。如果您使用简短的变量名编写代码，并且阅读该代码的人很容易理解，那么很好。如果您开始抱怨代码很含糊，那么您应该考虑使用更长的名称（在网络上搜索“ go language short name”（使用语言简称）会识别出几种此类抱怨）。同样，如果我开始抱怨长变量名使我的代码难以阅读，那么我会考虑使用较短的变量名。</p>\n</blockquote>\n<p>Gerrand makes one comment that I agree with: “The greater the distance between a name’s declaration and its uses, the longer the name should be.” The earlier discussion about using loop variables named i and j is an example of this rule.</p>\n<blockquote>\n<p>Gerrand 发表一个我同意的评论：“名称声明与使用之间的距离越大，名称就应该越长。” 前面有关使用名为 i 和 j 的循环变量的讨论是此规则的示例。</p>\n</blockquote>\n<h2 id=\"14-6-Conclusion-结论\"><a href=\"#14-6-Conclusion-结论\" class=\"headerlink\" title=\"14.6 Conclusion 结论\"></a>14.6 Conclusion 结论</h2><p>Well chosen names help to make code more obvious; when someone encounters the variable for the first time, their first guess about its behavior, made without much thought, will be correct. Choosing good names is an example of the investment mindset discussed in Chapter 3: if you take a little extra time up front to select good names, it will be easier for you to work on the code in the future. In addition, you will be less likely to introduce bugs. Developing a skill for naming is also an investment. When you first decide to stop settling for mediocre names, you may find it frustrating and time-consuming to come up with good names. However, as you get more experience you’ll find that it becomes easier; eventually, you’ll get to the point where it takes almost no extra time to choose good names, so you will get the benefits almost for free.</p>\n<blockquote>\n<p>精心选择的名称有助于使代码更明显。当某人第一次遇到该变量时，他们对行为的第一次猜测是正确的。选择好名字是第 3 章讨论的投资思维方式的一个示例：如果您花一些额外的时间来选择好名字，那么将来您将更容易处理代码。此外，您不太可能引入错误。培养命名技巧也是一项投资。当您第一次决定停止为平庸的名字定居时，您会发现想出好名字的过程既令人沮丧又耗时。但是，随着您获得更多的经验，您会发现它变得更加容易。最终，您将几乎不需要花费额外的时间来选择好名字，因此您几乎可以免费获得好处。</p>\n</blockquote>\n<p>1<a href=\"https://talks.golang.org/2014/names.slide#1\" target=\"_blank\" rel=\"noopener\">https://talks.golang.org/2014/names.slide#1</a></p>"},{"title":"软件设计的哲学 - ch19","date":"2021-02-18T16:00:00.000Z","_content":"软件发展趋势\n<!-- more -->\n# 第 19 章 软件发展趋势\n\n> Chapter 19 Software Trends\n\nAs a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software development over the last few decades. For each trend, I will describe how that trend relates to the principles in this book and use the principles to evaluate whether that trend provides leverage against software complexity.\n\n> 为了说明本书中讨论的原理，本章考虑了过去几十年来在软件开发中流行的几种趋势和模式。对于每种趋势，我将描述该趋势与本书中的原理之间的关系，并使用这些原理来评估该趋势是否提供了针对软件复杂性的杠杆作用。\n\n## 19.1 Object-oriented programming and inheritance 面向对象的编程和继承\n\nObject-oriented programming is one of the most important new ideas in software development over the last 30–40 years. It introduced notions such as classes, inheritance, private methods, and instance variables. If used carefully, these mechanisms can help to produce better software designs. For example, private methods and variables can be used to ensure information hiding: no code outside a class can invoke private methods or access private variables, so there can’t be any external dependencies on them.\n\n> 在过去的 30-40 年中，面向对象编程是软件开发中最重要的新思想之一。它引入了诸如类，继承，私有方法和实例变量之类的概念。如果仔细使用，这些机制可以帮助产生更好的软件设计。例如，私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。\n\nOne of the key elements of object-oriented programming is inheritance. Inheritance comes in two forms, which have different implications for software complexity. The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures, but different subclasses can implement the same methods in different ways. For example, the interface might define methods for performing I/O; one subclass might implement the I/O operations for disk files, and another subclass might implement the same operations for network sockets.\n\n> 面向对象编程的关键要素之一是继承。继承有两种形式，它们对软件复杂性有不同的含义。继承的第一种形式是接口继承，其中父类定义一个或多个方法的签名，但不实现这些方法。每个子类都必须实现签名，但是不同的子类可以以不同的方式实现相同的方法。例如，该接口可能定义用于执行 I/O 的方法。一个子类可能对磁盘文件实现 I/O 操作，而另一个子类可能对网络套接字实现相同的操作。\n\nInterface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving one problem (such as how to use an I/O interface to read and write disk files) to be used to solve other problems (such as communicating over a network socket). Another way of thinking about this is in terms of depth: the more different implementations there are of an interface, the deeper the interface becomes. In order for an interface to have many implementations, it must capture the essential features of all the underlying implementations while steering clear of the details that differ between the implementations; this notion is at the heart of abstraction.\n\n> 接口继承通过出于多种目的重用同一接口，从而提供了针对复杂性的杠杆作用。它使解决一个问题（例如如何使用 I/O 接口读取和写入磁盘文件）中获得的知识可以用于解决其他问题（例如通过网络套接字进行通信）。关于深度的另一种思考方式是：接口的实现越不同，接口就越深入。为了使接口具有许多实现，它必须捕获所有基础实现的基本功能，同时避免实现之间的差异。这个概念是抽象的核心。\n\nThe second form of inheritance is implementation inheritance. In this form, a parent class defines not only signatures for one or more methods, but also default implementations. Subclasses can choose to inherit the parent’s implementation of a method or override it by defining a new method with the same signature. Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copies of the method). Thus, implementation inheritance reduces the amount of code that needs to be modified as the system evolves; in other words, it reduces the change amplification problem described in Chapter 2.\n\n> 继承的第二种形式是实现继承。以这种形式，父类不仅定义了一个或多个方法的签名，而且还定义了默认实现。子类可以选择继承方法的父类实现，也可以通过定义具有相同签名的新方法来覆盖它。如果没有实现继承，则可能需要在几个子类中复制相同的方法实现，这将在这些子类之间创建依赖关系（修改需要在方法的所有副本中复制）。因此，实现继承减少了随着系统的发展而需要修改的代码量。换句话说，它减少了第 2 章中描述的变化放大问题。\n\nHowever, implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in information leakage between the classes in the inheritance hierarchy and makes it hard to modify one class in the hierarchy without looking at the others. For example, a developer making changes to the parent class may need to examine all of the subclasses to ensure that the changes don’t break anything. Similarly, if a subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent. In the worst case, programmers will need complete knowledge of the entire class hierarchy underneath the parent class in order to make changes to any of the classes. Class hierarchies that use implementation inheritance extensively tend to have high complexity.\n\n> 但是，实现继承会在父类及其每个子类之间创建依赖关系。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。\n\nThus, implementation inheritance should be used with caution. Before using implementation inheritance, consider whether an approach based on composition can provide the same benefits. For instance, it may be possible to use small helper classes to implement the shared functionality. Rather than inheriting functions from a parent, the original classes can each build upon the features of the helper classes.\n\n> 因此，应谨慎使用实现继承。在使用实现继承之前，请考虑基于组合的方法是否可以提供相同的好处。例如，可以使用小型帮助程序类来实现共享功能。原始类可以从辅助类的功能构建，而不是从父类继承函数。\n\nIf there is no viable alternative to implementation inheritance, try to separate the state managed by the parent class from that managed by subclasses. One way to do this is for certain instance variables to be managed entirely by methods in the parent class, with subclasses using them only in a read-only fashion or through other methods in the parent class. This applies the notion of information hiding within the class hierarchy to reduce dependencies.\n\n> 如果没有实现继承的可行选择，请尝试将父类管理的状态与子类管理的状态分开。一种方法是，某些实例变量完全由父类中的方法管理，子类仅以只读方式或通过父类中的其他方法使用它们。这适用于隐藏在类层次结构中的信息的概念，以减少依赖性。\n\nAlthough the mechanisms provided by object-oriented programming can assist in implementing clean designs, they do not, by themselves, guarantee good design. For example, if classes are shallow, or have complex interfaces, or permit external access to their internal state, then they will still result in high complexity.\n\n> 尽管面向对象编程提供的机制可以帮助实现干净的设计，但是它们本身不能保证良好的设计。例如，如果类很浅，或者具有复杂的接口，或者允许外部访问其内部状态，那么它们仍将导致很高的复杂性。\n\n## 19.2 Agile development 敏捷开发\n\nAgile development is an approach to software development that emerged in the late 1990’s from a collection of ideas about how to make software development more lightweight, flexible, and incremental; it was formally defined during a meeting of practitioners in 2001. Agile development is mostly about the process of software development (organizing teams, managing schedules, the role of unit testing, interacting with customers, etc.) as opposed to software design. Nonetheless, it relates to some of the design principles in this book.\n\n> 敏捷开发是一种软件开发方法，它是在 1990 年代末期出现的，其思想涉及如何使软件开发更加轻量，灵活和增量。它是在 2001 年的一次从业者会议上正式定义的。敏捷开发主要是关于软件开发的过程（组织团队，管理进度表，单元测试的角色，与客户交互等），而不是软件设计。但是，它与本书中的某些设计原则有关。\n\nOne of the most important elements of agile development is the notion that development should be incremental and iterative. In the agile approach, a software system is developed in a series of iterations, each of which adds and evaluates a few new features; each iteration includes design, test, and customer input. In general, this is similar to the incremental approach advocated here. As mentioned in Chapter 1, it isn’t possible to visualize a complex system well enough at the outset of a project to determine the best design. The best way to end up with a good design is to develop a system in increments, where each increment adds a few new abstractions and refactors existing abstractions based on experience. This is similar to the agile development approach.\n\n> 敏捷开发中最重要的元素之一是开发应该是渐进的和迭代的概念。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。通常，这类似于此处提倡的增量方法。如第 1 章所述，在项目开始时就不可能对复杂的系统进行充分的可视化以决定最佳设计。最终获得良好设计的最佳方法是逐步开发一个系统，其中每个增量都会添加一些新的抽象，并根据经验重构现有的抽象。这类似于敏捷开发方法。\n\nOne of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible. For example, some agile practitioners argue that you shouldn’t implement general-purpose mechanisms right away; implement a minimal special-purpose mechanism to start with, and refactor into something more generic later, once you know that it’s needed. Although these arguments make sense to a degree, they argue against an investment approach, and they encourage a more tactical style of programming. This can result in a rapid accumulation of complexity.\n\n> 敏捷开发的风险之一是它可能导致战术编程。敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。例如，一些敏捷的从业者认为，您不应该立即实施通用机制。实现一个最小的特殊用途机制，从此开始，并在以后知道需要时重构为更通用的东西。尽管这些论点在一定程度上是合理的，但它们反对投资方法，并鼓励采用更具战术性的编程风格。这可以导致复杂性的快速累积。\n\nDeveloping incrementally is generally a good idea, but the increments of development should be abstractions, not features. It’s fine to put off all thoughts about a particular abstraction until it’s needed by a feature. Once you need the abstraction, invest the time to design it cleanly; follow the advice of Chapter 6 and make it somewhat general-purpose.\n\n> 渐进式开发通常是一个好主意，但是渐进式开发应该是抽象的，而不是功能。可以推迟对特定抽象的所有想法，直到功能需要它为止。一旦需要抽象，就要花一些时间进行简洁的设计。遵循第 6 章的建议并使其具有通用性。\n\n## 19.3 Unit tests 单元测试\n\nIt used to be that developers rarely wrote tests. If tests were written at all, they were written by a separate QA team. However, one of the tenets of agile development is that testing should be tightly integrated with development, and programmers should write tests for their own code. This practice has now become widespread. Tests are typically divided into two kinds: unit tests and system tests. Unit tests are the ones most often written by developers. They are small and focused: each test usually validates a small section of code in a single method. Unit tests can be run in isolation, without setting up a production environment for the system. Unit tests are often run in conjunction with a test coverage tool to ensure that every line of code in the application is tested. Whenever developers write new code or modify existing code, they are responsible for updating the unit tests to maintain proper test coverage.\n\n> 过去，开发人员很少编写测试。如果测试是由一个独立的 QA 团队编写的，那么它们就是由一个独立的 QA 团队编写的。然而，敏捷开发的原则之一是测试应该与开发紧密集成，程序员应该为他们自己的代码编写测试。这种做法现在已经很普遍了。测试通常分为两类:单元测试和系统测试。单元测试是开发人员最常编写的测试。它们很小，而且重点突出:每个测试通常在单个方法中验证一小段代码。单元测试可以独立运行，而不需要为系统设置生产环境。单元测试通常与测试覆盖工具一起运行，以确保应用程序中的每一行代码都经过了测试。每当开发人员编写新代码或修改现有代码时，他们都要负责更新单元测试以保持适当的测试覆盖率。\n\nThe second kind of test consists of system tests (sometimes called integration tests), which ensure that the different parts of an application all work together properly. They typically involve running the entire application in a production environment. System tests are more likely to be written by a separate QA or testing team.\n\n> 第二种测试包括系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。系统测试更有可能由独立的质量检查或测试小组编写。\n\nTests, particularly unit tests, play an important role in software design because they facilitate refactoring. Without a test suite, it’s dangerous to make major structural changes to a system. There’s no easy way to find bugs, so it’s likely that bugs will go undetected until the new code is deployed, where they are much more expensive to find and fix. As a result, developers avoid refactoring in systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulates and design mistakes don’t get corrected.\n\n> 测试，尤其是单元测试，在软件设计中起着重要作用，因为它们有助于重构。没有测试套件，对系统进行重大结构更改很危险。没有容易找到错误的方法，因此在部署新代码之前，很可能将无法检测到错误，因为在新代码中查找和修复它们的成本要高得多。结果，开发人员避免在没有良好测试套件的系统中进行重构。他们尝试将每个新功能或错误修复的代码更改次数减至最少，这意味着复杂性会累积，而设计错误不会得到纠正。\n\nWith a good set of tests, developers can be more confident when refactoring because the test suite will find most bugs that are introduced. This encourages developers to make structural improvements to a system, which results in a better design. Unit tests are particularly valuable: they provide a higher degree of code coverage than system tests, so they are more likely to uncover any bugs.\n\n> 有了一套很好的测试，开发人员可以在重构时更有信心，因为测试套件将发现大多数引入的错误。这鼓励开发人员对系统进行结构改进，从而获得更好的设计。单元测试特别有价值：与系统测试相比，它们提供更高的代码覆盖率，因此它们更有可能发现任何错误。\n\nFor example, during the development of the Tcl scripting language, we decided to improve performance by replacing Tcl’s interpreter with a byte-code compiler. This was a huge change that affected almost every part of the core Tcl engine. Fortunately, Tcl had an excellent unit test suite, which we ran on the new byte-code engine. The existing tests were so effective in uncovering bugs in the new engine that only a single bug turned up after the alpha release of the byte-code compiler.\n\n> 例如，在开发 Tcl 脚本语言期间，我们决定通过用字节码编译器替换 Tcl 的解释器来提高性能。这是一个巨大的变化，几乎影响了核心 Tcl 引擎的每个部分。幸运的是，Tcl 有一个出色的单元测试套件，我们在新的字节码引擎上运行了该套件。现有测试在发现新引擎中的错误方面是如此有效，以至于在字节码编译器的 alpha 版本发布之后仅出现了一个错误。\n\n## 19.4 Test-driven development 测试驱动的开发\n\nTest-driven development is an approach to software development where programmers write unit tests before they write code. When creating a new class, the developer first writes unit tests for the class, based on its expected behavior. None of the tests pass, since there is no code for the class. Then the developer works through the tests one at a time, writing enough code for that test to pass. When all of the tests pass, the class is finished.\n\n> 测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。创建新类时，开发人员首先根据其预期行为为该类编写单元测试。没有测试通过，因为该类没有代码。然后，开发人员一次完成一个测试，编写足够的代码以使该测试通过。所有测试通过后，该类结束。\n\nAlthough I am a strong advocate of unit testing, I am not a fan of test-driven development. The problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design. This is tactical programming pure and simple, with all of its disadvantages. Test-driven development is too incremental: at any point in time, it’s tempting to just hack in the next feature to make the next test pass. There’s no obvious time to do design, so it’s easy to end up with a mess.\n\n> 尽管我是单元测试的坚决拥护者，但我不喜欢测试驱动的开发。测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。\n\nAs mentioned in Section 19.2, the units of development should be abstractions, not features. Once you discover the need for an abstraction, don’t create the abstraction in pieces over time; design it all at once (or at least enough to provide a reasonably comprehensive set of core functions). This is more likely to produce a clean design whose pieces fit together well.\n\n> 如第 19.2 节所述，开发单位应该是抽象的，而不是功能。一旦发现需要抽象，就不要随着时间的流逝而逐步创建抽象。一次设计所有功能（或至少足以提供一组合理全面的核心功能）。这样更有可能产生干净的设计，使各个部分很好地契合在一起。\n\nOne place where it makes sense to write the tests first is when fixing bugs. Before fixing a bug, write a unit test that fails because of the bug. Then fix the bug and make sure that the unit test now passes. This is the best way to make sure you really have fixed the bug. If you fix the bug before writing the test, it’s possible that the new unit test doesn’t actually trigger the bug, in which case it won’t tell you whether you really fixed the problem.\n\n> 首先编写测试的地方是修复错误。修复错误之前，请编写由于该错误而失败的单元测试。然后修复该错误，并确保现在可以通过单元测试。这是确保您已真正修复该错误的最佳方法。如果您在编写测试之前就已修复了该错误，则新的单元测试很可能实际上不会触发该错误，在这种情况下，它不会告诉您是否确实修复了该问题。\n\n## 19.5 Design patterns 设计模式\n\nA design pattern is a commonly used approach for solving a particular kind of problem, such as an iterator or an observer. The notion of design patterns was popularized by the book Design Patterns: Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson, and Vlissides, and design patterns are now widely used in object-oriented software development.\n\n> 设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。设计模式的概念在 Gamma，Helm，Johnson 和 Vlissides 的《设计模式：可重用的面向对象软件的元素》一书中得到了普及，现在设计模式已广泛用于面向对象的软件开发中。\n\nDesign patterns represent an alternative to design: rather than designing a new mechanism from scratch, just apply a well-known design pattern. For the most part, this is good: design patterns arose because they solve common problems, and because they are generally agreed to provide clean solutions. If a design pattern works well in a particular situation, it will probably be hard for you to come up with a different approach that is better.\n\n> 设计模式代表了设计的替代方法：与其从头设计新的机制，不如应用一种众所周知的设计模式。在大多数情况下，这是件好事：出现设计模式是因为它们解决了常见的问题，并且因为它们被普遍同意提供干净的解决方案。如果设计模式在特定情况下运作良好，那么您可能很难想出另一种更好的方法。\n\nThe greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don’t try to force a problem into a design pattern when a custom approach will be cleaner. Using design patterns doesn’t automatically improve a software system; it only does so if the design patterns fit. As with many ideas in software design, the notion that design patterns are good doesn’t necessarily mean that more design patterns are better.\n\n> 设计模式的最大风险是过度使用。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。使用设计模式并不能自动改善软件系统。只有在设计模式合适的情况下才这样做。与软件设计中的许多想法一样，设计模式良好的概念并不一定意味着更多的设计模式会更好。\n\n## 19.6 Getters and setters Getter 和 Setters\n\nIn the Java programming community, getter and setter methods are a popular design pattern. A getter and a setter are associated with an instance variable for a class. They have names like getFoo and setFoo, where Foo is the name of the variable. The getter method returns the current value of the variable, and the setter method modifies the value.\n\n> 在 Java 编程社区中，getter 和 setter 方法是一种流行的设计模式。一个 getter 和一个 setter 与一个类的实例变量相关联。它们具有类似 getFoo 和 setFoo 的名称，其中 Foo 是变量的名称。getter 方法返回变量的当前值，setter 方法修改该值。\n\nGetters and setters aren’t strictly necessary, since instance variables can be made public. The argument for getters and setters is that they allow additional functions to be performed while getting and setting, such as updating related values when a variable changes, notifying listeners of changes, or enforcing constraints on values. Even if these features aren’t needed initially, they can be added later without changing the interface.\n\n> 由于实例变量可以公开，因此不一定必须使用 getter 和 setter 方法。getter 和 setter 的论点是，它们允许在获取和设置时执行其他功能，例如在变量更改时更新相关值，通知更改的侦听器或对值实施约束。即使最初不需要这些功能，也可以稍后添加它们而无需更改界面。\n\nAlthough it may make sense to use getters and setters if you must expose instance variables, it’s better not to expose instance variables in the first place. Exposed instance variables mean that part of the class’s implementation is visible externally, which violates the idea of information hiding and increases the complexity of the class’s interface. Getters and setters are shallow methods (typically only a single line), so they add clutter to the class’s interface without providing much functionality. It’s better to avoid getters and setters (or any exposure of implementation data) as much as possible.\n\n> 尽管如果必须公开实例变量，则可以使用 getter 和 setter 方法，但最好不要首先公开实例变量。暴露的实例变量意味着类的实现的一部分在外部是可见的，这违反了信息隐藏的思想，并增加了类接口的复杂性。Getter 和 Setter 是浅层方法（通常只有一行），因此它们在不提供太多功能的情况下为类的接口增加了混乱。最好避免使用 getter 和 setter（或任何暴露的实现数据）。\n\nOne of the risks of establishing a design pattern is that developers assume the pattern is good and try to use it as much as possible. This has led to overusage of getters and setters in Java.\n\n> 建立设计模式的风险之一是，开发人员认为该模式是好的，并尝试尽可能多地使用它。这导致 Java 中的 getter 和 setter 的过度使用。\n\n## 19.7 Conclusion 结论\n\nWhenever you encounter a proposal for a new software development paradigm, challenge it from the standpoint of complexity: does the proposal really help to minimize complexity in large software systems? Many proposals sound good on the surface, but if you look more deeply you will see that some of them make complexity worse, not better.\n\n> 每当您遇到有关新软件开发范例的提案时，就必须从复杂性的角度对其进行挑战：该提案确实有助于最大程度地降低大型软件系统的复杂性吗？从表面上看，许多建议听起来不错，但是如果您深入研究，您会发现其中一些会使复杂性恶化，而不是更好。\n","source":"_posts/软件设计的哲学-ch19.md","raw":"---\ntitle: 软件设计的哲学 - ch19\ndate: 2021-02-19\ntags: 软件设计的哲学 软件开发 方法论\n---\n软件发展趋势\n<!-- more -->\n# 第 19 章 软件发展趋势\n\n> Chapter 19 Software Trends\n\nAs a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software development over the last few decades. For each trend, I will describe how that trend relates to the principles in this book and use the principles to evaluate whether that trend provides leverage against software complexity.\n\n> 为了说明本书中讨论的原理，本章考虑了过去几十年来在软件开发中流行的几种趋势和模式。对于每种趋势，我将描述该趋势与本书中的原理之间的关系，并使用这些原理来评估该趋势是否提供了针对软件复杂性的杠杆作用。\n\n## 19.1 Object-oriented programming and inheritance 面向对象的编程和继承\n\nObject-oriented programming is one of the most important new ideas in software development over the last 30–40 years. It introduced notions such as classes, inheritance, private methods, and instance variables. If used carefully, these mechanisms can help to produce better software designs. For example, private methods and variables can be used to ensure information hiding: no code outside a class can invoke private methods or access private variables, so there can’t be any external dependencies on them.\n\n> 在过去的 30-40 年中，面向对象编程是软件开发中最重要的新思想之一。它引入了诸如类，继承，私有方法和实例变量之类的概念。如果仔细使用，这些机制可以帮助产生更好的软件设计。例如，私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。\n\nOne of the key elements of object-oriented programming is inheritance. Inheritance comes in two forms, which have different implications for software complexity. The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures, but different subclasses can implement the same methods in different ways. For example, the interface might define methods for performing I/O; one subclass might implement the I/O operations for disk files, and another subclass might implement the same operations for network sockets.\n\n> 面向对象编程的关键要素之一是继承。继承有两种形式，它们对软件复杂性有不同的含义。继承的第一种形式是接口继承，其中父类定义一个或多个方法的签名，但不实现这些方法。每个子类都必须实现签名，但是不同的子类可以以不同的方式实现相同的方法。例如，该接口可能定义用于执行 I/O 的方法。一个子类可能对磁盘文件实现 I/O 操作，而另一个子类可能对网络套接字实现相同的操作。\n\nInterface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving one problem (such as how to use an I/O interface to read and write disk files) to be used to solve other problems (such as communicating over a network socket). Another way of thinking about this is in terms of depth: the more different implementations there are of an interface, the deeper the interface becomes. In order for an interface to have many implementations, it must capture the essential features of all the underlying implementations while steering clear of the details that differ between the implementations; this notion is at the heart of abstraction.\n\n> 接口继承通过出于多种目的重用同一接口，从而提供了针对复杂性的杠杆作用。它使解决一个问题（例如如何使用 I/O 接口读取和写入磁盘文件）中获得的知识可以用于解决其他问题（例如通过网络套接字进行通信）。关于深度的另一种思考方式是：接口的实现越不同，接口就越深入。为了使接口具有许多实现，它必须捕获所有基础实现的基本功能，同时避免实现之间的差异。这个概念是抽象的核心。\n\nThe second form of inheritance is implementation inheritance. In this form, a parent class defines not only signatures for one or more methods, but also default implementations. Subclasses can choose to inherit the parent’s implementation of a method or override it by defining a new method with the same signature. Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copies of the method). Thus, implementation inheritance reduces the amount of code that needs to be modified as the system evolves; in other words, it reduces the change amplification problem described in Chapter 2.\n\n> 继承的第二种形式是实现继承。以这种形式，父类不仅定义了一个或多个方法的签名，而且还定义了默认实现。子类可以选择继承方法的父类实现，也可以通过定义具有相同签名的新方法来覆盖它。如果没有实现继承，则可能需要在几个子类中复制相同的方法实现，这将在这些子类之间创建依赖关系（修改需要在方法的所有副本中复制）。因此，实现继承减少了随着系统的发展而需要修改的代码量。换句话说，它减少了第 2 章中描述的变化放大问题。\n\nHowever, implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in information leakage between the classes in the inheritance hierarchy and makes it hard to modify one class in the hierarchy without looking at the others. For example, a developer making changes to the parent class may need to examine all of the subclasses to ensure that the changes don’t break anything. Similarly, if a subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent. In the worst case, programmers will need complete knowledge of the entire class hierarchy underneath the parent class in order to make changes to any of the classes. Class hierarchies that use implementation inheritance extensively tend to have high complexity.\n\n> 但是，实现继承会在父类及其每个子类之间创建依赖关系。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。\n\nThus, implementation inheritance should be used with caution. Before using implementation inheritance, consider whether an approach based on composition can provide the same benefits. For instance, it may be possible to use small helper classes to implement the shared functionality. Rather than inheriting functions from a parent, the original classes can each build upon the features of the helper classes.\n\n> 因此，应谨慎使用实现继承。在使用实现继承之前，请考虑基于组合的方法是否可以提供相同的好处。例如，可以使用小型帮助程序类来实现共享功能。原始类可以从辅助类的功能构建，而不是从父类继承函数。\n\nIf there is no viable alternative to implementation inheritance, try to separate the state managed by the parent class from that managed by subclasses. One way to do this is for certain instance variables to be managed entirely by methods in the parent class, with subclasses using them only in a read-only fashion or through other methods in the parent class. This applies the notion of information hiding within the class hierarchy to reduce dependencies.\n\n> 如果没有实现继承的可行选择，请尝试将父类管理的状态与子类管理的状态分开。一种方法是，某些实例变量完全由父类中的方法管理，子类仅以只读方式或通过父类中的其他方法使用它们。这适用于隐藏在类层次结构中的信息的概念，以减少依赖性。\n\nAlthough the mechanisms provided by object-oriented programming can assist in implementing clean designs, they do not, by themselves, guarantee good design. For example, if classes are shallow, or have complex interfaces, or permit external access to their internal state, then they will still result in high complexity.\n\n> 尽管面向对象编程提供的机制可以帮助实现干净的设计，但是它们本身不能保证良好的设计。例如，如果类很浅，或者具有复杂的接口，或者允许外部访问其内部状态，那么它们仍将导致很高的复杂性。\n\n## 19.2 Agile development 敏捷开发\n\nAgile development is an approach to software development that emerged in the late 1990’s from a collection of ideas about how to make software development more lightweight, flexible, and incremental; it was formally defined during a meeting of practitioners in 2001. Agile development is mostly about the process of software development (organizing teams, managing schedules, the role of unit testing, interacting with customers, etc.) as opposed to software design. Nonetheless, it relates to some of the design principles in this book.\n\n> 敏捷开发是一种软件开发方法，它是在 1990 年代末期出现的，其思想涉及如何使软件开发更加轻量，灵活和增量。它是在 2001 年的一次从业者会议上正式定义的。敏捷开发主要是关于软件开发的过程（组织团队，管理进度表，单元测试的角色，与客户交互等），而不是软件设计。但是，它与本书中的某些设计原则有关。\n\nOne of the most important elements of agile development is the notion that development should be incremental and iterative. In the agile approach, a software system is developed in a series of iterations, each of which adds and evaluates a few new features; each iteration includes design, test, and customer input. In general, this is similar to the incremental approach advocated here. As mentioned in Chapter 1, it isn’t possible to visualize a complex system well enough at the outset of a project to determine the best design. The best way to end up with a good design is to develop a system in increments, where each increment adds a few new abstractions and refactors existing abstractions based on experience. This is similar to the agile development approach.\n\n> 敏捷开发中最重要的元素之一是开发应该是渐进的和迭代的概念。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。通常，这类似于此处提倡的增量方法。如第 1 章所述，在项目开始时就不可能对复杂的系统进行充分的可视化以决定最佳设计。最终获得良好设计的最佳方法是逐步开发一个系统，其中每个增量都会添加一些新的抽象，并根据经验重构现有的抽象。这类似于敏捷开发方法。\n\nOne of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible. For example, some agile practitioners argue that you shouldn’t implement general-purpose mechanisms right away; implement a minimal special-purpose mechanism to start with, and refactor into something more generic later, once you know that it’s needed. Although these arguments make sense to a degree, they argue against an investment approach, and they encourage a more tactical style of programming. This can result in a rapid accumulation of complexity.\n\n> 敏捷开发的风险之一是它可能导致战术编程。敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。例如，一些敏捷的从业者认为，您不应该立即实施通用机制。实现一个最小的特殊用途机制，从此开始，并在以后知道需要时重构为更通用的东西。尽管这些论点在一定程度上是合理的，但它们反对投资方法，并鼓励采用更具战术性的编程风格。这可以导致复杂性的快速累积。\n\nDeveloping incrementally is generally a good idea, but the increments of development should be abstractions, not features. It’s fine to put off all thoughts about a particular abstraction until it’s needed by a feature. Once you need the abstraction, invest the time to design it cleanly; follow the advice of Chapter 6 and make it somewhat general-purpose.\n\n> 渐进式开发通常是一个好主意，但是渐进式开发应该是抽象的，而不是功能。可以推迟对特定抽象的所有想法，直到功能需要它为止。一旦需要抽象，就要花一些时间进行简洁的设计。遵循第 6 章的建议并使其具有通用性。\n\n## 19.3 Unit tests 单元测试\n\nIt used to be that developers rarely wrote tests. If tests were written at all, they were written by a separate QA team. However, one of the tenets of agile development is that testing should be tightly integrated with development, and programmers should write tests for their own code. This practice has now become widespread. Tests are typically divided into two kinds: unit tests and system tests. Unit tests are the ones most often written by developers. They are small and focused: each test usually validates a small section of code in a single method. Unit tests can be run in isolation, without setting up a production environment for the system. Unit tests are often run in conjunction with a test coverage tool to ensure that every line of code in the application is tested. Whenever developers write new code or modify existing code, they are responsible for updating the unit tests to maintain proper test coverage.\n\n> 过去，开发人员很少编写测试。如果测试是由一个独立的 QA 团队编写的，那么它们就是由一个独立的 QA 团队编写的。然而，敏捷开发的原则之一是测试应该与开发紧密集成，程序员应该为他们自己的代码编写测试。这种做法现在已经很普遍了。测试通常分为两类:单元测试和系统测试。单元测试是开发人员最常编写的测试。它们很小，而且重点突出:每个测试通常在单个方法中验证一小段代码。单元测试可以独立运行，而不需要为系统设置生产环境。单元测试通常与测试覆盖工具一起运行，以确保应用程序中的每一行代码都经过了测试。每当开发人员编写新代码或修改现有代码时，他们都要负责更新单元测试以保持适当的测试覆盖率。\n\nThe second kind of test consists of system tests (sometimes called integration tests), which ensure that the different parts of an application all work together properly. They typically involve running the entire application in a production environment. System tests are more likely to be written by a separate QA or testing team.\n\n> 第二种测试包括系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。系统测试更有可能由独立的质量检查或测试小组编写。\n\nTests, particularly unit tests, play an important role in software design because they facilitate refactoring. Without a test suite, it’s dangerous to make major structural changes to a system. There’s no easy way to find bugs, so it’s likely that bugs will go undetected until the new code is deployed, where they are much more expensive to find and fix. As a result, developers avoid refactoring in systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulates and design mistakes don’t get corrected.\n\n> 测试，尤其是单元测试，在软件设计中起着重要作用，因为它们有助于重构。没有测试套件，对系统进行重大结构更改很危险。没有容易找到错误的方法，因此在部署新代码之前，很可能将无法检测到错误，因为在新代码中查找和修复它们的成本要高得多。结果，开发人员避免在没有良好测试套件的系统中进行重构。他们尝试将每个新功能或错误修复的代码更改次数减至最少，这意味着复杂性会累积，而设计错误不会得到纠正。\n\nWith a good set of tests, developers can be more confident when refactoring because the test suite will find most bugs that are introduced. This encourages developers to make structural improvements to a system, which results in a better design. Unit tests are particularly valuable: they provide a higher degree of code coverage than system tests, so they are more likely to uncover any bugs.\n\n> 有了一套很好的测试，开发人员可以在重构时更有信心，因为测试套件将发现大多数引入的错误。这鼓励开发人员对系统进行结构改进，从而获得更好的设计。单元测试特别有价值：与系统测试相比，它们提供更高的代码覆盖率，因此它们更有可能发现任何错误。\n\nFor example, during the development of the Tcl scripting language, we decided to improve performance by replacing Tcl’s interpreter with a byte-code compiler. This was a huge change that affected almost every part of the core Tcl engine. Fortunately, Tcl had an excellent unit test suite, which we ran on the new byte-code engine. The existing tests were so effective in uncovering bugs in the new engine that only a single bug turned up after the alpha release of the byte-code compiler.\n\n> 例如，在开发 Tcl 脚本语言期间，我们决定通过用字节码编译器替换 Tcl 的解释器来提高性能。这是一个巨大的变化，几乎影响了核心 Tcl 引擎的每个部分。幸运的是，Tcl 有一个出色的单元测试套件，我们在新的字节码引擎上运行了该套件。现有测试在发现新引擎中的错误方面是如此有效，以至于在字节码编译器的 alpha 版本发布之后仅出现了一个错误。\n\n## 19.4 Test-driven development 测试驱动的开发\n\nTest-driven development is an approach to software development where programmers write unit tests before they write code. When creating a new class, the developer first writes unit tests for the class, based on its expected behavior. None of the tests pass, since there is no code for the class. Then the developer works through the tests one at a time, writing enough code for that test to pass. When all of the tests pass, the class is finished.\n\n> 测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。创建新类时，开发人员首先根据其预期行为为该类编写单元测试。没有测试通过，因为该类没有代码。然后，开发人员一次完成一个测试，编写足够的代码以使该测试通过。所有测试通过后，该类结束。\n\nAlthough I am a strong advocate of unit testing, I am not a fan of test-driven development. The problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design. This is tactical programming pure and simple, with all of its disadvantages. Test-driven development is too incremental: at any point in time, it’s tempting to just hack in the next feature to make the next test pass. There’s no obvious time to do design, so it’s easy to end up with a mess.\n\n> 尽管我是单元测试的坚决拥护者，但我不喜欢测试驱动的开发。测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。\n\nAs mentioned in Section 19.2, the units of development should be abstractions, not features. Once you discover the need for an abstraction, don’t create the abstraction in pieces over time; design it all at once (or at least enough to provide a reasonably comprehensive set of core functions). This is more likely to produce a clean design whose pieces fit together well.\n\n> 如第 19.2 节所述，开发单位应该是抽象的，而不是功能。一旦发现需要抽象，就不要随着时间的流逝而逐步创建抽象。一次设计所有功能（或至少足以提供一组合理全面的核心功能）。这样更有可能产生干净的设计，使各个部分很好地契合在一起。\n\nOne place where it makes sense to write the tests first is when fixing bugs. Before fixing a bug, write a unit test that fails because of the bug. Then fix the bug and make sure that the unit test now passes. This is the best way to make sure you really have fixed the bug. If you fix the bug before writing the test, it’s possible that the new unit test doesn’t actually trigger the bug, in which case it won’t tell you whether you really fixed the problem.\n\n> 首先编写测试的地方是修复错误。修复错误之前，请编写由于该错误而失败的单元测试。然后修复该错误，并确保现在可以通过单元测试。这是确保您已真正修复该错误的最佳方法。如果您在编写测试之前就已修复了该错误，则新的单元测试很可能实际上不会触发该错误，在这种情况下，它不会告诉您是否确实修复了该问题。\n\n## 19.5 Design patterns 设计模式\n\nA design pattern is a commonly used approach for solving a particular kind of problem, such as an iterator or an observer. The notion of design patterns was popularized by the book Design Patterns: Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson, and Vlissides, and design patterns are now widely used in object-oriented software development.\n\n> 设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。设计模式的概念在 Gamma，Helm，Johnson 和 Vlissides 的《设计模式：可重用的面向对象软件的元素》一书中得到了普及，现在设计模式已广泛用于面向对象的软件开发中。\n\nDesign patterns represent an alternative to design: rather than designing a new mechanism from scratch, just apply a well-known design pattern. For the most part, this is good: design patterns arose because they solve common problems, and because they are generally agreed to provide clean solutions. If a design pattern works well in a particular situation, it will probably be hard for you to come up with a different approach that is better.\n\n> 设计模式代表了设计的替代方法：与其从头设计新的机制，不如应用一种众所周知的设计模式。在大多数情况下，这是件好事：出现设计模式是因为它们解决了常见的问题，并且因为它们被普遍同意提供干净的解决方案。如果设计模式在特定情况下运作良好，那么您可能很难想出另一种更好的方法。\n\nThe greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don’t try to force a problem into a design pattern when a custom approach will be cleaner. Using design patterns doesn’t automatically improve a software system; it only does so if the design patterns fit. As with many ideas in software design, the notion that design patterns are good doesn’t necessarily mean that more design patterns are better.\n\n> 设计模式的最大风险是过度使用。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。使用设计模式并不能自动改善软件系统。只有在设计模式合适的情况下才这样做。与软件设计中的许多想法一样，设计模式良好的概念并不一定意味着更多的设计模式会更好。\n\n## 19.6 Getters and setters Getter 和 Setters\n\nIn the Java programming community, getter and setter methods are a popular design pattern. A getter and a setter are associated with an instance variable for a class. They have names like getFoo and setFoo, where Foo is the name of the variable. The getter method returns the current value of the variable, and the setter method modifies the value.\n\n> 在 Java 编程社区中，getter 和 setter 方法是一种流行的设计模式。一个 getter 和一个 setter 与一个类的实例变量相关联。它们具有类似 getFoo 和 setFoo 的名称，其中 Foo 是变量的名称。getter 方法返回变量的当前值，setter 方法修改该值。\n\nGetters and setters aren’t strictly necessary, since instance variables can be made public. The argument for getters and setters is that they allow additional functions to be performed while getting and setting, such as updating related values when a variable changes, notifying listeners of changes, or enforcing constraints on values. Even if these features aren’t needed initially, they can be added later without changing the interface.\n\n> 由于实例变量可以公开，因此不一定必须使用 getter 和 setter 方法。getter 和 setter 的论点是，它们允许在获取和设置时执行其他功能，例如在变量更改时更新相关值，通知更改的侦听器或对值实施约束。即使最初不需要这些功能，也可以稍后添加它们而无需更改界面。\n\nAlthough it may make sense to use getters and setters if you must expose instance variables, it’s better not to expose instance variables in the first place. Exposed instance variables mean that part of the class’s implementation is visible externally, which violates the idea of information hiding and increases the complexity of the class’s interface. Getters and setters are shallow methods (typically only a single line), so they add clutter to the class’s interface without providing much functionality. It’s better to avoid getters and setters (or any exposure of implementation data) as much as possible.\n\n> 尽管如果必须公开实例变量，则可以使用 getter 和 setter 方法，但最好不要首先公开实例变量。暴露的实例变量意味着类的实现的一部分在外部是可见的，这违反了信息隐藏的思想，并增加了类接口的复杂性。Getter 和 Setter 是浅层方法（通常只有一行），因此它们在不提供太多功能的情况下为类的接口增加了混乱。最好避免使用 getter 和 setter（或任何暴露的实现数据）。\n\nOne of the risks of establishing a design pattern is that developers assume the pattern is good and try to use it as much as possible. This has led to overusage of getters and setters in Java.\n\n> 建立设计模式的风险之一是，开发人员认为该模式是好的，并尝试尽可能多地使用它。这导致 Java 中的 getter 和 setter 的过度使用。\n\n## 19.7 Conclusion 结论\n\nWhenever you encounter a proposal for a new software development paradigm, challenge it from the standpoint of complexity: does the proposal really help to minimize complexity in large software systems? Many proposals sound good on the surface, but if you look more deeply you will see that some of them make complexity worse, not better.\n\n> 每当您遇到有关新软件开发范例的提案时，就必须从复杂性的角度对其进行挑战：该提案确实有助于最大程度地降低大型软件系统的复杂性吗？从表面上看，许多建议听起来不错，但是如果您深入研究，您会发现其中一些会使复杂性恶化，而不是更好。\n","slug":"软件设计的哲学-ch19","published":1,"updated":"2021-02-16T04:53:00.728Z","_id":"ckl6pcc3m000hs4iy32w8hydn","comments":1,"layout":"post","photos":[],"link":"","content":"<p>软件发展趋势</p>\n<a id=\"more\"></a>\n<h1 id=\"第-19-章-软件发展趋势\"><a href=\"#第-19-章-软件发展趋势\" class=\"headerlink\" title=\"第 19 章 软件发展趋势\"></a>第 19 章 软件发展趋势</h1><blockquote>\n<p>Chapter 19 Software Trends</p>\n</blockquote>\n<p>As a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software development over the last few decades. For each trend, I will describe how that trend relates to the principles in this book and use the principles to evaluate whether that trend provides leverage against software complexity.</p>\n<blockquote>\n<p>为了说明本书中讨论的原理，本章考虑了过去几十年来在软件开发中流行的几种趋势和模式。对于每种趋势，我将描述该趋势与本书中的原理之间的关系，并使用这些原理来评估该趋势是否提供了针对软件复杂性的杠杆作用。</p>\n</blockquote>\n<h2 id=\"19-1-Object-oriented-programming-and-inheritance-面向对象的编程和继承\"><a href=\"#19-1-Object-oriented-programming-and-inheritance-面向对象的编程和继承\" class=\"headerlink\" title=\"19.1 Object-oriented programming and inheritance 面向对象的编程和继承\"></a>19.1 Object-oriented programming and inheritance 面向对象的编程和继承</h2><p>Object-oriented programming is one of the most important new ideas in software development over the last 30–40 years. It introduced notions such as classes, inheritance, private methods, and instance variables. If used carefully, these mechanisms can help to produce better software designs. For example, private methods and variables can be used to ensure information hiding: no code outside a class can invoke private methods or access private variables, so there can’t be any external dependencies on them.</p>\n<blockquote>\n<p>在过去的 30-40 年中，面向对象编程是软件开发中最重要的新思想之一。它引入了诸如类，继承，私有方法和实例变量之类的概念。如果仔细使用，这些机制可以帮助产生更好的软件设计。例如，私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。</p>\n</blockquote>\n<p>One of the key elements of object-oriented programming is inheritance. Inheritance comes in two forms, which have different implications for software complexity. The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures, but different subclasses can implement the same methods in different ways. For example, the interface might define methods for performing I/O; one subclass might implement the I/O operations for disk files, and another subclass might implement the same operations for network sockets.</p>\n<blockquote>\n<p>面向对象编程的关键要素之一是继承。继承有两种形式，它们对软件复杂性有不同的含义。继承的第一种形式是接口继承，其中父类定义一个或多个方法的签名，但不实现这些方法。每个子类都必须实现签名，但是不同的子类可以以不同的方式实现相同的方法。例如，该接口可能定义用于执行 I/O 的方法。一个子类可能对磁盘文件实现 I/O 操作，而另一个子类可能对网络套接字实现相同的操作。</p>\n</blockquote>\n<p>Interface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving one problem (such as how to use an I/O interface to read and write disk files) to be used to solve other problems (such as communicating over a network socket). Another way of thinking about this is in terms of depth: the more different implementations there are of an interface, the deeper the interface becomes. In order for an interface to have many implementations, it must capture the essential features of all the underlying implementations while steering clear of the details that differ between the implementations; this notion is at the heart of abstraction.</p>\n<blockquote>\n<p>接口继承通过出于多种目的重用同一接口，从而提供了针对复杂性的杠杆作用。它使解决一个问题（例如如何使用 I/O 接口读取和写入磁盘文件）中获得的知识可以用于解决其他问题（例如通过网络套接字进行通信）。关于深度的另一种思考方式是：接口的实现越不同，接口就越深入。为了使接口具有许多实现，它必须捕获所有基础实现的基本功能，同时避免实现之间的差异。这个概念是抽象的核心。</p>\n</blockquote>\n<p>The second form of inheritance is implementation inheritance. In this form, a parent class defines not only signatures for one or more methods, but also default implementations. Subclasses can choose to inherit the parent’s implementation of a method or override it by defining a new method with the same signature. Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copies of the method). Thus, implementation inheritance reduces the amount of code that needs to be modified as the system evolves; in other words, it reduces the change amplification problem described in Chapter 2.</p>\n<blockquote>\n<p>继承的第二种形式是实现继承。以这种形式，父类不仅定义了一个或多个方法的签名，而且还定义了默认实现。子类可以选择继承方法的父类实现，也可以通过定义具有相同签名的新方法来覆盖它。如果没有实现继承，则可能需要在几个子类中复制相同的方法实现，这将在这些子类之间创建依赖关系（修改需要在方法的所有副本中复制）。因此，实现继承减少了随着系统的发展而需要修改的代码量。换句话说，它减少了第 2 章中描述的变化放大问题。</p>\n</blockquote>\n<p>However, implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in information leakage between the classes in the inheritance hierarchy and makes it hard to modify one class in the hierarchy without looking at the others. For example, a developer making changes to the parent class may need to examine all of the subclasses to ensure that the changes don’t break anything. Similarly, if a subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent. In the worst case, programmers will need complete knowledge of the entire class hierarchy underneath the parent class in order to make changes to any of the classes. Class hierarchies that use implementation inheritance extensively tend to have high complexity.</p>\n<blockquote>\n<p>但是，实现继承会在父类及其每个子类之间创建依赖关系。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。</p>\n</blockquote>\n<p>Thus, implementation inheritance should be used with caution. Before using implementation inheritance, consider whether an approach based on composition can provide the same benefits. For instance, it may be possible to use small helper classes to implement the shared functionality. Rather than inheriting functions from a parent, the original classes can each build upon the features of the helper classes.</p>\n<blockquote>\n<p>因此，应谨慎使用实现继承。在使用实现继承之前，请考虑基于组合的方法是否可以提供相同的好处。例如，可以使用小型帮助程序类来实现共享功能。原始类可以从辅助类的功能构建，而不是从父类继承函数。</p>\n</blockquote>\n<p>If there is no viable alternative to implementation inheritance, try to separate the state managed by the parent class from that managed by subclasses. One way to do this is for certain instance variables to be managed entirely by methods in the parent class, with subclasses using them only in a read-only fashion or through other methods in the parent class. This applies the notion of information hiding within the class hierarchy to reduce dependencies.</p>\n<blockquote>\n<p>如果没有实现继承的可行选择，请尝试将父类管理的状态与子类管理的状态分开。一种方法是，某些实例变量完全由父类中的方法管理，子类仅以只读方式或通过父类中的其他方法使用它们。这适用于隐藏在类层次结构中的信息的概念，以减少依赖性。</p>\n</blockquote>\n<p>Although the mechanisms provided by object-oriented programming can assist in implementing clean designs, they do not, by themselves, guarantee good design. For example, if classes are shallow, or have complex interfaces, or permit external access to their internal state, then they will still result in high complexity.</p>\n<blockquote>\n<p>尽管面向对象编程提供的机制可以帮助实现干净的设计，但是它们本身不能保证良好的设计。例如，如果类很浅，或者具有复杂的接口，或者允许外部访问其内部状态，那么它们仍将导致很高的复杂性。</p>\n</blockquote>\n<h2 id=\"19-2-Agile-development-敏捷开发\"><a href=\"#19-2-Agile-development-敏捷开发\" class=\"headerlink\" title=\"19.2 Agile development 敏捷开发\"></a>19.2 Agile development 敏捷开发</h2><p>Agile development is an approach to software development that emerged in the late 1990’s from a collection of ideas about how to make software development more lightweight, flexible, and incremental; it was formally defined during a meeting of practitioners in 2001. Agile development is mostly about the process of software development (organizing teams, managing schedules, the role of unit testing, interacting with customers, etc.) as opposed to software design. Nonetheless, it relates to some of the design principles in this book.</p>\n<blockquote>\n<p>敏捷开发是一种软件开发方法，它是在 1990 年代末期出现的，其思想涉及如何使软件开发更加轻量，灵活和增量。它是在 2001 年的一次从业者会议上正式定义的。敏捷开发主要是关于软件开发的过程（组织团队，管理进度表，单元测试的角色，与客户交互等），而不是软件设计。但是，它与本书中的某些设计原则有关。</p>\n</blockquote>\n<p>One of the most important elements of agile development is the notion that development should be incremental and iterative. In the agile approach, a software system is developed in a series of iterations, each of which adds and evaluates a few new features; each iteration includes design, test, and customer input. In general, this is similar to the incremental approach advocated here. As mentioned in Chapter 1, it isn’t possible to visualize a complex system well enough at the outset of a project to determine the best design. The best way to end up with a good design is to develop a system in increments, where each increment adds a few new abstractions and refactors existing abstractions based on experience. This is similar to the agile development approach.</p>\n<blockquote>\n<p>敏捷开发中最重要的元素之一是开发应该是渐进的和迭代的概念。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。通常，这类似于此处提倡的增量方法。如第 1 章所述，在项目开始时就不可能对复杂的系统进行充分的可视化以决定最佳设计。最终获得良好设计的最佳方法是逐步开发一个系统，其中每个增量都会添加一些新的抽象，并根据经验重构现有的抽象。这类似于敏捷开发方法。</p>\n</blockquote>\n<p>One of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible. For example, some agile practitioners argue that you shouldn’t implement general-purpose mechanisms right away; implement a minimal special-purpose mechanism to start with, and refactor into something more generic later, once you know that it’s needed. Although these arguments make sense to a degree, they argue against an investment approach, and they encourage a more tactical style of programming. This can result in a rapid accumulation of complexity.</p>\n<blockquote>\n<p>敏捷开发的风险之一是它可能导致战术编程。敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。例如，一些敏捷的从业者认为，您不应该立即实施通用机制。实现一个最小的特殊用途机制，从此开始，并在以后知道需要时重构为更通用的东西。尽管这些论点在一定程度上是合理的，但它们反对投资方法，并鼓励采用更具战术性的编程风格。这可以导致复杂性的快速累积。</p>\n</blockquote>\n<p>Developing incrementally is generally a good idea, but the increments of development should be abstractions, not features. It’s fine to put off all thoughts about a particular abstraction until it’s needed by a feature. Once you need the abstraction, invest the time to design it cleanly; follow the advice of Chapter 6 and make it somewhat general-purpose.</p>\n<blockquote>\n<p>渐进式开发通常是一个好主意，但是渐进式开发应该是抽象的，而不是功能。可以推迟对特定抽象的所有想法，直到功能需要它为止。一旦需要抽象，就要花一些时间进行简洁的设计。遵循第 6 章的建议并使其具有通用性。</p>\n</blockquote>\n<h2 id=\"19-3-Unit-tests-单元测试\"><a href=\"#19-3-Unit-tests-单元测试\" class=\"headerlink\" title=\"19.3 Unit tests 单元测试\"></a>19.3 Unit tests 单元测试</h2><p>It used to be that developers rarely wrote tests. If tests were written at all, they were written by a separate QA team. However, one of the tenets of agile development is that testing should be tightly integrated with development, and programmers should write tests for their own code. This practice has now become widespread. Tests are typically divided into two kinds: unit tests and system tests. Unit tests are the ones most often written by developers. They are small and focused: each test usually validates a small section of code in a single method. Unit tests can be run in isolation, without setting up a production environment for the system. Unit tests are often run in conjunction with a test coverage tool to ensure that every line of code in the application is tested. Whenever developers write new code or modify existing code, they are responsible for updating the unit tests to maintain proper test coverage.</p>\n<blockquote>\n<p>过去，开发人员很少编写测试。如果测试是由一个独立的 QA 团队编写的，那么它们就是由一个独立的 QA 团队编写的。然而，敏捷开发的原则之一是测试应该与开发紧密集成，程序员应该为他们自己的代码编写测试。这种做法现在已经很普遍了。测试通常分为两类:单元测试和系统测试。单元测试是开发人员最常编写的测试。它们很小，而且重点突出:每个测试通常在单个方法中验证一小段代码。单元测试可以独立运行，而不需要为系统设置生产环境。单元测试通常与测试覆盖工具一起运行，以确保应用程序中的每一行代码都经过了测试。每当开发人员编写新代码或修改现有代码时，他们都要负责更新单元测试以保持适当的测试覆盖率。</p>\n</blockquote>\n<p>The second kind of test consists of system tests (sometimes called integration tests), which ensure that the different parts of an application all work together properly. They typically involve running the entire application in a production environment. System tests are more likely to be written by a separate QA or testing team.</p>\n<blockquote>\n<p>第二种测试包括系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。系统测试更有可能由独立的质量检查或测试小组编写。</p>\n</blockquote>\n<p>Tests, particularly unit tests, play an important role in software design because they facilitate refactoring. Without a test suite, it’s dangerous to make major structural changes to a system. There’s no easy way to find bugs, so it’s likely that bugs will go undetected until the new code is deployed, where they are much more expensive to find and fix. As a result, developers avoid refactoring in systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulates and design mistakes don’t get corrected.</p>\n<blockquote>\n<p>测试，尤其是单元测试，在软件设计中起着重要作用，因为它们有助于重构。没有测试套件，对系统进行重大结构更改很危险。没有容易找到错误的方法，因此在部署新代码之前，很可能将无法检测到错误，因为在新代码中查找和修复它们的成本要高得多。结果，开发人员避免在没有良好测试套件的系统中进行重构。他们尝试将每个新功能或错误修复的代码更改次数减至最少，这意味着复杂性会累积，而设计错误不会得到纠正。</p>\n</blockquote>\n<p>With a good set of tests, developers can be more confident when refactoring because the test suite will find most bugs that are introduced. This encourages developers to make structural improvements to a system, which results in a better design. Unit tests are particularly valuable: they provide a higher degree of code coverage than system tests, so they are more likely to uncover any bugs.</p>\n<blockquote>\n<p>有了一套很好的测试，开发人员可以在重构时更有信心，因为测试套件将发现大多数引入的错误。这鼓励开发人员对系统进行结构改进，从而获得更好的设计。单元测试特别有价值：与系统测试相比，它们提供更高的代码覆盖率，因此它们更有可能发现任何错误。</p>\n</blockquote>\n<p>For example, during the development of the Tcl scripting language, we decided to improve performance by replacing Tcl’s interpreter with a byte-code compiler. This was a huge change that affected almost every part of the core Tcl engine. Fortunately, Tcl had an excellent unit test suite, which we ran on the new byte-code engine. The existing tests were so effective in uncovering bugs in the new engine that only a single bug turned up after the alpha release of the byte-code compiler.</p>\n<blockquote>\n<p>例如，在开发 Tcl 脚本语言期间，我们决定通过用字节码编译器替换 Tcl 的解释器来提高性能。这是一个巨大的变化，几乎影响了核心 Tcl 引擎的每个部分。幸运的是，Tcl 有一个出色的单元测试套件，我们在新的字节码引擎上运行了该套件。现有测试在发现新引擎中的错误方面是如此有效，以至于在字节码编译器的 alpha 版本发布之后仅出现了一个错误。</p>\n</blockquote>\n<h2 id=\"19-4-Test-driven-development-测试驱动的开发\"><a href=\"#19-4-Test-driven-development-测试驱动的开发\" class=\"headerlink\" title=\"19.4 Test-driven development 测试驱动的开发\"></a>19.4 Test-driven development 测试驱动的开发</h2><p>Test-driven development is an approach to software development where programmers write unit tests before they write code. When creating a new class, the developer first writes unit tests for the class, based on its expected behavior. None of the tests pass, since there is no code for the class. Then the developer works through the tests one at a time, writing enough code for that test to pass. When all of the tests pass, the class is finished.</p>\n<blockquote>\n<p>测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。创建新类时，开发人员首先根据其预期行为为该类编写单元测试。没有测试通过，因为该类没有代码。然后，开发人员一次完成一个测试，编写足够的代码以使该测试通过。所有测试通过后，该类结束。</p>\n</blockquote>\n<p>Although I am a strong advocate of unit testing, I am not a fan of test-driven development. The problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design. This is tactical programming pure and simple, with all of its disadvantages. Test-driven development is too incremental: at any point in time, it’s tempting to just hack in the next feature to make the next test pass. There’s no obvious time to do design, so it’s easy to end up with a mess.</p>\n<blockquote>\n<p>尽管我是单元测试的坚决拥护者，但我不喜欢测试驱动的开发。测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。</p>\n</blockquote>\n<p>As mentioned in Section 19.2, the units of development should be abstractions, not features. Once you discover the need for an abstraction, don’t create the abstraction in pieces over time; design it all at once (or at least enough to provide a reasonably comprehensive set of core functions). This is more likely to produce a clean design whose pieces fit together well.</p>\n<blockquote>\n<p>如第 19.2 节所述，开发单位应该是抽象的，而不是功能。一旦发现需要抽象，就不要随着时间的流逝而逐步创建抽象。一次设计所有功能（或至少足以提供一组合理全面的核心功能）。这样更有可能产生干净的设计，使各个部分很好地契合在一起。</p>\n</blockquote>\n<p>One place where it makes sense to write the tests first is when fixing bugs. Before fixing a bug, write a unit test that fails because of the bug. Then fix the bug and make sure that the unit test now passes. This is the best way to make sure you really have fixed the bug. If you fix the bug before writing the test, it’s possible that the new unit test doesn’t actually trigger the bug, in which case it won’t tell you whether you really fixed the problem.</p>\n<blockquote>\n<p>首先编写测试的地方是修复错误。修复错误之前，请编写由于该错误而失败的单元测试。然后修复该错误，并确保现在可以通过单元测试。这是确保您已真正修复该错误的最佳方法。如果您在编写测试之前就已修复了该错误，则新的单元测试很可能实际上不会触发该错误，在这种情况下，它不会告诉您是否确实修复了该问题。</p>\n</blockquote>\n<h2 id=\"19-5-Design-patterns-设计模式\"><a href=\"#19-5-Design-patterns-设计模式\" class=\"headerlink\" title=\"19.5 Design patterns 设计模式\"></a>19.5 Design patterns 设计模式</h2><p>A design pattern is a commonly used approach for solving a particular kind of problem, such as an iterator or an observer. The notion of design patterns was popularized by the book Design Patterns: Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson, and Vlissides, and design patterns are now widely used in object-oriented software development.</p>\n<blockquote>\n<p>设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。设计模式的概念在 Gamma，Helm，Johnson 和 Vlissides 的《设计模式：可重用的面向对象软件的元素》一书中得到了普及，现在设计模式已广泛用于面向对象的软件开发中。</p>\n</blockquote>\n<p>Design patterns represent an alternative to design: rather than designing a new mechanism from scratch, just apply a well-known design pattern. For the most part, this is good: design patterns arose because they solve common problems, and because they are generally agreed to provide clean solutions. If a design pattern works well in a particular situation, it will probably be hard for you to come up with a different approach that is better.</p>\n<blockquote>\n<p>设计模式代表了设计的替代方法：与其从头设计新的机制，不如应用一种众所周知的设计模式。在大多数情况下，这是件好事：出现设计模式是因为它们解决了常见的问题，并且因为它们被普遍同意提供干净的解决方案。如果设计模式在特定情况下运作良好，那么您可能很难想出另一种更好的方法。</p>\n</blockquote>\n<p>The greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don’t try to force a problem into a design pattern when a custom approach will be cleaner. Using design patterns doesn’t automatically improve a software system; it only does so if the design patterns fit. As with many ideas in software design, the notion that design patterns are good doesn’t necessarily mean that more design patterns are better.</p>\n<blockquote>\n<p>设计模式的最大风险是过度使用。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。使用设计模式并不能自动改善软件系统。只有在设计模式合适的情况下才这样做。与软件设计中的许多想法一样，设计模式良好的概念并不一定意味着更多的设计模式会更好。</p>\n</blockquote>\n<h2 id=\"19-6-Getters-and-setters-Getter-和-Setters\"><a href=\"#19-6-Getters-and-setters-Getter-和-Setters\" class=\"headerlink\" title=\"19.6 Getters and setters Getter 和 Setters\"></a>19.6 Getters and setters Getter 和 Setters</h2><p>In the Java programming community, getter and setter methods are a popular design pattern. A getter and a setter are associated with an instance variable for a class. They have names like getFoo and setFoo, where Foo is the name of the variable. The getter method returns the current value of the variable, and the setter method modifies the value.</p>\n<blockquote>\n<p>在 Java 编程社区中，getter 和 setter 方法是一种流行的设计模式。一个 getter 和一个 setter 与一个类的实例变量相关联。它们具有类似 getFoo 和 setFoo 的名称，其中 Foo 是变量的名称。getter 方法返回变量的当前值，setter 方法修改该值。</p>\n</blockquote>\n<p>Getters and setters aren’t strictly necessary, since instance variables can be made public. The argument for getters and setters is that they allow additional functions to be performed while getting and setting, such as updating related values when a variable changes, notifying listeners of changes, or enforcing constraints on values. Even if these features aren’t needed initially, they can be added later without changing the interface.</p>\n<blockquote>\n<p>由于实例变量可以公开，因此不一定必须使用 getter 和 setter 方法。getter 和 setter 的论点是，它们允许在获取和设置时执行其他功能，例如在变量更改时更新相关值，通知更改的侦听器或对值实施约束。即使最初不需要这些功能，也可以稍后添加它们而无需更改界面。</p>\n</blockquote>\n<p>Although it may make sense to use getters and setters if you must expose instance variables, it’s better not to expose instance variables in the first place. Exposed instance variables mean that part of the class’s implementation is visible externally, which violates the idea of information hiding and increases the complexity of the class’s interface. Getters and setters are shallow methods (typically only a single line), so they add clutter to the class’s interface without providing much functionality. It’s better to avoid getters and setters (or any exposure of implementation data) as much as possible.</p>\n<blockquote>\n<p>尽管如果必须公开实例变量，则可以使用 getter 和 setter 方法，但最好不要首先公开实例变量。暴露的实例变量意味着类的实现的一部分在外部是可见的，这违反了信息隐藏的思想，并增加了类接口的复杂性。Getter 和 Setter 是浅层方法（通常只有一行），因此它们在不提供太多功能的情况下为类的接口增加了混乱。最好避免使用 getter 和 setter（或任何暴露的实现数据）。</p>\n</blockquote>\n<p>One of the risks of establishing a design pattern is that developers assume the pattern is good and try to use it as much as possible. This has led to overusage of getters and setters in Java.</p>\n<blockquote>\n<p>建立设计模式的风险之一是，开发人员认为该模式是好的，并尝试尽可能多地使用它。这导致 Java 中的 getter 和 setter 的过度使用。</p>\n</blockquote>\n<h2 id=\"19-7-Conclusion-结论\"><a href=\"#19-7-Conclusion-结论\" class=\"headerlink\" title=\"19.7 Conclusion 结论\"></a>19.7 Conclusion 结论</h2><p>Whenever you encounter a proposal for a new software development paradigm, challenge it from the standpoint of complexity: does the proposal really help to minimize complexity in large software systems? Many proposals sound good on the surface, but if you look more deeply you will see that some of them make complexity worse, not better.</p>\n<blockquote>\n<p>每当您遇到有关新软件开发范例的提案时，就必须从复杂性的角度对其进行挑战：该提案确实有助于最大程度地降低大型软件系统的复杂性吗？从表面上看，许多建议听起来不错，但是如果您深入研究，您会发现其中一些会使复杂性恶化，而不是更好。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>软件发展趋势</p>","more":"<h1 id=\"第-19-章-软件发展趋势\"><a href=\"#第-19-章-软件发展趋势\" class=\"headerlink\" title=\"第 19 章 软件发展趋势\"></a>第 19 章 软件发展趋势</h1><blockquote>\n<p>Chapter 19 Software Trends</p>\n</blockquote>\n<p>As a way of illustrating the principles discussed in this book, this chapter considers several trends and patterns that have become popular in software development over the last few decades. For each trend, I will describe how that trend relates to the principles in this book and use the principles to evaluate whether that trend provides leverage against software complexity.</p>\n<blockquote>\n<p>为了说明本书中讨论的原理，本章考虑了过去几十年来在软件开发中流行的几种趋势和模式。对于每种趋势，我将描述该趋势与本书中的原理之间的关系，并使用这些原理来评估该趋势是否提供了针对软件复杂性的杠杆作用。</p>\n</blockquote>\n<h2 id=\"19-1-Object-oriented-programming-and-inheritance-面向对象的编程和继承\"><a href=\"#19-1-Object-oriented-programming-and-inheritance-面向对象的编程和继承\" class=\"headerlink\" title=\"19.1 Object-oriented programming and inheritance 面向对象的编程和继承\"></a>19.1 Object-oriented programming and inheritance 面向对象的编程和继承</h2><p>Object-oriented programming is one of the most important new ideas in software development over the last 30–40 years. It introduced notions such as classes, inheritance, private methods, and instance variables. If used carefully, these mechanisms can help to produce better software designs. For example, private methods and variables can be used to ensure information hiding: no code outside a class can invoke private methods or access private variables, so there can’t be any external dependencies on them.</p>\n<blockquote>\n<p>在过去的 30-40 年中，面向对象编程是软件开发中最重要的新思想之一。它引入了诸如类，继承，私有方法和实例变量之类的概念。如果仔细使用，这些机制可以帮助产生更好的软件设计。例如，私有方法和变量可用于确保信息隐藏：类外的任何代码都不能调用私有方法或访问私有变量，因此它们上没有任何外部依赖关系。</p>\n</blockquote>\n<p>One of the key elements of object-oriented programming is inheritance. Inheritance comes in two forms, which have different implications for software complexity. The first form of inheritance is interface inheritance, in which a parent class defines the signatures for one or more methods, but does not implement the methods. Each subclass must implement the signatures, but different subclasses can implement the same methods in different ways. For example, the interface might define methods for performing I/O; one subclass might implement the I/O operations for disk files, and another subclass might implement the same operations for network sockets.</p>\n<blockquote>\n<p>面向对象编程的关键要素之一是继承。继承有两种形式，它们对软件复杂性有不同的含义。继承的第一种形式是接口继承，其中父类定义一个或多个方法的签名，但不实现这些方法。每个子类都必须实现签名，但是不同的子类可以以不同的方式实现相同的方法。例如，该接口可能定义用于执行 I/O 的方法。一个子类可能对磁盘文件实现 I/O 操作，而另一个子类可能对网络套接字实现相同的操作。</p>\n</blockquote>\n<p>Interface inheritance provides leverage against complexity by reusing the same interface for multiple purposes. It allows knowledge acquired in solving one problem (such as how to use an I/O interface to read and write disk files) to be used to solve other problems (such as communicating over a network socket). Another way of thinking about this is in terms of depth: the more different implementations there are of an interface, the deeper the interface becomes. In order for an interface to have many implementations, it must capture the essential features of all the underlying implementations while steering clear of the details that differ between the implementations; this notion is at the heart of abstraction.</p>\n<blockquote>\n<p>接口继承通过出于多种目的重用同一接口，从而提供了针对复杂性的杠杆作用。它使解决一个问题（例如如何使用 I/O 接口读取和写入磁盘文件）中获得的知识可以用于解决其他问题（例如通过网络套接字进行通信）。关于深度的另一种思考方式是：接口的实现越不同，接口就越深入。为了使接口具有许多实现，它必须捕获所有基础实现的基本功能，同时避免实现之间的差异。这个概念是抽象的核心。</p>\n</blockquote>\n<p>The second form of inheritance is implementation inheritance. In this form, a parent class defines not only signatures for one or more methods, but also default implementations. Subclasses can choose to inherit the parent’s implementation of a method or override it by defining a new method with the same signature. Without implementation inheritance, the same method implementation might need to be duplicated in several subclasses, which would create dependencies between those subclasses (modifications would need to be duplicated in all copies of the method). Thus, implementation inheritance reduces the amount of code that needs to be modified as the system evolves; in other words, it reduces the change amplification problem described in Chapter 2.</p>\n<blockquote>\n<p>继承的第二种形式是实现继承。以这种形式，父类不仅定义了一个或多个方法的签名，而且还定义了默认实现。子类可以选择继承方法的父类实现，也可以通过定义具有相同签名的新方法来覆盖它。如果没有实现继承，则可能需要在几个子类中复制相同的方法实现，这将在这些子类之间创建依赖关系（修改需要在方法的所有副本中复制）。因此，实现继承减少了随着系统的发展而需要修改的代码量。换句话说，它减少了第 2 章中描述的变化放大问题。</p>\n</blockquote>\n<p>However, implementation inheritance creates dependencies between the parent class and each of its subclasses. Class instance variables in the parent class are often accessed by both the parent and child classes; this results in information leakage between the classes in the inheritance hierarchy and makes it hard to modify one class in the hierarchy without looking at the others. For example, a developer making changes to the parent class may need to examine all of the subclasses to ensure that the changes don’t break anything. Similarly, if a subclass overrides a method in the parent class, the developer of the subclass may need to examine the implementation in the parent. In the worst case, programmers will need complete knowledge of the entire class hierarchy underneath the parent class in order to make changes to any of the classes. Class hierarchies that use implementation inheritance extensively tend to have high complexity.</p>\n<blockquote>\n<p>但是，实现继承会在父类及其每个子类之间创建依赖关系。父类和子类通常都访问父类中的类实例变量。这会导致继承层次结构中的类之间的信息泄漏，并且使得在不查看其他类的情况下很难修改层次结构中的一个类。例如，对父类进行更改的开发人员可能需要检查所有子类，以确保所做的更改不会破坏任何内容。同样，如果子类覆盖父类中的方法，则子类的开发人员可能需要检查父类中的实现。在最坏的情况下，程序员将需要完全了解父类下的整个类层次结构，以便对任何类进行更改。</p>\n</blockquote>\n<p>Thus, implementation inheritance should be used with caution. Before using implementation inheritance, consider whether an approach based on composition can provide the same benefits. For instance, it may be possible to use small helper classes to implement the shared functionality. Rather than inheriting functions from a parent, the original classes can each build upon the features of the helper classes.</p>\n<blockquote>\n<p>因此，应谨慎使用实现继承。在使用实现继承之前，请考虑基于组合的方法是否可以提供相同的好处。例如，可以使用小型帮助程序类来实现共享功能。原始类可以从辅助类的功能构建，而不是从父类继承函数。</p>\n</blockquote>\n<p>If there is no viable alternative to implementation inheritance, try to separate the state managed by the parent class from that managed by subclasses. One way to do this is for certain instance variables to be managed entirely by methods in the parent class, with subclasses using them only in a read-only fashion or through other methods in the parent class. This applies the notion of information hiding within the class hierarchy to reduce dependencies.</p>\n<blockquote>\n<p>如果没有实现继承的可行选择，请尝试将父类管理的状态与子类管理的状态分开。一种方法是，某些实例变量完全由父类中的方法管理，子类仅以只读方式或通过父类中的其他方法使用它们。这适用于隐藏在类层次结构中的信息的概念，以减少依赖性。</p>\n</blockquote>\n<p>Although the mechanisms provided by object-oriented programming can assist in implementing clean designs, they do not, by themselves, guarantee good design. For example, if classes are shallow, or have complex interfaces, or permit external access to their internal state, then they will still result in high complexity.</p>\n<blockquote>\n<p>尽管面向对象编程提供的机制可以帮助实现干净的设计，但是它们本身不能保证良好的设计。例如，如果类很浅，或者具有复杂的接口，或者允许外部访问其内部状态，那么它们仍将导致很高的复杂性。</p>\n</blockquote>\n<h2 id=\"19-2-Agile-development-敏捷开发\"><a href=\"#19-2-Agile-development-敏捷开发\" class=\"headerlink\" title=\"19.2 Agile development 敏捷开发\"></a>19.2 Agile development 敏捷开发</h2><p>Agile development is an approach to software development that emerged in the late 1990’s from a collection of ideas about how to make software development more lightweight, flexible, and incremental; it was formally defined during a meeting of practitioners in 2001. Agile development is mostly about the process of software development (organizing teams, managing schedules, the role of unit testing, interacting with customers, etc.) as opposed to software design. Nonetheless, it relates to some of the design principles in this book.</p>\n<blockquote>\n<p>敏捷开发是一种软件开发方法，它是在 1990 年代末期出现的，其思想涉及如何使软件开发更加轻量，灵活和增量。它是在 2001 年的一次从业者会议上正式定义的。敏捷开发主要是关于软件开发的过程（组织团队，管理进度表，单元测试的角色，与客户交互等），而不是软件设计。但是，它与本书中的某些设计原则有关。</p>\n</blockquote>\n<p>One of the most important elements of agile development is the notion that development should be incremental and iterative. In the agile approach, a software system is developed in a series of iterations, each of which adds and evaluates a few new features; each iteration includes design, test, and customer input. In general, this is similar to the incremental approach advocated here. As mentioned in Chapter 1, it isn’t possible to visualize a complex system well enough at the outset of a project to determine the best design. The best way to end up with a good design is to develop a system in increments, where each increment adds a few new abstractions and refactors existing abstractions based on experience. This is similar to the agile development approach.</p>\n<blockquote>\n<p>敏捷开发中最重要的元素之一是开发应该是渐进的和迭代的概念。在敏捷方法中，软件系统是通过一系列迭代开发的，每个迭代都添加并评估了一些新功能。每个迭代都包括设计，测试和客户输入。通常，这类似于此处提倡的增量方法。如第 1 章所述，在项目开始时就不可能对复杂的系统进行充分的可视化以决定最佳设计。最终获得良好设计的最佳方法是逐步开发一个系统，其中每个增量都会添加一些新的抽象，并根据经验重构现有的抽象。这类似于敏捷开发方法。</p>\n</blockquote>\n<p>One of the risks of agile development is that it can lead to tactical programming. Agile development tends to focus developers on features, not abstractions, and it encourages developers to put off design decisions in order to produce working software as soon as possible. For example, some agile practitioners argue that you shouldn’t implement general-purpose mechanisms right away; implement a minimal special-purpose mechanism to start with, and refactor into something more generic later, once you know that it’s needed. Although these arguments make sense to a degree, they argue against an investment approach, and they encourage a more tactical style of programming. This can result in a rapid accumulation of complexity.</p>\n<blockquote>\n<p>敏捷开发的风险之一是它可能导致战术编程。敏捷开发倾向于使开发人员专注于功能，而不是抽象，它鼓励开发人员推迟设计决策，以便尽快生产可运行的软件。例如，一些敏捷的从业者认为，您不应该立即实施通用机制。实现一个最小的特殊用途机制，从此开始，并在以后知道需要时重构为更通用的东西。尽管这些论点在一定程度上是合理的，但它们反对投资方法，并鼓励采用更具战术性的编程风格。这可以导致复杂性的快速累积。</p>\n</blockquote>\n<p>Developing incrementally is generally a good idea, but the increments of development should be abstractions, not features. It’s fine to put off all thoughts about a particular abstraction until it’s needed by a feature. Once you need the abstraction, invest the time to design it cleanly; follow the advice of Chapter 6 and make it somewhat general-purpose.</p>\n<blockquote>\n<p>渐进式开发通常是一个好主意，但是渐进式开发应该是抽象的，而不是功能。可以推迟对特定抽象的所有想法，直到功能需要它为止。一旦需要抽象，就要花一些时间进行简洁的设计。遵循第 6 章的建议并使其具有通用性。</p>\n</blockquote>\n<h2 id=\"19-3-Unit-tests-单元测试\"><a href=\"#19-3-Unit-tests-单元测试\" class=\"headerlink\" title=\"19.3 Unit tests 单元测试\"></a>19.3 Unit tests 单元测试</h2><p>It used to be that developers rarely wrote tests. If tests were written at all, they were written by a separate QA team. However, one of the tenets of agile development is that testing should be tightly integrated with development, and programmers should write tests for their own code. This practice has now become widespread. Tests are typically divided into two kinds: unit tests and system tests. Unit tests are the ones most often written by developers. They are small and focused: each test usually validates a small section of code in a single method. Unit tests can be run in isolation, without setting up a production environment for the system. Unit tests are often run in conjunction with a test coverage tool to ensure that every line of code in the application is tested. Whenever developers write new code or modify existing code, they are responsible for updating the unit tests to maintain proper test coverage.</p>\n<blockquote>\n<p>过去，开发人员很少编写测试。如果测试是由一个独立的 QA 团队编写的，那么它们就是由一个独立的 QA 团队编写的。然而，敏捷开发的原则之一是测试应该与开发紧密集成，程序员应该为他们自己的代码编写测试。这种做法现在已经很普遍了。测试通常分为两类:单元测试和系统测试。单元测试是开发人员最常编写的测试。它们很小，而且重点突出:每个测试通常在单个方法中验证一小段代码。单元测试可以独立运行，而不需要为系统设置生产环境。单元测试通常与测试覆盖工具一起运行，以确保应用程序中的每一行代码都经过了测试。每当开发人员编写新代码或修改现有代码时，他们都要负责更新单元测试以保持适当的测试覆盖率。</p>\n</blockquote>\n<p>The second kind of test consists of system tests (sometimes called integration tests), which ensure that the different parts of an application all work together properly. They typically involve running the entire application in a production environment. System tests are more likely to be written by a separate QA or testing team.</p>\n<blockquote>\n<p>第二种测试包括系统测试（有时称为集成测试），这些测试可确保应用程序的不同部分都能正常协同工作。它们通常涉及在生产环境中运行整个应用程序。系统测试更有可能由独立的质量检查或测试小组编写。</p>\n</blockquote>\n<p>Tests, particularly unit tests, play an important role in software design because they facilitate refactoring. Without a test suite, it’s dangerous to make major structural changes to a system. There’s no easy way to find bugs, so it’s likely that bugs will go undetected until the new code is deployed, where they are much more expensive to find and fix. As a result, developers avoid refactoring in systems without good test suites; they try to minimize the number of code changes for each new feature or bug fix, which means that complexity accumulates and design mistakes don’t get corrected.</p>\n<blockquote>\n<p>测试，尤其是单元测试，在软件设计中起着重要作用，因为它们有助于重构。没有测试套件，对系统进行重大结构更改很危险。没有容易找到错误的方法，因此在部署新代码之前，很可能将无法检测到错误，因为在新代码中查找和修复它们的成本要高得多。结果，开发人员避免在没有良好测试套件的系统中进行重构。他们尝试将每个新功能或错误修复的代码更改次数减至最少，这意味着复杂性会累积，而设计错误不会得到纠正。</p>\n</blockquote>\n<p>With a good set of tests, developers can be more confident when refactoring because the test suite will find most bugs that are introduced. This encourages developers to make structural improvements to a system, which results in a better design. Unit tests are particularly valuable: they provide a higher degree of code coverage than system tests, so they are more likely to uncover any bugs.</p>\n<blockquote>\n<p>有了一套很好的测试，开发人员可以在重构时更有信心，因为测试套件将发现大多数引入的错误。这鼓励开发人员对系统进行结构改进，从而获得更好的设计。单元测试特别有价值：与系统测试相比，它们提供更高的代码覆盖率，因此它们更有可能发现任何错误。</p>\n</blockquote>\n<p>For example, during the development of the Tcl scripting language, we decided to improve performance by replacing Tcl’s interpreter with a byte-code compiler. This was a huge change that affected almost every part of the core Tcl engine. Fortunately, Tcl had an excellent unit test suite, which we ran on the new byte-code engine. The existing tests were so effective in uncovering bugs in the new engine that only a single bug turned up after the alpha release of the byte-code compiler.</p>\n<blockquote>\n<p>例如，在开发 Tcl 脚本语言期间，我们决定通过用字节码编译器替换 Tcl 的解释器来提高性能。这是一个巨大的变化，几乎影响了核心 Tcl 引擎的每个部分。幸运的是，Tcl 有一个出色的单元测试套件，我们在新的字节码引擎上运行了该套件。现有测试在发现新引擎中的错误方面是如此有效，以至于在字节码编译器的 alpha 版本发布之后仅出现了一个错误。</p>\n</blockquote>\n<h2 id=\"19-4-Test-driven-development-测试驱动的开发\"><a href=\"#19-4-Test-driven-development-测试驱动的开发\" class=\"headerlink\" title=\"19.4 Test-driven development 测试驱动的开发\"></a>19.4 Test-driven development 测试驱动的开发</h2><p>Test-driven development is an approach to software development where programmers write unit tests before they write code. When creating a new class, the developer first writes unit tests for the class, based on its expected behavior. None of the tests pass, since there is no code for the class. Then the developer works through the tests one at a time, writing enough code for that test to pass. When all of the tests pass, the class is finished.</p>\n<blockquote>\n<p>测试驱动开发是一种软件开发方法，程序员可以在编写代码之前先编写单元测试。创建新类时，开发人员首先根据其预期行为为该类编写单元测试。没有测试通过，因为该类没有代码。然后，开发人员一次完成一个测试，编写足够的代码以使该测试通过。所有测试通过后，该类结束。</p>\n</blockquote>\n<p>Although I am a strong advocate of unit testing, I am not a fan of test-driven development. The problem with test-driven development is that it focuses attention on getting specific features working, rather than finding the best design. This is tactical programming pure and simple, with all of its disadvantages. Test-driven development is too incremental: at any point in time, it’s tempting to just hack in the next feature to make the next test pass. There’s no obvious time to do design, so it’s easy to end up with a mess.</p>\n<blockquote>\n<p>尽管我是单元测试的坚决拥护者，但我不喜欢测试驱动的开发。测试驱动开发的问题在于，它将注意力集中在使特定功能起作用，而不是寻找最佳设计上。这是一种纯净而简单的战术编程，具有所有缺点。测试驱动的开发过于增量：在任何时间点，很容易破解下一个功能以进行下一个测试通过。没有明显的时间进行设计，因此很容易陷入混乱。</p>\n</blockquote>\n<p>As mentioned in Section 19.2, the units of development should be abstractions, not features. Once you discover the need for an abstraction, don’t create the abstraction in pieces over time; design it all at once (or at least enough to provide a reasonably comprehensive set of core functions). This is more likely to produce a clean design whose pieces fit together well.</p>\n<blockquote>\n<p>如第 19.2 节所述，开发单位应该是抽象的，而不是功能。一旦发现需要抽象，就不要随着时间的流逝而逐步创建抽象。一次设计所有功能（或至少足以提供一组合理全面的核心功能）。这样更有可能产生干净的设计，使各个部分很好地契合在一起。</p>\n</blockquote>\n<p>One place where it makes sense to write the tests first is when fixing bugs. Before fixing a bug, write a unit test that fails because of the bug. Then fix the bug and make sure that the unit test now passes. This is the best way to make sure you really have fixed the bug. If you fix the bug before writing the test, it’s possible that the new unit test doesn’t actually trigger the bug, in which case it won’t tell you whether you really fixed the problem.</p>\n<blockquote>\n<p>首先编写测试的地方是修复错误。修复错误之前，请编写由于该错误而失败的单元测试。然后修复该错误，并确保现在可以通过单元测试。这是确保您已真正修复该错误的最佳方法。如果您在编写测试之前就已修复了该错误，则新的单元测试很可能实际上不会触发该错误，在这种情况下，它不会告诉您是否确实修复了该问题。</p>\n</blockquote>\n<h2 id=\"19-5-Design-patterns-设计模式\"><a href=\"#19-5-Design-patterns-设计模式\" class=\"headerlink\" title=\"19.5 Design patterns 设计模式\"></a>19.5 Design patterns 设计模式</h2><p>A design pattern is a commonly used approach for solving a particular kind of problem, such as an iterator or an observer. The notion of design patterns was popularized by the book Design Patterns: Elements of Reusable Object-Oriented Software by Gamma, Helm, Johnson, and Vlissides, and design patterns are now widely used in object-oriented software development.</p>\n<blockquote>\n<p>设计模式是解决特定类型问题（例如迭代器或观察器）的常用方法。设计模式的概念在 Gamma，Helm，Johnson 和 Vlissides 的《设计模式：可重用的面向对象软件的元素》一书中得到了普及，现在设计模式已广泛用于面向对象的软件开发中。</p>\n</blockquote>\n<p>Design patterns represent an alternative to design: rather than designing a new mechanism from scratch, just apply a well-known design pattern. For the most part, this is good: design patterns arose because they solve common problems, and because they are generally agreed to provide clean solutions. If a design pattern works well in a particular situation, it will probably be hard for you to come up with a different approach that is better.</p>\n<blockquote>\n<p>设计模式代表了设计的替代方法：与其从头设计新的机制，不如应用一种众所周知的设计模式。在大多数情况下，这是件好事：出现设计模式是因为它们解决了常见的问题，并且因为它们被普遍同意提供干净的解决方案。如果设计模式在特定情况下运作良好，那么您可能很难想出另一种更好的方法。</p>\n</blockquote>\n<p>The greatest risk with design patterns is over-application. Not every problem can be solved cleanly with an existing design pattern; don’t try to force a problem into a design pattern when a custom approach will be cleaner. Using design patterns doesn’t automatically improve a software system; it only does so if the design patterns fit. As with many ideas in software design, the notion that design patterns are good doesn’t necessarily mean that more design patterns are better.</p>\n<blockquote>\n<p>设计模式的最大风险是过度使用。使用现有的设计模式并不能完全解决所有问题。当自定义方法更加简洁时，请勿尝试将问题强加到设计模式中。使用设计模式并不能自动改善软件系统。只有在设计模式合适的情况下才这样做。与软件设计中的许多想法一样，设计模式良好的概念并不一定意味着更多的设计模式会更好。</p>\n</blockquote>\n<h2 id=\"19-6-Getters-and-setters-Getter-和-Setters\"><a href=\"#19-6-Getters-and-setters-Getter-和-Setters\" class=\"headerlink\" title=\"19.6 Getters and setters Getter 和 Setters\"></a>19.6 Getters and setters Getter 和 Setters</h2><p>In the Java programming community, getter and setter methods are a popular design pattern. A getter and a setter are associated with an instance variable for a class. They have names like getFoo and setFoo, where Foo is the name of the variable. The getter method returns the current value of the variable, and the setter method modifies the value.</p>\n<blockquote>\n<p>在 Java 编程社区中，getter 和 setter 方法是一种流行的设计模式。一个 getter 和一个 setter 与一个类的实例变量相关联。它们具有类似 getFoo 和 setFoo 的名称，其中 Foo 是变量的名称。getter 方法返回变量的当前值，setter 方法修改该值。</p>\n</blockquote>\n<p>Getters and setters aren’t strictly necessary, since instance variables can be made public. The argument for getters and setters is that they allow additional functions to be performed while getting and setting, such as updating related values when a variable changes, notifying listeners of changes, or enforcing constraints on values. Even if these features aren’t needed initially, they can be added later without changing the interface.</p>\n<blockquote>\n<p>由于实例变量可以公开，因此不一定必须使用 getter 和 setter 方法。getter 和 setter 的论点是，它们允许在获取和设置时执行其他功能，例如在变量更改时更新相关值，通知更改的侦听器或对值实施约束。即使最初不需要这些功能，也可以稍后添加它们而无需更改界面。</p>\n</blockquote>\n<p>Although it may make sense to use getters and setters if you must expose instance variables, it’s better not to expose instance variables in the first place. Exposed instance variables mean that part of the class’s implementation is visible externally, which violates the idea of information hiding and increases the complexity of the class’s interface. Getters and setters are shallow methods (typically only a single line), so they add clutter to the class’s interface without providing much functionality. It’s better to avoid getters and setters (or any exposure of implementation data) as much as possible.</p>\n<blockquote>\n<p>尽管如果必须公开实例变量，则可以使用 getter 和 setter 方法，但最好不要首先公开实例变量。暴露的实例变量意味着类的实现的一部分在外部是可见的，这违反了信息隐藏的思想，并增加了类接口的复杂性。Getter 和 Setter 是浅层方法（通常只有一行），因此它们在不提供太多功能的情况下为类的接口增加了混乱。最好避免使用 getter 和 setter（或任何暴露的实现数据）。</p>\n</blockquote>\n<p>One of the risks of establishing a design pattern is that developers assume the pattern is good and try to use it as much as possible. This has led to overusage of getters and setters in Java.</p>\n<blockquote>\n<p>建立设计模式的风险之一是，开发人员认为该模式是好的，并尝试尽可能多地使用它。这导致 Java 中的 getter 和 setter 的过度使用。</p>\n</blockquote>\n<h2 id=\"19-7-Conclusion-结论\"><a href=\"#19-7-Conclusion-结论\" class=\"headerlink\" title=\"19.7 Conclusion 结论\"></a>19.7 Conclusion 结论</h2><p>Whenever you encounter a proposal for a new software development paradigm, challenge it from the standpoint of complexity: does the proposal really help to minimize complexity in large software systems? Many proposals sound good on the surface, but if you look more deeply you will see that some of them make complexity worse, not better.</p>\n<blockquote>\n<p>每当您遇到有关新软件开发范例的提案时，就必须从复杂性的角度对其进行挑战：该提案确实有助于最大程度地降低大型软件系统的复杂性吗？从表面上看，许多建议听起来不错，但是如果您深入研究，您会发现其中一些会使复杂性恶化，而不是更好。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch11","date":"2021-02-10T16:00:00.000Z","_content":"设计它两次\n<!-- more -->\n# 第 11 章 设计它两次\n\n> Chapter 11 Design it Twice\n\nDesigning software is hard, so it’s unlikely that your first thoughts about how to structure a module or system will produce the best design. You’ll end up with a much better result if you consider multiple options for each major design decision: design it twice.\n\n> 设计软件非常困难，因此您对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策考虑多个选项，最终将获得更好的结果：设计两次。\n\nSuppose you are designing the class that will manage the text of a file for a GUI text editor. The first step is to define the interface that the class will present to the rest of the editor; rather than picking the first idea that comes to mind, consider several possibilities. One choice is a line-oriented interface, with operations to insert, modify, and delete whole lines of text. Another option is an interface based on individual character insertions and deletions. A third choice is a string-oriented interface, which operates on arbitrary ranges of characters that may cross line boundaries. You don’t need to pin down every feature of each alternative; it’s sufficient at this point to sketch out a few of the most important methods.\n\n> 假设您正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。您无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。\n\nTry to pick approaches that are radically different from each other; you’ll learn more that way. Even if you are certain that there is only one reasonable approach, consider a second design anyway, no matter how bad you think it will be. It will be instructive to think about the weaknesses of that design and contrast them with the features of other designs.\n\n> 尝试选择彼此根本不同的方法；这样您将学到更多。即使您确定只有一种合理的方法，无论您认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。\n\nAfter you have roughed out the designs for the alternatives, make a list of the pros and cons of each one. The most important consideration for an interface is ease of use for higher level software. In the example above, both the line-oriented interface and the character-oriented interface will require extra work in software that uses the text class. The line-oriented interface will require higher level software to split and join lines during partial-line and multi-line operations such as cutting and pasting the selection. The character-oriented interface will require loops to implement operations that modify more than a single character. It is also worth considering other factors:\n\n> 在对备选方案进行粗略设计之后，列出每个方案的优缺点。接口最重要的考虑因素是高级软件的易用性。在上面的示例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：\n\n- Does one alternative have a simpler interface than another? In the text example, all of the text interfaces are relatively simple.\n- Is one interface more general-purpose than another?\n- Does one interface enable a more efficient implementation than another? In the text example, the character-oriented approach is likely to be significantly slower than the others, because it requires a separate call into the text module for each character.\n\n---\n\n> - 一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。\n> - 一个接口比另一个接口更通用吗？\n> - 一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。\n\nOnce you have compared alternative designs, you will be in a better position to identify the best design. The best choice may be one of the alternatives, or you may discover that you can combine features of multiple alternatives into a new design that is better than any of the original choices.\n\n> 比较了备选设计之后，您将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者您可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。\n\nSometimes none of the alternatives is particularly attractive; when this happens, see if you can come up with additional schemes. Use the problems you identified with the original alternatives to drive the new design(s). If you were designing the text class and considered only the line-oriented and character-oriented approaches, you might notice that each of the alternatives is awkward because it requires higher level software to perform additional text manipulations. That’s a red flag: if there’s going to be a text class, it should handle all of the text manipulation. In order to eliminate the additional text manipulations, the text interface needs to match more closely the operations happening in higher level software. These operations don’t always correspond to single characters or single lines. This line of reasoning should lead you to a range-oriented API for text, which eliminates the problem with the earlier designs.\n\n> 有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用您在原始替代方案中发现的问题来推动新设计。如果您在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。\n\nThe design-it-twice principle can be applied at many levels in a system. For a module, you can use this approach first to pick the interface, as described above. Then you can apply it again when you are designing the implementation: for the text class, you might consider implementations such as a linked list of lines, fixed-size blocks of characters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the implementation, the most important things are simplicity and performance. It’s also useful to explore multiple designs at higher levels in the system, such as when choosing features for a user interface, or when decomposing a system into major modules. In each case, it’s easier to identify the best approach if you can compare a few alternatives.\n\n> 两次设计原则可以在系统的许多级别上应用。对于模块，您可以首先使用此方法来选择接口，如上所述。然后，您可以在设计实现时再次应用它：对于文本类，您可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果您可以比较几种选择，则更容易确定最佳方法。\n\nDesigning it twice does not need to take a lot of extra time. For a smaller module such as a class, you may not need more than an hour or two to consider alternatives. This is a small amount of time compared to the days or weeks you will spend implementing the class. The initial design experiments will probably result in a significantly better design, which will more than pay for the time spent designing it twice. For larger modules you’ll spend more time in the initial design explorations, but the implementation will also take longer, and the benefits of a better design will also be higher.\n\n> 对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），您可能不需要一两个小时就能考虑替代方法。与您将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。对于较大的模块，您将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。\n\nI have noticed that the design-it-twice principle is sometimes hard for really smart people to embrace. When they are growing up, smart people discover that their first quick idea about any problem is sufficient for a good grade; there is no need to consider a second or third possibility. This makes it easy to develop bad work habits. However, as these people get older, they get promoted into environments with harder and harder problems. Eventually, everyone reaches a point where your first ideas are no longer good enough; if you want to get really great results, you have to consider a second possibility, or perhaps a third, no matter how smart you are. The design of large software systems falls in this category: no-one is good enough to get it right with their first try.\n\n> 我已经注意到，真正聪明的人有时很难接受两次设计原则。当他们长大后，聪明的人会发现，他们对任何问题的第一个快速构想就足以取得良好的成绩。无需考虑第二种或第三种可能性。这使得容易养成不良的工作习惯。但是，随着这些人变老，他们将被提升到越来越困难的环境中。最终，每个人 ​​ 都达到了您的第一个想法不再足够好的地步。如果您想获得非常好的结果，那么无论您多么聪明，都必须考虑第二种可能性，或者第三种可能性。大型软件系统的设计属于此类：没有人能很好地在首次尝试时就将其正确。\n\nUnfortunately, I often see smart people who insist on implementing the first idea that comes to mind, and this causes them to underperform their true potential (it also makes them frustrating to work with). Perhaps they subconsciously believe that “smart people get it right the first time,” so if they try multiple designs it would mean they are not smart after all. This is not the case. It isn’t that you aren’t smart; it’s that the problems are really hard! Furthermore, that’s a good thing: it’s much more fun to work on a difficult problem where you have to think carefully, rather than an easy problem where you don’t have to think at all.\n\n> 不幸的是，我经常看到聪明的人坚持要实现第一个想到的想法，这会使他们无法发挥其真正的潜力（这也使他们沮丧地工作）。也许他们下意识地相信“聪明的人第一次就能做到”，因此，如果他们尝试多种设计，那将意味着他们毕竟并不聪明。不是这种情况。不是说你不聪明；问题真的很难解决！此外，这是一件好事：处理一个必须认真思考的难题比处理一个根本不需要思考的难题更有趣。\n\nThe design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approaches will teach you about the factors that make designs better or worse. Over time, this will make it easier for you to rule out bad designs and hone in on really great ones.\n\n> “两次设计”方法不仅可以改善您的设计，而且可以提高您的设计技能。设计和比较多种方法的过程将教您使设计更好或更坏的因素。随着时间的流逝，这将使您更容易排除不良的设计并磨练真正的出色设计。\n","source":"_posts/软件设计的哲学-ch11.md","raw":"---\ntitle: 软件设计的哲学 - ch11\ndate: 2021-02-11\ntags: 软件设计的哲学 软件开发 方法论\n---\n设计它两次\n<!-- more -->\n# 第 11 章 设计它两次\n\n> Chapter 11 Design it Twice\n\nDesigning software is hard, so it’s unlikely that your first thoughts about how to structure a module or system will produce the best design. You’ll end up with a much better result if you consider multiple options for each major design decision: design it twice.\n\n> 设计软件非常困难，因此您对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策考虑多个选项，最终将获得更好的结果：设计两次。\n\nSuppose you are designing the class that will manage the text of a file for a GUI text editor. The first step is to define the interface that the class will present to the rest of the editor; rather than picking the first idea that comes to mind, consider several possibilities. One choice is a line-oriented interface, with operations to insert, modify, and delete whole lines of text. Another option is an interface based on individual character insertions and deletions. A third choice is a string-oriented interface, which operates on arbitrary ranges of characters that may cross line boundaries. You don’t need to pin down every feature of each alternative; it’s sufficient at this point to sketch out a few of the most important methods.\n\n> 假设您正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。您无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。\n\nTry to pick approaches that are radically different from each other; you’ll learn more that way. Even if you are certain that there is only one reasonable approach, consider a second design anyway, no matter how bad you think it will be. It will be instructive to think about the weaknesses of that design and contrast them with the features of other designs.\n\n> 尝试选择彼此根本不同的方法；这样您将学到更多。即使您确定只有一种合理的方法，无论您认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。\n\nAfter you have roughed out the designs for the alternatives, make a list of the pros and cons of each one. The most important consideration for an interface is ease of use for higher level software. In the example above, both the line-oriented interface and the character-oriented interface will require extra work in software that uses the text class. The line-oriented interface will require higher level software to split and join lines during partial-line and multi-line operations such as cutting and pasting the selection. The character-oriented interface will require loops to implement operations that modify more than a single character. It is also worth considering other factors:\n\n> 在对备选方案进行粗略设计之后，列出每个方案的优缺点。接口最重要的考虑因素是高级软件的易用性。在上面的示例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：\n\n- Does one alternative have a simpler interface than another? In the text example, all of the text interfaces are relatively simple.\n- Is one interface more general-purpose than another?\n- Does one interface enable a more efficient implementation than another? In the text example, the character-oriented approach is likely to be significantly slower than the others, because it requires a separate call into the text module for each character.\n\n---\n\n> - 一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。\n> - 一个接口比另一个接口更通用吗？\n> - 一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。\n\nOnce you have compared alternative designs, you will be in a better position to identify the best design. The best choice may be one of the alternatives, or you may discover that you can combine features of multiple alternatives into a new design that is better than any of the original choices.\n\n> 比较了备选设计之后，您将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者您可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。\n\nSometimes none of the alternatives is particularly attractive; when this happens, see if you can come up with additional schemes. Use the problems you identified with the original alternatives to drive the new design(s). If you were designing the text class and considered only the line-oriented and character-oriented approaches, you might notice that each of the alternatives is awkward because it requires higher level software to perform additional text manipulations. That’s a red flag: if there’s going to be a text class, it should handle all of the text manipulation. In order to eliminate the additional text manipulations, the text interface needs to match more closely the operations happening in higher level software. These operations don’t always correspond to single characters or single lines. This line of reasoning should lead you to a range-oriented API for text, which eliminates the problem with the earlier designs.\n\n> 有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用您在原始替代方案中发现的问题来推动新设计。如果您在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。\n\nThe design-it-twice principle can be applied at many levels in a system. For a module, you can use this approach first to pick the interface, as described above. Then you can apply it again when you are designing the implementation: for the text class, you might consider implementations such as a linked list of lines, fixed-size blocks of characters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the implementation, the most important things are simplicity and performance. It’s also useful to explore multiple designs at higher levels in the system, such as when choosing features for a user interface, or when decomposing a system into major modules. In each case, it’s easier to identify the best approach if you can compare a few alternatives.\n\n> 两次设计原则可以在系统的许多级别上应用。对于模块，您可以首先使用此方法来选择接口，如上所述。然后，您可以在设计实现时再次应用它：对于文本类，您可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果您可以比较几种选择，则更容易确定最佳方法。\n\nDesigning it twice does not need to take a lot of extra time. For a smaller module such as a class, you may not need more than an hour or two to consider alternatives. This is a small amount of time compared to the days or weeks you will spend implementing the class. The initial design experiments will probably result in a significantly better design, which will more than pay for the time spent designing it twice. For larger modules you’ll spend more time in the initial design explorations, but the implementation will also take longer, and the benefits of a better design will also be higher.\n\n> 对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），您可能不需要一两个小时就能考虑替代方法。与您将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。对于较大的模块，您将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。\n\nI have noticed that the design-it-twice principle is sometimes hard for really smart people to embrace. When they are growing up, smart people discover that their first quick idea about any problem is sufficient for a good grade; there is no need to consider a second or third possibility. This makes it easy to develop bad work habits. However, as these people get older, they get promoted into environments with harder and harder problems. Eventually, everyone reaches a point where your first ideas are no longer good enough; if you want to get really great results, you have to consider a second possibility, or perhaps a third, no matter how smart you are. The design of large software systems falls in this category: no-one is good enough to get it right with their first try.\n\n> 我已经注意到，真正聪明的人有时很难接受两次设计原则。当他们长大后，聪明的人会发现，他们对任何问题的第一个快速构想就足以取得良好的成绩。无需考虑第二种或第三种可能性。这使得容易养成不良的工作习惯。但是，随着这些人变老，他们将被提升到越来越困难的环境中。最终，每个人 ​​ 都达到了您的第一个想法不再足够好的地步。如果您想获得非常好的结果，那么无论您多么聪明，都必须考虑第二种可能性，或者第三种可能性。大型软件系统的设计属于此类：没有人能很好地在首次尝试时就将其正确。\n\nUnfortunately, I often see smart people who insist on implementing the first idea that comes to mind, and this causes them to underperform their true potential (it also makes them frustrating to work with). Perhaps they subconsciously believe that “smart people get it right the first time,” so if they try multiple designs it would mean they are not smart after all. This is not the case. It isn’t that you aren’t smart; it’s that the problems are really hard! Furthermore, that’s a good thing: it’s much more fun to work on a difficult problem where you have to think carefully, rather than an easy problem where you don’t have to think at all.\n\n> 不幸的是，我经常看到聪明的人坚持要实现第一个想到的想法，这会使他们无法发挥其真正的潜力（这也使他们沮丧地工作）。也许他们下意识地相信“聪明的人第一次就能做到”，因此，如果他们尝试多种设计，那将意味着他们毕竟并不聪明。不是这种情况。不是说你不聪明；问题真的很难解决！此外，这是一件好事：处理一个必须认真思考的难题比处理一个根本不需要思考的难题更有趣。\n\nThe design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approaches will teach you about the factors that make designs better or worse. Over time, this will make it easier for you to rule out bad designs and hone in on really great ones.\n\n> “两次设计”方法不仅可以改善您的设计，而且可以提高您的设计技能。设计和比较多种方法的过程将教您使设计更好或更坏的因素。随着时间的流逝，这将使您更容易排除不良的设计并磨练真正的出色设计。\n","slug":"软件设计的哲学-ch11","published":1,"updated":"2021-02-16T04:53:43.382Z","_id":"ckl7iw2v60002kiiy0k7yh78g","comments":1,"layout":"post","photos":[],"link":"","content":"<p>设计它两次</p>\n<a id=\"more\"></a>\n<h1 id=\"第-11-章-设计它两次\"><a href=\"#第-11-章-设计它两次\" class=\"headerlink\" title=\"第 11 章 设计它两次\"></a>第 11 章 设计它两次</h1><blockquote>\n<p>Chapter 11 Design it Twice</p>\n</blockquote>\n<p>Designing software is hard, so it’s unlikely that your first thoughts about how to structure a module or system will produce the best design. You’ll end up with a much better result if you consider multiple options for each major design decision: design it twice.</p>\n<blockquote>\n<p>设计软件非常困难，因此您对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策考虑多个选项，最终将获得更好的结果：设计两次。</p>\n</blockquote>\n<p>Suppose you are designing the class that will manage the text of a file for a GUI text editor. The first step is to define the interface that the class will present to the rest of the editor; rather than picking the first idea that comes to mind, consider several possibilities. One choice is a line-oriented interface, with operations to insert, modify, and delete whole lines of text. Another option is an interface based on individual character insertions and deletions. A third choice is a string-oriented interface, which operates on arbitrary ranges of characters that may cross line boundaries. You don’t need to pin down every feature of each alternative; it’s sufficient at this point to sketch out a few of the most important methods.</p>\n<blockquote>\n<p>假设您正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。您无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。</p>\n</blockquote>\n<p>Try to pick approaches that are radically different from each other; you’ll learn more that way. Even if you are certain that there is only one reasonable approach, consider a second design anyway, no matter how bad you think it will be. It will be instructive to think about the weaknesses of that design and contrast them with the features of other designs.</p>\n<blockquote>\n<p>尝试选择彼此根本不同的方法；这样您将学到更多。即使您确定只有一种合理的方法，无论您认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。</p>\n</blockquote>\n<p>After you have roughed out the designs for the alternatives, make a list of the pros and cons of each one. The most important consideration for an interface is ease of use for higher level software. In the example above, both the line-oriented interface and the character-oriented interface will require extra work in software that uses the text class. The line-oriented interface will require higher level software to split and join lines during partial-line and multi-line operations such as cutting and pasting the selection. The character-oriented interface will require loops to implement operations that modify more than a single character. It is also worth considering other factors:</p>\n<blockquote>\n<p>在对备选方案进行粗略设计之后，列出每个方案的优缺点。接口最重要的考虑因素是高级软件的易用性。在上面的示例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：</p>\n</blockquote>\n<ul>\n<li>Does one alternative have a simpler interface than another? In the text example, all of the text interfaces are relatively simple.</li>\n<li>Is one interface more general-purpose than another?</li>\n<li>Does one interface enable a more efficient implementation than another? In the text example, the character-oriented approach is likely to be significantly slower than the others, because it requires a separate call into the text module for each character.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。</li>\n<li>一个接口比另一个接口更通用吗？</li>\n<li>一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。</li>\n</ul>\n</blockquote>\n<p>Once you have compared alternative designs, you will be in a better position to identify the best design. The best choice may be one of the alternatives, or you may discover that you can combine features of multiple alternatives into a new design that is better than any of the original choices.</p>\n<blockquote>\n<p>比较了备选设计之后，您将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者您可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。</p>\n</blockquote>\n<p>Sometimes none of the alternatives is particularly attractive; when this happens, see if you can come up with additional schemes. Use the problems you identified with the original alternatives to drive the new design(s). If you were designing the text class and considered only the line-oriented and character-oriented approaches, you might notice that each of the alternatives is awkward because it requires higher level software to perform additional text manipulations. That’s a red flag: if there’s going to be a text class, it should handle all of the text manipulation. In order to eliminate the additional text manipulations, the text interface needs to match more closely the operations happening in higher level software. These operations don’t always correspond to single characters or single lines. This line of reasoning should lead you to a range-oriented API for text, which eliminates the problem with the earlier designs.</p>\n<blockquote>\n<p>有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用您在原始替代方案中发现的问题来推动新设计。如果您在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。</p>\n</blockquote>\n<p>The design-it-twice principle can be applied at many levels in a system. For a module, you can use this approach first to pick the interface, as described above. Then you can apply it again when you are designing the implementation: for the text class, you might consider implementations such as a linked list of lines, fixed-size blocks of characters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the implementation, the most important things are simplicity and performance. It’s also useful to explore multiple designs at higher levels in the system, such as when choosing features for a user interface, or when decomposing a system into major modules. In each case, it’s easier to identify the best approach if you can compare a few alternatives.</p>\n<blockquote>\n<p>两次设计原则可以在系统的许多级别上应用。对于模块，您可以首先使用此方法来选择接口，如上所述。然后，您可以在设计实现时再次应用它：对于文本类，您可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果您可以比较几种选择，则更容易确定最佳方法。</p>\n</blockquote>\n<p>Designing it twice does not need to take a lot of extra time. For a smaller module such as a class, you may not need more than an hour or two to consider alternatives. This is a small amount of time compared to the days or weeks you will spend implementing the class. The initial design experiments will probably result in a significantly better design, which will more than pay for the time spent designing it twice. For larger modules you’ll spend more time in the initial design explorations, but the implementation will also take longer, and the benefits of a better design will also be higher.</p>\n<blockquote>\n<p>对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），您可能不需要一两个小时就能考虑替代方法。与您将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。对于较大的模块，您将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。</p>\n</blockquote>\n<p>I have noticed that the design-it-twice principle is sometimes hard for really smart people to embrace. When they are growing up, smart people discover that their first quick idea about any problem is sufficient for a good grade; there is no need to consider a second or third possibility. This makes it easy to develop bad work habits. However, as these people get older, they get promoted into environments with harder and harder problems. Eventually, everyone reaches a point where your first ideas are no longer good enough; if you want to get really great results, you have to consider a second possibility, or perhaps a third, no matter how smart you are. The design of large software systems falls in this category: no-one is good enough to get it right with their first try.</p>\n<blockquote>\n<p>我已经注意到，真正聪明的人有时很难接受两次设计原则。当他们长大后，聪明的人会发现，他们对任何问题的第一个快速构想就足以取得良好的成绩。无需考虑第二种或第三种可能性。这使得容易养成不良的工作习惯。但是，随着这些人变老，他们将被提升到越来越困难的环境中。最终，每个人 ​​ 都达到了您的第一个想法不再足够好的地步。如果您想获得非常好的结果，那么无论您多么聪明，都必须考虑第二种可能性，或者第三种可能性。大型软件系统的设计属于此类：没有人能很好地在首次尝试时就将其正确。</p>\n</blockquote>\n<p>Unfortunately, I often see smart people who insist on implementing the first idea that comes to mind, and this causes them to underperform their true potential (it also makes them frustrating to work with). Perhaps they subconsciously believe that “smart people get it right the first time,” so if they try multiple designs it would mean they are not smart after all. This is not the case. It isn’t that you aren’t smart; it’s that the problems are really hard! Furthermore, that’s a good thing: it’s much more fun to work on a difficult problem where you have to think carefully, rather than an easy problem where you don’t have to think at all.</p>\n<blockquote>\n<p>不幸的是，我经常看到聪明的人坚持要实现第一个想到的想法，这会使他们无法发挥其真正的潜力（这也使他们沮丧地工作）。也许他们下意识地相信“聪明的人第一次就能做到”，因此，如果他们尝试多种设计，那将意味着他们毕竟并不聪明。不是这种情况。不是说你不聪明；问题真的很难解决！此外，这是一件好事：处理一个必须认真思考的难题比处理一个根本不需要思考的难题更有趣。</p>\n</blockquote>\n<p>The design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approaches will teach you about the factors that make designs better or worse. Over time, this will make it easier for you to rule out bad designs and hone in on really great ones.</p>\n<blockquote>\n<p>“两次设计”方法不仅可以改善您的设计，而且可以提高您的设计技能。设计和比较多种方法的过程将教您使设计更好或更坏的因素。随着时间的流逝，这将使您更容易排除不良的设计并磨练真正的出色设计。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>设计它两次</p>","more":"<h1 id=\"第-11-章-设计它两次\"><a href=\"#第-11-章-设计它两次\" class=\"headerlink\" title=\"第 11 章 设计它两次\"></a>第 11 章 设计它两次</h1><blockquote>\n<p>Chapter 11 Design it Twice</p>\n</blockquote>\n<p>Designing software is hard, so it’s unlikely that your first thoughts about how to structure a module or system will produce the best design. You’ll end up with a much better result if you consider multiple options for each major design decision: design it twice.</p>\n<blockquote>\n<p>设计软件非常困难，因此您对如何构造模块或系统的初步思考不太可能会产生最佳的设计。如果为每个主要设计决策考虑多个选项，最终将获得更好的结果：设计两次。</p>\n</blockquote>\n<p>Suppose you are designing the class that will manage the text of a file for a GUI text editor. The first step is to define the interface that the class will present to the rest of the editor; rather than picking the first idea that comes to mind, consider several possibilities. One choice is a line-oriented interface, with operations to insert, modify, and delete whole lines of text. Another option is an interface based on individual character insertions and deletions. A third choice is a string-oriented interface, which operates on arbitrary ranges of characters that may cross line boundaries. You don’t need to pin down every feature of each alternative; it’s sufficient at this point to sketch out a few of the most important methods.</p>\n<blockquote>\n<p>假设您正在设计用于管理 GUI 文本编辑器文件文本的类。第一步是定义该类将呈现给编辑器其余部分的接口。与其选择想到的第一个想法，不如考虑几种可能性。一种选择是面向行的界面，该界面具有插入，修改和删除整行文本的操作。另一个选择是基于单个字符插入和删除的接口。第三种选择是面向字符串的接口，该接口可对可能跨越线边界的任意范围的字符进行操作。您无需确定每个替代方案的每个功能；在这一点上，勾勒出一些最重要的方法就足够了。</p>\n</blockquote>\n<p>Try to pick approaches that are radically different from each other; you’ll learn more that way. Even if you are certain that there is only one reasonable approach, consider a second design anyway, no matter how bad you think it will be. It will be instructive to think about the weaknesses of that design and contrast them with the features of other designs.</p>\n<blockquote>\n<p>尝试选择彼此根本不同的方法；这样您将学到更多。即使您确定只有一种合理的方法，无论您认为有多糟糕，都应该考虑第二种设计。考虑该设计的弱点并将它们与其他设计的特征进行对比将很有启发性。</p>\n</blockquote>\n<p>After you have roughed out the designs for the alternatives, make a list of the pros and cons of each one. The most important consideration for an interface is ease of use for higher level software. In the example above, both the line-oriented interface and the character-oriented interface will require extra work in software that uses the text class. The line-oriented interface will require higher level software to split and join lines during partial-line and multi-line operations such as cutting and pasting the selection. The character-oriented interface will require loops to implement operations that modify more than a single character. It is also worth considering other factors:</p>\n<blockquote>\n<p>在对备选方案进行粗略设计之后，列出每个方案的优缺点。接口最重要的考虑因素是高级软件的易用性。在上面的示例中，面向行的界面和面向字符的界面都需要使用文本类的软件中的额外工作。面向行的界面将需要更高级别的软件来在部分行和多行操作（例如剪切和粘贴所选内容）期间拆分和合并行。面向字符的接口将需要循环来实现修改多个字符的操作。还值得考虑其他因素：</p>\n</blockquote>\n<ul>\n<li>Does one alternative have a simpler interface than another? In the text example, all of the text interfaces are relatively simple.</li>\n<li>Is one interface more general-purpose than another?</li>\n<li>Does one interface enable a more efficient implementation than another? In the text example, the character-oriented approach is likely to be significantly slower than the others, because it requires a separate call into the text module for each character.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>一种选择是否具有比另一种更简单的界面？在文本示例中，所有文本界面都相对简单。</li>\n<li>一个接口比另一个接口更通用吗？</li>\n<li>一个接口是否比另一个接口更有效地实现？在文本示例中，面向字符的方法可能比其他方法慢得多，因为它需要为每个字符单独调用文本模块。</li>\n</ul>\n</blockquote>\n<p>Once you have compared alternative designs, you will be in a better position to identify the best design. The best choice may be one of the alternatives, or you may discover that you can combine features of multiple alternatives into a new design that is better than any of the original choices.</p>\n<blockquote>\n<p>比较了备选设计之后，您将可以更好地确定最佳设计。最佳选择可能是这些选择之一，或者您可能发现可以将多个选择的功能组合到一个比任何原始选择都要好的新设计中。</p>\n</blockquote>\n<p>Sometimes none of the alternatives is particularly attractive; when this happens, see if you can come up with additional schemes. Use the problems you identified with the original alternatives to drive the new design(s). If you were designing the text class and considered only the line-oriented and character-oriented approaches, you might notice that each of the alternatives is awkward because it requires higher level software to perform additional text manipulations. That’s a red flag: if there’s going to be a text class, it should handle all of the text manipulation. In order to eliminate the additional text manipulations, the text interface needs to match more closely the operations happening in higher level software. These operations don’t always correspond to single characters or single lines. This line of reasoning should lead you to a range-oriented API for text, which eliminates the problem with the earlier designs.</p>\n<blockquote>\n<p>有时，没有其他选择特别有吸引力。发生这种情况时，请查看是否可以提出其他方案。使用您在原始替代方案中发现的问题来推动新设计。如果您在设计文本类并且仅考虑面向行和面向字符的方法，则可能会注意到每个替代方案都比较笨拙，因为它需要更高级别的软件来执行其他文本操作。那是一个危险信号：如果要有一个文本类，它应该处理所有文本操作。为了消除其他文本操作，文本界面需要更紧密地匹配高级软件中发生的操作。这些操作并不总是对应于单个字符或一行。</p>\n</blockquote>\n<p>The design-it-twice principle can be applied at many levels in a system. For a module, you can use this approach first to pick the interface, as described above. Then you can apply it again when you are designing the implementation: for the text class, you might consider implementations such as a linked list of lines, fixed-size blocks of characters, or a “gap buffer.” The goals will be different for the implementation than for the interface: for the implementation, the most important things are simplicity and performance. It’s also useful to explore multiple designs at higher levels in the system, such as when choosing features for a user interface, or when decomposing a system into major modules. In each case, it’s easier to identify the best approach if you can compare a few alternatives.</p>\n<blockquote>\n<p>两次设计原则可以在系统的许多级别上应用。对于模块，您可以首先使用此方法来选择接口，如上所述。然后，您可以在设计实现时再次应用它：对于文本类，您可以考虑实现这些实现，例如行的链接列表，固定大小的字符块或“间隙缓冲区”。实现的目标与接口的目标是不同的：对于实现，最重要的是简单性和性能。在系统的更高层次上探索多种设计也很有用，例如在为用户界面选择功能或将系统分解为主要模块时。在每种情况下，如果您可以比较几种选择，则更容易确定最佳方法。</p>\n</blockquote>\n<p>Designing it twice does not need to take a lot of extra time. For a smaller module such as a class, you may not need more than an hour or two to consider alternatives. This is a small amount of time compared to the days or weeks you will spend implementing the class. The initial design experiments will probably result in a significantly better design, which will more than pay for the time spent designing it twice. For larger modules you’ll spend more time in the initial design explorations, but the implementation will also take longer, and the benefits of a better design will also be higher.</p>\n<blockquote>\n<p>对其进行两次设计不需要花费很多额外的时间。对于较小的模块（如课程），您可能不需要一两个小时就能考虑替代方法。与您将花费数天或数周时间来实施该课程相比，这是很少的时间。最初的设计实验可能会导致明显更好的设计，这将比花两次设计时间所花的时间多。对于较大的模块，您将花费更多的时间进行初始设计探索，但是实现也将花费更长的时间，并且更好的设计所带来的好处也会更高。</p>\n</blockquote>\n<p>I have noticed that the design-it-twice principle is sometimes hard for really smart people to embrace. When they are growing up, smart people discover that their first quick idea about any problem is sufficient for a good grade; there is no need to consider a second or third possibility. This makes it easy to develop bad work habits. However, as these people get older, they get promoted into environments with harder and harder problems. Eventually, everyone reaches a point where your first ideas are no longer good enough; if you want to get really great results, you have to consider a second possibility, or perhaps a third, no matter how smart you are. The design of large software systems falls in this category: no-one is good enough to get it right with their first try.</p>\n<blockquote>\n<p>我已经注意到，真正聪明的人有时很难接受两次设计原则。当他们长大后，聪明的人会发现，他们对任何问题的第一个快速构想就足以取得良好的成绩。无需考虑第二种或第三种可能性。这使得容易养成不良的工作习惯。但是，随着这些人变老，他们将被提升到越来越困难的环境中。最终，每个人 ​​ 都达到了您的第一个想法不再足够好的地步。如果您想获得非常好的结果，那么无论您多么聪明，都必须考虑第二种可能性，或者第三种可能性。大型软件系统的设计属于此类：没有人能很好地在首次尝试时就将其正确。</p>\n</blockquote>\n<p>Unfortunately, I often see smart people who insist on implementing the first idea that comes to mind, and this causes them to underperform their true potential (it also makes them frustrating to work with). Perhaps they subconsciously believe that “smart people get it right the first time,” so if they try multiple designs it would mean they are not smart after all. This is not the case. It isn’t that you aren’t smart; it’s that the problems are really hard! Furthermore, that’s a good thing: it’s much more fun to work on a difficult problem where you have to think carefully, rather than an easy problem where you don’t have to think at all.</p>\n<blockquote>\n<p>不幸的是，我经常看到聪明的人坚持要实现第一个想到的想法，这会使他们无法发挥其真正的潜力（这也使他们沮丧地工作）。也许他们下意识地相信“聪明的人第一次就能做到”，因此，如果他们尝试多种设计，那将意味着他们毕竟并不聪明。不是这种情况。不是说你不聪明；问题真的很难解决！此外，这是一件好事：处理一个必须认真思考的难题比处理一个根本不需要思考的难题更有趣。</p>\n</blockquote>\n<p>The design-it-twice approach not only improves your designs, but it also improves your design skills. The process of devising and comparing multiple approaches will teach you about the factors that make designs better or worse. Over time, this will make it easier for you to rule out bad designs and hone in on really great ones.</p>\n<blockquote>\n<p>“两次设计”方法不仅可以改善您的设计，而且可以提高您的设计技能。设计和比较多种方法的过程将教您使设计更好或更坏的因素。随着时间的流逝，这将使您更容易排除不良的设计并磨练真正的出色设计。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch12","date":"2021-02-11T16:00:00.000Z","_content":"为什么写评论呢？四个理由\n<!-- more -->\n# 第 12 章 为什么写评论呢？四个理由\n\n> Chapter 12 Why Write Comments? The Four Excuses\n\nIn-code documentation plays a crucial role in software design. Comments are essential to help developers understand a system and work efficiently, but the role of comments goes beyond this. Documentation also plays an important role in abstraction; without comments, you can’t hide complexity. Finally, the process of writing comments, if done correctly, will actually improve a system’s design. Conversely, a good software design loses much of its value if it is poorly documented.\n\n> 代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有评论，您就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。\n\nUnfortunately, this view is not universally shared. A significant fraction of production code contains essentially no comments. Many developers think that comments are a waste of time; others see the value in comments, but somehow never get around to writing them. Fortunately, many development teams recognize the value of documentation, and it feels like the prevalence of these teams is gradually increasing. However, even in teams that encourage documentation, comments are often viewed as drudge work and many developers don’t understand how to write them, so the resulting documentation is often mediocre. Inadequate documentation creates a huge and unnecessary drag on software development.\n\n> 不幸的是，这种观点并未得到普遍认同。生产代码的很大一部分基本上不包含任何注释。许多开发人员认为评论是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。\n\nIn this chapter I will discuss the excuses developers use to avoid writing comments, and the reasons why comments really do matter. Chapter 13 will then describe how to write good comments and the next few chapters after that will discuss related issues such as choosing variable names and how to use documentation to improve a system’s design. I hope these chapters will convince you of three things: good comments can make a big difference in the overall quality of software; it isn’t hard to write good comments; and (this may be hard to believe) writing comments can actually be fun.\n\n> 在本章中，我将讨论开发人员避免写评论的借口，以及评论真正重要的原因。然后，第 13 章将描述如何编写好的注释，其后的几章将讨论相关问题，例如选择变量名以及如何使用文档来改进系统的设计。我希望这些章节能使您相信三件事：好的评论可以对软件的整体质量产生很大的影响；写好评论并不难；并且（可能很难相信）写评论实际上很有趣。\n\nWhen developers don’t write comments, they usually justify their behavior with one or more of the following excuses:\n\n> 当开发人员不发表评论时，他们通常会以以下一种或多种借口为自己的行为辩护：\n\n- “Good code is self-documenting.”\n- “I don’t have time to write comments.”\n- “Comments get out of date and become misleading.”\n- “The comments I have seen are all worthless; why bother?” In the sections below I will address each of these excuses in turn.\n\n---\n\n> - “好的代码可以自我记录。”\n> - “我没有时间写评论。”\n> - “评论过时，并会产生误导。”\n> - “我所看到的评论都是毫无价值的；何必？” 在以下各节中，我将依次讨论这些借口。\n\n## 12.1 Good code is self-documenting 好的代码可以自我记录\n\nSome people believe that if code is written well, it is so obvious that no comments are needed. This is a delicious myth, like a rumor that ice cream is good for your health: we’d really like to believe it! Unfortunately, it’s simply not true. To be sure, there are things you can do when writing code to reduce the need for comments, such as choosing good variable names (see Chapter 14). Nonetheless, there is still a significant amount of design information that can’t be represented in code. For example, only a small part of a class’s interface, such as the signatures of its methods, can be specified formally in the code. The informal aspects of an interface, such as a high-level description of what each method does or the meaning of its result, can only be described in comments. There are many other examples of things that can’t be described in the code, such as the rationale for a particular design decision, or the conditions under which it makes sense to call a particular method.\n\n> 有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对您的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名（请参阅第 14 章）。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。界面的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。\n\nSome developers argue that if others want to know what a method does, they should just read the code of the method: this will be more accurate than any comment. It’s possible that a reader could deduce the abstract interface of the method by reading its code, but it would be time-consuming and painful. In addition, if you write code with the expectation that users will read method implementations, you will try to make each method as short as possible, so that it’s easy to read. If the method does anything nontrivial, you will break it up into several smaller methods. This will result in a large number of shallow methods. Furthermore, it doesn’t really make the code easier to read: in order to understand the behavior of the top-level method, readers will probably need to understand the behaviors of the nested methods. For large systems it isn’t practical for users to read the code to learn the behavior.\n\n> 一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既费时又痛苦。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。\n\nMoreover, comments are fundamental to abstractions. Recall from Chapter 4 that the goal of abstractions is to hide complexity: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed. Without comments, the only abstraction of a method is its declaration, which specifies its name and the names and types of its arguments and results. The declaration is missing too much essential information to provide a useful abstraction by itself. For example, a method to extract a substring might have two arguments, start and end, indicating the range of characters to extract. From the declaration alone, it isn’t possible to tell whether the extracted substring will include the character indicated by end, or what happens if start > end. Comments allow us to capture the additional information that callers need, thereby completing the simplified view while hiding implementation details. It’s also important that comments are written in a human language such as English; this makes them less precise than code, but it provides more expressive power, so we can create simple, intuitive descriptions. If you want to use abstractions to hide complexity, comments are essential.\n\n> 此外，注释是抽象的基础。回顾第四章，抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以安全忽略的细节。如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 end 指示的字符，或者如果 start> end 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。\n\n## 12.2 I don’t have time to write comments 我没有时间写评论\n\nIt’s tempting to prioritize comments lower than other development tasks. Given a choice between adding a new feature and documenting an existing feature, it seems logical to choose the new feature. However, software projects are almost always under time pressure, and there will always be things that seem higher priority than writing comments. Thus, if you allow documentation to be de-prioritized, you’ll end up with no documentation.\n\n> 优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果您允许取消对文档的优先级，则最终将没有文档。\n\nThe counter-argument to this excuse is the investment mindset discussed on page 15. If you want a clean software structure, which will allow you to work efficiently over the long-term, then you must take some extra time up front in order to create that structure. Good comments make a huge difference in the maintainability of software, so the effort spent on them will pay for itself quickly. Furthermore, writing comments needn’t take a lot of time. Ask yourself how much of your development time you spend typing in code (as opposed to designing, compiling, testing, etc.), assuming you don’t include any comments; I doubt that the answer is more than 10%. Now suppose that you spend as much time typing comments as typing code; this should be a safe upper bound. With these assumptions, writing good comments won’t add more than about 10% to your development time. The benefits of having good documentation will quickly offset this cost.\n\n> 与该借口相反的是第 15 页上讨论的投资思路。如果您想要一个干净的软件结构，可以长期有效地工作，那么您必须花一些额外的时间才能创建该结构。好的评论对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写评论不需要花费很多时间。询问自己，假设您不包含任何注释，那么您花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设您花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的评论不会增加您的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。\n\nFurthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods. Chapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an important design tool that improves the overall design. These comments pay for themselves immediately.\n\n> 此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。第 15 章认为，这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些评论立即付诸行动。\n\n## 12.3 Comments get out of date and become misleading 评论过时并产生误导\n\nComments do sometimes get out of date, but this need not be a major problem in practice. Keeping documentation up-to-date does not require an enormous effort. Large changes to the documentation are only required if there have been large changes to the code, and the code changes will take more time than the documentation changes. Chapter 16 discusses how to organize documentation so that it is as easy as possible to keep it updated after code modifications (the key ideas are to avoid duplicated documentation and keep the documentation close to the corresponding code). Code reviews provide a great mechanism for detecting and fixing stale comments.\n\n> 注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。第 16 章讨论了如何组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。\n\n## 12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的\n\nOf the four excuses, this is probably the one with the most merit. Every software developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem is solvable; writing solid documentation is not hard, once you know how. The next chapters will lay out a framework for how to write good documentation and maintain it over time.\n\n> 在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。下一章将为如何编写良好的文档并随时间进行维护提供一个框架。\n\n## 12.5 Benefits of well-written comments\n\nNow that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments. The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code. This information ranges from low-level details, such as a hardware quirk that motivates a particularly tricky piece of code, up to high-level concepts such as the rationale for a class. When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately. Without documentation, future developers will have to rederive or guess at the developer’s original knowledge; this will take additional time, and there is a risk of bugs if the new developer misunderstands the original designer’s intentions. Comments are valuable even when the original designer is the one making the changes: if it has been more than a few weeks since you last worked in a piece of code, you will have forgotten many of the details of the original design.\n\n> 既然我已经讨论了（并希望揭穿了这些）反对撰写评论的论点，让我们考虑一下从良好评论中将获得的好处。注释背后的总体思想是捕获设计者所想但不能在代码中表示的信息。这些信息从低级详细信息（例如，激发特殊代码的硬件怪癖）到高级概念（例如，类的基本原理）。当其他开发人员稍后进行修改时，这些注释将使他们能够更快，更准确地工作。没有文档，未来的开发人员将不得不重新编写或猜测开发人员的原始知识。这将花费额外的时间，并且如果新开发者误解了原始设计者的意图，则存在错误的风险。\n\nChapter 2 described three ways in which complexity manifests itself in software systems:\n\n> 第 2 章介绍了在软件系统中表现出复杂性的三种方式：\n\n- Change amplification: a seemingly simple change requires code modifications in many places.\n- Cognitive load: in order to make a change, the developer must accumulate a large amount of information.\n- Unknown unknowns: it is unclear what code needs to be modified, or what information must be considered in order to make those modifications.\n\n---\n\n> - 变更放大：看似简单的变更需要在许多地方进行代码修改。\n> - 认知负荷：为了进行更改，开发人员必须积累大量信息。\n> - 未知未知数：尚不清楚需要修改哪些代码，或必须考虑哪些信息才能进行这些修改。\n\nGood documentation helps with the last two of these issues. Documentation can reduce cognitive load by providing developers with the information they need to make changes and by making it easy for developers to ignore information that is irrelevant. Without adequate documentation, developers may have to read large amounts of code to reconstruct what was in the designer’s mind. Documentation can also reduce the unknown unknowns by clarifying the structure of the system, so that it is clear what information and code is relevant for any given change.\n\n> 好的文档可以帮助解决最后两个问题。通过为开发人员提供他们进行更改所需的信息，并使开发人员容易忽略不相关的信息，文档可以减轻认知负担。没有足够的文档，开发人员可能必须阅读大量代码才能重构设计人员的想法。文档还可以通过阐明系统的结构来减少未知的未知数，从而可以清楚地了解与任何给定更改相关的信息和代码。\n\nChapter 2 pointed out that the primary causes of complexity are dependencies and obscurity. Good documentation can clarify dependencies, and it fills in gaps to eliminate obscurity.\n\n> 第 2 章指出，导致复杂性的主要原因是依赖性和模糊性。好的文档可以阐明依赖关系，并且可以填补空白以消除模糊性。\n\nThe next few chapters will show you how to write good documentation. They will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.\n\n> 接下来的几章将向您展示如何编写好的文档。他们还将讨论如何将文档编写集成到设计过程中，从而改善软件设计。\n","source":"_posts/软件设计的哲学-ch12.md","raw":"---\ntitle: 软件设计的哲学 - ch12\ndate: 2021-02-12\ntags: 软件设计的哲学 软件开发 方法论\n---\n为什么写评论呢？四个理由\n<!-- more -->\n# 第 12 章 为什么写评论呢？四个理由\n\n> Chapter 12 Why Write Comments? The Four Excuses\n\nIn-code documentation plays a crucial role in software design. Comments are essential to help developers understand a system and work efficiently, but the role of comments goes beyond this. Documentation also plays an important role in abstraction; without comments, you can’t hide complexity. Finally, the process of writing comments, if done correctly, will actually improve a system’s design. Conversely, a good software design loses much of its value if it is poorly documented.\n\n> 代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有评论，您就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。\n\nUnfortunately, this view is not universally shared. A significant fraction of production code contains essentially no comments. Many developers think that comments are a waste of time; others see the value in comments, but somehow never get around to writing them. Fortunately, many development teams recognize the value of documentation, and it feels like the prevalence of these teams is gradually increasing. However, even in teams that encourage documentation, comments are often viewed as drudge work and many developers don’t understand how to write them, so the resulting documentation is often mediocre. Inadequate documentation creates a huge and unnecessary drag on software development.\n\n> 不幸的是，这种观点并未得到普遍认同。生产代码的很大一部分基本上不包含任何注释。许多开发人员认为评论是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。\n\nIn this chapter I will discuss the excuses developers use to avoid writing comments, and the reasons why comments really do matter. Chapter 13 will then describe how to write good comments and the next few chapters after that will discuss related issues such as choosing variable names and how to use documentation to improve a system’s design. I hope these chapters will convince you of three things: good comments can make a big difference in the overall quality of software; it isn’t hard to write good comments; and (this may be hard to believe) writing comments can actually be fun.\n\n> 在本章中，我将讨论开发人员避免写评论的借口，以及评论真正重要的原因。然后，第 13 章将描述如何编写好的注释，其后的几章将讨论相关问题，例如选择变量名以及如何使用文档来改进系统的设计。我希望这些章节能使您相信三件事：好的评论可以对软件的整体质量产生很大的影响；写好评论并不难；并且（可能很难相信）写评论实际上很有趣。\n\nWhen developers don’t write comments, they usually justify their behavior with one or more of the following excuses:\n\n> 当开发人员不发表评论时，他们通常会以以下一种或多种借口为自己的行为辩护：\n\n- “Good code is self-documenting.”\n- “I don’t have time to write comments.”\n- “Comments get out of date and become misleading.”\n- “The comments I have seen are all worthless; why bother?” In the sections below I will address each of these excuses in turn.\n\n---\n\n> - “好的代码可以自我记录。”\n> - “我没有时间写评论。”\n> - “评论过时，并会产生误导。”\n> - “我所看到的评论都是毫无价值的；何必？” 在以下各节中，我将依次讨论这些借口。\n\n## 12.1 Good code is self-documenting 好的代码可以自我记录\n\nSome people believe that if code is written well, it is so obvious that no comments are needed. This is a delicious myth, like a rumor that ice cream is good for your health: we’d really like to believe it! Unfortunately, it’s simply not true. To be sure, there are things you can do when writing code to reduce the need for comments, such as choosing good variable names (see Chapter 14). Nonetheless, there is still a significant amount of design information that can’t be represented in code. For example, only a small part of a class’s interface, such as the signatures of its methods, can be specified formally in the code. The informal aspects of an interface, such as a high-level description of what each method does or the meaning of its result, can only be described in comments. There are many other examples of things that can’t be described in the code, such as the rationale for a particular design decision, or the conditions under which it makes sense to call a particular method.\n\n> 有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对您的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名（请参阅第 14 章）。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。界面的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。\n\nSome developers argue that if others want to know what a method does, they should just read the code of the method: this will be more accurate than any comment. It’s possible that a reader could deduce the abstract interface of the method by reading its code, but it would be time-consuming and painful. In addition, if you write code with the expectation that users will read method implementations, you will try to make each method as short as possible, so that it’s easy to read. If the method does anything nontrivial, you will break it up into several smaller methods. This will result in a large number of shallow methods. Furthermore, it doesn’t really make the code easier to read: in order to understand the behavior of the top-level method, readers will probably need to understand the behaviors of the nested methods. For large systems it isn’t practical for users to read the code to learn the behavior.\n\n> 一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既费时又痛苦。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。\n\nMoreover, comments are fundamental to abstractions. Recall from Chapter 4 that the goal of abstractions is to hide complexity: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed. Without comments, the only abstraction of a method is its declaration, which specifies its name and the names and types of its arguments and results. The declaration is missing too much essential information to provide a useful abstraction by itself. For example, a method to extract a substring might have two arguments, start and end, indicating the range of characters to extract. From the declaration alone, it isn’t possible to tell whether the extracted substring will include the character indicated by end, or what happens if start > end. Comments allow us to capture the additional information that callers need, thereby completing the simplified view while hiding implementation details. It’s also important that comments are written in a human language such as English; this makes them less precise than code, but it provides more expressive power, so we can create simple, intuitive descriptions. If you want to use abstractions to hide complexity, comments are essential.\n\n> 此外，注释是抽象的基础。回顾第四章，抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以安全忽略的细节。如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 end 指示的字符，或者如果 start> end 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。\n\n## 12.2 I don’t have time to write comments 我没有时间写评论\n\nIt’s tempting to prioritize comments lower than other development tasks. Given a choice between adding a new feature and documenting an existing feature, it seems logical to choose the new feature. However, software projects are almost always under time pressure, and there will always be things that seem higher priority than writing comments. Thus, if you allow documentation to be de-prioritized, you’ll end up with no documentation.\n\n> 优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果您允许取消对文档的优先级，则最终将没有文档。\n\nThe counter-argument to this excuse is the investment mindset discussed on page 15. If you want a clean software structure, which will allow you to work efficiently over the long-term, then you must take some extra time up front in order to create that structure. Good comments make a huge difference in the maintainability of software, so the effort spent on them will pay for itself quickly. Furthermore, writing comments needn’t take a lot of time. Ask yourself how much of your development time you spend typing in code (as opposed to designing, compiling, testing, etc.), assuming you don’t include any comments; I doubt that the answer is more than 10%. Now suppose that you spend as much time typing comments as typing code; this should be a safe upper bound. With these assumptions, writing good comments won’t add more than about 10% to your development time. The benefits of having good documentation will quickly offset this cost.\n\n> 与该借口相反的是第 15 页上讨论的投资思路。如果您想要一个干净的软件结构，可以长期有效地工作，那么您必须花一些额外的时间才能创建该结构。好的评论对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写评论不需要花费很多时间。询问自己，假设您不包含任何注释，那么您花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设您花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的评论不会增加您的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。\n\nFurthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods. Chapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an important design tool that improves the overall design. These comments pay for themselves immediately.\n\n> 此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。第 15 章认为，这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些评论立即付诸行动。\n\n## 12.3 Comments get out of date and become misleading 评论过时并产生误导\n\nComments do sometimes get out of date, but this need not be a major problem in practice. Keeping documentation up-to-date does not require an enormous effort. Large changes to the documentation are only required if there have been large changes to the code, and the code changes will take more time than the documentation changes. Chapter 16 discusses how to organize documentation so that it is as easy as possible to keep it updated after code modifications (the key ideas are to avoid duplicated documentation and keep the documentation close to the corresponding code). Code reviews provide a great mechanism for detecting and fixing stale comments.\n\n> 注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。第 16 章讨论了如何组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。\n\n## 12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的\n\nOf the four excuses, this is probably the one with the most merit. Every software developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem is solvable; writing solid documentation is not hard, once you know how. The next chapters will lay out a framework for how to write good documentation and maintain it over time.\n\n> 在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。下一章将为如何编写良好的文档并随时间进行维护提供一个框架。\n\n## 12.5 Benefits of well-written comments\n\nNow that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments. The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code. This information ranges from low-level details, such as a hardware quirk that motivates a particularly tricky piece of code, up to high-level concepts such as the rationale for a class. When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately. Without documentation, future developers will have to rederive or guess at the developer’s original knowledge; this will take additional time, and there is a risk of bugs if the new developer misunderstands the original designer’s intentions. Comments are valuable even when the original designer is the one making the changes: if it has been more than a few weeks since you last worked in a piece of code, you will have forgotten many of the details of the original design.\n\n> 既然我已经讨论了（并希望揭穿了这些）反对撰写评论的论点，让我们考虑一下从良好评论中将获得的好处。注释背后的总体思想是捕获设计者所想但不能在代码中表示的信息。这些信息从低级详细信息（例如，激发特殊代码的硬件怪癖）到高级概念（例如，类的基本原理）。当其他开发人员稍后进行修改时，这些注释将使他们能够更快，更准确地工作。没有文档，未来的开发人员将不得不重新编写或猜测开发人员的原始知识。这将花费额外的时间，并且如果新开发者误解了原始设计者的意图，则存在错误的风险。\n\nChapter 2 described three ways in which complexity manifests itself in software systems:\n\n> 第 2 章介绍了在软件系统中表现出复杂性的三种方式：\n\n- Change amplification: a seemingly simple change requires code modifications in many places.\n- Cognitive load: in order to make a change, the developer must accumulate a large amount of information.\n- Unknown unknowns: it is unclear what code needs to be modified, or what information must be considered in order to make those modifications.\n\n---\n\n> - 变更放大：看似简单的变更需要在许多地方进行代码修改。\n> - 认知负荷：为了进行更改，开发人员必须积累大量信息。\n> - 未知未知数：尚不清楚需要修改哪些代码，或必须考虑哪些信息才能进行这些修改。\n\nGood documentation helps with the last two of these issues. Documentation can reduce cognitive load by providing developers with the information they need to make changes and by making it easy for developers to ignore information that is irrelevant. Without adequate documentation, developers may have to read large amounts of code to reconstruct what was in the designer’s mind. Documentation can also reduce the unknown unknowns by clarifying the structure of the system, so that it is clear what information and code is relevant for any given change.\n\n> 好的文档可以帮助解决最后两个问题。通过为开发人员提供他们进行更改所需的信息，并使开发人员容易忽略不相关的信息，文档可以减轻认知负担。没有足够的文档，开发人员可能必须阅读大量代码才能重构设计人员的想法。文档还可以通过阐明系统的结构来减少未知的未知数，从而可以清楚地了解与任何给定更改相关的信息和代码。\n\nChapter 2 pointed out that the primary causes of complexity are dependencies and obscurity. Good documentation can clarify dependencies, and it fills in gaps to eliminate obscurity.\n\n> 第 2 章指出，导致复杂性的主要原因是依赖性和模糊性。好的文档可以阐明依赖关系，并且可以填补空白以消除模糊性。\n\nThe next few chapters will show you how to write good documentation. They will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.\n\n> 接下来的几章将向您展示如何编写好的文档。他们还将讨论如何将文档编写集成到设计过程中，从而改善软件设计。\n","slug":"软件设计的哲学-ch12","published":1,"updated":"2021-02-16T04:53:38.256Z","_id":"ckl7iw2vk0009kiiygbex2pak","comments":1,"layout":"post","photos":[],"link":"","content":"<p>为什么写评论呢？四个理由</p>\n<a id=\"more\"></a>\n<h1 id=\"第-12-章-为什么写评论呢？四个理由\"><a href=\"#第-12-章-为什么写评论呢？四个理由\" class=\"headerlink\" title=\"第 12 章 为什么写评论呢？四个理由\"></a>第 12 章 为什么写评论呢？四个理由</h1><blockquote>\n<p>Chapter 12 Why Write Comments? The Four Excuses</p>\n</blockquote>\n<p>In-code documentation plays a crucial role in software design. Comments are essential to help developers understand a system and work efficiently, but the role of comments goes beyond this. Documentation also plays an important role in abstraction; without comments, you can’t hide complexity. Finally, the process of writing comments, if done correctly, will actually improve a system’s design. Conversely, a good software design loses much of its value if it is poorly documented.</p>\n<blockquote>\n<p>代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有评论，您就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。</p>\n</blockquote>\n<p>Unfortunately, this view is not universally shared. A significant fraction of production code contains essentially no comments. Many developers think that comments are a waste of time; others see the value in comments, but somehow never get around to writing them. Fortunately, many development teams recognize the value of documentation, and it feels like the prevalence of these teams is gradually increasing. However, even in teams that encourage documentation, comments are often viewed as drudge work and many developers don’t understand how to write them, so the resulting documentation is often mediocre. Inadequate documentation creates a huge and unnecessary drag on software development.</p>\n<blockquote>\n<p>不幸的是，这种观点并未得到普遍认同。生产代码的很大一部分基本上不包含任何注释。许多开发人员认为评论是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。</p>\n</blockquote>\n<p>In this chapter I will discuss the excuses developers use to avoid writing comments, and the reasons why comments really do matter. Chapter 13 will then describe how to write good comments and the next few chapters after that will discuss related issues such as choosing variable names and how to use documentation to improve a system’s design. I hope these chapters will convince you of three things: good comments can make a big difference in the overall quality of software; it isn’t hard to write good comments; and (this may be hard to believe) writing comments can actually be fun.</p>\n<blockquote>\n<p>在本章中，我将讨论开发人员避免写评论的借口，以及评论真正重要的原因。然后，第 13 章将描述如何编写好的注释，其后的几章将讨论相关问题，例如选择变量名以及如何使用文档来改进系统的设计。我希望这些章节能使您相信三件事：好的评论可以对软件的整体质量产生很大的影响；写好评论并不难；并且（可能很难相信）写评论实际上很有趣。</p>\n</blockquote>\n<p>When developers don’t write comments, they usually justify their behavior with one or more of the following excuses:</p>\n<blockquote>\n<p>当开发人员不发表评论时，他们通常会以以下一种或多种借口为自己的行为辩护：</p>\n</blockquote>\n<ul>\n<li>“Good code is self-documenting.”</li>\n<li>“I don’t have time to write comments.”</li>\n<li>“Comments get out of date and become misleading.”</li>\n<li>“The comments I have seen are all worthless; why bother?” In the sections below I will address each of these excuses in turn.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>“好的代码可以自我记录。”</li>\n<li>“我没有时间写评论。”</li>\n<li>“评论过时，并会产生误导。”</li>\n<li>“我所看到的评论都是毫无价值的；何必？” 在以下各节中，我将依次讨论这些借口。</li>\n</ul>\n</blockquote>\n<h2 id=\"12-1-Good-code-is-self-documenting-好的代码可以自我记录\"><a href=\"#12-1-Good-code-is-self-documenting-好的代码可以自我记录\" class=\"headerlink\" title=\"12.1 Good code is self-documenting 好的代码可以自我记录\"></a>12.1 Good code is self-documenting 好的代码可以自我记录</h2><p>Some people believe that if code is written well, it is so obvious that no comments are needed. This is a delicious myth, like a rumor that ice cream is good for your health: we’d really like to believe it! Unfortunately, it’s simply not true. To be sure, there are things you can do when writing code to reduce the need for comments, such as choosing good variable names (see Chapter 14). Nonetheless, there is still a significant amount of design information that can’t be represented in code. For example, only a small part of a class’s interface, such as the signatures of its methods, can be specified formally in the code. The informal aspects of an interface, such as a high-level description of what each method does or the meaning of its result, can only be described in comments. There are many other examples of things that can’t be described in the code, such as the rationale for a particular design decision, or the conditions under which it makes sense to call a particular method.</p>\n<blockquote>\n<p>有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对您的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名（请参阅第 14 章）。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。界面的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。</p>\n</blockquote>\n<p>Some developers argue that if others want to know what a method does, they should just read the code of the method: this will be more accurate than any comment. It’s possible that a reader could deduce the abstract interface of the method by reading its code, but it would be time-consuming and painful. In addition, if you write code with the expectation that users will read method implementations, you will try to make each method as short as possible, so that it’s easy to read. If the method does anything nontrivial, you will break it up into several smaller methods. This will result in a large number of shallow methods. Furthermore, it doesn’t really make the code easier to read: in order to understand the behavior of the top-level method, readers will probably need to understand the behaviors of the nested methods. For large systems it isn’t practical for users to read the code to learn the behavior.</p>\n<blockquote>\n<p>一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既费时又痛苦。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。</p>\n</blockquote>\n<p>Moreover, comments are fundamental to abstractions. Recall from Chapter 4 that the goal of abstractions is to hide complexity: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed. Without comments, the only abstraction of a method is its declaration, which specifies its name and the names and types of its arguments and results. The declaration is missing too much essential information to provide a useful abstraction by itself. For example, a method to extract a substring might have two arguments, start and end, indicating the range of characters to extract. From the declaration alone, it isn’t possible to tell whether the extracted substring will include the character indicated by end, or what happens if start &gt; end. Comments allow us to capture the additional information that callers need, thereby completing the simplified view while hiding implementation details. It’s also important that comments are written in a human language such as English; this makes them less precise than code, but it provides more expressive power, so we can create simple, intuitive descriptions. If you want to use abstractions to hide complexity, comments are essential.</p>\n<blockquote>\n<p>此外，注释是抽象的基础。回顾第四章，抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以安全忽略的细节。如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 end 指示的字符，或者如果 start&gt; end 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。</p>\n</blockquote>\n<h2 id=\"12-2-I-don’t-have-time-to-write-comments-我没有时间写评论\"><a href=\"#12-2-I-don’t-have-time-to-write-comments-我没有时间写评论\" class=\"headerlink\" title=\"12.2 I don’t have time to write comments 我没有时间写评论\"></a>12.2 I don’t have time to write comments 我没有时间写评论</h2><p>It’s tempting to prioritize comments lower than other development tasks. Given a choice between adding a new feature and documenting an existing feature, it seems logical to choose the new feature. However, software projects are almost always under time pressure, and there will always be things that seem higher priority than writing comments. Thus, if you allow documentation to be de-prioritized, you’ll end up with no documentation.</p>\n<blockquote>\n<p>优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果您允许取消对文档的优先级，则最终将没有文档。</p>\n</blockquote>\n<p>The counter-argument to this excuse is the investment mindset discussed on page 15. If you want a clean software structure, which will allow you to work efficiently over the long-term, then you must take some extra time up front in order to create that structure. Good comments make a huge difference in the maintainability of software, so the effort spent on them will pay for itself quickly. Furthermore, writing comments needn’t take a lot of time. Ask yourself how much of your development time you spend typing in code (as opposed to designing, compiling, testing, etc.), assuming you don’t include any comments; I doubt that the answer is more than 10%. Now suppose that you spend as much time typing comments as typing code; this should be a safe upper bound. With these assumptions, writing good comments won’t add more than about 10% to your development time. The benefits of having good documentation will quickly offset this cost.</p>\n<blockquote>\n<p>与该借口相反的是第 15 页上讨论的投资思路。如果您想要一个干净的软件结构，可以长期有效地工作，那么您必须花一些额外的时间才能创建该结构。好的评论对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写评论不需要花费很多时间。询问自己，假设您不包含任何注释，那么您花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设您花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的评论不会增加您的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。</p>\n</blockquote>\n<p>Furthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods. Chapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an important design tool that improves the overall design. These comments pay for themselves immediately.</p>\n<blockquote>\n<p>此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。第 15 章认为，这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些评论立即付诸行动。</p>\n</blockquote>\n<h2 id=\"12-3-Comments-get-out-of-date-and-become-misleading-评论过时并产生误导\"><a href=\"#12-3-Comments-get-out-of-date-and-become-misleading-评论过时并产生误导\" class=\"headerlink\" title=\"12.3 Comments get out of date and become misleading 评论过时并产生误导\"></a>12.3 Comments get out of date and become misleading 评论过时并产生误导</h2><p>Comments do sometimes get out of date, but this need not be a major problem in practice. Keeping documentation up-to-date does not require an enormous effort. Large changes to the documentation are only required if there have been large changes to the code, and the code changes will take more time than the documentation changes. Chapter 16 discusses how to organize documentation so that it is as easy as possible to keep it updated after code modifications (the key ideas are to avoid duplicated documentation and keep the documentation close to the corresponding code). Code reviews provide a great mechanism for detecting and fixing stale comments.</p>\n<blockquote>\n<p>注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。第 16 章讨论了如何组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。</p>\n</blockquote>\n<h2 id=\"12-4-All-the-comments-I-have-seen-are-worthless-我所看到的所有评论都是毫无价值的\"><a href=\"#12-4-All-the-comments-I-have-seen-are-worthless-我所看到的所有评论都是毫无价值的\" class=\"headerlink\" title=\"12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的\"></a>12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的</h2><p>Of the four excuses, this is probably the one with the most merit. Every software developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem is solvable; writing solid documentation is not hard, once you know how. The next chapters will lay out a framework for how to write good documentation and maintain it over time.</p>\n<blockquote>\n<p>在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。下一章将为如何编写良好的文档并随时间进行维护提供一个框架。</p>\n</blockquote>\n<h2 id=\"12-5-Benefits-of-well-written-comments\"><a href=\"#12-5-Benefits-of-well-written-comments\" class=\"headerlink\" title=\"12.5 Benefits of well-written comments\"></a>12.5 Benefits of well-written comments</h2><p>Now that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments. The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code. This information ranges from low-level details, such as a hardware quirk that motivates a particularly tricky piece of code, up to high-level concepts such as the rationale for a class. When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately. Without documentation, future developers will have to rederive or guess at the developer’s original knowledge; this will take additional time, and there is a risk of bugs if the new developer misunderstands the original designer’s intentions. Comments are valuable even when the original designer is the one making the changes: if it has been more than a few weeks since you last worked in a piece of code, you will have forgotten many of the details of the original design.</p>\n<blockquote>\n<p>既然我已经讨论了（并希望揭穿了这些）反对撰写评论的论点，让我们考虑一下从良好评论中将获得的好处。注释背后的总体思想是捕获设计者所想但不能在代码中表示的信息。这些信息从低级详细信息（例如，激发特殊代码的硬件怪癖）到高级概念（例如，类的基本原理）。当其他开发人员稍后进行修改时，这些注释将使他们能够更快，更准确地工作。没有文档，未来的开发人员将不得不重新编写或猜测开发人员的原始知识。这将花费额外的时间，并且如果新开发者误解了原始设计者的意图，则存在错误的风险。</p>\n</blockquote>\n<p>Chapter 2 described three ways in which complexity manifests itself in software systems:</p>\n<blockquote>\n<p>第 2 章介绍了在软件系统中表现出复杂性的三种方式：</p>\n</blockquote>\n<ul>\n<li>Change amplification: a seemingly simple change requires code modifications in many places.</li>\n<li>Cognitive load: in order to make a change, the developer must accumulate a large amount of information.</li>\n<li>Unknown unknowns: it is unclear what code needs to be modified, or what information must be considered in order to make those modifications.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>变更放大：看似简单的变更需要在许多地方进行代码修改。</li>\n<li>认知负荷：为了进行更改，开发人员必须积累大量信息。</li>\n<li>未知未知数：尚不清楚需要修改哪些代码，或必须考虑哪些信息才能进行这些修改。</li>\n</ul>\n</blockquote>\n<p>Good documentation helps with the last two of these issues. Documentation can reduce cognitive load by providing developers with the information they need to make changes and by making it easy for developers to ignore information that is irrelevant. Without adequate documentation, developers may have to read large amounts of code to reconstruct what was in the designer’s mind. Documentation can also reduce the unknown unknowns by clarifying the structure of the system, so that it is clear what information and code is relevant for any given change.</p>\n<blockquote>\n<p>好的文档可以帮助解决最后两个问题。通过为开发人员提供他们进行更改所需的信息，并使开发人员容易忽略不相关的信息，文档可以减轻认知负担。没有足够的文档，开发人员可能必须阅读大量代码才能重构设计人员的想法。文档还可以通过阐明系统的结构来减少未知的未知数，从而可以清楚地了解与任何给定更改相关的信息和代码。</p>\n</blockquote>\n<p>Chapter 2 pointed out that the primary causes of complexity are dependencies and obscurity. Good documentation can clarify dependencies, and it fills in gaps to eliminate obscurity.</p>\n<blockquote>\n<p>第 2 章指出，导致复杂性的主要原因是依赖性和模糊性。好的文档可以阐明依赖关系，并且可以填补空白以消除模糊性。</p>\n</blockquote>\n<p>The next few chapters will show you how to write good documentation. They will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.</p>\n<blockquote>\n<p>接下来的几章将向您展示如何编写好的文档。他们还将讨论如何将文档编写集成到设计过程中，从而改善软件设计。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>为什么写评论呢？四个理由</p>","more":"<h1 id=\"第-12-章-为什么写评论呢？四个理由\"><a href=\"#第-12-章-为什么写评论呢？四个理由\" class=\"headerlink\" title=\"第 12 章 为什么写评论呢？四个理由\"></a>第 12 章 为什么写评论呢？四个理由</h1><blockquote>\n<p>Chapter 12 Why Write Comments? The Four Excuses</p>\n</blockquote>\n<p>In-code documentation plays a crucial role in software design. Comments are essential to help developers understand a system and work efficiently, but the role of comments goes beyond this. Documentation also plays an important role in abstraction; without comments, you can’t hide complexity. Finally, the process of writing comments, if done correctly, will actually improve a system’s design. Conversely, a good software design loses much of its value if it is poorly documented.</p>\n<blockquote>\n<p>代码内文档在软件设计中起着至关重要的作用。注释对于帮助开发人员理解系统和有效工作至关重要，但是注释的作用不止于此。文档在抽象中也起着重要作用。没有评论，您就无法隐藏复杂性。最后，编写注释的过程（如果正确完成）将实际上改善系统的设计。相反，如果没有很好的文档记录，那么好的软件设计会失去很多价值。</p>\n</blockquote>\n<p>Unfortunately, this view is not universally shared. A significant fraction of production code contains essentially no comments. Many developers think that comments are a waste of time; others see the value in comments, but somehow never get around to writing them. Fortunately, many development teams recognize the value of documentation, and it feels like the prevalence of these teams is gradually increasing. However, even in teams that encourage documentation, comments are often viewed as drudge work and many developers don’t understand how to write them, so the resulting documentation is often mediocre. Inadequate documentation creates a huge and unnecessary drag on software development.</p>\n<blockquote>\n<p>不幸的是，这种观点并未得到普遍认同。生产代码的很大一部分基本上不包含任何注释。许多开发人员认为评论是浪费时间。其他人则看到了注释中的价值，但不知何故从不动手编写它们。幸运的是，许多开发团队认识到了文档的价值，并且感觉这些团队的普及率正在逐渐提高。但是，即使在鼓励文档的团队中，注释也经常被视为繁琐的工作，而且许多开发人员也不了解如何编写注释，因此生成的文档通常是平庸的。文档不足会给软件开发带来巨大且不必要的拖累。</p>\n</blockquote>\n<p>In this chapter I will discuss the excuses developers use to avoid writing comments, and the reasons why comments really do matter. Chapter 13 will then describe how to write good comments and the next few chapters after that will discuss related issues such as choosing variable names and how to use documentation to improve a system’s design. I hope these chapters will convince you of three things: good comments can make a big difference in the overall quality of software; it isn’t hard to write good comments; and (this may be hard to believe) writing comments can actually be fun.</p>\n<blockquote>\n<p>在本章中，我将讨论开发人员避免写评论的借口，以及评论真正重要的原因。然后，第 13 章将描述如何编写好的注释，其后的几章将讨论相关问题，例如选择变量名以及如何使用文档来改进系统的设计。我希望这些章节能使您相信三件事：好的评论可以对软件的整体质量产生很大的影响；写好评论并不难；并且（可能很难相信）写评论实际上很有趣。</p>\n</blockquote>\n<p>When developers don’t write comments, they usually justify their behavior with one or more of the following excuses:</p>\n<blockquote>\n<p>当开发人员不发表评论时，他们通常会以以下一种或多种借口为自己的行为辩护：</p>\n</blockquote>\n<ul>\n<li>“Good code is self-documenting.”</li>\n<li>“I don’t have time to write comments.”</li>\n<li>“Comments get out of date and become misleading.”</li>\n<li>“The comments I have seen are all worthless; why bother?” In the sections below I will address each of these excuses in turn.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>“好的代码可以自我记录。”</li>\n<li>“我没有时间写评论。”</li>\n<li>“评论过时，并会产生误导。”</li>\n<li>“我所看到的评论都是毫无价值的；何必？” 在以下各节中，我将依次讨论这些借口。</li>\n</ul>\n</blockquote>\n<h2 id=\"12-1-Good-code-is-self-documenting-好的代码可以自我记录\"><a href=\"#12-1-Good-code-is-self-documenting-好的代码可以自我记录\" class=\"headerlink\" title=\"12.1 Good code is self-documenting 好的代码可以自我记录\"></a>12.1 Good code is self-documenting 好的代码可以自我记录</h2><p>Some people believe that if code is written well, it is so obvious that no comments are needed. This is a delicious myth, like a rumor that ice cream is good for your health: we’d really like to believe it! Unfortunately, it’s simply not true. To be sure, there are things you can do when writing code to reduce the need for comments, such as choosing good variable names (see Chapter 14). Nonetheless, there is still a significant amount of design information that can’t be represented in code. For example, only a small part of a class’s interface, such as the signatures of its methods, can be specified formally in the code. The informal aspects of an interface, such as a high-level description of what each method does or the meaning of its result, can only be described in comments. There are many other examples of things that can’t be described in the code, such as the rationale for a particular design decision, or the conditions under which it makes sense to call a particular method.</p>\n<blockquote>\n<p>有人认为，如果代码编写得当，那么显而易见，不需要注释。这是一个美味的神话，就像谣言说冰淇淋对您的健康有益：我们真的很想相信！不幸的是，事实并非如此。可以肯定的是，在编写代码时可以做一些事情来减少对注释的需求，例如选择好的变量名（请参阅第 14 章）。尽管如此，仍有大量设计信息无法用代码表示。例如，只能在代码中正式指定类接口的一小部分，例如其方法的签名。界面的非正式方面，例如对每种方法的作用或其结果含义的高级描述，只能在注释中描述。</p>\n</blockquote>\n<p>Some developers argue that if others want to know what a method does, they should just read the code of the method: this will be more accurate than any comment. It’s possible that a reader could deduce the abstract interface of the method by reading its code, but it would be time-consuming and painful. In addition, if you write code with the expectation that users will read method implementations, you will try to make each method as short as possible, so that it’s easy to read. If the method does anything nontrivial, you will break it up into several smaller methods. This will result in a large number of shallow methods. Furthermore, it doesn’t really make the code easier to read: in order to understand the behavior of the top-level method, readers will probably need to understand the behaviors of the nested methods. For large systems it isn’t practical for users to read the code to learn the behavior.</p>\n<blockquote>\n<p>一些开发人员认为，如果其他人想知道某个方法的作用，那么他们应该只阅读该方法的代码：这将比任何注释都更准确。读者可能会通过阅读其代码来推断该方法的抽象接口，但这既费时又痛苦。另外，如果在编写代码时期望用户会阅读方法实现，则将尝试使每个方法尽可能短，以便于阅读。如果该方法执行了一些重要操作，则将其分解为几个较小的方法。这将导致大量浅层方法。此外，它并没有真正使代码更易于阅读：为了理解顶层方法的行为，读者可能需要了解嵌套方法的行为。</p>\n</blockquote>\n<p>Moreover, comments are fundamental to abstractions. Recall from Chapter 4 that the goal of abstractions is to hide complexity: an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. If users must read the code of a method in order to use it, then there is no abstraction: all of the complexity of the method is exposed. Without comments, the only abstraction of a method is its declaration, which specifies its name and the names and types of its arguments and results. The declaration is missing too much essential information to provide a useful abstraction by itself. For example, a method to extract a substring might have two arguments, start and end, indicating the range of characters to extract. From the declaration alone, it isn’t possible to tell whether the extracted substring will include the character indicated by end, or what happens if start &gt; end. Comments allow us to capture the additional information that callers need, thereby completing the simplified view while hiding implementation details. It’s also important that comments are written in a human language such as English; this makes them less precise than code, but it provides more expressive power, so we can create simple, intuitive descriptions. If you want to use abstractions to hide complexity, comments are essential.</p>\n<blockquote>\n<p>此外，注释是抽象的基础。回顾第四章，抽象的目的是隐藏复杂性：抽象是实体的简化视图，该实体保留必要的信息，但忽略了可以安全忽略的细节。如果用户必须阅读方法的代码才能使用它，则没有任何抽象：方法的所有复杂性都将暴露出来。没有注释，方法的唯一抽象就是其声明，该声明指定其名称以及其参数和结果的名称和类型。该声明缺少太多基本信息，无法单独提供有用的抽象。例如，提取子字符串的方法可能有两个参数，开始和结束，表示要提取的字符范围。仅凭宣言，无法确定提取的子字符串是否将包含 end 指示的字符，或者如果 start&gt; end 会发生什么。注释使我们能够捕获调用者所需的其他信息，从而在隐藏实现细节的同时完成简化的视图。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。用人类语言（例如英语）写评论也很重要；这使它们不如代码精确，但提供了更多的表达能力，因此我们可以创建简单直观的描述。如果要使用抽象来隐藏复杂性，则注释必不可少。</p>\n</blockquote>\n<h2 id=\"12-2-I-don’t-have-time-to-write-comments-我没有时间写评论\"><a href=\"#12-2-I-don’t-have-time-to-write-comments-我没有时间写评论\" class=\"headerlink\" title=\"12.2 I don’t have time to write comments 我没有时间写评论\"></a>12.2 I don’t have time to write comments 我没有时间写评论</h2><p>It’s tempting to prioritize comments lower than other development tasks. Given a choice between adding a new feature and documenting an existing feature, it seems logical to choose the new feature. However, software projects are almost always under time pressure, and there will always be things that seem higher priority than writing comments. Thus, if you allow documentation to be de-prioritized, you’ll end up with no documentation.</p>\n<blockquote>\n<p>优先考虑低于其他开发任务的注释是很诱人的。在添加新功能和记录现有功能之间做出选择之后，选择新功能似乎合乎逻辑。但是，软件项目几乎总是处于时间压力之下，并且总会有比编写注释优先级更高的事情。因此，如果您允许取消对文档的优先级，则最终将没有文档。</p>\n</blockquote>\n<p>The counter-argument to this excuse is the investment mindset discussed on page 15. If you want a clean software structure, which will allow you to work efficiently over the long-term, then you must take some extra time up front in order to create that structure. Good comments make a huge difference in the maintainability of software, so the effort spent on them will pay for itself quickly. Furthermore, writing comments needn’t take a lot of time. Ask yourself how much of your development time you spend typing in code (as opposed to designing, compiling, testing, etc.), assuming you don’t include any comments; I doubt that the answer is more than 10%. Now suppose that you spend as much time typing comments as typing code; this should be a safe upper bound. With these assumptions, writing good comments won’t add more than about 10% to your development time. The benefits of having good documentation will quickly offset this cost.</p>\n<blockquote>\n<p>与该借口相反的是第 15 页上讨论的投资思路。如果您想要一个干净的软件结构，可以长期有效地工作，那么您必须花一些额外的时间才能创建该结构。好的评论对软件的可维护性有很大的影响，因此花费在它们上面的精力将很快收回成本。此外，撰写评论不需要花费很多时间。询问自己，假设您不包含任何注释，那么您花费了多少开发时间来键入代码（与设计，编译，测试等相对）。我怀疑答案是否超过 10％。现在假设您花在输入注释上的时间与输入代码所花费的时间一样多。这应该是一个安全的上限。基于这些假设，撰写好的评论不会增加您的开发时间约 10％。拥有良好文档的好处将迅速抵消这一成本。</p>\n</blockquote>\n<p>Furthermore, many of the most important comments are those related to abstractions, such as the top-level documentation for classes and methods. Chapter 15 will argue that these comments should be written as part of the design process, and that the act of writing the documentation serves as an important design tool that improves the overall design. These comments pay for themselves immediately.</p>\n<blockquote>\n<p>此外，许多最重要的注释是与抽象有关的注释，例如类和方法的顶级文档。第 15 章认为，这些注释应作为设计过程的一部分编写，并且编写文档的行为是改善整体设计的重要设计工具。这些评论立即付诸行动。</p>\n</blockquote>\n<h2 id=\"12-3-Comments-get-out-of-date-and-become-misleading-评论过时并产生误导\"><a href=\"#12-3-Comments-get-out-of-date-and-become-misleading-评论过时并产生误导\" class=\"headerlink\" title=\"12.3 Comments get out of date and become misleading 评论过时并产生误导\"></a>12.3 Comments get out of date and become misleading 评论过时并产生误导</h2><p>Comments do sometimes get out of date, but this need not be a major problem in practice. Keeping documentation up-to-date does not require an enormous effort. Large changes to the documentation are only required if there have been large changes to the code, and the code changes will take more time than the documentation changes. Chapter 16 discusses how to organize documentation so that it is as easy as possible to keep it updated after code modifications (the key ideas are to avoid duplicated documentation and keep the documentation close to the corresponding code). Code reviews provide a great mechanism for detecting and fixing stale comments.</p>\n<blockquote>\n<p>注释有时确实会过时，但这实际上并不是主要问题。使文档保持最新状态并不需要付出巨大的努力。仅当对代码进行了较大的更改时才需要对文档进行大的更改，并且代码更改将比文档的更改花费更多的时间。第 16 章讨论了如何组织文档，以便在修改代码后尽可能容易地对其进行更新（主要思想是避免重复的文档并使文档与相应的代码保持一致）。代码审查提供了一种检测和修复陈旧注释的强大机制。</p>\n</blockquote>\n<h2 id=\"12-4-All-the-comments-I-have-seen-are-worthless-我所看到的所有评论都是毫无价值的\"><a href=\"#12-4-All-the-comments-I-have-seen-are-worthless-我所看到的所有评论都是毫无价值的\" class=\"headerlink\" title=\"12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的\"></a>12.4 All the comments I have seen are worthless 我所看到的所有评论都是毫无价值的</h2><p>Of the four excuses, this is probably the one with the most merit. Every software developer has seen comments that provide no useful information, and most existing documentation is so-so at best. Fortunately, this problem is solvable; writing solid documentation is not hard, once you know how. The next chapters will lay out a framework for how to write good documentation and maintain it over time.</p>\n<blockquote>\n<p>在这四个借口中，这可能是最有价值的借口。每个软件开发人员都看到没有提供有用信息的注释，并且大多数现有文档充其量都是这样。幸运的是，这个问题是可以解决的。一旦知道了如何编写可靠的文档并不难。下一章将为如何编写良好的文档并随时间进行维护提供一个框架。</p>\n</blockquote>\n<h2 id=\"12-5-Benefits-of-well-written-comments\"><a href=\"#12-5-Benefits-of-well-written-comments\" class=\"headerlink\" title=\"12.5 Benefits of well-written comments\"></a>12.5 Benefits of well-written comments</h2><p>Now that I have discussed (and, hopefully, debunked) the arguments against writing comments, let’s consider the benefits that you will get from good comments. The overall idea behind comments is to capture information that was in the mind of the designer but couldn’t be represented in the code. This information ranges from low-level details, such as a hardware quirk that motivates a particularly tricky piece of code, up to high-level concepts such as the rationale for a class. When other developers come along later to make modifications, the comments will allow them to work more quickly and accurately. Without documentation, future developers will have to rederive or guess at the developer’s original knowledge; this will take additional time, and there is a risk of bugs if the new developer misunderstands the original designer’s intentions. Comments are valuable even when the original designer is the one making the changes: if it has been more than a few weeks since you last worked in a piece of code, you will have forgotten many of the details of the original design.</p>\n<blockquote>\n<p>既然我已经讨论了（并希望揭穿了这些）反对撰写评论的论点，让我们考虑一下从良好评论中将获得的好处。注释背后的总体思想是捕获设计者所想但不能在代码中表示的信息。这些信息从低级详细信息（例如，激发特殊代码的硬件怪癖）到高级概念（例如，类的基本原理）。当其他开发人员稍后进行修改时，这些注释将使他们能够更快，更准确地工作。没有文档，未来的开发人员将不得不重新编写或猜测开发人员的原始知识。这将花费额外的时间，并且如果新开发者误解了原始设计者的意图，则存在错误的风险。</p>\n</blockquote>\n<p>Chapter 2 described three ways in which complexity manifests itself in software systems:</p>\n<blockquote>\n<p>第 2 章介绍了在软件系统中表现出复杂性的三种方式：</p>\n</blockquote>\n<ul>\n<li>Change amplification: a seemingly simple change requires code modifications in many places.</li>\n<li>Cognitive load: in order to make a change, the developer must accumulate a large amount of information.</li>\n<li>Unknown unknowns: it is unclear what code needs to be modified, or what information must be considered in order to make those modifications.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>变更放大：看似简单的变更需要在许多地方进行代码修改。</li>\n<li>认知负荷：为了进行更改，开发人员必须积累大量信息。</li>\n<li>未知未知数：尚不清楚需要修改哪些代码，或必须考虑哪些信息才能进行这些修改。</li>\n</ul>\n</blockquote>\n<p>Good documentation helps with the last two of these issues. Documentation can reduce cognitive load by providing developers with the information they need to make changes and by making it easy for developers to ignore information that is irrelevant. Without adequate documentation, developers may have to read large amounts of code to reconstruct what was in the designer’s mind. Documentation can also reduce the unknown unknowns by clarifying the structure of the system, so that it is clear what information and code is relevant for any given change.</p>\n<blockquote>\n<p>好的文档可以帮助解决最后两个问题。通过为开发人员提供他们进行更改所需的信息，并使开发人员容易忽略不相关的信息，文档可以减轻认知负担。没有足够的文档，开发人员可能必须阅读大量代码才能重构设计人员的想法。文档还可以通过阐明系统的结构来减少未知的未知数，从而可以清楚地了解与任何给定更改相关的信息和代码。</p>\n</blockquote>\n<p>Chapter 2 pointed out that the primary causes of complexity are dependencies and obscurity. Good documentation can clarify dependencies, and it fills in gaps to eliminate obscurity.</p>\n<blockquote>\n<p>第 2 章指出，导致复杂性的主要原因是依赖性和模糊性。好的文档可以阐明依赖关系，并且可以填补空白以消除模糊性。</p>\n</blockquote>\n<p>The next few chapters will show you how to write good documentation. They will also discuss how to integrate documentation-writing into the design process so that it improves the design of your software.</p>\n<blockquote>\n<p>接下来的几章将向您展示如何编写好的文档。他们还将讨论如何将文档编写集成到设计过程中，从而改善软件设计。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch15","date":"2021-02-14T16:00:00.000Z","_content":"先写评论\n<!-- more -->\n# 第 15 章 先写评论\n\n> Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)\n\nMany developers put off writing documentation until the end of the development process, after coding and unit testing are complete. This is one of the surest ways to produce poor quality documentation. The best time to write comments is at the beginning of the process, as you write the code. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.\n\n> 在完成编码和单元测试之后，许多开发人员推迟编写文档，直到开发过程结束。这是产生质量差的文档的最可靠方法之一。编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。\n\n## 15.1 Delayed comments are bad comments 评论延迟是不好的评论\n\nAlmost every developer I have ever met puts off writing comments. When asked why they don’t write documentation earlier, they say that the code is still changing. If they write documentation early, they say, they’ll have to rewrite it when the code changes; better to wait until the code stabilizes. However, I suspect that there is also another reason, which is that they view documentation as drudge work; thus, they put it off as long as possible.\n\n> 我见过的几乎每个开发人员都会推迟发表评论。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为繁琐的工作。因此，他们尽可能地推迟了。\n\nUnfortunately, this approach has several negative consequences. First, delaying documentation often means that it never gets written at all. Once you start delaying, it’s easy to delay a bit more; after all, the code will be even more stable in a few more weeks. By the time the code has inarguably stabilized, there is a lot of it, which means the task of writing documentation has become huge and even less attractive. There’s never a convenient time to stop for a few days and fill in all of the missing comments, and it’s easy to rationalize that the best thing for the project is to move on and fix bugs or write the next new feature. This will create even more undocumented code.\n\n> 不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，吸引力也越来越小。从来没有一个方便的时间可以停下来几天并填写所有遗漏的注释，并且很容易使该项目的最佳选择合理化，那就是继续并修复错误或编写下一个新功能。这将创建更多未记录的代码。\n\nEven if you do have the self-discipline to go back and write the comments (and don’t fool yourself: you probably don’t), the comments won’t be very good. By this time in the process, you have checked out mentally. In your mind, this piece of code is done; you are eager to move on to your next project. You know that writing comments is the right thing to do, but it’s no fun. You just want to get through it as quickly as possible. Thus, you make a quick pass over the code, adding just enough comments to look respectable. By now, it’s been a while since you designed the code, so your memories of the design process are becoming fuzzy. You look at the code as you are writing the comments, so the comments repeat the code. Even if you try to reconstruct the design ideas that aren’t obvious from the code, there will be things you don’t remember. Thus, the comments are missing some of the most important things they should describe.\n\n> 即使你有自律性回去写评论(不要欺骗你自己:你可能没有)，评论也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写评论是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，您可以快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，您已经有一段时间没有设计代码了，所以您对设计过程的记忆变得模糊了。您在编写注释时查看代码，因此注释重复了代码。即使您试图重构代码中不明显的设计思想，也会有您不记得的事情。因此，这些评论忽略了他们应该描述的一些最重要的事情。\n\n## 15.2 Write the comments first 首先写评论\n\nI use a different approach to writing comments, where I write the comments at the very beginning:\n\n> 我使用一种不同的方法来编写评论，在开始时就写评论：\n\n- For a new class, I start by writing the class interface comment.\n- Next, I write interface comments and signatures for the most important public methods, but I leave the method bodies empty.\n- I iterate a bit over these comments until the basic structure feels about right.\n- At this point I write declarations and comments for the most important class instance variables in the class.\n- Finally, I fill in the bodies of the methods, adding implementation comments as needed.\n- While writing method bodies, I usually discover the need for additional methods and instance variables. For each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.\n\n---\n\n> - 对于新类，我首先编写类接口注释。\n> - 接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。\n> - 我对这些评论进行了迭代，直到基本结构感觉正确为止。\n> - 在这一点上，我为类中最重要的类实例变量编写了声明和注释。\n> - 最后，我填写方法的主体，并根据需要添加实现注释。\n> - 在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。例如变量，我在编写变量声明的同时填写了注释。\n\nWhen the code is done, the comments are also done. There is never a backlog of unwritten comments.\n\n> 代码完成后，注释也将完成。从来没有积压的书面评论。\n\nThe comments-first approach has three benefits. First, it produces better comments. If you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them. It’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation. During the coding and testing process you will notice and fix problems with the comments. As a result, the comments improve over the course of development.\n\n> 评论优先的方法具有三个好处。首先，它会产生更好的评论。如果您在设计课程时写评论，那么关键的设计问题将在您的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样您就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，您会注意到并修复注释问题。结果，评论在开发过程中得到了改善。\n\n## 15.3 Comments are a design tool 评论是一种设计工具\n\nThe second, and most important, benefit of writing the comments at the beginning is that it improves the system design. Comments provide the only way to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code. To write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing? It’s important to do this early in the design process; otherwise you are just hacking code.\n\n> 在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果您在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的评论，您必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，您只是在破解代码。\n\nComments serve as a canary in the coal mine of complexity. If a method or variable requires a long comment, it is a red flag that you don’t have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classes have very simple interfaces yet implement powerful functions. The best way to judge the complexity of an interface is from the comments that describe it. If the interface comment for a method provides all the information needed to use the method and is also short and simple, that indicates that the method has a simple interface. Conversely, if there’s no way to describe a method completely without a long and complicated comment, then the method has a complex interface. You can compare a method’s interface comment with the implementation to get a sense of how deep the method is: if the interface comment must describe all the major features of the implementation, then the method is shallow. The same idea applies to variables: if it takes a long comment to fully describe a variable, it’s a red flag that suggests you may not have chosen the right variable decomposition. Overall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.\n\n> 评论是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明您没有很好的抽象。请记住，在第 4 章中，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的评论中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。您可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明您可能没有选择正确的变量分解。总体而言，编写注释的行为使您可以及早评估设计决策，以便发现并解决问题。\n\nimg Red Flag: Hard to Describe img\n\nThe comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.\n\n> 描述方法或变量的注释应该简单而完整。如果您发现很难写这样的评论，则表明您所描述的内容的设计可能存在问题。\n\nOf course, comments are only a good indicator of complexity if they are complete and clear. If you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.\n\n> 当然，如果评论完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释过于神秘以至于难以理解，则该注释不能很好地衡量该方法的深度。\n\n## 15.4 Early comments are fun comments 早期评论很有趣\n\nThe third and final benefit of writing comments early is that it makes comment-writing more fun. For me, one of the most enjoyable parts of programming is the early design phase for a new class, where I’m fleshing out the abstractions and structure for the class. Most of my comments are written during this phase, and the comments are how I record and test the quality of my design decisions. I’m looking for the design that can be expressed completely and clearly in the fewest words. The simpler the comments, the better I feel about my design, so finding simple comments is a source of pride. If you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.\n\n> 尽早编写评论的第三个也是最后一个好处是，它使编写评论更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，在那里，我将充实该类的抽象和结构。我的大部分评论都是在此阶段编写的，这些评论是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果您是策略性编程，而您的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是您确定最佳设计的方式。\n\n## 15.5 Are early comments expensive? 早期评论是否昂贵？\n\nNow let’s revisit the argument for delaying comments, which is that it avoids the cost of reworking the comments as the code evolves. A simple back-of-the-envelope calculation will show that this doesn’t save much. First, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time. Even if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time. Delaying the comments until the end will save only a fraction of this, which isn’t very much.\n\n> 现在，让我们重新讨论延迟注释的参数，这是因为它避免了在代码演变时重新处理注释的开销。一个简单的信封计算将显示这并不能节省很多。首先，估算您一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使您的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将评论延迟到最后只会节省其中的一小部分，这不是很多。\n\nWriting the comments first will mean that the abstractions will be more stable before you start writing code. This will probably save time during coding. In contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach. When you consider all of these factors, it’s possible that it might be faster overall to write the comments first.\n\n> 首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果您首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当您考虑所有这些因素时，可能首先整体编写注释可能会更快。\n\n## 15.6 Conclusion 结论\n\nIf you haven’t ever tried writing the comments first, give it a try. Stick with it long enough to get used to it. Then think about how it affects the quality of your comments, the quality of your design, and your overall enjoyment of software development. After you have tried this for a while, let me know whether your experience matches mine, and why or why not.\n\n> 如果您从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响您的评论质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道您的经历是否与我的相符，以及为什么或为什么不这样。\n","source":"_posts/软件设计的哲学-ch15.md","raw":"---\ntitle: 软件设计的哲学 - ch15\ndate: 2021-02-15\ntags: 软件设计的哲学 软件开发 方法论\n---\n先写评论\n<!-- more -->\n# 第 15 章 先写评论\n\n> Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)\n\nMany developers put off writing documentation until the end of the development process, after coding and unit testing are complete. This is one of the surest ways to produce poor quality documentation. The best time to write comments is at the beginning of the process, as you write the code. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.\n\n> 在完成编码和单元测试之后，许多开发人员推迟编写文档，直到开发过程结束。这是产生质量差的文档的最可靠方法之一。编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。\n\n## 15.1 Delayed comments are bad comments 评论延迟是不好的评论\n\nAlmost every developer I have ever met puts off writing comments. When asked why they don’t write documentation earlier, they say that the code is still changing. If they write documentation early, they say, they’ll have to rewrite it when the code changes; better to wait until the code stabilizes. However, I suspect that there is also another reason, which is that they view documentation as drudge work; thus, they put it off as long as possible.\n\n> 我见过的几乎每个开发人员都会推迟发表评论。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为繁琐的工作。因此，他们尽可能地推迟了。\n\nUnfortunately, this approach has several negative consequences. First, delaying documentation often means that it never gets written at all. Once you start delaying, it’s easy to delay a bit more; after all, the code will be even more stable in a few more weeks. By the time the code has inarguably stabilized, there is a lot of it, which means the task of writing documentation has become huge and even less attractive. There’s never a convenient time to stop for a few days and fill in all of the missing comments, and it’s easy to rationalize that the best thing for the project is to move on and fix bugs or write the next new feature. This will create even more undocumented code.\n\n> 不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，吸引力也越来越小。从来没有一个方便的时间可以停下来几天并填写所有遗漏的注释，并且很容易使该项目的最佳选择合理化，那就是继续并修复错误或编写下一个新功能。这将创建更多未记录的代码。\n\nEven if you do have the self-discipline to go back and write the comments (and don’t fool yourself: you probably don’t), the comments won’t be very good. By this time in the process, you have checked out mentally. In your mind, this piece of code is done; you are eager to move on to your next project. You know that writing comments is the right thing to do, but it’s no fun. You just want to get through it as quickly as possible. Thus, you make a quick pass over the code, adding just enough comments to look respectable. By now, it’s been a while since you designed the code, so your memories of the design process are becoming fuzzy. You look at the code as you are writing the comments, so the comments repeat the code. Even if you try to reconstruct the design ideas that aren’t obvious from the code, there will be things you don’t remember. Thus, the comments are missing some of the most important things they should describe.\n\n> 即使你有自律性回去写评论(不要欺骗你自己:你可能没有)，评论也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写评论是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，您可以快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，您已经有一段时间没有设计代码了，所以您对设计过程的记忆变得模糊了。您在编写注释时查看代码，因此注释重复了代码。即使您试图重构代码中不明显的设计思想，也会有您不记得的事情。因此，这些评论忽略了他们应该描述的一些最重要的事情。\n\n## 15.2 Write the comments first 首先写评论\n\nI use a different approach to writing comments, where I write the comments at the very beginning:\n\n> 我使用一种不同的方法来编写评论，在开始时就写评论：\n\n- For a new class, I start by writing the class interface comment.\n- Next, I write interface comments and signatures for the most important public methods, but I leave the method bodies empty.\n- I iterate a bit over these comments until the basic structure feels about right.\n- At this point I write declarations and comments for the most important class instance variables in the class.\n- Finally, I fill in the bodies of the methods, adding implementation comments as needed.\n- While writing method bodies, I usually discover the need for additional methods and instance variables. For each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.\n\n---\n\n> - 对于新类，我首先编写类接口注释。\n> - 接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。\n> - 我对这些评论进行了迭代，直到基本结构感觉正确为止。\n> - 在这一点上，我为类中最重要的类实例变量编写了声明和注释。\n> - 最后，我填写方法的主体，并根据需要添加实现注释。\n> - 在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。例如变量，我在编写变量声明的同时填写了注释。\n\nWhen the code is done, the comments are also done. There is never a backlog of unwritten comments.\n\n> 代码完成后，注释也将完成。从来没有积压的书面评论。\n\nThe comments-first approach has three benefits. First, it produces better comments. If you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them. It’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation. During the coding and testing process you will notice and fix problems with the comments. As a result, the comments improve over the course of development.\n\n> 评论优先的方法具有三个好处。首先，它会产生更好的评论。如果您在设计课程时写评论，那么关键的设计问题将在您的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样您就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，您会注意到并修复注释问题。结果，评论在开发过程中得到了改善。\n\n## 15.3 Comments are a design tool 评论是一种设计工具\n\nThe second, and most important, benefit of writing the comments at the beginning is that it improves the system design. Comments provide the only way to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code. To write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing? It’s important to do this early in the design process; otherwise you are just hacking code.\n\n> 在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果您在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的评论，您必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，您只是在破解代码。\n\nComments serve as a canary in the coal mine of complexity. If a method or variable requires a long comment, it is a red flag that you don’t have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classes have very simple interfaces yet implement powerful functions. The best way to judge the complexity of an interface is from the comments that describe it. If the interface comment for a method provides all the information needed to use the method and is also short and simple, that indicates that the method has a simple interface. Conversely, if there’s no way to describe a method completely without a long and complicated comment, then the method has a complex interface. You can compare a method’s interface comment with the implementation to get a sense of how deep the method is: if the interface comment must describe all the major features of the implementation, then the method is shallow. The same idea applies to variables: if it takes a long comment to fully describe a variable, it’s a red flag that suggests you may not have chosen the right variable decomposition. Overall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.\n\n> 评论是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明您没有很好的抽象。请记住，在第 4 章中，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的评论中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。您可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明您可能没有选择正确的变量分解。总体而言，编写注释的行为使您可以及早评估设计决策，以便发现并解决问题。\n\nimg Red Flag: Hard to Describe img\n\nThe comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.\n\n> 描述方法或变量的注释应该简单而完整。如果您发现很难写这样的评论，则表明您所描述的内容的设计可能存在问题。\n\nOf course, comments are only a good indicator of complexity if they are complete and clear. If you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.\n\n> 当然，如果评论完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释过于神秘以至于难以理解，则该注释不能很好地衡量该方法的深度。\n\n## 15.4 Early comments are fun comments 早期评论很有趣\n\nThe third and final benefit of writing comments early is that it makes comment-writing more fun. For me, one of the most enjoyable parts of programming is the early design phase for a new class, where I’m fleshing out the abstractions and structure for the class. Most of my comments are written during this phase, and the comments are how I record and test the quality of my design decisions. I’m looking for the design that can be expressed completely and clearly in the fewest words. The simpler the comments, the better I feel about my design, so finding simple comments is a source of pride. If you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.\n\n> 尽早编写评论的第三个也是最后一个好处是，它使编写评论更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，在那里，我将充实该类的抽象和结构。我的大部分评论都是在此阶段编写的，这些评论是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果您是策略性编程，而您的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是您确定最佳设计的方式。\n\n## 15.5 Are early comments expensive? 早期评论是否昂贵？\n\nNow let’s revisit the argument for delaying comments, which is that it avoids the cost of reworking the comments as the code evolves. A simple back-of-the-envelope calculation will show that this doesn’t save much. First, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time. Even if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time. Delaying the comments until the end will save only a fraction of this, which isn’t very much.\n\n> 现在，让我们重新讨论延迟注释的参数，这是因为它避免了在代码演变时重新处理注释的开销。一个简单的信封计算将显示这并不能节省很多。首先，估算您一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使您的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将评论延迟到最后只会节省其中的一小部分，这不是很多。\n\nWriting the comments first will mean that the abstractions will be more stable before you start writing code. This will probably save time during coding. In contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach. When you consider all of these factors, it’s possible that it might be faster overall to write the comments first.\n\n> 首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果您首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当您考虑所有这些因素时，可能首先整体编写注释可能会更快。\n\n## 15.6 Conclusion 结论\n\nIf you haven’t ever tried writing the comments first, give it a try. Stick with it long enough to get used to it. Then think about how it affects the quality of your comments, the quality of your design, and your overall enjoyment of software development. After you have tried this for a while, let me know whether your experience matches mine, and why or why not.\n\n> 如果您从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响您的评论质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道您的经历是否与我的相符，以及为什么或为什么不这样。\n","slug":"软件设计的哲学-ch15","published":1,"updated":"2021-02-16T04:53:19.799Z","_id":"ckl7iw2vl000akiiyca6o1qx0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>先写评论</p>\n<a id=\"more\"></a>\n<h1 id=\"第-15-章-先写评论\"><a href=\"#第-15-章-先写评论\" class=\"headerlink\" title=\"第 15 章 先写评论\"></a>第 15 章 先写评论</h1><blockquote>\n<p>Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)</p>\n</blockquote>\n<p>Many developers put off writing documentation until the end of the development process, after coding and unit testing are complete. This is one of the surest ways to produce poor quality documentation. The best time to write comments is at the beginning of the process, as you write the code. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.</p>\n<blockquote>\n<p>在完成编码和单元测试之后，许多开发人员推迟编写文档，直到开发过程结束。这是产生质量差的文档的最可靠方法之一。编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。</p>\n</blockquote>\n<h2 id=\"15-1-Delayed-comments-are-bad-comments-评论延迟是不好的评论\"><a href=\"#15-1-Delayed-comments-are-bad-comments-评论延迟是不好的评论\" class=\"headerlink\" title=\"15.1 Delayed comments are bad comments 评论延迟是不好的评论\"></a>15.1 Delayed comments are bad comments 评论延迟是不好的评论</h2><p>Almost every developer I have ever met puts off writing comments. When asked why they don’t write documentation earlier, they say that the code is still changing. If they write documentation early, they say, they’ll have to rewrite it when the code changes; better to wait until the code stabilizes. However, I suspect that there is also another reason, which is that they view documentation as drudge work; thus, they put it off as long as possible.</p>\n<blockquote>\n<p>我见过的几乎每个开发人员都会推迟发表评论。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为繁琐的工作。因此，他们尽可能地推迟了。</p>\n</blockquote>\n<p>Unfortunately, this approach has several negative consequences. First, delaying documentation often means that it never gets written at all. Once you start delaying, it’s easy to delay a bit more; after all, the code will be even more stable in a few more weeks. By the time the code has inarguably stabilized, there is a lot of it, which means the task of writing documentation has become huge and even less attractive. There’s never a convenient time to stop for a few days and fill in all of the missing comments, and it’s easy to rationalize that the best thing for the project is to move on and fix bugs or write the next new feature. This will create even more undocumented code.</p>\n<blockquote>\n<p>不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，吸引力也越来越小。从来没有一个方便的时间可以停下来几天并填写所有遗漏的注释，并且很容易使该项目的最佳选择合理化，那就是继续并修复错误或编写下一个新功能。这将创建更多未记录的代码。</p>\n</blockquote>\n<p>Even if you do have the self-discipline to go back and write the comments (and don’t fool yourself: you probably don’t), the comments won’t be very good. By this time in the process, you have checked out mentally. In your mind, this piece of code is done; you are eager to move on to your next project. You know that writing comments is the right thing to do, but it’s no fun. You just want to get through it as quickly as possible. Thus, you make a quick pass over the code, adding just enough comments to look respectable. By now, it’s been a while since you designed the code, so your memories of the design process are becoming fuzzy. You look at the code as you are writing the comments, so the comments repeat the code. Even if you try to reconstruct the design ideas that aren’t obvious from the code, there will be things you don’t remember. Thus, the comments are missing some of the most important things they should describe.</p>\n<blockquote>\n<p>即使你有自律性回去写评论(不要欺骗你自己:你可能没有)，评论也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写评论是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，您可以快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，您已经有一段时间没有设计代码了，所以您对设计过程的记忆变得模糊了。您在编写注释时查看代码，因此注释重复了代码。即使您试图重构代码中不明显的设计思想，也会有您不记得的事情。因此，这些评论忽略了他们应该描述的一些最重要的事情。</p>\n</blockquote>\n<h2 id=\"15-2-Write-the-comments-first-首先写评论\"><a href=\"#15-2-Write-the-comments-first-首先写评论\" class=\"headerlink\" title=\"15.2 Write the comments first 首先写评论\"></a>15.2 Write the comments first 首先写评论</h2><p>I use a different approach to writing comments, where I write the comments at the very beginning:</p>\n<blockquote>\n<p>我使用一种不同的方法来编写评论，在开始时就写评论：</p>\n</blockquote>\n<ul>\n<li>For a new class, I start by writing the class interface comment.</li>\n<li>Next, I write interface comments and signatures for the most important public methods, but I leave the method bodies empty.</li>\n<li>I iterate a bit over these comments until the basic structure feels about right.</li>\n<li>At this point I write declarations and comments for the most important class instance variables in the class.</li>\n<li>Finally, I fill in the bodies of the methods, adding implementation comments as needed.</li>\n<li>While writing method bodies, I usually discover the need for additional methods and instance variables. For each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>对于新类，我首先编写类接口注释。</li>\n<li>接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。</li>\n<li>我对这些评论进行了迭代，直到基本结构感觉正确为止。</li>\n<li>在这一点上，我为类中最重要的类实例变量编写了声明和注释。</li>\n<li>最后，我填写方法的主体，并根据需要添加实现注释。</li>\n<li>在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。例如变量，我在编写变量声明的同时填写了注释。</li>\n</ul>\n</blockquote>\n<p>When the code is done, the comments are also done. There is never a backlog of unwritten comments.</p>\n<blockquote>\n<p>代码完成后，注释也将完成。从来没有积压的书面评论。</p>\n</blockquote>\n<p>The comments-first approach has three benefits. First, it produces better comments. If you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them. It’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation. During the coding and testing process you will notice and fix problems with the comments. As a result, the comments improve over the course of development.</p>\n<blockquote>\n<p>评论优先的方法具有三个好处。首先，它会产生更好的评论。如果您在设计课程时写评论，那么关键的设计问题将在您的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样您就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，您会注意到并修复注释问题。结果，评论在开发过程中得到了改善。</p>\n</blockquote>\n<h2 id=\"15-3-Comments-are-a-design-tool-评论是一种设计工具\"><a href=\"#15-3-Comments-are-a-design-tool-评论是一种设计工具\" class=\"headerlink\" title=\"15.3 Comments are a design tool 评论是一种设计工具\"></a>15.3 Comments are a design tool 评论是一种设计工具</h2><p>The second, and most important, benefit of writing the comments at the beginning is that it improves the system design. Comments provide the only way to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code. To write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing? It’s important to do this early in the design process; otherwise you are just hacking code.</p>\n<blockquote>\n<p>在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果您在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的评论，您必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，您只是在破解代码。</p>\n</blockquote>\n<p>Comments serve as a canary in the coal mine of complexity. If a method or variable requires a long comment, it is a red flag that you don’t have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classes have very simple interfaces yet implement powerful functions. The best way to judge the complexity of an interface is from the comments that describe it. If the interface comment for a method provides all the information needed to use the method and is also short and simple, that indicates that the method has a simple interface. Conversely, if there’s no way to describe a method completely without a long and complicated comment, then the method has a complex interface. You can compare a method’s interface comment with the implementation to get a sense of how deep the method is: if the interface comment must describe all the major features of the implementation, then the method is shallow. The same idea applies to variables: if it takes a long comment to fully describe a variable, it’s a red flag that suggests you may not have chosen the right variable decomposition. Overall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.</p>\n<blockquote>\n<p>评论是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明您没有很好的抽象。请记住，在第 4 章中，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的评论中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。您可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明您可能没有选择正确的变量分解。总体而言，编写注释的行为使您可以及早评估设计决策，以便发现并解决问题。</p>\n</blockquote>\n<p>img Red Flag: Hard to Describe img</p>\n<p>The comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.</p>\n<blockquote>\n<p>描述方法或变量的注释应该简单而完整。如果您发现很难写这样的评论，则表明您所描述的内容的设计可能存在问题。</p>\n</blockquote>\n<p>Of course, comments are only a good indicator of complexity if they are complete and clear. If you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.</p>\n<blockquote>\n<p>当然，如果评论完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释过于神秘以至于难以理解，则该注释不能很好地衡量该方法的深度。</p>\n</blockquote>\n<h2 id=\"15-4-Early-comments-are-fun-comments-早期评论很有趣\"><a href=\"#15-4-Early-comments-are-fun-comments-早期评论很有趣\" class=\"headerlink\" title=\"15.4 Early comments are fun comments 早期评论很有趣\"></a>15.4 Early comments are fun comments 早期评论很有趣</h2><p>The third and final benefit of writing comments early is that it makes comment-writing more fun. For me, one of the most enjoyable parts of programming is the early design phase for a new class, where I’m fleshing out the abstractions and structure for the class. Most of my comments are written during this phase, and the comments are how I record and test the quality of my design decisions. I’m looking for the design that can be expressed completely and clearly in the fewest words. The simpler the comments, the better I feel about my design, so finding simple comments is a source of pride. If you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.</p>\n<blockquote>\n<p>尽早编写评论的第三个也是最后一个好处是，它使编写评论更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，在那里，我将充实该类的抽象和结构。我的大部分评论都是在此阶段编写的，这些评论是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果您是策略性编程，而您的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是您确定最佳设计的方式。</p>\n</blockquote>\n<h2 id=\"15-5-Are-early-comments-expensive-早期评论是否昂贵？\"><a href=\"#15-5-Are-early-comments-expensive-早期评论是否昂贵？\" class=\"headerlink\" title=\"15.5 Are early comments expensive? 早期评论是否昂贵？\"></a>15.5 Are early comments expensive? 早期评论是否昂贵？</h2><p>Now let’s revisit the argument for delaying comments, which is that it avoids the cost of reworking the comments as the code evolves. A simple back-of-the-envelope calculation will show that this doesn’t save much. First, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time. Even if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time. Delaying the comments until the end will save only a fraction of this, which isn’t very much.</p>\n<blockquote>\n<p>现在，让我们重新讨论延迟注释的参数，这是因为它避免了在代码演变时重新处理注释的开销。一个简单的信封计算将显示这并不能节省很多。首先，估算您一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使您的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将评论延迟到最后只会节省其中的一小部分，这不是很多。</p>\n</blockquote>\n<p>Writing the comments first will mean that the abstractions will be more stable before you start writing code. This will probably save time during coding. In contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach. When you consider all of these factors, it’s possible that it might be faster overall to write the comments first.</p>\n<blockquote>\n<p>首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果您首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当您考虑所有这些因素时，可能首先整体编写注释可能会更快。</p>\n</blockquote>\n<h2 id=\"15-6-Conclusion-结论\"><a href=\"#15-6-Conclusion-结论\" class=\"headerlink\" title=\"15.6 Conclusion 结论\"></a>15.6 Conclusion 结论</h2><p>If you haven’t ever tried writing the comments first, give it a try. Stick with it long enough to get used to it. Then think about how it affects the quality of your comments, the quality of your design, and your overall enjoyment of software development. After you have tried this for a while, let me know whether your experience matches mine, and why or why not.</p>\n<blockquote>\n<p>如果您从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响您的评论质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道您的经历是否与我的相符，以及为什么或为什么不这样。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>先写评论</p>","more":"<h1 id=\"第-15-章-先写评论\"><a href=\"#第-15-章-先写评论\" class=\"headerlink\" title=\"第 15 章 先写评论\"></a>第 15 章 先写评论</h1><blockquote>\n<p>Chapter 15 Write The Comments First(Use Comments As Part Of The Design Process)</p>\n</blockquote>\n<p>Many developers put off writing documentation until the end of the development process, after coding and unit testing are complete. This is one of the surest ways to produce poor quality documentation. The best time to write comments is at the beginning of the process, as you write the code. Writing the comments first makes documentation part of the design process. Not only does this produce better documentation, but it also produces better designs and it makes the process of writing documentation more enjoyable.</p>\n<blockquote>\n<p>在完成编码和单元测试之后，许多开发人员推迟编写文档，直到开发过程结束。这是产生质量差的文档的最可靠方法之一。编写注释的最佳时间是在过程开始时。首先编写注释使文档成为设计过程的一部分。这不仅可以产生更好的文档，还可以产生更好的设计，并使编写文档的过程更加愉快。</p>\n</blockquote>\n<h2 id=\"15-1-Delayed-comments-are-bad-comments-评论延迟是不好的评论\"><a href=\"#15-1-Delayed-comments-are-bad-comments-评论延迟是不好的评论\" class=\"headerlink\" title=\"15.1 Delayed comments are bad comments 评论延迟是不好的评论\"></a>15.1 Delayed comments are bad comments 评论延迟是不好的评论</h2><p>Almost every developer I have ever met puts off writing comments. When asked why they don’t write documentation earlier, they say that the code is still changing. If they write documentation early, they say, they’ll have to rewrite it when the code changes; better to wait until the code stabilizes. However, I suspect that there is also another reason, which is that they view documentation as drudge work; thus, they put it off as long as possible.</p>\n<blockquote>\n<p>我见过的几乎每个开发人员都会推迟发表评论。当被问及为什么不更早编写文档时，他们说代码仍在更改。他们说，如果他们尽早编写文档，则必须在代码更改时重新编写文档。最好等到代码稳定下来。但是，我怀疑还有另一个原因，那就是他们将文档视为繁琐的工作。因此，他们尽可能地推迟了。</p>\n</blockquote>\n<p>Unfortunately, this approach has several negative consequences. First, delaying documentation often means that it never gets written at all. Once you start delaying, it’s easy to delay a bit more; after all, the code will be even more stable in a few more weeks. By the time the code has inarguably stabilized, there is a lot of it, which means the task of writing documentation has become huge and even less attractive. There’s never a convenient time to stop for a few days and fill in all of the missing comments, and it’s easy to rationalize that the best thing for the project is to move on and fix bugs or write the next new feature. This will create even more undocumented code.</p>\n<blockquote>\n<p>不幸的是，这种方法有几个负面影响。首先，延迟文档通常意味着根本无法编写文档。一旦开始延迟，就容易再延迟一些。毕竟，代码将在几周后变得更加稳定。到了代码毫无疑问地稳定下来的时候，代码已经很多了，这意味着编写文档的任务变得越来越庞大，吸引力也越来越小。从来没有一个方便的时间可以停下来几天并填写所有遗漏的注释，并且很容易使该项目的最佳选择合理化，那就是继续并修复错误或编写下一个新功能。这将创建更多未记录的代码。</p>\n</blockquote>\n<p>Even if you do have the self-discipline to go back and write the comments (and don’t fool yourself: you probably don’t), the comments won’t be very good. By this time in the process, you have checked out mentally. In your mind, this piece of code is done; you are eager to move on to your next project. You know that writing comments is the right thing to do, but it’s no fun. You just want to get through it as quickly as possible. Thus, you make a quick pass over the code, adding just enough comments to look respectable. By now, it’s been a while since you designed the code, so your memories of the design process are becoming fuzzy. You look at the code as you are writing the comments, so the comments repeat the code. Even if you try to reconstruct the design ideas that aren’t obvious from the code, there will be things you don’t remember. Thus, the comments are missing some of the most important things they should describe.</p>\n<blockquote>\n<p>即使你有自律性回去写评论(不要欺骗你自己:你可能没有)，评论也不会很好。在这个过程的这个时候，你已经在精神上离开了。在你的脑海中，这段代码已经完成了;你急于开始下一个项目。你知道写评论是正确的事情，但它没有乐趣。你只想尽快度过难关。因此，您可以快速地浏览代码，添加足够的注释以使其看起来令人满意。到目前为止，您已经有一段时间没有设计代码了，所以您对设计过程的记忆变得模糊了。您在编写注释时查看代码，因此注释重复了代码。即使您试图重构代码中不明显的设计思想，也会有您不记得的事情。因此，这些评论忽略了他们应该描述的一些最重要的事情。</p>\n</blockquote>\n<h2 id=\"15-2-Write-the-comments-first-首先写评论\"><a href=\"#15-2-Write-the-comments-first-首先写评论\" class=\"headerlink\" title=\"15.2 Write the comments first 首先写评论\"></a>15.2 Write the comments first 首先写评论</h2><p>I use a different approach to writing comments, where I write the comments at the very beginning:</p>\n<blockquote>\n<p>我使用一种不同的方法来编写评论，在开始时就写评论：</p>\n</blockquote>\n<ul>\n<li>For a new class, I start by writing the class interface comment.</li>\n<li>Next, I write interface comments and signatures for the most important public methods, but I leave the method bodies empty.</li>\n<li>I iterate a bit over these comments until the basic structure feels about right.</li>\n<li>At this point I write declarations and comments for the most important class instance variables in the class.</li>\n<li>Finally, I fill in the bodies of the methods, adding implementation comments as needed.</li>\n<li>While writing method bodies, I usually discover the need for additional methods and instance variables. For each new method I write the interface comment before the body of the method; for instance variables I fill in the comment at the same time that I write the variable declaration.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>对于新类，我首先编写类接口注释。</li>\n<li>接下来，我为最重要的公共方法编写接口注释和签名，但将方法主体保留为空。</li>\n<li>我对这些评论进行了迭代，直到基本结构感觉正确为止。</li>\n<li>在这一点上，我为类中最重要的类实例变量编写了声明和注释。</li>\n<li>最后，我填写方法的主体，并根据需要添加实现注释。</li>\n<li>在编写方法主体时，我通常会发现需要其他方法和实例变量。对于每个新方法，我在方法主体之前编写接口注释。例如变量，我在编写变量声明的同时填写了注释。</li>\n</ul>\n</blockquote>\n<p>When the code is done, the comments are also done. There is never a backlog of unwritten comments.</p>\n<blockquote>\n<p>代码完成后，注释也将完成。从来没有积压的书面评论。</p>\n</blockquote>\n<p>The comments-first approach has three benefits. First, it produces better comments. If you write the comments as you are designing the class, the key design issues will be fresh in your mind, so it’s easy to record them. It’s better to write the interface comment for each method before its body, so you can focus on the method’s abstraction and interface without being distracted by its implementation. During the coding and testing process you will notice and fix problems with the comments. As a result, the comments improve over the course of development.</p>\n<blockquote>\n<p>评论优先的方法具有三个好处。首先，它会产生更好的评论。如果您在设计课程时写评论，那么关键的设计问题将在您的脑海中浮现，因此很容易记录下来。最好在每个方法的主体之前编写接口注释，这样您就可以专注于方法的抽象和接口，而不会因其实现而分心。在编码和测试过程中，您会注意到并修复注释问题。结果，评论在开发过程中得到了改善。</p>\n</blockquote>\n<h2 id=\"15-3-Comments-are-a-design-tool-评论是一种设计工具\"><a href=\"#15-3-Comments-are-a-design-tool-评论是一种设计工具\" class=\"headerlink\" title=\"15.3 Comments are a design tool 评论是一种设计工具\"></a>15.3 Comments are a design tool 评论是一种设计工具</h2><p>The second, and most important, benefit of writing the comments at the beginning is that it improves the system design. Comments provide the only way to fully capture abstractions, and good abstractions are fundamental to good system design. If you write comments describing the abstractions at the beginning, you can review and tune them before writing implementation code. To write a good comment, you must identify the essence of a variable or piece of code: what are the most important aspects of this thing? It’s important to do this early in the design process; otherwise you are just hacking code.</p>\n<blockquote>\n<p>在开始时编写注释的第二个也是最重要的好处是可以改善系统设计。注释提供了完全捕获抽象的唯一方法，好的抽象是好的系统设计的基础。如果您在一开始就写了描述抽象的注释，则可以在编写实现代码之前对其进行检查和调整。要写一个好的评论，您必须确定一个变量或一段代码的本质：这件事最重要的方面是什么？在设计过程的早期进行此操作很重要；否则，您只是在破解代码。</p>\n</blockquote>\n<p>Comments serve as a canary in the coal mine of complexity. If a method or variable requires a long comment, it is a red flag that you don’t have a good abstraction. Remember from Chapter 4 that classes should be deep: the best classes have very simple interfaces yet implement powerful functions. The best way to judge the complexity of an interface is from the comments that describe it. If the interface comment for a method provides all the information needed to use the method and is also short and simple, that indicates that the method has a simple interface. Conversely, if there’s no way to describe a method completely without a long and complicated comment, then the method has a complex interface. You can compare a method’s interface comment with the implementation to get a sense of how deep the method is: if the interface comment must describe all the major features of the implementation, then the method is shallow. The same idea applies to variables: if it takes a long comment to fully describe a variable, it’s a red flag that suggests you may not have chosen the right variable decomposition. Overall, the act of writing comments allows you to evaluate your design decisions early, so you can discover and fix problems.</p>\n<blockquote>\n<p>评论是复杂煤矿中的金丝雀。如果方法或变量需要较长的注释，则它是一个危险信号，表明您没有很好的抽象。请记住，在第 4 章中，类应该很深：最好的类具有非常简单的接口，但可以实现强大的功能。判断接口复杂性的最佳方法是从描述接口的评论中进行。如果某个方法的接口注释提供了使用该方法所需的所有信息，并且又简短又简单，则表明该方法具有简单的接口。相反，如果没有冗长而复杂的注释无法完全描述一个方法，则该方法具有复杂的接口。您可以将方法的接口注释与实现进行比较，以了解该方法的深度：如果接口注释必须描述实现的所有主要功能，则该方法很浅。同样的想法也适用于变量：如果要花很长的时间来完整描述一个变量，那是一个危险信号，表明您可能没有选择正确的变量分解。总体而言，编写注释的行为使您可以及早评估设计决策，以便发现并解决问题。</p>\n</blockquote>\n<p>img Red Flag: Hard to Describe img</p>\n<p>The comment that describes a method or variable should be simple and yet complete. If you find it difficult to write such a comment, that’s an indicator that there may be a problem with the design of the thing you are describing.</p>\n<blockquote>\n<p>描述方法或变量的注释应该简单而完整。如果您发现很难写这样的评论，则表明您所描述的内容的设计可能存在问题。</p>\n</blockquote>\n<p>Of course, comments are only a good indicator of complexity if they are complete and clear. If you write a method interface comment that doesn’t provide all the information needed to invoke the method, or one that is so cryptic that it’s hard to understand, then that comment doesn’t provide a good measure of the method’s depth.</p>\n<blockquote>\n<p>当然，如果评论完整而清晰，那么它们仅是复杂性的良好指标。如果编写的方法接口注释未提供调用该方法所需的全部信息，或者编写的注释过于神秘以至于难以理解，则该注释不能很好地衡量该方法的深度。</p>\n</blockquote>\n<h2 id=\"15-4-Early-comments-are-fun-comments-早期评论很有趣\"><a href=\"#15-4-Early-comments-are-fun-comments-早期评论很有趣\" class=\"headerlink\" title=\"15.4 Early comments are fun comments 早期评论很有趣\"></a>15.4 Early comments are fun comments 早期评论很有趣</h2><p>The third and final benefit of writing comments early is that it makes comment-writing more fun. For me, one of the most enjoyable parts of programming is the early design phase for a new class, where I’m fleshing out the abstractions and structure for the class. Most of my comments are written during this phase, and the comments are how I record and test the quality of my design decisions. I’m looking for the design that can be expressed completely and clearly in the fewest words. The simpler the comments, the better I feel about my design, so finding simple comments is a source of pride. If you are programming strategically, where your main goal is a great design rather than just writing code that works, then writing comments should be fun, since that’s how you identify the best designs.</p>\n<blockquote>\n<p>尽早编写评论的第三个也是最后一个好处是，它使编写评论更加有趣。对我来说，编程中最有趣的部分之一是新类的早期设计阶段，在那里，我将充实该类的抽象和结构。我的大部分评论都是在此阶段编写的，这些评论是我记录和测试设计决策质量的方式。我正在寻找可以用最少的词来完整而清晰地表达的设计。注释越简单，我对设计的感觉就越好，因此找到简单的注释是一种自豪感。如果您是策略性编程，而您的主要目标是一个出色的设计，而不仅仅是编写有效的代码，那么编写注释应该很有趣，因为这是您确定最佳设计的方式。</p>\n</blockquote>\n<h2 id=\"15-5-Are-early-comments-expensive-早期评论是否昂贵？\"><a href=\"#15-5-Are-early-comments-expensive-早期评论是否昂贵？\" class=\"headerlink\" title=\"15.5 Are early comments expensive? 早期评论是否昂贵？\"></a>15.5 Are early comments expensive? 早期评论是否昂贵？</h2><p>Now let’s revisit the argument for delaying comments, which is that it avoids the cost of reworking the comments as the code evolves. A simple back-of-the-envelope calculation will show that this doesn’t save much. First, estimate the total fraction of development time that you spend typing in code and comments together, including time to revise code and comments; it’s unlikely that this will be more than about 10% of all development time. Even if half of your total code lines are comments, writing comments probably doesn’t account for more than about 5% of your total development time. Delaying the comments until the end will save only a fraction of this, which isn’t very much.</p>\n<blockquote>\n<p>现在，让我们重新讨论延迟注释的参数，这是因为它避免了在代码演变时重新处理注释的开销。一个简单的信封计算将显示这并不能节省很多。首先，估算您一起键入代码和注释所花费的开发时间的总和，包括修改代码和注释的时间；这不太可能超过所有开发时间的 10％。即使您的全部代码行中有一半是注释，编写注释也可能不会占开发总时间的 5％以上。将评论延迟到最后只会节省其中的一小部分，这不是很多。</p>\n</blockquote>\n<p>Writing the comments first will mean that the abstractions will be more stable before you start writing code. This will probably save time during coding. In contrast, if you write the code first, the abstractions will probably evolve as you code, which will require more code revisions than the comments-first approach. When you consider all of these factors, it’s possible that it might be faster overall to write the comments first.</p>\n<blockquote>\n<p>首先编写注释将意味着在开始编写代码之前，抽象将更加稳定。这可能会节省编码时间。相反，如果您首先编写代码，则抽象可能会随代码的发展而变化，与注释优先方法相比，将需要更多的代码修订。当您考虑所有这些因素时，可能首先整体编写注释可能会更快。</p>\n</blockquote>\n<h2 id=\"15-6-Conclusion-结论\"><a href=\"#15-6-Conclusion-结论\" class=\"headerlink\" title=\"15.6 Conclusion 结论\"></a>15.6 Conclusion 结论</h2><p>If you haven’t ever tried writing the comments first, give it a try. Stick with it long enough to get used to it. Then think about how it affects the quality of your comments, the quality of your design, and your overall enjoyment of software development. After you have tried this for a while, let me know whether your experience matches mine, and why or why not.</p>\n<blockquote>\n<p>如果您从未尝试过先编写注释，请尝试一下。坚持足够长的时间来习惯它。然后考虑它如何影响您的评论质量，设计质量以及软件开发的整体乐趣。在尝试了一段时间之后，让我知道您的经历是否与我的相符，以及为什么或为什么不这样。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch7","date":"2021-02-06T16:00:00.000Z","_content":"不同的层，不同的抽象\n<!-- more -->\n# 第 7 章 不同的层，不同的抽象\n\n> Chapter 7 Different Layer, Different Abstraction\n\nSoftware systems are composed in layers, where higher layers use the facilities provided by lower layers. In a well-designed system, each layer provides a different abstraction from the layers above and below it; if you follow a single operation as it moves up and down through layers by invoking methods, the abstractions change with each method call. For example:\n\n> 软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。如果您通过调用方法遵循单个操作在层中上下移动，则每个方法调用的抽象都会改变。例如：\n\n- In a file system, the uppermost layer implements a file abstraction. A file consists of a variable-length array of bytes, which can be updated by reading and writing variable-length byte ranges. The next lower layer in the file system implements a cache in memory of fixed-size disk blocks; callers can assume that frequently used blocks will stay in memory where they can be accessed quickly. The lowest layer consists of device drivers, which move blocks between secondary storage devices and memory.\n- In a network transport protocol such as TCP, the abstraction provided by the topmost layer is a stream of bytes delivered reliably from one machine to another. This level is built on a lower level that transmits packets of bounded size between machines on a best-effort basis: most packets will be delivered successfully, but some packets may be lost or delivered out of order.\n\n---\n\n> - 在文件系统中，最上层实现文件抽象。文件由可变长度的字节数组组成，可以通过读写可变长度的字节范围来更新该字节。文件系统的下一个下一层在固定大小的磁盘块的内存中实现了高速缓存。调用者可以假定经常使用的块将保留在内存中，以便可以快速访问它们。最低层由设备驱动程序组成，它们在辅助存储设备和内存之间移动块。\n> - 在诸如 TCP 的网络传输协议中，最顶层提供的抽象是从一台机器可靠地传递到另一台机器的字节流。此级别在较低级别上构建，该级别可以尽最大努力在计算机之间传输有限大小的数据包：大多数数据包将成功交付，但某些数据包可能会丢失或乱序交付。\n\nIf a system contains adjacent layers with similar abstractions, this is a red flag that suggests a problem with the class decomposition. This chapter discusses situations where this happens, the problems that result, and how to refactor to eliminate the problems.\n\n> 如果系统包含具有相似抽象的相邻层，则这是一个红色标记，表明类分解存在问题。本章讨论了发生这种情况的情况，导致的问题以及如何重构以消除问题。\n\n## 7.1 Pass-through methods 传递方法\n\nWhen adjacent layers have similar abstractions, the problem often manifests itself in the form of pass-through methods. A pass-through method is one that does little except invoke another method, whose signature is similar or identical to that of the calling method. For example, a student project implementing a GUI text editor contained a class consisting almost entirely of pass-through methods. Here is an extract from that class:\n\n> 当相邻的层具有相似的抽象时，问题通常以直通方法的形式表现出来。传递方法是一种很少执行的方法，除了调用另一个方法（其签名与调用方法的签名相似或相同）之外。例如，一个实施 GUI 文本编辑器的学生项目包含一个几乎完全由传递方法组成的类。这是该类的摘录：\n\n```java\npublic class TextDocument ... {\n    private TextArea textArea;\n    private TextDocumentListener listener;\n    ...\n    public Character getLastTypedCharacter() {\n        return textArea.getLastTypedCharacter();\n    }\n    public int getCursorOffset() {\n        return textArea.getCursorOffset();\n    }\n    public void insertString(String textToInsert, int offset) {\n        textArea.insertString(textToInsert, offset);\n    }\n    public void willInsertString(String stringToInsert, int offset) {\n        if (listener != null) {\n            listener.willInsertString(this, stringToInsert, offset);\n        }\n    }\n    ...\n}\n```\n\n13 of the 15 public methods in that class were pass-through methods.\n\n> 该类别中 15 个公共方法中的 13 个是传递方法。\n\nimg Red Flag: Pass-Through Method img\n\nA pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.\n\n> 传递方法是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与传递方法相同的 API。这通常表示各类之间没有明确的职责划分。\n\nPass-through methods make classes shallower: they increase the interface complexity of the class, which adds complexity, but they don’t increase the total functionality of the system. Of the four methods above, only the last one has any functionality, and even there it is trivial: the method checks the validity of one variable. Pass-through methods also create dependencies between classes: if the signature changes for the insertString method in TextArea, then the insertString method in TextDocument will have to change to match.\n\n> 传递方法使类变浅：它们增加了类的接口复杂性，从而增加了复杂性，但是并没有增加系统的整体功能。在上述四个方法中，只有最后一个具有任何功能，甚至没有什么功能：该方法检查一个变量的有效性。直通方法还会在类之间创建依赖关系：如果针对 TextArea 中的 insertString 方法更改了签名，则必须更改 TextDocument 中的 insertString 方法以进行匹配。\n\nPass-through methods indicate that there is confusion over the division of responsibility between classes. In the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implemented entirely in TextArea. This is usually a bad idea: the interface to a piece of functionality should be in the same class that implements the functionality. When you see pass-through methods from one class to another, consider the two classes and ask yourself “Exactly which features and abstractions is each of these classes responsible for?” You will probably notice that there is an overlap in responsibility between the classes.\n\n> 传递方法表明类之间的责任划分存在混淆。在上面的示例中，TextDocument 类提供了 insertString 方法，但是用于插入文本的功能完全在 TextArea 中实现。这通常是一个坏主意：某个功能的接口应该在实现该功能的同一类中。当您看到从一个类到另一个类的传递方法时，请考虑这两个类，并问自己“这些类分别负责哪些功能和抽象？” 您可能会注意到，各类之间的职责重叠。\n\nThe solution is to refactor the classes so that each class has a distinct and coherent set of responsibilities. Figure 7.1 illustrates several ways to do this. One approach, shown in Figure 7.1(b), is to expose the lower level class directly to the callers of the higher level class, removing all responsibility for the feature from the higher level class. Another approach is to redistribute the functionality between the classes, as in Figure 7.1(c). Finally, if the classes can’t be disentangled, the best solution may be to merge them as in Figure 7.1(d).\n\n> 解决方案是重构类，以使每个类都有各自不同且连贯的职责。图 7.1 说明了几种方法。一种方法，如图 7.1（b）所示，是将较低级别的类直接暴露给较高级别的类的调用者，而从较高级别的类中删除对该功能的所有责任。另一种方法是在类之间重新分配功能，如图 7.1（c）所示。最后，如果无法解开这些类，最好的解决方案可能是如图 7.1（d）所示合并它们。\n\nIn the example above, there were three classes with intertwined responsibilities: TextDocument, TextArea, and TextDocumentListener. The student eliminated the pass-through methods by moving methods between classes and collapsing the three classes into just two, whose responsibilities were more clearly differentiated.\n\n> 在上面的示例中，职责交织的三个类为：TextDocument，TextArea 和 TextDocumentListener。学生通过在班级之间移动方法并将三个班级缩减为两个班级来消除传递方法，这两个班级的职责更加明确。\n\n## 7.2 When is interface duplication OK? 接口复制何时可以？\n\nHaving methods with the same signature is not always bad. The important thing is that each new method should contribute significant functionality. Pass-through methods are bad because they contribute no new functionality.\n\n> 具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。传递方法很糟糕，因为它们不提供任何新功能。\n\nOne example where it’s useful for a method to call another method with the same signature is a dispatcher. A dispatcher is a method that uses its arguments to select one of several other methods to invoke; then it passes most or all of its arguments to the chosen method. The signature for the dispatcher is often the same as the signature for the methods that it calls. Even so, the dispatcher provides useful functionality: it chooses which of several other methods should carry out each task.\n\n> 分派器是一个示例，该示例对于一种方法调用具有相同签名的另一种方法很有用。调度程序是一种使用其参数选择要调用的其他方法之一的方法。然后将其大部分或所有参数传递给所选方法。调度程序的签名通常与其调用的方法的签名相同。即便如此，调度程序仍提供有用的功能：它可以选择其他几种方法中的哪一种来执行每个任务。\n\n![](../../img/figures/00015.jpeg)\n\nFigure 7.1: Pass-through methods. In (a), class C1 contains three pass-through methods, which do nothing but invoke methods with the same signature in C2 (each symbol represents a particular method signature). The pass-through methods can be eliminated by having C1’s callers invoke C2 directly as in (b), by redistributing functionality between C1 and C2 to avoid calls between the classes as in (c), or by combining the classes as in (d).\n\n> 图 7.1：直通方法。在（a）中，类 C1 包含三个直通方法，这些方法只调用 C2 中具有相同签名的方法（每个符号代表一个特定的方法签名）。可以通过使 C1 的调用方像在（b）中那样直接调用 C2，通过在 C1 和 C2 之间重新分配功能以避免在（c）中的类之间进行调用，或者通过组合在（d）中的类来消除传递方法。 。\n\nFor example, when a Web server receives an incoming HTTP request from a Web browser, it invokes a dispatcher that examines the URL in the incoming request and selects a specific method to handle the request. Some URLs might be handled by returning the contents of a file on disk; others might be handled by invoking a procedure in a language such as PHP or JavaScript. The dispatch process can be quite intricate, and is usually driven by a set of rules that are matched against the incoming URL.\n\n> 例如，当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度程序，该调度程序检查传入请求中的 URL 并选择一种特定的方法来处理该请求。某些 URL 可以通过返回磁盘上文件的内容来处理。其他人则可以通过调用诸如 PHP 或 JavaScript 之类的语言的过程来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。\n\nIt is fine for several methods to have the same signature as long as each of them provides useful and distinct functionality. The methods invoked by a dispatcher have this property. Another example is interfaces with multiple implementations, such as disk drivers in an operating system. Each driver provides support for a different kind of disk, but they all have the same interface. When several methods provide different implementations of the same interface, it reduces cognitive load. Once you have worked with one of these methods, it’s easier to work with the others, since you don’t need to learn a new interface. Methods like this are usually in the same layer and they don’t invoke each other.\n\n> 只要每种方法都提供有用且独特的功能，几种方法都应具有相同的签名。调度程序调用的方法具有此属性。另一个示例是具有多种实现方式的接口，例如操作系统中的磁盘驱动程序。每个驱动程序都支持不同类型的磁盘，但是它们都有相同的接口。当几种方法提供同一接口的不同实现时，它将减少认知负担。使用其中一种方法后，与其他方法一起使用会更容易，因为您无需学习新的界面。像这样的方法通常位于同一层，并且它们不会相互调用。\n\n## 7.3 Decorators 装饰器\n\nThe decorator design pattern (also known as a “wrapper”) is one that encourages API duplication across layers. A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object. In the Java I/O example from Chapter 4, the BufferedInputStream class is a decorator: given an InputStream object, it provides the same API but introduces buffering. For example, when its read method is invoked to read a single character, it invokes read on the underlying InputStream to read a much larger block, and saves the extra characters to satisfy future read calls. Another example occurs in windowing systems: a Window class implements a simple form of window that is not scrollable, and a ScrollableWindow class decorates the Window class by adding horizontal and vertical scrollbars.\n\n> 装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。\n\nThe motivation for decorators is to separate special-purpose extensions of a class from a more generic core. However, decorator classes tend to be shallow: they introduce a large amount of boilerplate for a small amount of new functionality. Decorator classes often contain many pass-through methods. It’s easy to overuse the decorator pattern, creating a new class for every small new feature. This results in an explosion of shallow classes, such as the Java I/O example.\n\n> 装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多传递方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。\n\nBefore creating a decorator class, consider alternatives such as the following:\n\n> 创建装饰器类之前，请考虑以下替代方法：\n\n- Could you add the new functionality directly to the underlying class, rather than creating a decorator class? This makes sense if the new functionality is relatively general-purpose, or if it is logically related to the underlying class, or if most uses of the underlying class will also use the new functionality. For example, virtually everyone who creates a Java InputStream will also create a BufferedInputStream, and buffering is a natural part of I/O, so these classes should have been combined.\n- If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?\n- Could you merge the new functionality with an existing decorator, rather than creating a new decorator? This would result in a single deeper decorator class rather than multiple shallow ones.\n- Finally, ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class? In the windowing example, the scrollbars could probably be implemented separately from the main window, without wrapping all of its existing functionality.\n\n---\n\n> - 您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。\n> - 如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？\n> - 您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。\n> - 最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。\n\nSometimes decorators make sense, but there is usually a better alternative.\n\n> 有时装饰者很有意义，但通常有更好的选择。\n\n## 7.4 Interface versus implementation 接口与实现\n\nAnother application of the “different layer, different abstraction” rule is that the interface of a class should normally be different from its implementation: the representations used internally should be different from the abstractions that appear in the interface. If the two have similar abstractions, then the class probably isn’t very deep. For example, in the text editor project discussed in Chapter 6, most of the teams implemented the text module in terms of lines of text, with each line stored separately. Some of the teams also designed the APIs for the text class around lines, with methods such as getLine and putLine. However, this made the text class shallow and awkward to use. In the higher-level user interface code, it’s common to insert text in the middle of a line (e.g., when the user is typing) or to delete a range of text that spans lines. With a line-oriented API for the text class, callers were forced to split and join lines to implement the user-interface operations. This code was nontrivial and it was duplicated and scattered across the implementation of the user interface.\n\n> “不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。\n\nThe text classes were much easier to use when they provided a character-oriented interface, such as an insert method that inserts an arbitrary string of text (which may include newlines) at an arbitrary position in the text and a delete method that deletes the text between two arbitrary positions in the text. Internally, the text was still represented in terms of lines. A character-oriented interface encapsulates the complexity of line splitting and joining inside the text class, which makes the text class deeper and simplifies higher level code that uses the class. With this approach, the text API is quite different from the line-oriented storage mechanism; the difference represents valuable functionality provided by the class.\n\n> 文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能。\n\n## 7.5 Pass-through variables 传递变量\n\nAnother form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods. Figure 7.2(a) shows an example from a datacenter service. A command-line argument describes certificates to use for secure communication. This information is only needed by a low-level method m3, which calls a library method to open a socket, but it is passed down through all the methods on the path between main and m3. The cert variable appears in the signature of each of the intermediate methods.\n\n> 跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。图 7.2（a）显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。\n\nPass-through variables add complexity because they force all of the intermediate methods to be aware of their existence, even though the methods have no use for the variables. Furthermore, if a new variable comes into existence (for example, a system is initially built without support for certificates, but you later decide to add that support), you may have to modify a large number of interfaces and methods to pass the variable through all of the relevant paths.\n\n> 传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。\n\nEliminating pass-through variables can be challenging. One approach is to see if there is already an object shared between the topmost and bottommost methods. In the datacenter service example of Figure 7.2, perhaps there is an object containing other information about network communication, which is available to both main and m3. If so, main can store the certificate information in that object, so it needn’t be passed through all of the intervening methods on the path to m3 (see Figure 7.2(b)). However, if there is such an object, then it may itself be a pass-through variable (how else does m3 get access to it?).\n\n> 消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在图 7.2 的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书（请参见图 7.2（b））。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。\n\nAnother approach is to store the information in a global variable, as in Figure 7.2(c). This avoids the need to pass the information from method to method, but global variables almost always create other problems. For example, global variables make it impossible to create two independent instances of the same system in the same process, since accesses to the global variables will conflict. It may seem unlikely that you would need multiple instances in production, but they are often useful in testing.\n\n> 另一种方法是将信息存储在全局变量中，如图 7.2（c）所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。\n\nThe solution I use most often is to introduce a context object as in Figure 7.2(d). A context stores all of the application’s global state (anything that would otherwise be a pass-through variable or global variable). Most applications have multiple variables in their global state, representing things such as configuration options, shared subsystems, and performance counters. There is one context object per instance of the system. The context allows multiple instances of the system to coexist in a single process, each with its own context.\n\n> 我最常使用的解决方案是引入一个上下文对象，如图 7.2（d）所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。\n\nUnfortunately, the context will probably be needed in many places, so it can potentially become a pass-through variable. To reduce the number of methods that must be aware of it, a reference to the context can be saved in most of the system’s major objects. In the example of Figure 7.2(d), the class containing m3 stores a reference to the context as an instance variable in its objects. When a new object is created, the creating method retrieves the context reference from its object and passes it to the constructor for the new object. With this approach, the context is available everywhere, but it only appears as an explicit argument in constructors.\n\n> 不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在图 7.2（d）的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。\n\n![](../../img/figures/00016.gif)\n\nFigure 7.2: Possible techniques for dealing with a pass-through variable. In (a), cert is passed through methods m1 and m2 even though they don’t use it. In (b), main and m3 have shared access to an object, so the variable can be stored there instead of passing it through m1 and m2. In (c), cert is stored as a global variable. In (d), cert is stored in a context object along with other system-wide information, such as a timeout value and performance counters; a reference to the context is stored in all objects whose methods need access to it.\n\n> 图 7.2：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。\n\nThe context object unifies the handling of all system-global information and eliminates the need for pass-through variables. If a new variable needs to be added, it can be added to the context object; no existing code is affected except for the constructor and destructor for the context. The context makes it easy to identify and manage the global state of the system, since it is all stored in one place. The context is also convenient for testing: test code can change the global configuration of the application by modifying fields in the context. It would be much more difficult to implement such changes if the system used pass-through variables.\n\n> 上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。\n\nContexts are far from an ideal solution. The variables stored in a context have most of the disadvantages of global variables; for example, it may not be obvious why a particular variable is present, or where it is used. Without discipline, a context can turn into a huge grab-bag of data that creates nonobvious dependencies throughout the system. Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable. Unfortunately, I haven’t found a better solution than contexts.\n\n> 上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。\n\n## 7.6 Conclusion 结论\n\nEach piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element. In order for an element to provide a net gain against complexity, it must eliminate some complexity that would be present in the absence of the design element. Otherwise, you are better off implementing the system without that particular element. For example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.\n\n> 界面，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。\n\nThe “different layer, different abstraction” rule is just an application of this idea: if different layers have the same abstraction, such as pass-through methods or decorators, then there’s a good chance that they haven’t provided enough benefit to compensate for the additional infrastructure they represent. Similarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality.\n\n> “不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如传递方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能。\n","source":"_posts/软件设计的哲学-ch7.md","raw":"---\ntitle: 软件设计的哲学 - ch7\ndate: 2021-02-7\ntags: 软件设计的哲学 软件开发 方法论\n---\n不同的层，不同的抽象\n<!-- more -->\n# 第 7 章 不同的层，不同的抽象\n\n> Chapter 7 Different Layer, Different Abstraction\n\nSoftware systems are composed in layers, where higher layers use the facilities provided by lower layers. In a well-designed system, each layer provides a different abstraction from the layers above and below it; if you follow a single operation as it moves up and down through layers by invoking methods, the abstractions change with each method call. For example:\n\n> 软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。如果您通过调用方法遵循单个操作在层中上下移动，则每个方法调用的抽象都会改变。例如：\n\n- In a file system, the uppermost layer implements a file abstraction. A file consists of a variable-length array of bytes, which can be updated by reading and writing variable-length byte ranges. The next lower layer in the file system implements a cache in memory of fixed-size disk blocks; callers can assume that frequently used blocks will stay in memory where they can be accessed quickly. The lowest layer consists of device drivers, which move blocks between secondary storage devices and memory.\n- In a network transport protocol such as TCP, the abstraction provided by the topmost layer is a stream of bytes delivered reliably from one machine to another. This level is built on a lower level that transmits packets of bounded size between machines on a best-effort basis: most packets will be delivered successfully, but some packets may be lost or delivered out of order.\n\n---\n\n> - 在文件系统中，最上层实现文件抽象。文件由可变长度的字节数组组成，可以通过读写可变长度的字节范围来更新该字节。文件系统的下一个下一层在固定大小的磁盘块的内存中实现了高速缓存。调用者可以假定经常使用的块将保留在内存中，以便可以快速访问它们。最低层由设备驱动程序组成，它们在辅助存储设备和内存之间移动块。\n> - 在诸如 TCP 的网络传输协议中，最顶层提供的抽象是从一台机器可靠地传递到另一台机器的字节流。此级别在较低级别上构建，该级别可以尽最大努力在计算机之间传输有限大小的数据包：大多数数据包将成功交付，但某些数据包可能会丢失或乱序交付。\n\nIf a system contains adjacent layers with similar abstractions, this is a red flag that suggests a problem with the class decomposition. This chapter discusses situations where this happens, the problems that result, and how to refactor to eliminate the problems.\n\n> 如果系统包含具有相似抽象的相邻层，则这是一个红色标记，表明类分解存在问题。本章讨论了发生这种情况的情况，导致的问题以及如何重构以消除问题。\n\n## 7.1 Pass-through methods 传递方法\n\nWhen adjacent layers have similar abstractions, the problem often manifests itself in the form of pass-through methods. A pass-through method is one that does little except invoke another method, whose signature is similar or identical to that of the calling method. For example, a student project implementing a GUI text editor contained a class consisting almost entirely of pass-through methods. Here is an extract from that class:\n\n> 当相邻的层具有相似的抽象时，问题通常以直通方法的形式表现出来。传递方法是一种很少执行的方法，除了调用另一个方法（其签名与调用方法的签名相似或相同）之外。例如，一个实施 GUI 文本编辑器的学生项目包含一个几乎完全由传递方法组成的类。这是该类的摘录：\n\n```java\npublic class TextDocument ... {\n    private TextArea textArea;\n    private TextDocumentListener listener;\n    ...\n    public Character getLastTypedCharacter() {\n        return textArea.getLastTypedCharacter();\n    }\n    public int getCursorOffset() {\n        return textArea.getCursorOffset();\n    }\n    public void insertString(String textToInsert, int offset) {\n        textArea.insertString(textToInsert, offset);\n    }\n    public void willInsertString(String stringToInsert, int offset) {\n        if (listener != null) {\n            listener.willInsertString(this, stringToInsert, offset);\n        }\n    }\n    ...\n}\n```\n\n13 of the 15 public methods in that class were pass-through methods.\n\n> 该类别中 15 个公共方法中的 13 个是传递方法。\n\nimg Red Flag: Pass-Through Method img\n\nA pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.\n\n> 传递方法是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与传递方法相同的 API。这通常表示各类之间没有明确的职责划分。\n\nPass-through methods make classes shallower: they increase the interface complexity of the class, which adds complexity, but they don’t increase the total functionality of the system. Of the four methods above, only the last one has any functionality, and even there it is trivial: the method checks the validity of one variable. Pass-through methods also create dependencies between classes: if the signature changes for the insertString method in TextArea, then the insertString method in TextDocument will have to change to match.\n\n> 传递方法使类变浅：它们增加了类的接口复杂性，从而增加了复杂性，但是并没有增加系统的整体功能。在上述四个方法中，只有最后一个具有任何功能，甚至没有什么功能：该方法检查一个变量的有效性。直通方法还会在类之间创建依赖关系：如果针对 TextArea 中的 insertString 方法更改了签名，则必须更改 TextDocument 中的 insertString 方法以进行匹配。\n\nPass-through methods indicate that there is confusion over the division of responsibility between classes. In the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implemented entirely in TextArea. This is usually a bad idea: the interface to a piece of functionality should be in the same class that implements the functionality. When you see pass-through methods from one class to another, consider the two classes and ask yourself “Exactly which features and abstractions is each of these classes responsible for?” You will probably notice that there is an overlap in responsibility between the classes.\n\n> 传递方法表明类之间的责任划分存在混淆。在上面的示例中，TextDocument 类提供了 insertString 方法，但是用于插入文本的功能完全在 TextArea 中实现。这通常是一个坏主意：某个功能的接口应该在实现该功能的同一类中。当您看到从一个类到另一个类的传递方法时，请考虑这两个类，并问自己“这些类分别负责哪些功能和抽象？” 您可能会注意到，各类之间的职责重叠。\n\nThe solution is to refactor the classes so that each class has a distinct and coherent set of responsibilities. Figure 7.1 illustrates several ways to do this. One approach, shown in Figure 7.1(b), is to expose the lower level class directly to the callers of the higher level class, removing all responsibility for the feature from the higher level class. Another approach is to redistribute the functionality between the classes, as in Figure 7.1(c). Finally, if the classes can’t be disentangled, the best solution may be to merge them as in Figure 7.1(d).\n\n> 解决方案是重构类，以使每个类都有各自不同且连贯的职责。图 7.1 说明了几种方法。一种方法，如图 7.1（b）所示，是将较低级别的类直接暴露给较高级别的类的调用者，而从较高级别的类中删除对该功能的所有责任。另一种方法是在类之间重新分配功能，如图 7.1（c）所示。最后，如果无法解开这些类，最好的解决方案可能是如图 7.1（d）所示合并它们。\n\nIn the example above, there were three classes with intertwined responsibilities: TextDocument, TextArea, and TextDocumentListener. The student eliminated the pass-through methods by moving methods between classes and collapsing the three classes into just two, whose responsibilities were more clearly differentiated.\n\n> 在上面的示例中，职责交织的三个类为：TextDocument，TextArea 和 TextDocumentListener。学生通过在班级之间移动方法并将三个班级缩减为两个班级来消除传递方法，这两个班级的职责更加明确。\n\n## 7.2 When is interface duplication OK? 接口复制何时可以？\n\nHaving methods with the same signature is not always bad. The important thing is that each new method should contribute significant functionality. Pass-through methods are bad because they contribute no new functionality.\n\n> 具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。传递方法很糟糕，因为它们不提供任何新功能。\n\nOne example where it’s useful for a method to call another method with the same signature is a dispatcher. A dispatcher is a method that uses its arguments to select one of several other methods to invoke; then it passes most or all of its arguments to the chosen method. The signature for the dispatcher is often the same as the signature for the methods that it calls. Even so, the dispatcher provides useful functionality: it chooses which of several other methods should carry out each task.\n\n> 分派器是一个示例，该示例对于一种方法调用具有相同签名的另一种方法很有用。调度程序是一种使用其参数选择要调用的其他方法之一的方法。然后将其大部分或所有参数传递给所选方法。调度程序的签名通常与其调用的方法的签名相同。即便如此，调度程序仍提供有用的功能：它可以选择其他几种方法中的哪一种来执行每个任务。\n\n![](../../img/figures/00015.jpeg)\n\nFigure 7.1: Pass-through methods. In (a), class C1 contains three pass-through methods, which do nothing but invoke methods with the same signature in C2 (each symbol represents a particular method signature). The pass-through methods can be eliminated by having C1’s callers invoke C2 directly as in (b), by redistributing functionality between C1 and C2 to avoid calls between the classes as in (c), or by combining the classes as in (d).\n\n> 图 7.1：直通方法。在（a）中，类 C1 包含三个直通方法，这些方法只调用 C2 中具有相同签名的方法（每个符号代表一个特定的方法签名）。可以通过使 C1 的调用方像在（b）中那样直接调用 C2，通过在 C1 和 C2 之间重新分配功能以避免在（c）中的类之间进行调用，或者通过组合在（d）中的类来消除传递方法。 。\n\nFor example, when a Web server receives an incoming HTTP request from a Web browser, it invokes a dispatcher that examines the URL in the incoming request and selects a specific method to handle the request. Some URLs might be handled by returning the contents of a file on disk; others might be handled by invoking a procedure in a language such as PHP or JavaScript. The dispatch process can be quite intricate, and is usually driven by a set of rules that are matched against the incoming URL.\n\n> 例如，当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度程序，该调度程序检查传入请求中的 URL 并选择一种特定的方法来处理该请求。某些 URL 可以通过返回磁盘上文件的内容来处理。其他人则可以通过调用诸如 PHP 或 JavaScript 之类的语言的过程来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。\n\nIt is fine for several methods to have the same signature as long as each of them provides useful and distinct functionality. The methods invoked by a dispatcher have this property. Another example is interfaces with multiple implementations, such as disk drivers in an operating system. Each driver provides support for a different kind of disk, but they all have the same interface. When several methods provide different implementations of the same interface, it reduces cognitive load. Once you have worked with one of these methods, it’s easier to work with the others, since you don’t need to learn a new interface. Methods like this are usually in the same layer and they don’t invoke each other.\n\n> 只要每种方法都提供有用且独特的功能，几种方法都应具有相同的签名。调度程序调用的方法具有此属性。另一个示例是具有多种实现方式的接口，例如操作系统中的磁盘驱动程序。每个驱动程序都支持不同类型的磁盘，但是它们都有相同的接口。当几种方法提供同一接口的不同实现时，它将减少认知负担。使用其中一种方法后，与其他方法一起使用会更容易，因为您无需学习新的界面。像这样的方法通常位于同一层，并且它们不会相互调用。\n\n## 7.3 Decorators 装饰器\n\nThe decorator design pattern (also known as a “wrapper”) is one that encourages API duplication across layers. A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object. In the Java I/O example from Chapter 4, the BufferedInputStream class is a decorator: given an InputStream object, it provides the same API but introduces buffering. For example, when its read method is invoked to read a single character, it invokes read on the underlying InputStream to read a much larger block, and saves the extra characters to satisfy future read calls. Another example occurs in windowing systems: a Window class implements a simple form of window that is not scrollable, and a ScrollableWindow class decorates the Window class by adding horizontal and vertical scrollbars.\n\n> 装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。\n\nThe motivation for decorators is to separate special-purpose extensions of a class from a more generic core. However, decorator classes tend to be shallow: they introduce a large amount of boilerplate for a small amount of new functionality. Decorator classes often contain many pass-through methods. It’s easy to overuse the decorator pattern, creating a new class for every small new feature. This results in an explosion of shallow classes, such as the Java I/O example.\n\n> 装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多传递方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。\n\nBefore creating a decorator class, consider alternatives such as the following:\n\n> 创建装饰器类之前，请考虑以下替代方法：\n\n- Could you add the new functionality directly to the underlying class, rather than creating a decorator class? This makes sense if the new functionality is relatively general-purpose, or if it is logically related to the underlying class, or if most uses of the underlying class will also use the new functionality. For example, virtually everyone who creates a Java InputStream will also create a BufferedInputStream, and buffering is a natural part of I/O, so these classes should have been combined.\n- If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?\n- Could you merge the new functionality with an existing decorator, rather than creating a new decorator? This would result in a single deeper decorator class rather than multiple shallow ones.\n- Finally, ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class? In the windowing example, the scrollbars could probably be implemented separately from the main window, without wrapping all of its existing functionality.\n\n---\n\n> - 您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。\n> - 如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？\n> - 您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。\n> - 最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。\n\nSometimes decorators make sense, but there is usually a better alternative.\n\n> 有时装饰者很有意义，但通常有更好的选择。\n\n## 7.4 Interface versus implementation 接口与实现\n\nAnother application of the “different layer, different abstraction” rule is that the interface of a class should normally be different from its implementation: the representations used internally should be different from the abstractions that appear in the interface. If the two have similar abstractions, then the class probably isn’t very deep. For example, in the text editor project discussed in Chapter 6, most of the teams implemented the text module in terms of lines of text, with each line stored separately. Some of the teams also designed the APIs for the text class around lines, with methods such as getLine and putLine. However, this made the text class shallow and awkward to use. In the higher-level user interface code, it’s common to insert text in the middle of a line (e.g., when the user is typing) or to delete a range of text that spans lines. With a line-oriented API for the text class, callers were forced to split and join lines to implement the user-interface operations. This code was nontrivial and it was duplicated and scattered across the implementation of the user interface.\n\n> “不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。\n\nThe text classes were much easier to use when they provided a character-oriented interface, such as an insert method that inserts an arbitrary string of text (which may include newlines) at an arbitrary position in the text and a delete method that deletes the text between two arbitrary positions in the text. Internally, the text was still represented in terms of lines. A character-oriented interface encapsulates the complexity of line splitting and joining inside the text class, which makes the text class deeper and simplifies higher level code that uses the class. With this approach, the text API is quite different from the line-oriented storage mechanism; the difference represents valuable functionality provided by the class.\n\n> 文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能。\n\n## 7.5 Pass-through variables 传递变量\n\nAnother form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods. Figure 7.2(a) shows an example from a datacenter service. A command-line argument describes certificates to use for secure communication. This information is only needed by a low-level method m3, which calls a library method to open a socket, but it is passed down through all the methods on the path between main and m3. The cert variable appears in the signature of each of the intermediate methods.\n\n> 跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。图 7.2（a）显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。\n\nPass-through variables add complexity because they force all of the intermediate methods to be aware of their existence, even though the methods have no use for the variables. Furthermore, if a new variable comes into existence (for example, a system is initially built without support for certificates, but you later decide to add that support), you may have to modify a large number of interfaces and methods to pass the variable through all of the relevant paths.\n\n> 传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。\n\nEliminating pass-through variables can be challenging. One approach is to see if there is already an object shared between the topmost and bottommost methods. In the datacenter service example of Figure 7.2, perhaps there is an object containing other information about network communication, which is available to both main and m3. If so, main can store the certificate information in that object, so it needn’t be passed through all of the intervening methods on the path to m3 (see Figure 7.2(b)). However, if there is such an object, then it may itself be a pass-through variable (how else does m3 get access to it?).\n\n> 消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在图 7.2 的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书（请参见图 7.2（b））。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。\n\nAnother approach is to store the information in a global variable, as in Figure 7.2(c). This avoids the need to pass the information from method to method, but global variables almost always create other problems. For example, global variables make it impossible to create two independent instances of the same system in the same process, since accesses to the global variables will conflict. It may seem unlikely that you would need multiple instances in production, but they are often useful in testing.\n\n> 另一种方法是将信息存储在全局变量中，如图 7.2（c）所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。\n\nThe solution I use most often is to introduce a context object as in Figure 7.2(d). A context stores all of the application’s global state (anything that would otherwise be a pass-through variable or global variable). Most applications have multiple variables in their global state, representing things such as configuration options, shared subsystems, and performance counters. There is one context object per instance of the system. The context allows multiple instances of the system to coexist in a single process, each with its own context.\n\n> 我最常使用的解决方案是引入一个上下文对象，如图 7.2（d）所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。\n\nUnfortunately, the context will probably be needed in many places, so it can potentially become a pass-through variable. To reduce the number of methods that must be aware of it, a reference to the context can be saved in most of the system’s major objects. In the example of Figure 7.2(d), the class containing m3 stores a reference to the context as an instance variable in its objects. When a new object is created, the creating method retrieves the context reference from its object and passes it to the constructor for the new object. With this approach, the context is available everywhere, but it only appears as an explicit argument in constructors.\n\n> 不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在图 7.2（d）的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。\n\n![](../../img/figures/00016.gif)\n\nFigure 7.2: Possible techniques for dealing with a pass-through variable. In (a), cert is passed through methods m1 and m2 even though they don’t use it. In (b), main and m3 have shared access to an object, so the variable can be stored there instead of passing it through m1 and m2. In (c), cert is stored as a global variable. In (d), cert is stored in a context object along with other system-wide information, such as a timeout value and performance counters; a reference to the context is stored in all objects whose methods need access to it.\n\n> 图 7.2：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。\n\nThe context object unifies the handling of all system-global information and eliminates the need for pass-through variables. If a new variable needs to be added, it can be added to the context object; no existing code is affected except for the constructor and destructor for the context. The context makes it easy to identify and manage the global state of the system, since it is all stored in one place. The context is also convenient for testing: test code can change the global configuration of the application by modifying fields in the context. It would be much more difficult to implement such changes if the system used pass-through variables.\n\n> 上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。\n\nContexts are far from an ideal solution. The variables stored in a context have most of the disadvantages of global variables; for example, it may not be obvious why a particular variable is present, or where it is used. Without discipline, a context can turn into a huge grab-bag of data that creates nonobvious dependencies throughout the system. Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable. Unfortunately, I haven’t found a better solution than contexts.\n\n> 上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。\n\n## 7.6 Conclusion 结论\n\nEach piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element. In order for an element to provide a net gain against complexity, it must eliminate some complexity that would be present in the absence of the design element. Otherwise, you are better off implementing the system without that particular element. For example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.\n\n> 界面，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。\n\nThe “different layer, different abstraction” rule is just an application of this idea: if different layers have the same abstraction, such as pass-through methods or decorators, then there’s a good chance that they haven’t provided enough benefit to compensate for the additional infrastructure they represent. Similarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality.\n\n> “不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如传递方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能。\n","slug":"软件设计的哲学-ch7","published":1,"updated":"2021-02-16T04:54:03.029Z","_id":"ckl7iw2vv000ikiiy3qr8brw2","comments":1,"layout":"post","photos":[],"link":"","content":"<p>不同的层，不同的抽象</p>\n<a id=\"more\"></a>\n<h1 id=\"第-7-章-不同的层，不同的抽象\"><a href=\"#第-7-章-不同的层，不同的抽象\" class=\"headerlink\" title=\"第 7 章 不同的层，不同的抽象\"></a>第 7 章 不同的层，不同的抽象</h1><blockquote>\n<p>Chapter 7 Different Layer, Different Abstraction</p>\n</blockquote>\n<p>Software systems are composed in layers, where higher layers use the facilities provided by lower layers. In a well-designed system, each layer provides a different abstraction from the layers above and below it; if you follow a single operation as it moves up and down through layers by invoking methods, the abstractions change with each method call. For example:</p>\n<blockquote>\n<p>软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。如果您通过调用方法遵循单个操作在层中上下移动，则每个方法调用的抽象都会改变。例如：</p>\n</blockquote>\n<ul>\n<li>In a file system, the uppermost layer implements a file abstraction. A file consists of a variable-length array of bytes, which can be updated by reading and writing variable-length byte ranges. The next lower layer in the file system implements a cache in memory of fixed-size disk blocks; callers can assume that frequently used blocks will stay in memory where they can be accessed quickly. The lowest layer consists of device drivers, which move blocks between secondary storage devices and memory.</li>\n<li>In a network transport protocol such as TCP, the abstraction provided by the topmost layer is a stream of bytes delivered reliably from one machine to another. This level is built on a lower level that transmits packets of bounded size between machines on a best-effort basis: most packets will be delivered successfully, but some packets may be lost or delivered out of order.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>在文件系统中，最上层实现文件抽象。文件由可变长度的字节数组组成，可以通过读写可变长度的字节范围来更新该字节。文件系统的下一个下一层在固定大小的磁盘块的内存中实现了高速缓存。调用者可以假定经常使用的块将保留在内存中，以便可以快速访问它们。最低层由设备驱动程序组成，它们在辅助存储设备和内存之间移动块。</li>\n<li>在诸如 TCP 的网络传输协议中，最顶层提供的抽象是从一台机器可靠地传递到另一台机器的字节流。此级别在较低级别上构建，该级别可以尽最大努力在计算机之间传输有限大小的数据包：大多数数据包将成功交付，但某些数据包可能会丢失或乱序交付。</li>\n</ul>\n</blockquote>\n<p>If a system contains adjacent layers with similar abstractions, this is a red flag that suggests a problem with the class decomposition. This chapter discusses situations where this happens, the problems that result, and how to refactor to eliminate the problems.</p>\n<blockquote>\n<p>如果系统包含具有相似抽象的相邻层，则这是一个红色标记，表明类分解存在问题。本章讨论了发生这种情况的情况，导致的问题以及如何重构以消除问题。</p>\n</blockquote>\n<h2 id=\"7-1-Pass-through-methods-传递方法\"><a href=\"#7-1-Pass-through-methods-传递方法\" class=\"headerlink\" title=\"7.1 Pass-through methods 传递方法\"></a>7.1 Pass-through methods 传递方法</h2><p>When adjacent layers have similar abstractions, the problem often manifests itself in the form of pass-through methods. A pass-through method is one that does little except invoke another method, whose signature is similar or identical to that of the calling method. For example, a student project implementing a GUI text editor contained a class consisting almost entirely of pass-through methods. Here is an extract from that class:</p>\n<blockquote>\n<p>当相邻的层具有相似的抽象时，问题通常以直通方法的形式表现出来。传递方法是一种很少执行的方法，除了调用另一个方法（其签名与调用方法的签名相似或相同）之外。例如，一个实施 GUI 文本编辑器的学生项目包含一个几乎完全由传递方法组成的类。这是该类的摘录：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextDocument</span> ... </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextArea textArea;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextDocumentListener listener;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Character <span class=\"title\">getLastTypedCharacter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> textArea.getLastTypedCharacter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCursorOffset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> textArea.getCursorOffset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertString</span><span class=\"params\">(String textToInsert, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</span><br><span class=\"line\">        textArea.insertString(textToInsert, offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">willInsertString</span><span class=\"params\">(String stringToInsert, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            listener.willInsertString(<span class=\"keyword\">this</span>, stringToInsert, offset);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>13 of the 15 public methods in that class were pass-through methods.</p>\n<blockquote>\n<p>该类别中 15 个公共方法中的 13 个是传递方法。</p>\n</blockquote>\n<p>img Red Flag: Pass-Through Method img</p>\n<p>A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.</p>\n<blockquote>\n<p>传递方法是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与传递方法相同的 API。这通常表示各类之间没有明确的职责划分。</p>\n</blockquote>\n<p>Pass-through methods make classes shallower: they increase the interface complexity of the class, which adds complexity, but they don’t increase the total functionality of the system. Of the four methods above, only the last one has any functionality, and even there it is trivial: the method checks the validity of one variable. Pass-through methods also create dependencies between classes: if the signature changes for the insertString method in TextArea, then the insertString method in TextDocument will have to change to match.</p>\n<blockquote>\n<p>传递方法使类变浅：它们增加了类的接口复杂性，从而增加了复杂性，但是并没有增加系统的整体功能。在上述四个方法中，只有最后一个具有任何功能，甚至没有什么功能：该方法检查一个变量的有效性。直通方法还会在类之间创建依赖关系：如果针对 TextArea 中的 insertString 方法更改了签名，则必须更改 TextDocument 中的 insertString 方法以进行匹配。</p>\n</blockquote>\n<p>Pass-through methods indicate that there is confusion over the division of responsibility between classes. In the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implemented entirely in TextArea. This is usually a bad idea: the interface to a piece of functionality should be in the same class that implements the functionality. When you see pass-through methods from one class to another, consider the two classes and ask yourself “Exactly which features and abstractions is each of these classes responsible for?” You will probably notice that there is an overlap in responsibility between the classes.</p>\n<blockquote>\n<p>传递方法表明类之间的责任划分存在混淆。在上面的示例中，TextDocument 类提供了 insertString 方法，但是用于插入文本的功能完全在 TextArea 中实现。这通常是一个坏主意：某个功能的接口应该在实现该功能的同一类中。当您看到从一个类到另一个类的传递方法时，请考虑这两个类，并问自己“这些类分别负责哪些功能和抽象？” 您可能会注意到，各类之间的职责重叠。</p>\n</blockquote>\n<p>The solution is to refactor the classes so that each class has a distinct and coherent set of responsibilities. Figure 7.1 illustrates several ways to do this. One approach, shown in Figure 7.1(b), is to expose the lower level class directly to the callers of the higher level class, removing all responsibility for the feature from the higher level class. Another approach is to redistribute the functionality between the classes, as in Figure 7.1(c). Finally, if the classes can’t be disentangled, the best solution may be to merge them as in Figure 7.1(d).</p>\n<blockquote>\n<p>解决方案是重构类，以使每个类都有各自不同且连贯的职责。图 7.1 说明了几种方法。一种方法，如图 7.1（b）所示，是将较低级别的类直接暴露给较高级别的类的调用者，而从较高级别的类中删除对该功能的所有责任。另一种方法是在类之间重新分配功能，如图 7.1（c）所示。最后，如果无法解开这些类，最好的解决方案可能是如图 7.1（d）所示合并它们。</p>\n</blockquote>\n<p>In the example above, there were three classes with intertwined responsibilities: TextDocument, TextArea, and TextDocumentListener. The student eliminated the pass-through methods by moving methods between classes and collapsing the three classes into just two, whose responsibilities were more clearly differentiated.</p>\n<blockquote>\n<p>在上面的示例中，职责交织的三个类为：TextDocument，TextArea 和 TextDocumentListener。学生通过在班级之间移动方法并将三个班级缩减为两个班级来消除传递方法，这两个班级的职责更加明确。</p>\n</blockquote>\n<h2 id=\"7-2-When-is-interface-duplication-OK-接口复制何时可以？\"><a href=\"#7-2-When-is-interface-duplication-OK-接口复制何时可以？\" class=\"headerlink\" title=\"7.2 When is interface duplication OK? 接口复制何时可以？\"></a>7.2 When is interface duplication OK? 接口复制何时可以？</h2><p>Having methods with the same signature is not always bad. The important thing is that each new method should contribute significant functionality. Pass-through methods are bad because they contribute no new functionality.</p>\n<blockquote>\n<p>具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。传递方法很糟糕，因为它们不提供任何新功能。</p>\n</blockquote>\n<p>One example where it’s useful for a method to call another method with the same signature is a dispatcher. A dispatcher is a method that uses its arguments to select one of several other methods to invoke; then it passes most or all of its arguments to the chosen method. The signature for the dispatcher is often the same as the signature for the methods that it calls. Even so, the dispatcher provides useful functionality: it chooses which of several other methods should carry out each task.</p>\n<blockquote>\n<p>分派器是一个示例，该示例对于一种方法调用具有相同签名的另一种方法很有用。调度程序是一种使用其参数选择要调用的其他方法之一的方法。然后将其大部分或所有参数传递给所选方法。调度程序的签名通常与其调用的方法的签名相同。即便如此，调度程序仍提供有用的功能：它可以选择其他几种方法中的哪一种来执行每个任务。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00015.jpeg\" alt=\"\"></p>\n<p>Figure 7.1: Pass-through methods. In (a), class C1 contains three pass-through methods, which do nothing but invoke methods with the same signature in C2 (each symbol represents a particular method signature). The pass-through methods can be eliminated by having C1’s callers invoke C2 directly as in (b), by redistributing functionality between C1 and C2 to avoid calls between the classes as in (c), or by combining the classes as in (d).</p>\n<blockquote>\n<p>图 7.1：直通方法。在（a）中，类 C1 包含三个直通方法，这些方法只调用 C2 中具有相同签名的方法（每个符号代表一个特定的方法签名）。可以通过使 C1 的调用方像在（b）中那样直接调用 C2，通过在 C1 和 C2 之间重新分配功能以避免在（c）中的类之间进行调用，或者通过组合在（d）中的类来消除传递方法。 。</p>\n</blockquote>\n<p>For example, when a Web server receives an incoming HTTP request from a Web browser, it invokes a dispatcher that examines the URL in the incoming request and selects a specific method to handle the request. Some URLs might be handled by returning the contents of a file on disk; others might be handled by invoking a procedure in a language such as PHP or JavaScript. The dispatch process can be quite intricate, and is usually driven by a set of rules that are matched against the incoming URL.</p>\n<blockquote>\n<p>例如，当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度程序，该调度程序检查传入请求中的 URL 并选择一种特定的方法来处理该请求。某些 URL 可以通过返回磁盘上文件的内容来处理。其他人则可以通过调用诸如 PHP 或 JavaScript 之类的语言的过程来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。</p>\n</blockquote>\n<p>It is fine for several methods to have the same signature as long as each of them provides useful and distinct functionality. The methods invoked by a dispatcher have this property. Another example is interfaces with multiple implementations, such as disk drivers in an operating system. Each driver provides support for a different kind of disk, but they all have the same interface. When several methods provide different implementations of the same interface, it reduces cognitive load. Once you have worked with one of these methods, it’s easier to work with the others, since you don’t need to learn a new interface. Methods like this are usually in the same layer and they don’t invoke each other.</p>\n<blockquote>\n<p>只要每种方法都提供有用且独特的功能，几种方法都应具有相同的签名。调度程序调用的方法具有此属性。另一个示例是具有多种实现方式的接口，例如操作系统中的磁盘驱动程序。每个驱动程序都支持不同类型的磁盘，但是它们都有相同的接口。当几种方法提供同一接口的不同实现时，它将减少认知负担。使用其中一种方法后，与其他方法一起使用会更容易，因为您无需学习新的界面。像这样的方法通常位于同一层，并且它们不会相互调用。</p>\n</blockquote>\n<h2 id=\"7-3-Decorators-装饰器\"><a href=\"#7-3-Decorators-装饰器\" class=\"headerlink\" title=\"7.3 Decorators 装饰器\"></a>7.3 Decorators 装饰器</h2><p>The decorator design pattern (also known as a “wrapper”) is one that encourages API duplication across layers. A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object. In the Java I/O example from Chapter 4, the BufferedInputStream class is a decorator: given an InputStream object, it provides the same API but introduces buffering. For example, when its read method is invoked to read a single character, it invokes read on the underlying InputStream to read a much larger block, and saves the extra characters to satisfy future read calls. Another example occurs in windowing systems: a Window class implements a simple form of window that is not scrollable, and a ScrollableWindow class decorates the Window class by adding horizontal and vertical scrollbars.</p>\n<blockquote>\n<p>装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。</p>\n</blockquote>\n<p>The motivation for decorators is to separate special-purpose extensions of a class from a more generic core. However, decorator classes tend to be shallow: they introduce a large amount of boilerplate for a small amount of new functionality. Decorator classes often contain many pass-through methods. It’s easy to overuse the decorator pattern, creating a new class for every small new feature. This results in an explosion of shallow classes, such as the Java I/O example.</p>\n<blockquote>\n<p>装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多传递方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。</p>\n</blockquote>\n<p>Before creating a decorator class, consider alternatives such as the following:</p>\n<blockquote>\n<p>创建装饰器类之前，请考虑以下替代方法：</p>\n</blockquote>\n<ul>\n<li>Could you add the new functionality directly to the underlying class, rather than creating a decorator class? This makes sense if the new functionality is relatively general-purpose, or if it is logically related to the underlying class, or if most uses of the underlying class will also use the new functionality. For example, virtually everyone who creates a Java InputStream will also create a BufferedInputStream, and buffering is a natural part of I/O, so these classes should have been combined.</li>\n<li>If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?</li>\n<li>Could you merge the new functionality with an existing decorator, rather than creating a new decorator? This would result in a single deeper decorator class rather than multiple shallow ones.</li>\n<li>Finally, ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class? In the windowing example, the scrollbars could probably be implemented separately from the main window, without wrapping all of its existing functionality.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。</li>\n<li>如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？</li>\n<li>您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。</li>\n<li>最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。</li>\n</ul>\n</blockquote>\n<p>Sometimes decorators make sense, but there is usually a better alternative.</p>\n<blockquote>\n<p>有时装饰者很有意义，但通常有更好的选择。</p>\n</blockquote>\n<h2 id=\"7-4-Interface-versus-implementation-接口与实现\"><a href=\"#7-4-Interface-versus-implementation-接口与实现\" class=\"headerlink\" title=\"7.4 Interface versus implementation 接口与实现\"></a>7.4 Interface versus implementation 接口与实现</h2><p>Another application of the “different layer, different abstraction” rule is that the interface of a class should normally be different from its implementation: the representations used internally should be different from the abstractions that appear in the interface. If the two have similar abstractions, then the class probably isn’t very deep. For example, in the text editor project discussed in Chapter 6, most of the teams implemented the text module in terms of lines of text, with each line stored separately. Some of the teams also designed the APIs for the text class around lines, with methods such as getLine and putLine. However, this made the text class shallow and awkward to use. In the higher-level user interface code, it’s common to insert text in the middle of a line (e.g., when the user is typing) or to delete a range of text that spans lines. With a line-oriented API for the text class, callers were forced to split and join lines to implement the user-interface operations. This code was nontrivial and it was duplicated and scattered across the implementation of the user interface.</p>\n<blockquote>\n<p>“不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。</p>\n</blockquote>\n<p>The text classes were much easier to use when they provided a character-oriented interface, such as an insert method that inserts an arbitrary string of text (which may include newlines) at an arbitrary position in the text and a delete method that deletes the text between two arbitrary positions in the text. Internally, the text was still represented in terms of lines. A character-oriented interface encapsulates the complexity of line splitting and joining inside the text class, which makes the text class deeper and simplifies higher level code that uses the class. With this approach, the text API is quite different from the line-oriented storage mechanism; the difference represents valuable functionality provided by the class.</p>\n<blockquote>\n<p>文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能。</p>\n</blockquote>\n<h2 id=\"7-5-Pass-through-variables-传递变量\"><a href=\"#7-5-Pass-through-variables-传递变量\" class=\"headerlink\" title=\"7.5 Pass-through variables 传递变量\"></a>7.5 Pass-through variables 传递变量</h2><p>Another form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods. Figure 7.2(a) shows an example from a datacenter service. A command-line argument describes certificates to use for secure communication. This information is only needed by a low-level method m3, which calls a library method to open a socket, but it is passed down through all the methods on the path between main and m3. The cert variable appears in the signature of each of the intermediate methods.</p>\n<blockquote>\n<p>跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。图 7.2（a）显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。</p>\n</blockquote>\n<p>Pass-through variables add complexity because they force all of the intermediate methods to be aware of their existence, even though the methods have no use for the variables. Furthermore, if a new variable comes into existence (for example, a system is initially built without support for certificates, but you later decide to add that support), you may have to modify a large number of interfaces and methods to pass the variable through all of the relevant paths.</p>\n<blockquote>\n<p>传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。</p>\n</blockquote>\n<p>Eliminating pass-through variables can be challenging. One approach is to see if there is already an object shared between the topmost and bottommost methods. In the datacenter service example of Figure 7.2, perhaps there is an object containing other information about network communication, which is available to both main and m3. If so, main can store the certificate information in that object, so it needn’t be passed through all of the intervening methods on the path to m3 (see Figure 7.2(b)). However, if there is such an object, then it may itself be a pass-through variable (how else does m3 get access to it?).</p>\n<blockquote>\n<p>消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在图 7.2 的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书（请参见图 7.2（b））。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。</p>\n</blockquote>\n<p>Another approach is to store the information in a global variable, as in Figure 7.2(c). This avoids the need to pass the information from method to method, but global variables almost always create other problems. For example, global variables make it impossible to create two independent instances of the same system in the same process, since accesses to the global variables will conflict. It may seem unlikely that you would need multiple instances in production, but they are often useful in testing.</p>\n<blockquote>\n<p>另一种方法是将信息存储在全局变量中，如图 7.2（c）所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。</p>\n</blockquote>\n<p>The solution I use most often is to introduce a context object as in Figure 7.2(d). A context stores all of the application’s global state (anything that would otherwise be a pass-through variable or global variable). Most applications have multiple variables in their global state, representing things such as configuration options, shared subsystems, and performance counters. There is one context object per instance of the system. The context allows multiple instances of the system to coexist in a single process, each with its own context.</p>\n<blockquote>\n<p>我最常使用的解决方案是引入一个上下文对象，如图 7.2（d）所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。</p>\n</blockquote>\n<p>Unfortunately, the context will probably be needed in many places, so it can potentially become a pass-through variable. To reduce the number of methods that must be aware of it, a reference to the context can be saved in most of the system’s major objects. In the example of Figure 7.2(d), the class containing m3 stores a reference to the context as an instance variable in its objects. When a new object is created, the creating method retrieves the context reference from its object and passes it to the constructor for the new object. With this approach, the context is available everywhere, but it only appears as an explicit argument in constructors.</p>\n<blockquote>\n<p>不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在图 7.2（d）的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00016.gif\" alt=\"\"></p>\n<p>Figure 7.2: Possible techniques for dealing with a pass-through variable. In (a), cert is passed through methods m1 and m2 even though they don’t use it. In (b), main and m3 have shared access to an object, so the variable can be stored there instead of passing it through m1 and m2. In (c), cert is stored as a global variable. In (d), cert is stored in a context object along with other system-wide information, such as a timeout value and performance counters; a reference to the context is stored in all objects whose methods need access to it.</p>\n<blockquote>\n<p>图 7.2：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。</p>\n</blockquote>\n<p>The context object unifies the handling of all system-global information and eliminates the need for pass-through variables. If a new variable needs to be added, it can be added to the context object; no existing code is affected except for the constructor and destructor for the context. The context makes it easy to identify and manage the global state of the system, since it is all stored in one place. The context is also convenient for testing: test code can change the global configuration of the application by modifying fields in the context. It would be much more difficult to implement such changes if the system used pass-through variables.</p>\n<blockquote>\n<p>上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。</p>\n</blockquote>\n<p>Contexts are far from an ideal solution. The variables stored in a context have most of the disadvantages of global variables; for example, it may not be obvious why a particular variable is present, or where it is used. Without discipline, a context can turn into a huge grab-bag of data that creates nonobvious dependencies throughout the system. Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable. Unfortunately, I haven’t found a better solution than contexts.</p>\n<blockquote>\n<p>上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。</p>\n</blockquote>\n<h2 id=\"7-6-Conclusion-结论\"><a href=\"#7-6-Conclusion-结论\" class=\"headerlink\" title=\"7.6 Conclusion 结论\"></a>7.6 Conclusion 结论</h2><p>Each piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element. In order for an element to provide a net gain against complexity, it must eliminate some complexity that would be present in the absence of the design element. Otherwise, you are better off implementing the system without that particular element. For example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.</p>\n<blockquote>\n<p>界面，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。</p>\n</blockquote>\n<p>The “different layer, different abstraction” rule is just an application of this idea: if different layers have the same abstraction, such as pass-through methods or decorators, then there’s a good chance that they haven’t provided enough benefit to compensate for the additional infrastructure they represent. Similarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality.</p>\n<blockquote>\n<p>“不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如传递方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>不同的层，不同的抽象</p>","more":"<h1 id=\"第-7-章-不同的层，不同的抽象\"><a href=\"#第-7-章-不同的层，不同的抽象\" class=\"headerlink\" title=\"第 7 章 不同的层，不同的抽象\"></a>第 7 章 不同的层，不同的抽象</h1><blockquote>\n<p>Chapter 7 Different Layer, Different Abstraction</p>\n</blockquote>\n<p>Software systems are composed in layers, where higher layers use the facilities provided by lower layers. In a well-designed system, each layer provides a different abstraction from the layers above and below it; if you follow a single operation as it moves up and down through layers by invoking methods, the abstractions change with each method call. For example:</p>\n<blockquote>\n<p>软件系统由层组成，其中较高的层使用较低层提供的功能。在设计良好的系统中，每一层都提供与其上，下两层不同的抽象。如果您通过调用方法遵循单个操作在层中上下移动，则每个方法调用的抽象都会改变。例如：</p>\n</blockquote>\n<ul>\n<li>In a file system, the uppermost layer implements a file abstraction. A file consists of a variable-length array of bytes, which can be updated by reading and writing variable-length byte ranges. The next lower layer in the file system implements a cache in memory of fixed-size disk blocks; callers can assume that frequently used blocks will stay in memory where they can be accessed quickly. The lowest layer consists of device drivers, which move blocks between secondary storage devices and memory.</li>\n<li>In a network transport protocol such as TCP, the abstraction provided by the topmost layer is a stream of bytes delivered reliably from one machine to another. This level is built on a lower level that transmits packets of bounded size between machines on a best-effort basis: most packets will be delivered successfully, but some packets may be lost or delivered out of order.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>在文件系统中，最上层实现文件抽象。文件由可变长度的字节数组组成，可以通过读写可变长度的字节范围来更新该字节。文件系统的下一个下一层在固定大小的磁盘块的内存中实现了高速缓存。调用者可以假定经常使用的块将保留在内存中，以便可以快速访问它们。最低层由设备驱动程序组成，它们在辅助存储设备和内存之间移动块。</li>\n<li>在诸如 TCP 的网络传输协议中，最顶层提供的抽象是从一台机器可靠地传递到另一台机器的字节流。此级别在较低级别上构建，该级别可以尽最大努力在计算机之间传输有限大小的数据包：大多数数据包将成功交付，但某些数据包可能会丢失或乱序交付。</li>\n</ul>\n</blockquote>\n<p>If a system contains adjacent layers with similar abstractions, this is a red flag that suggests a problem with the class decomposition. This chapter discusses situations where this happens, the problems that result, and how to refactor to eliminate the problems.</p>\n<blockquote>\n<p>如果系统包含具有相似抽象的相邻层，则这是一个红色标记，表明类分解存在问题。本章讨论了发生这种情况的情况，导致的问题以及如何重构以消除问题。</p>\n</blockquote>\n<h2 id=\"7-1-Pass-through-methods-传递方法\"><a href=\"#7-1-Pass-through-methods-传递方法\" class=\"headerlink\" title=\"7.1 Pass-through methods 传递方法\"></a>7.1 Pass-through methods 传递方法</h2><p>When adjacent layers have similar abstractions, the problem often manifests itself in the form of pass-through methods. A pass-through method is one that does little except invoke another method, whose signature is similar or identical to that of the calling method. For example, a student project implementing a GUI text editor contained a class consisting almost entirely of pass-through methods. Here is an extract from that class:</p>\n<blockquote>\n<p>当相邻的层具有相似的抽象时，问题通常以直通方法的形式表现出来。传递方法是一种很少执行的方法，除了调用另一个方法（其签名与调用方法的签名相似或相同）之外。例如，一个实施 GUI 文本编辑器的学生项目包含一个几乎完全由传递方法组成的类。这是该类的摘录：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TextDocument</span> ... </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextArea textArea;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> TextDocumentListener listener;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Character <span class=\"title\">getLastTypedCharacter</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> textArea.getLastTypedCharacter();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getCursorOffset</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> textArea.getCursorOffset();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">insertString</span><span class=\"params\">(String textToInsert, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</span><br><span class=\"line\">        textArea.insertString(textToInsert, offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">willInsertString</span><span class=\"params\">(String stringToInsert, <span class=\"keyword\">int</span> offset)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (listener != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            listener.willInsertString(<span class=\"keyword\">this</span>, stringToInsert, offset);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>13 of the 15 public methods in that class were pass-through methods.</p>\n<blockquote>\n<p>该类别中 15 个公共方法中的 13 个是传递方法。</p>\n</blockquote>\n<p>img Red Flag: Pass-Through Method img</p>\n<p>A pass-through method is one that does nothing except pass its arguments to another method, usually with the same API as the pass-through method. This typically indicates that there is not a clean division of responsibility between the classes.</p>\n<blockquote>\n<p>传递方法是一种不执行任何操作的方法，只是将其参数传递给另一个方法，通常使用与传递方法相同的 API。这通常表示各类之间没有明确的职责划分。</p>\n</blockquote>\n<p>Pass-through methods make classes shallower: they increase the interface complexity of the class, which adds complexity, but they don’t increase the total functionality of the system. Of the four methods above, only the last one has any functionality, and even there it is trivial: the method checks the validity of one variable. Pass-through methods also create dependencies between classes: if the signature changes for the insertString method in TextArea, then the insertString method in TextDocument will have to change to match.</p>\n<blockquote>\n<p>传递方法使类变浅：它们增加了类的接口复杂性，从而增加了复杂性，但是并没有增加系统的整体功能。在上述四个方法中，只有最后一个具有任何功能，甚至没有什么功能：该方法检查一个变量的有效性。直通方法还会在类之间创建依赖关系：如果针对 TextArea 中的 insertString 方法更改了签名，则必须更改 TextDocument 中的 insertString 方法以进行匹配。</p>\n</blockquote>\n<p>Pass-through methods indicate that there is confusion over the division of responsibility between classes. In the example above, the TextDocument class offers an insertString method, but the functionality for inserting text is implemented entirely in TextArea. This is usually a bad idea: the interface to a piece of functionality should be in the same class that implements the functionality. When you see pass-through methods from one class to another, consider the two classes and ask yourself “Exactly which features and abstractions is each of these classes responsible for?” You will probably notice that there is an overlap in responsibility between the classes.</p>\n<blockquote>\n<p>传递方法表明类之间的责任划分存在混淆。在上面的示例中，TextDocument 类提供了 insertString 方法，但是用于插入文本的功能完全在 TextArea 中实现。这通常是一个坏主意：某个功能的接口应该在实现该功能的同一类中。当您看到从一个类到另一个类的传递方法时，请考虑这两个类，并问自己“这些类分别负责哪些功能和抽象？” 您可能会注意到，各类之间的职责重叠。</p>\n</blockquote>\n<p>The solution is to refactor the classes so that each class has a distinct and coherent set of responsibilities. Figure 7.1 illustrates several ways to do this. One approach, shown in Figure 7.1(b), is to expose the lower level class directly to the callers of the higher level class, removing all responsibility for the feature from the higher level class. Another approach is to redistribute the functionality between the classes, as in Figure 7.1(c). Finally, if the classes can’t be disentangled, the best solution may be to merge them as in Figure 7.1(d).</p>\n<blockquote>\n<p>解决方案是重构类，以使每个类都有各自不同且连贯的职责。图 7.1 说明了几种方法。一种方法，如图 7.1（b）所示，是将较低级别的类直接暴露给较高级别的类的调用者，而从较高级别的类中删除对该功能的所有责任。另一种方法是在类之间重新分配功能，如图 7.1（c）所示。最后，如果无法解开这些类，最好的解决方案可能是如图 7.1（d）所示合并它们。</p>\n</blockquote>\n<p>In the example above, there were three classes with intertwined responsibilities: TextDocument, TextArea, and TextDocumentListener. The student eliminated the pass-through methods by moving methods between classes and collapsing the three classes into just two, whose responsibilities were more clearly differentiated.</p>\n<blockquote>\n<p>在上面的示例中，职责交织的三个类为：TextDocument，TextArea 和 TextDocumentListener。学生通过在班级之间移动方法并将三个班级缩减为两个班级来消除传递方法，这两个班级的职责更加明确。</p>\n</blockquote>\n<h2 id=\"7-2-When-is-interface-duplication-OK-接口复制何时可以？\"><a href=\"#7-2-When-is-interface-duplication-OK-接口复制何时可以？\" class=\"headerlink\" title=\"7.2 When is interface duplication OK? 接口复制何时可以？\"></a>7.2 When is interface duplication OK? 接口复制何时可以？</h2><p>Having methods with the same signature is not always bad. The important thing is that each new method should contribute significant functionality. Pass-through methods are bad because they contribute no new functionality.</p>\n<blockquote>\n<p>具有相同签名的方法并不总是不好的。重要的是，每种新方法都应贡献重要的功能。传递方法很糟糕，因为它们不提供任何新功能。</p>\n</blockquote>\n<p>One example where it’s useful for a method to call another method with the same signature is a dispatcher. A dispatcher is a method that uses its arguments to select one of several other methods to invoke; then it passes most or all of its arguments to the chosen method. The signature for the dispatcher is often the same as the signature for the methods that it calls. Even so, the dispatcher provides useful functionality: it chooses which of several other methods should carry out each task.</p>\n<blockquote>\n<p>分派器是一个示例，该示例对于一种方法调用具有相同签名的另一种方法很有用。调度程序是一种使用其参数选择要调用的其他方法之一的方法。然后将其大部分或所有参数传递给所选方法。调度程序的签名通常与其调用的方法的签名相同。即便如此，调度程序仍提供有用的功能：它可以选择其他几种方法中的哪一种来执行每个任务。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00015.jpeg\" alt=\"\"></p>\n<p>Figure 7.1: Pass-through methods. In (a), class C1 contains three pass-through methods, which do nothing but invoke methods with the same signature in C2 (each symbol represents a particular method signature). The pass-through methods can be eliminated by having C1’s callers invoke C2 directly as in (b), by redistributing functionality between C1 and C2 to avoid calls between the classes as in (c), or by combining the classes as in (d).</p>\n<blockquote>\n<p>图 7.1：直通方法。在（a）中，类 C1 包含三个直通方法，这些方法只调用 C2 中具有相同签名的方法（每个符号代表一个特定的方法签名）。可以通过使 C1 的调用方像在（b）中那样直接调用 C2，通过在 C1 和 C2 之间重新分配功能以避免在（c）中的类之间进行调用，或者通过组合在（d）中的类来消除传递方法。 。</p>\n</blockquote>\n<p>For example, when a Web server receives an incoming HTTP request from a Web browser, it invokes a dispatcher that examines the URL in the incoming request and selects a specific method to handle the request. Some URLs might be handled by returning the contents of a file on disk; others might be handled by invoking a procedure in a language such as PHP or JavaScript. The dispatch process can be quite intricate, and is usually driven by a set of rules that are matched against the incoming URL.</p>\n<blockquote>\n<p>例如，当 Web 服务器从 Web 浏览器接收到传入的 HTTP 请求时，它将调用一个调度程序，该调度程序检查传入请求中的 URL 并选择一种特定的方法来处理该请求。某些 URL 可以通过返回磁盘上文件的内容来处理。其他人则可以通过调用诸如 PHP 或 JavaScript 之类的语言的过程来处理。分发过程可能非常复杂，通常由与传入 URL 匹配的一组规则来驱动。</p>\n</blockquote>\n<p>It is fine for several methods to have the same signature as long as each of them provides useful and distinct functionality. The methods invoked by a dispatcher have this property. Another example is interfaces with multiple implementations, such as disk drivers in an operating system. Each driver provides support for a different kind of disk, but they all have the same interface. When several methods provide different implementations of the same interface, it reduces cognitive load. Once you have worked with one of these methods, it’s easier to work with the others, since you don’t need to learn a new interface. Methods like this are usually in the same layer and they don’t invoke each other.</p>\n<blockquote>\n<p>只要每种方法都提供有用且独特的功能，几种方法都应具有相同的签名。调度程序调用的方法具有此属性。另一个示例是具有多种实现方式的接口，例如操作系统中的磁盘驱动程序。每个驱动程序都支持不同类型的磁盘，但是它们都有相同的接口。当几种方法提供同一接口的不同实现时，它将减少认知负担。使用其中一种方法后，与其他方法一起使用会更容易，因为您无需学习新的界面。像这样的方法通常位于同一层，并且它们不会相互调用。</p>\n</blockquote>\n<h2 id=\"7-3-Decorators-装饰器\"><a href=\"#7-3-Decorators-装饰器\" class=\"headerlink\" title=\"7.3 Decorators 装饰器\"></a>7.3 Decorators 装饰器</h2><p>The decorator design pattern (also known as a “wrapper”) is one that encourages API duplication across layers. A decorator object takes an existing object and extends its functionality; it provides an API similar or identical to the underlying object, and its methods invoke the methods of the underlying object. In the Java I/O example from Chapter 4, the BufferedInputStream class is a decorator: given an InputStream object, it provides the same API but introduces buffering. For example, when its read method is invoked to read a single character, it invokes read on the underlying InputStream to read a much larger block, and saves the extra characters to satisfy future read calls. Another example occurs in windowing systems: a Window class implements a simple form of window that is not scrollable, and a ScrollableWindow class decorates the Window class by adding horizontal and vertical scrollbars.</p>\n<blockquote>\n<p>装饰器设计模式(也称为“包装器”)是一种鼓励跨层复制 API 的模式。装饰对象接受现有对象并扩展其功能;它提供一个与底层对象相似或相同的 API，它的方法调用底层对象的方法。在第 4 章的 Java I/O 示例中，BufferedInputStream 类是一个装饰器:给定一个 InputStream 对象，它提供了相同的 API，但是引入了缓冲。例如，当它的 read 方法被调用来读取单个字符时，它会调用底层 InputStream 上的 read 来读取更大的块，并保存额外的字符来满足未来的 read 调用。另一个例子出现在窗口系统中:Window 类实现了一个不能滚动的窗口的简单形式，而 ScrollableWindow 类通过添加水平和垂直滚动条来装饰窗口类。</p>\n</blockquote>\n<p>The motivation for decorators is to separate special-purpose extensions of a class from a more generic core. However, decorator classes tend to be shallow: they introduce a large amount of boilerplate for a small amount of new functionality. Decorator classes often contain many pass-through methods. It’s easy to overuse the decorator pattern, creating a new class for every small new feature. This results in an explosion of shallow classes, such as the Java I/O example.</p>\n<blockquote>\n<p>装饰器的动机是将类的专用扩展与更通用的核心分开。但是，装饰器类往往很浅：它们引入了大量的样板，以实现少量的新功能。装饰器类通常包含许多传递方法。过度使用装饰器模式很容易，为每个小的新功能创建一个新类。这导致诸如 Java I/O 示例之类的浅层类激增。</p>\n</blockquote>\n<p>Before creating a decorator class, consider alternatives such as the following:</p>\n<blockquote>\n<p>创建装饰器类之前，请考虑以下替代方法：</p>\n</blockquote>\n<ul>\n<li>Could you add the new functionality directly to the underlying class, rather than creating a decorator class? This makes sense if the new functionality is relatively general-purpose, or if it is logically related to the underlying class, or if most uses of the underlying class will also use the new functionality. For example, virtually everyone who creates a Java InputStream will also create a BufferedInputStream, and buffering is a natural part of I/O, so these classes should have been combined.</li>\n<li>If the new functionality is specialized for a particular use case, would it make sense to merge it with the use case, rather than creating a separate class?</li>\n<li>Could you merge the new functionality with an existing decorator, rather than creating a new decorator? This would result in a single deeper decorator class rather than multiple shallow ones.</li>\n<li>Finally, ask yourself whether the new functionality really needs to wrap the existing functionality: could you implement it as a stand-alone class that is independent of the base class? In the windowing example, the scrollbars could probably be implemented separately from the main window, without wrapping all of its existing functionality.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>您能否将新功能直接添加到基础类，而不是创建装饰器类？如果新功能是相对通用的，或者在逻辑上与基础类相关，或者如果基础类的大多数使用也将使用新功能，则这是有意义的。例如，几乎每个创建 Java InputStream 的人都会创建一个 BufferedInputStream，并且缓冲是 I/O 的自然组成部分，因此应该合并这些类。</li>\n<li>如果新功能专用于特定用例，将其与用例合并而不是创建单独的类是否有意义？</li>\n<li>您可以将新功能与现有的装饰器合并，而不是创建新的装饰器吗？这将导致一个更深的装饰器类，而不是多个浅的装饰器类。</li>\n<li>最后，问问自己新功能是否真的需要包装现有功能：是否可以将其实现为独立于基类的独立类？在窗口示例中，滚动条可能与主窗口分开实现，而无需包装其所有现有功能。</li>\n</ul>\n</blockquote>\n<p>Sometimes decorators make sense, but there is usually a better alternative.</p>\n<blockquote>\n<p>有时装饰者很有意义，但通常有更好的选择。</p>\n</blockquote>\n<h2 id=\"7-4-Interface-versus-implementation-接口与实现\"><a href=\"#7-4-Interface-versus-implementation-接口与实现\" class=\"headerlink\" title=\"7.4 Interface versus implementation 接口与实现\"></a>7.4 Interface versus implementation 接口与实现</h2><p>Another application of the “different layer, different abstraction” rule is that the interface of a class should normally be different from its implementation: the representations used internally should be different from the abstractions that appear in the interface. If the two have similar abstractions, then the class probably isn’t very deep. For example, in the text editor project discussed in Chapter 6, most of the teams implemented the text module in terms of lines of text, with each line stored separately. Some of the teams also designed the APIs for the text class around lines, with methods such as getLine and putLine. However, this made the text class shallow and awkward to use. In the higher-level user interface code, it’s common to insert text in the middle of a line (e.g., when the user is typing) or to delete a range of text that spans lines. With a line-oriented API for the text class, callers were forced to split and join lines to implement the user-interface operations. This code was nontrivial and it was duplicated and scattered across the implementation of the user interface.</p>\n<blockquote>\n<p>“不同层，不同抽象”规则的另一个应用是，类的接口通常应与其实现不同：内部使用的表示形式应与接口中出现的抽象形式不同。如果两者具有相似的抽象，则该类可能不是很深。例如，在第 6 章讨论的文本编辑器项目中，大多数团队都以文本行的形式实现了文本模块，每行分别存储。一些团队还使用 getLine 和 putLine 之类的方法围绕行设计了文本类的 API。但是，这使文本类使用起来较浅且笨拙。在较高级别的用户界面代码中，通常在行中间插入文本（例如，当用户键入内容时）或删除跨行的文本范围。通过用于文本类的面向行的 API，调用者被迫拆分和合并行以实现用户界面操作。这段代码很简单，并且在用户界面的实现中被复制和散布。</p>\n</blockquote>\n<p>The text classes were much easier to use when they provided a character-oriented interface, such as an insert method that inserts an arbitrary string of text (which may include newlines) at an arbitrary position in the text and a delete method that deletes the text between two arbitrary positions in the text. Internally, the text was still represented in terms of lines. A character-oriented interface encapsulates the complexity of line splitting and joining inside the text class, which makes the text class deeper and simplifies higher level code that uses the class. With this approach, the text API is quite different from the line-oriented storage mechanism; the difference represents valuable functionality provided by the class.</p>\n<blockquote>\n<p>文本类提供面向字符的接口时，使用起来要容易得多，例如，insert 方法可在文本的任意位置插入任意文本字符串（可能包括换行符），而 delete 方法则删除文本在文本中的两个任意位置之间。在内部，文本仍以行表示。面向字符的接口封装了文本类内部的行拆分和连接的复杂性，这使文本类更深，并简化了使用该类的高级代码。通过这种方法，文本 API 与面向行的存储机制大不相同。差异表示该类提供的有价值的功能。</p>\n</blockquote>\n<h2 id=\"7-5-Pass-through-variables-传递变量\"><a href=\"#7-5-Pass-through-variables-传递变量\" class=\"headerlink\" title=\"7.5 Pass-through variables 传递变量\"></a>7.5 Pass-through variables 传递变量</h2><p>Another form of API duplication across layers is a pass-through variable, which is a variable that is passed down through a long chain of methods. Figure 7.2(a) shows an example from a datacenter service. A command-line argument describes certificates to use for secure communication. This information is only needed by a low-level method m3, which calls a library method to open a socket, but it is passed down through all the methods on the path between main and m3. The cert variable appears in the signature of each of the intermediate methods.</p>\n<blockquote>\n<p>跨层 API 复制的另一种形式是传递变量，该变量是通过一长串方法向下传递的变量。图 7.2（a）显示了数据中心服务的示例。命令行参数描述用于安全通信的证书。只有底层方法 m3 才需要此信息，该方法调用一个库方法来打开套接字，但是该信息会通过 main 和 m3 之间路径上的所有方法向下传递。cert 变量出现在每个中间方法的签名中。</p>\n</blockquote>\n<p>Pass-through variables add complexity because they force all of the intermediate methods to be aware of their existence, even though the methods have no use for the variables. Furthermore, if a new variable comes into existence (for example, a system is initially built without support for certificates, but you later decide to add that support), you may have to modify a large number of interfaces and methods to pass the variable through all of the relevant paths.</p>\n<blockquote>\n<p>传递变量增加了复杂性，因为它们强制所有中间方法知道它们的存在，即使这些方法对变量没有用处。此外，如果存在一个新变量（例如，最初构建的系统不支持证书，但是您后来决定添加该支持），则可能必须修改大量的接口和方法才能将变量传递给所有相关路径。</p>\n</blockquote>\n<p>Eliminating pass-through variables can be challenging. One approach is to see if there is already an object shared between the topmost and bottommost methods. In the datacenter service example of Figure 7.2, perhaps there is an object containing other information about network communication, which is available to both main and m3. If so, main can store the certificate information in that object, so it needn’t be passed through all of the intervening methods on the path to m3 (see Figure 7.2(b)). However, if there is such an object, then it may itself be a pass-through variable (how else does m3 get access to it?).</p>\n<blockquote>\n<p>消除传递变量可能具有挑战性。一种方法是查看最顶层和最底层方法之间是否已共享对象。在图 7.2 的数据中心服务示例中，也许存在一个对象，其中包含有关网络通信的其他信息，这对于 main 和 m3 都是可用的。如果是这样，main 可以将证书信息存储在该对象中，因此不必通过通往 m3 的路径上的所有干预方法来传递证书（请参见图 7.2（b））。但是，如果存在这样的对象，则它本身可能是传递变量（m3 还将如何访问它？）。</p>\n</blockquote>\n<p>Another approach is to store the information in a global variable, as in Figure 7.2(c). This avoids the need to pass the information from method to method, but global variables almost always create other problems. For example, global variables make it impossible to create two independent instances of the same system in the same process, since accesses to the global variables will conflict. It may seem unlikely that you would need multiple instances in production, but they are often useful in testing.</p>\n<blockquote>\n<p>另一种方法是将信息存储在全局变量中，如图 7.2（c）所示。这避免了将信息从一个方法传递到另一个方法的需要，但是全局变量几乎总是会产生其他问题。例如，全局变量使得不可能在同一过程中创建同一系统的两个独立实例，因为对全局变量的访问会发生冲突。在生产中似乎不太可能需要多个实例，但是它们通常在测试中很有用。</p>\n</blockquote>\n<p>The solution I use most often is to introduce a context object as in Figure 7.2(d). A context stores all of the application’s global state (anything that would otherwise be a pass-through variable or global variable). Most applications have multiple variables in their global state, representing things such as configuration options, shared subsystems, and performance counters. There is one context object per instance of the system. The context allows multiple instances of the system to coexist in a single process, each with its own context.</p>\n<blockquote>\n<p>我最常使用的解决方案是引入一个上下文对象，如图 7.2（d）所示。上下文存储应用程序的所有全局状态（否则将是传递变量或全局变量的任何状态）。大多数应用程序在其全局状态下具有多个变量，这些变量表示诸如配置选项，共享子系统和性能计数器之类的内容。每个系统实例只有一个上下文对象。上下文允许系统的多个实例在单个进程中共存，每个实例都有自己的上下文。</p>\n</blockquote>\n<p>Unfortunately, the context will probably be needed in many places, so it can potentially become a pass-through variable. To reduce the number of methods that must be aware of it, a reference to the context can be saved in most of the system’s major objects. In the example of Figure 7.2(d), the class containing m3 stores a reference to the context as an instance variable in its objects. When a new object is created, the creating method retrieves the context reference from its object and passes it to the constructor for the new object. With this approach, the context is available everywhere, but it only appears as an explicit argument in constructors.</p>\n<blockquote>\n<p>不幸的是，在许多地方可能都需要上下文，因此它有可能成为传递变量。为了减少必须意识到的方法数量，可以将上下文的引用保存在系统的大多数主要对象中。在图 7.2（d）的示例中，包含 m3 的类将对上下文的引用作为实例变量存储在其对象中。创建新对象时，创建方法将从其对象中检索上下文引用，并将其传递给新对象的构造函数。使用这种方法，上下文随处可见，但在构造函数中仅作为显式参数出现。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00016.gif\" alt=\"\"></p>\n<p>Figure 7.2: Possible techniques for dealing with a pass-through variable. In (a), cert is passed through methods m1 and m2 even though they don’t use it. In (b), main and m3 have shared access to an object, so the variable can be stored there instead of passing it through m1 and m2. In (c), cert is stored as a global variable. In (d), cert is stored in a context object along with other system-wide information, such as a timeout value and performance counters; a reference to the context is stored in all objects whose methods need access to it.</p>\n<blockquote>\n<p>图 7.2：处理传递变量的可能技术。在（a）中，证书通过方法 m1 和 m2 传递，即使它们不使用它也是如此。在（b）中，main 和 m3 具有对一个对象的共享访问权，因此可以将变量存储在此处，而不用将其传递给 m1 和 m2。在（c）中，cert 存储为全局变量。在（d）中，证书与其他系统范围的信息（例如超时值和性能计数器）一起存储在上下文对象中；对上下文的引用存储在其方法需要访问它的所有对象中。</p>\n</blockquote>\n<p>The context object unifies the handling of all system-global information and eliminates the need for pass-through variables. If a new variable needs to be added, it can be added to the context object; no existing code is affected except for the constructor and destructor for the context. The context makes it easy to identify and manage the global state of the system, since it is all stored in one place. The context is also convenient for testing: test code can change the global configuration of the application by modifying fields in the context. It would be much more difficult to implement such changes if the system used pass-through variables.</p>\n<blockquote>\n<p>上下文对象统一了所有系统全局信息的处理，并且不需要传递变量。如果需要添加新变量，则可以将其添加到上下文对象；除了上下文的构造函数和析构函数外，现有代码均不受影响。由于上下文全部存储在一个位置，因此上下文可以轻松识别和管理系统的全局状态。上下文也便于测试：测试代码可以通过修改上下文中的字段来更改应用程序的全局配置。如果系统使用传递变量，则实施此类更改将更加困难。</p>\n</blockquote>\n<p>Contexts are far from an ideal solution. The variables stored in a context have most of the disadvantages of global variables; for example, it may not be obvious why a particular variable is present, or where it is used. Without discipline, a context can turn into a huge grab-bag of data that creates nonobvious dependencies throughout the system. Contexts may also create thread-safety issues; the best way to avoid problems is for variables in a context to be immutable. Unfortunately, I haven’t found a better solution than contexts.</p>\n<blockquote>\n<p>上下文远非理想的解决方案。存储在上下文中的变量具有全局变量的大多数缺点。例如，为什么存在特定变量或在何处使用特定变量可能并不明显。没有纪律，上下文会变成巨大的数据抓包，从而在整个系统中创建不明显的依赖关系。上下文也可能产生线程安全问题；避免问题的最佳方法是使上下文中的变量不可变。不幸的是，我没有找到比上下文更好的解决方案。</p>\n</blockquote>\n<h2 id=\"7-6-Conclusion-结论\"><a href=\"#7-6-Conclusion-结论\" class=\"headerlink\" title=\"7.6 Conclusion 结论\"></a>7.6 Conclusion 结论</h2><p>Each piece of design infrastructure added to a system, such as an interface, argument, function, class, or definition, adds complexity, since developers must learn about this element. In order for an element to provide a net gain against complexity, it must eliminate some complexity that would be present in the absence of the design element. Otherwise, you are better off implementing the system without that particular element. For example, a class can reduce complexity by encapsulating functionality so that users of the class needn’t be aware of it.</p>\n<blockquote>\n<p>界面，参数，函数，类或定义之类的添加到系统中的每个设计基础架构都会增加复杂性，因为开发人员必须了解该元素。为了使元素能够提供相对于复杂性的净收益，它必须消除在没有设计元素的情况下会出现的一些复杂性。否则，最好不要使用该特定元素来实施系统。例如，一个类可以通过封装功能来降低复杂性，以使该类的用户无需意识到这一点。</p>\n</blockquote>\n<p>The “different layer, different abstraction” rule is just an application of this idea: if different layers have the same abstraction, such as pass-through methods or decorators, then there’s a good chance that they haven’t provided enough benefit to compensate for the additional infrastructure they represent. Similarly, pass-through arguments require each of several methods to be aware of their existence (which adds to complexity) without contributing additional functionality.</p>\n<blockquote>\n<p>“不同的层，不同的抽象”规则只是此思想的一种应用：如果不同的层具有相同的抽象，例如传递方法或装饰器，则很有可能它们没有提供足够的利益来补偿它们代表的其他基础结构。类似地，传递参数要求几种方法中的每一种都知道它们的存在（这增加了复杂性），而又不提供其他功能。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch5","date":"2021-02-04T16:00:00.000Z","_content":"信息隐藏(和泄漏)\n<!-- more -->\n# 第 5 章 信息隐藏(和泄漏)\n\n> Chapter 5 Information Hiding (and Leakage)\n\nChapter 4 argued that modules should be deep. This chapter, and the next few that follow, discuss techniques for creating deep modules.\n\n> 第四章认为模块应该很深。本章及随后的其他章节讨论了创建深层模块的技术。\n\n## 5.1 Information hiding 信息隐藏\n\nThe most important technique for achieving deep modules is information hiding. This technique was first described by David Parnas1. The basic idea is that each module should encapsulate a few pieces of knowledge, which represent design decisions. The knowledge is embedded in the module’s implementation but does not appear in its interface, so it is not visible to other modules.\n\n> 实现深层模块最重要的技术是信息隐藏。该技术最早由 David Parnas1 描述。基本思想是每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其界面中，因此其他模块不可见。\n\nThe information hidden within a module usually consists of details about how to implement some mechanism. Here are some examples of information that might be hidden within a module:\n\n> 隐藏在模块中的信息通常包含有关如何实现某种机制的详细信息。以下是一些可能隐藏在模块中的信息示例：\n\n- How to store information in a B-tree, and how to access it efficiently.\n- How to identify the physical disk block corresponding to each logical block within a file.\n- How to implement the TCP network protocol.\n- How to schedule threads on a multi-core processor.\n- How to parse JSON documents.\n\n---\n\n> - 如何在 B 树中存储信息，以及如何有效地访问它。\n> - 如何识别与文件中每个逻辑块相对应的物理磁盘块。\n> - 如何实现 TCP 网络协议。\n> - 如何在多核处理器上调度线程。\n> - 如何解析 JSON 文档。\n\nThe hidden information includes data structures and algorithms related to the mechanism. It can also include lower-level details such as the size of a page, and it can include higher-level concepts that are more abstract, such as an assumption that most files are small.\n\n> 隐藏的信息包括与该机制有关的数据结构和算法。它还可以包含较低级别的详细信息（例如页面大小），还可以包含更抽象的较高级别的概念，例如大多数文件较小的假设。\n\nInformation hiding reduces complexity in two ways. First, it simplifies the interface to a module. The interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the cognitive load on developers who use the module. For instance, a developer using a B-tree class need not worry about the ideal fanout for nodes in the tree or how to keep the tree balanced. Second, information hiding makes it easier to evolve the system. If a piece of information is hidden, there are no dependencies on that information outside the module containing the information, so a design change related to that information will affect only the one module. For example, if the TCP protocol changes (to introduce a new mechanism for congestion control, for instance), the protocol’s implementation will have to be modified, but no changes should be needed in higher-level code that uses TCP to send and receive data.\n\n> 信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。例如，使用 B-tree 类的开发人员不需要考虑树中节点的理想扇出，也不需要考虑如何保持树的平衡。其次，信息隐藏使系统更容易演化。如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖，因此与该信息相关的设计更改将只影响一个模块。例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改。\n\nWhen designing a new module, you should think carefully about what information can be hidden in that module. If you can hide more information, you should also be able to simplify the module’s interface, and this makes the module deeper.\n\n> 设计新模块时，应仔细考虑可以在该模块中隐藏哪些信息。如果您可以隐藏更多信息，则还应该能够简化模块的界面，这会使模块更深。\n\nNote: hiding variables and methods in a class by declaring them private isn’t the same thing as information hiding. Private elements can help with information hiding, since they make it impossible for the items to be accessed directly from outside the class. However, information about the private items can still be exposed through public methods such as getter and setter methods. When this happens the nature and usage of the variables are just as exposed as if the variables were public.\n\n> 注意：通过声明变量和方法为私有来隐藏类中的变量和方法与信息隐藏不是同一回事。私有元素可以帮助隐藏信息，因为它们使无法从类外部直接访问项目。但是，有关私人物品的信息仍可以通过公共方法（如 getter 和 setter 方法）公开。发生这种情况时，变量的性质和用法就如同变量是公开的一样暴露。\n\nThe best form of information hiding is when information is totally hidden within a module, so that it is irrelevant and invisible to users of the module. However, partial information hiding also has value. For example, if a particular feature or piece of information is only needed by a few of a class’s users, and it is accessed through separate methods so that it isn’t visible in the most common use cases, then that information is mostly hidden. Such information will create fewer dependencies than information that is visible to every user of the class.\n\n> 信息隐藏的最佳形式是将信息完全隐藏在模块中，从而使该信息对模块的用户无关且不可见。但是，部分信息隐藏也具有价值。例如，如果某个类的某些用户仅需要特定的功能或信息，并且可以通过单独的方法对其进行访问，以使其在最常见的用例中不可见，则该信息通常会被隐藏。与类的每个用户可见的信息相比，此类信息将创建更少的依赖项。\n\n## 5.2 Information leakage 信息泄漏\n\nThe opposite of information hiding is information leakage. Information leakage occurs when a design decision is reflected in multiple modules. This creates a dependency between the modules: any change to that design decision will require changes to all of the involved modules. If a piece of information is reflected in the interface for a module, then by definition it has been leaked; thus, simpler interfaces tend to correlate with better information hiding. However, information can be leaked even if it doesn’t appear in a module’s interface. Suppose two classes both have knowledge of a particular file format (perhaps one class reads files in that format and the other class writes them). Even if neither class exposes that information in its interface, they both depend on the file format: if the format changes, both classes will need to be modified. Back-door leakage like this is more pernicious than leakage through an interface, because it isn’t obvious.\n\n> 信息隐藏的反面是信息泄漏。当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了依赖关系：对该设计决策的任何更改都将要求对所有涉及的模块进行更改。如果一条信息反映在模块的界面中，则根据定义，该信息已经泄漏；因此，更简单的界面往往与更好的信息隐藏相关。但是，即使信息未出现在模块的界面中，也可能会泄漏信息。假设两个类都具有特定文件格式的知识（也许一个类读取该格式的文件，而另一个类写入它们）。即使两个类都不在其接口中公开该信息，它们都取决于文件格式：如果格式更改，则两个类都将需要修改。\n\nInformation leakage is one of the most important red flags in software design. One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage. If you encounter information leakage between classes, ask yourself “How can I reorganize these classes so that this particular piece of knowledge only affects a single class?” If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class. Another possible approach is to pull the information out of all of the affected classes and create a new class that encapsulates just that information. However, this approach will be effective only if you can find a simple interface that abstracts away from the details; if the new class exposes most of the knowledge through its interface, then it won’t provide much value (you’ve simply replaced back-door leakage with leakage through an interface).\n\n> 信息泄漏是软件设计中最重要的危险信号之一。作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类?”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)。\n\nimg Red Flag: Information Leakage img\n\nInformation leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.\n\n> 当在多个地方使用相同的知识时，例如两个都理解特定类型文件格式的不同类，就会发生信息泄漏。\n\n## 5.3 Temporal decomposition 时间分解\n\nOne common cause of information leakage is a design style I call temporal decomposition. In temporal decomposition, the structure of a system corresponds to the time order in which operations will occur. Consider an application that reads a file in a particular format, modifies the contents of the file, and then writes the file out again. With temporal decomposition, this application might be broken into three classes: one to read the file, another to perform the modifications, and a third to write out the new version. Both the file reading and file writing steps have knowledge about the file format, which results in information leakage. The solution is to combine the core mechanisms for reading and writing files into a single class. This class will get used during both the reading and writing phases of the application. It’s easy to fall into the trap of temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest themselves at several different times over the life of the application; as a result, temporal decomposition often results in information leakage.\n\n> 信息泄漏的一个常见原因是我称为时间分解的设计风格。在时间分解中，系统的结构对应于操作将发生的时间顺序。考虑一个应用程序，该应用程序以特定格式读取文件，修改文件内容，然后再次将文件写出。通过时间分解，该应用程序可以分为三类：一类用于读取文件，另一类用于执行修改，第三类用于写出新版本。文件读取和文件写入步骤都具有有关文件格式的知识，这会导致信息泄漏。解决方案是将用于读写文件的核心机制结合到一个类中。该类将在应用程序的读取和写入阶段使用。很容易陷入时间分解的陷阱，因为在编写代码时通常会想到必须执行操作的顺序。但是，大多数设计决策会在应用程序的整个生命周期中的多个不同时刻表现出来。结果，时间分解常常导致信息泄漏。\n\nOrder usually does matter, so it will be reflected somewhere in the application. However, it shouldn’t be reflected in the module structure unless that structure is consistent with information hiding (perhaps the different stages use totally different information). When designing modules, focus on the knowledge that’s needed to perform each task, not the order in which tasks occur.\n\n> 顺序通常很重要，因此它将反映在应用程序中的某个位置。但是，除非该结构与信息隐藏保持一致（也许不同阶段使用完全不同的信息），否则不应将其反映在模块结构中。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。\n\nimg Red Flag: Temporal Decomposition img\n\nIn temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.\n\n> 在时间分解中，执行顺序反映在代码结构中：在不同时间发生的操作在不同的方法或类中。如果在执行的不同点使用相同的知识，则会在多个位置对其进行编码，从而导致信息泄漏。\n\n## 5.4 Example: HTTP server 示例：HTTP 服务器\n\nTo illustrate the issues in information hiding, let’s consider the design decisions made by students implementing the HTTP protocol in a software design course. It’s useful to see both the things they did well and they areas where they had problems.\n\n> 为了说明信息隐藏中的问题，让我们考虑由学生在软件设计课程中实现 HTTP 协议的设计决策。看到他们做得好的事情以及遇到问题的地方都是很有用的。\n\nHTTP is a mechanism used by Web browsers to communicate with Web servers. When a user clicks on a link in a Web browser or submits a form, the browser uses HTTP to send a request over the network to a Web server. Once the server has processed the request, it sends a response back to the browser; the response normally contains a new Web page to display. The HTTP protocol specifies the format of requests and responses, both of which are represented textually. Figure 5.1 shows a sample HTTP request describing a form submission. The students in the course were asked to implement one or more classes to make it easy for Web servers to receive incoming HTTP requests and send responses.\n\n> HTTP 是 Web 浏览器用来与 Web 服务器通信的机制。当用户单击 Web 浏览器中的链接或提交表单时，浏览器使用 HTTP 通过网络将请求发送到 Web 服务器。服务器处理完请求后，会将响应发送回浏览器。该响应通常包含要显示的新网页。HTTP 协议指定了请求和响应的格式，两者均以文本形式表示。图 5.1 显示了描述表单提交的 HTTP 请求示例。要求课程中的学生实施一门或多门课程，以使 Web 服务器可以轻松地接收传入的 HTTP 请求并发送响应。\n\n![](../../img/figures/00014.gif)\n\nFigure 5.1: A POST request in the HTTP protocol consists of text sent over a TCP socket. Each request contains an initial line, a collection of headers terminated by an empty line, and an optional body. The initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender. Each header line consists of a name such as Content-Length followed by its value. For this request, the body contains additional parameters (comment and priority).\n\n> 图 5.1：HTTP 协议中的 POST 请求包含通过 TCP 套接字发送的文本。每个请求都包含一个初始行，一个由空行终止的标头集合以及一个可选主体。初始行包含请求类型（POST 用于提交表单数据），指示操作（/注释/创建）和可选参数的 URL（photo_id 的值为 246）以及发送者使用的 HTTP 协议版本。每个标题行由一个名称（例如 Content-Length）及其后的值组成。对于此请求，正文包含其他参数（注释和优先级）。\n\n## 5.5 Example: too many classes 示例：太多的类\n\nThe most common mistake made by students was to divide their code into a large number of shallow classes, which led to information leakage between the classes. One team used two different classes for receiving HTTP requests; the first class read the request from the network connection into a string, and the second class parsed the string. This is an example of a temporal decomposition (“first we read the request, then we parse it”). Information leakage occurred because an HTTP request can’t be read without parsing much of the message; for example, the Content-Length header specifies the length of the request body, so the headers must be parsed in order to compute the total request length. As a result, both classes needed to understand most of the structure of HTTP requests, and parsing code was duplicated in both classes. This approach also created extra complexity for callers, who had to invoke two methods in different classes, in a particular order, to receive a request.\n\n> 学生最常犯的错误是将他们的代码分成大量的浅层类，这导致了类之间的信息泄漏。一个团队使用两种不同的类来接收 HTTP 请求。第一类将来自网络连接的请求读取为字符串，第二类将字符串解析。这是时间分解的一个示例（“首先读取请求，然后解析它”）。发生信息泄漏是因为无法解析大量消息就无法读取 HTTP 请求。例如，Content-Length 标头指定了请求主体的长度，因此必须对标头进行解析才能计算总请求长度。结果，这两个类都需要了解 HTTP 请求的大多数结构，并且解析代码在两个类中都是重复的。\n\nBecause the classes shared so much information, it would have been better to merge them into a single class that handles both request reading and parsing. This provides better information hiding, since it isolates all knowledge of the request format in one class, and it also provides a simpler interface to callers (just one method to invoke).\n\n> 由于这些类共享大量信息，因此最好将它们合并为一个同时处理请求读取和解析的类。由于它将请求格式的所有知识隔离在一个类中，因此它提供了更好的信息隐藏，并且还为调用者提供了一个更简单的接口（只是一种调用方法）。\n\nThis example illustrates a general theme in software design: information hiding can often be improved by making a class slightly larger. One reason for doing this is to bring together all of the code related to a particular capability (such as parsing an HTTP request), so that the resulting class contains everything related to that capability. A second reason for increasing the size of a class is to raise the level of the interface; for example, rather than having separate methods for each of three steps of a computation, have a single method that performs the entire computation. This can result in a simpler interface. Both of these benefits apply in the example of the previous paragraph: combining the classes brings together all of the code related to parsing an HTTP request, and it replaces two externally-visible methods with one. The combined class is deeper than the original classes.\n\n> 此示例说明了软件设计中的一般主题：通常可以通过使类稍大一些来改善信息隐藏。这样做的一个原因是将与特定功能相关的所有代码（例如，解析 HTTP 请求）组合在一起，以便生成的类包含与该功能相关的所有内容。增加类大小的第二个原因是提高接口的级别。例如，与其为计算的三个步骤中的每一个步骤使用单独的方法，不如使用一种方法来执行整个计算。这样可以简化界面。这两个优点都适用于上一段的示例：组合类将与解析 HTTP 请求相关的所有代码组合在一起，并且用一个替换了两个外部可见的方法。\n\nOf course, it is possible to take the notion of larger classes too far (such as a single class for the entire application). Chapter 9 will discuss conditions under which it makes sense to separate code into multiple smaller classes.\n\n> 当然，可以将较大的类的概念考虑得太远（例如整个应用程序的单个类）。第 9 章将讨论将代码分成多个较小的类的合理条件。\n\n## 5.6 Example: HTTP parameter handling 示例：HTTP 参数处理\n\nAfter an HTTP request has been received by a server, the server needs to access some of the information from the request. The code that handles the request in Figure 5.1 might need to know the value of the photo_id parameter. Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes, in the body (comment and priority in Figure 5.1). Each parameter has a name and a value. The values of parameters use a special encoding called URL encoding; for example, in the value for comment in Figure 5.1, “+” is used to represent a space character, and “%21” is used instead of “!”. In order to process a request, the server will need the values for some of the parameters, and it will want them in unencoded form.\n\n> 服务器收到 HTTP 请求后，服务器需要访问该请求中的某些信息。图 5.1 中处理请求的代码可能需要知道 photo_id 参数的值。参数可以在请求的第一行中指定（图 5.1 中的 photo_id），有时也可以在正文中指定（图 5.1 中的注释和优先级）。每个参数都有一个名称和一个值。参数的值使用一种称为 URL 编码的特殊编码。例如，在图 5.1 中的注释值中，“ +”代表空格字符，“％21”代替“！”。为了处理请求，服务器将需要某些参数的值，并且希望它们采用未编码的形式。\n\nMost of the student projects made two good choices with respect to parameter handling. First, they recognized that server applications don’t care whether a parameter is specified in the header line or the body of the request, so they hid this distinction from callers and merged the parameters from both locations together. Second, they hid knowledge of URL encoding: the HTTP parser decodes parameter values before returning them to the Web server, so that the value of the comment parameter in Figure 5.1 will be returned as “What a cute baby!”, not “What+a+cute+baby%21”). In both of these cases, information hiding resulted in simpler APIs for the code using the HTTP module.\n\n> 关于参数处理，大多数学生项目都做出了两个不错的选择。首先，他们认识到服务器应用程序不在乎是否在标题行或请求的正文中指定了参数，因此他们对调用者隐藏了这种区别，并将两个位置的参数合并在一起。其次，他们隐藏了 URL 编码的知识：HTTP 解析器在将参数值返回到 Web 服务器之前先对其进行解码，以便图 5.1 中的 comment 参数的值将返回 “What a cute baby!”，而不是 “What+a+cute+baby%21”）。在这两种情况下，信息隐藏都使使用 HTTP 模块的代码的 API 更加简单。\n\nHowever, most of the students used an interface for returning parameters that was too shallow, and this resulted in lost opportunities for information hiding. Most projects used an object of type HTTPRequest to hold the parsed HTTP request, and the HTTPRequest class had a single method like the following one to return parameters:\n\n> 但是，大多数学生使用的界面返回的参数太浅，这导致丢失信息隐藏的机会。大多数项目使用 HTTPRequest 类型的对象来保存已解析的 HTTP 请求，并且 HTTPRequest 类具有一种类似于以下方法的单个方法来返回参数：\n\n```java\npublic Map<String, String> getParams() {\n    return this.params;\n}\n```\n\nRather than returning a single parameter, the method returns a reference to the Map used internally to store all of the parameters. This method is shallow, and it exposes the internal representation used by the HTTPRequest class to store parameters. Any change to that representation will result in a change to the interface, which will require modifications to all callers. When implementations are modified, the changes often involve changes in the representation of key data structures (to improve performance, for example). Thus, it’s important to avoid exposing internal data structures as much as possible. This approach also makes more work for callers: a caller must first invoke getParams, then it must call another method to retrieve a specific parameter from the Map. Finally, callers must realize that they should not modify the Map returned by getParams, since that will affect the internal state of the HTTPRequest.\n\n> 该方法不是返回单个参数，而是返回内部用于存储所有参数的映射的引用。这个方法是浅层的，它公开了 HTTPRequest 类用来存储参数的内部表示。对该表示的任何更改都将导致接口的更改，这将需要对所有调用者进行修改。在修改实现时，更改通常涉及关键数据结构表示的更改(例如，为了提高性能)。因此，尽量避免暴露内部数据结构是很重要的。这种方法还为调用者提供了更多的工作:调用者必须首先调用 getParams，然后必须调用另一个方法来从映射中检索特定的参数。最后，调用者必须意识到他们不应该修改 getParams 返回的映射，因为这会影响 HTTPRequest 的内部状态。\n\nHere is a better interface for retrieving parameter values:\n\n> 这是一个用于检索参数值的更好的接口：\n\n```java\npublic String getParameter(String name) { ... }\n\npublic int getIntParameter(String name) { ... }\n```\n\ngetParameter returns a parameter value as a string. It provides a slightly deeper interface than getParams above; more importantly, it hides the internal representation of parameters. getIntParameter converts the value of a parameter from its string form in the HTTP request to an integer (e.g., the photo_id parameter in Figure 5.1). This saves the caller from having to request string-to-integer conversion separately, and hides that mechanism from the caller. Additional methods for other data types, such as getDoubleParameter, could be defined if needed. (All of these methods will throw exceptions if the desired parameter doesn’t exist, or if it can’t be converted to the requested type; the exception declarations have been omitted in the code above).\n\n> getParameter 以字符串形式返回参数值。它提供了一个比上面的 getParams 更深的接口；更重要的是，它隐藏了参数的内部表示。getIntParameter 将参数的值从 HTTP 请求中的字符串形式转换为整数（例如，图 5.1 中的 photo_id 参数）。这使调用者不必单独请求字符串到整数的转换，并且对调用者隐藏了该机制。如果需要，可以定义其他数据类型的其他方法，例如 getDoubleParameter。（如果所需的参数不存在，或者无法将其转换为所请求的类型，则所有这些方法都将引发异常；上面的代码中省略了异常声明）。\n\n## 5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值\n\nThe HTTP projects also had to provide support for generating HTTP responses. The most common mistake students made in this area was inadequate defaults. Each HTTP response must specify an HTTP protocol version; one team required callers to specify this version explicitly when creating a response object. However, the response version must correspond to that in the request object, and the request must already be passed as an argument when sending the response (it indicates where to send the response). Thus, it makes more sense for the HTTP classes to provide the response version automatically. The caller is unlikely to know what version to specify, and if the caller does specify a value, it probably results in information leakage between the HTTP library and the caller. HTTP responses also include a Date header specifying the time when the response was sent; the HTTP library should provide a sensible default for this as well.\n\n> HTTP 项目还必须提供对生成 HTTP 响应的支持。学生在该领域中最常见的错误是默认值不足。每个 HTTP 响应必须指定一个 HTTP 协议版本。一个团队要求呼叫者在创建响应对象时明确指定此版本。但是，响应版本必须与请求对象中的版本相对应，并且在发送响应时必须已将请求作为参数传递（它指示将响应发送到何处）。因此，HTTP 类自动提供响应版本更为有意义。调用者不太可能知道要指定哪个版本，并且如果调用者确实指定了一个值，则可能导致 HTTP 库和调用者之间的信息泄漏。HTTP 响应还包括一个 Date 标头，用于指定发送响应的时间；HTTP 库也应该为此提供一个合理的默认值。\n\nDefaults illustrate the principle that interfaces should be designed to make the common case as simple as possible. They are also an example of partial information hiding: in the normal case, the caller need not be aware of the existence of the defaulted item. In the rare cases where a caller needs to override a default, it will have to know about the value, and it can invoke a special method to modify it.\n\n> 默认值说明了应该设计接口以使常见情况尽可能简单的原则。它们还是隐藏部分信息的一个示例：在正常情况下，调用者无需知道默认项的存在。在极少数情况下，调用方需要覆盖默认值，它必须知道该值，并且可以调用特殊方法来对其进行修改。\n\nWhenever possible, classes should “do the right thing” without being explicitly asked. Defaults are an example of this. The Java I/O example on page 26 illustrates this point in a negative way. Buffering in file I/O is so universally desirable that noone should ever have to ask explicitly for it, or even be aware of its existence; the I/O classes should do the right thing and provide it automatically. The best features are the ones you get without even knowing they exist.\n\n> 只要有可能，类就应该“做正确的事”，而无需明确要求。默认值就是一个例子。第 26 页上的 Java I/O 示例以负面方式说明了这一点。普遍希望在文件 I/O 中缓冲，以至于没有人需要明确要求它，甚至不知道它的存在。I/O 类应该做正确的事情并自动提供它。最好的功能是您甚至不知道它们存在的功能。\n\nimg Red Flag: Overexposure img\n\nIf the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.\n\n> 如果常用功能的 API 迫使用户了解很少使用的其他功能，则这会增加不需要很少使用功能的用户的认知负担。\n\n## 5.8 Information hiding within a class 信息隐藏在班级中\n\nThe examples in this chapter focused on information hiding as it relates to the externally visible APIs for classes, but information hiding can also be applied at other levels in the system, such as within a class. Try to design the private methods within a class so that each method encapsulates some information or capability and hides it from the rest of the class. In addition, try to minimize the number of places where each instance variable is used. Some variables may need to be accessed widely across the class, but others may be needed in only a few places; if you can reduce the number of places where a variable is used, you will eliminate dependencies within the class and reduce its complexity.\n\n> 本章中的示例着重于信息隐藏，因为它与类的外部可见 API 有关，但是信息隐藏也可以应用于系统中的其他级别，例如类内。尝试在一个类中设计私有方法，以便每个方法都封装一些信息或功能，并将其隐藏在类的其余部分中。此外，请尽量减少使用每个实例变量的位置数量。有些变量可能需要在整个班级中广泛使用，但是其他变量可能只需要在少数地方使用；如果可以减少使用变量的位置的数量，则将消除类内的依赖关系并降低其复杂性。\n\n## 5.9 Taking it too far 走得太远\n\nInformation hiding only makes sense when the information being hidden is not needed outside its module. If the information is needed outside the module, then you must not hide it. Suppose that the performance of a module is affected by certain configuration parameters, and that different uses of the module will require different settings of the parameters. In this case it is important that the parameters are exposed in the interface of the module, so that they can be turned appropriately. As a software designer, your goal should be to minimize the amount of information needed outside a module; for example, if a module can automatically adjust its configuration, that is better than exposing configuration parameters. But, it’s important to recognize which information is needed outside a module and make sure it is exposed.\n\n> 仅当在其模块外部不需要隐藏信息时，隐藏信息才有意义。如果模块外部需要该信息，则不得隐藏它。假设模块的性能受某些配置参数的影响，并且模块的不同用途将需要对参数进行不同的设置。在这种情况下，将参数暴露在模块的界面中很重要，以便可以对其进行适当的旋转。作为软件设计师，您的目标应该是最大程度地减少模块外部所需的信息量。例如，如果模块可以自动调整其配置，那将比公开配置参数更好。但是，重要的是要识别模块外部需要哪些信息，并确保将其公开。\n\n## 5.10 Conclusion 结论\n\nInformation hiding and deep modules are closely related. If a module hides a lot of information, that tends to increase the amount of functionality provided by the module while also reducing its interface. This makes the module deeper. Conversely, if a module doesn’t hide much information, then either it doesn’t have much functionality, or it has a complex interface; either way, the module is shallow.\n\n> 信息隐藏和深层模块密切相关。如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。相反，如果一个模块没有隐藏太多信息，则它要么功能不多，要么接口复杂。无论哪种方式，模块都是浅的。\n\nWhen decomposing a system into modules, try not to be influenced by the order in which operations will occur at runtime; that will lead you down the path of temporal decomposition, which will result in information leakage and shallow modules. Instead, think about the different pieces of knowledge that are needed to carry out the tasks of your application, and design each module to encapsulate one or a few of those pieces of knowledge. This will produce a clean and simple design with deep modules.\n\n> 将系统分解为模块时，请尽量不要受运行时操作顺序的影响。这将使您沿着时间分解的路径前进，这将导致信息泄漏和模块浅。相反，请考虑执行应用程序任务所需的不同知识，并设计每个模块以封装这些知识中的一个或几个。这将产生带有深色模块的干净简单的设计。\n\n1David Parnas, “On the Criteria to be Used in Decomposing Systems into Modules,” Communications of the ACM, December 1972.\n\n> 1 David Parnas，“关于将系统分解为模块的标准”，ACM 通讯，1972 年 12 月。\n","source":"_posts/软件设计的哲学-ch5.md","raw":"---\ntitle: 软件设计的哲学 - ch5\ndate: 2021-02-5\ntags: 软件设计的哲学 软件开发 方法论\n---\n信息隐藏(和泄漏)\n<!-- more -->\n# 第 5 章 信息隐藏(和泄漏)\n\n> Chapter 5 Information Hiding (and Leakage)\n\nChapter 4 argued that modules should be deep. This chapter, and the next few that follow, discuss techniques for creating deep modules.\n\n> 第四章认为模块应该很深。本章及随后的其他章节讨论了创建深层模块的技术。\n\n## 5.1 Information hiding 信息隐藏\n\nThe most important technique for achieving deep modules is information hiding. This technique was first described by David Parnas1. The basic idea is that each module should encapsulate a few pieces of knowledge, which represent design decisions. The knowledge is embedded in the module’s implementation but does not appear in its interface, so it is not visible to other modules.\n\n> 实现深层模块最重要的技术是信息隐藏。该技术最早由 David Parnas1 描述。基本思想是每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其界面中，因此其他模块不可见。\n\nThe information hidden within a module usually consists of details about how to implement some mechanism. Here are some examples of information that might be hidden within a module:\n\n> 隐藏在模块中的信息通常包含有关如何实现某种机制的详细信息。以下是一些可能隐藏在模块中的信息示例：\n\n- How to store information in a B-tree, and how to access it efficiently.\n- How to identify the physical disk block corresponding to each logical block within a file.\n- How to implement the TCP network protocol.\n- How to schedule threads on a multi-core processor.\n- How to parse JSON documents.\n\n---\n\n> - 如何在 B 树中存储信息，以及如何有效地访问它。\n> - 如何识别与文件中每个逻辑块相对应的物理磁盘块。\n> - 如何实现 TCP 网络协议。\n> - 如何在多核处理器上调度线程。\n> - 如何解析 JSON 文档。\n\nThe hidden information includes data structures and algorithms related to the mechanism. It can also include lower-level details such as the size of a page, and it can include higher-level concepts that are more abstract, such as an assumption that most files are small.\n\n> 隐藏的信息包括与该机制有关的数据结构和算法。它还可以包含较低级别的详细信息（例如页面大小），还可以包含更抽象的较高级别的概念，例如大多数文件较小的假设。\n\nInformation hiding reduces complexity in two ways. First, it simplifies the interface to a module. The interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the cognitive load on developers who use the module. For instance, a developer using a B-tree class need not worry about the ideal fanout for nodes in the tree or how to keep the tree balanced. Second, information hiding makes it easier to evolve the system. If a piece of information is hidden, there are no dependencies on that information outside the module containing the information, so a design change related to that information will affect only the one module. For example, if the TCP protocol changes (to introduce a new mechanism for congestion control, for instance), the protocol’s implementation will have to be modified, but no changes should be needed in higher-level code that uses TCP to send and receive data.\n\n> 信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。例如，使用 B-tree 类的开发人员不需要考虑树中节点的理想扇出，也不需要考虑如何保持树的平衡。其次，信息隐藏使系统更容易演化。如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖，因此与该信息相关的设计更改将只影响一个模块。例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改。\n\nWhen designing a new module, you should think carefully about what information can be hidden in that module. If you can hide more information, you should also be able to simplify the module’s interface, and this makes the module deeper.\n\n> 设计新模块时，应仔细考虑可以在该模块中隐藏哪些信息。如果您可以隐藏更多信息，则还应该能够简化模块的界面，这会使模块更深。\n\nNote: hiding variables and methods in a class by declaring them private isn’t the same thing as information hiding. Private elements can help with information hiding, since they make it impossible for the items to be accessed directly from outside the class. However, information about the private items can still be exposed through public methods such as getter and setter methods. When this happens the nature and usage of the variables are just as exposed as if the variables were public.\n\n> 注意：通过声明变量和方法为私有来隐藏类中的变量和方法与信息隐藏不是同一回事。私有元素可以帮助隐藏信息，因为它们使无法从类外部直接访问项目。但是，有关私人物品的信息仍可以通过公共方法（如 getter 和 setter 方法）公开。发生这种情况时，变量的性质和用法就如同变量是公开的一样暴露。\n\nThe best form of information hiding is when information is totally hidden within a module, so that it is irrelevant and invisible to users of the module. However, partial information hiding also has value. For example, if a particular feature or piece of information is only needed by a few of a class’s users, and it is accessed through separate methods so that it isn’t visible in the most common use cases, then that information is mostly hidden. Such information will create fewer dependencies than information that is visible to every user of the class.\n\n> 信息隐藏的最佳形式是将信息完全隐藏在模块中，从而使该信息对模块的用户无关且不可见。但是，部分信息隐藏也具有价值。例如，如果某个类的某些用户仅需要特定的功能或信息，并且可以通过单独的方法对其进行访问，以使其在最常见的用例中不可见，则该信息通常会被隐藏。与类的每个用户可见的信息相比，此类信息将创建更少的依赖项。\n\n## 5.2 Information leakage 信息泄漏\n\nThe opposite of information hiding is information leakage. Information leakage occurs when a design decision is reflected in multiple modules. This creates a dependency between the modules: any change to that design decision will require changes to all of the involved modules. If a piece of information is reflected in the interface for a module, then by definition it has been leaked; thus, simpler interfaces tend to correlate with better information hiding. However, information can be leaked even if it doesn’t appear in a module’s interface. Suppose two classes both have knowledge of a particular file format (perhaps one class reads files in that format and the other class writes them). Even if neither class exposes that information in its interface, they both depend on the file format: if the format changes, both classes will need to be modified. Back-door leakage like this is more pernicious than leakage through an interface, because it isn’t obvious.\n\n> 信息隐藏的反面是信息泄漏。当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了依赖关系：对该设计决策的任何更改都将要求对所有涉及的模块进行更改。如果一条信息反映在模块的界面中，则根据定义，该信息已经泄漏；因此，更简单的界面往往与更好的信息隐藏相关。但是，即使信息未出现在模块的界面中，也可能会泄漏信息。假设两个类都具有特定文件格式的知识（也许一个类读取该格式的文件，而另一个类写入它们）。即使两个类都不在其接口中公开该信息，它们都取决于文件格式：如果格式更改，则两个类都将需要修改。\n\nInformation leakage is one of the most important red flags in software design. One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage. If you encounter information leakage between classes, ask yourself “How can I reorganize these classes so that this particular piece of knowledge only affects a single class?” If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class. Another possible approach is to pull the information out of all of the affected classes and create a new class that encapsulates just that information. However, this approach will be effective only if you can find a simple interface that abstracts away from the details; if the new class exposes most of the knowledge through its interface, then it won’t provide much value (you’ve simply replaced back-door leakage with leakage through an interface).\n\n> 信息泄漏是软件设计中最重要的危险信号之一。作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类?”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)。\n\nimg Red Flag: Information Leakage img\n\nInformation leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.\n\n> 当在多个地方使用相同的知识时，例如两个都理解特定类型文件格式的不同类，就会发生信息泄漏。\n\n## 5.3 Temporal decomposition 时间分解\n\nOne common cause of information leakage is a design style I call temporal decomposition. In temporal decomposition, the structure of a system corresponds to the time order in which operations will occur. Consider an application that reads a file in a particular format, modifies the contents of the file, and then writes the file out again. With temporal decomposition, this application might be broken into three classes: one to read the file, another to perform the modifications, and a third to write out the new version. Both the file reading and file writing steps have knowledge about the file format, which results in information leakage. The solution is to combine the core mechanisms for reading and writing files into a single class. This class will get used during both the reading and writing phases of the application. It’s easy to fall into the trap of temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest themselves at several different times over the life of the application; as a result, temporal decomposition often results in information leakage.\n\n> 信息泄漏的一个常见原因是我称为时间分解的设计风格。在时间分解中，系统的结构对应于操作将发生的时间顺序。考虑一个应用程序，该应用程序以特定格式读取文件，修改文件内容，然后再次将文件写出。通过时间分解，该应用程序可以分为三类：一类用于读取文件，另一类用于执行修改，第三类用于写出新版本。文件读取和文件写入步骤都具有有关文件格式的知识，这会导致信息泄漏。解决方案是将用于读写文件的核心机制结合到一个类中。该类将在应用程序的读取和写入阶段使用。很容易陷入时间分解的陷阱，因为在编写代码时通常会想到必须执行操作的顺序。但是，大多数设计决策会在应用程序的整个生命周期中的多个不同时刻表现出来。结果，时间分解常常导致信息泄漏。\n\nOrder usually does matter, so it will be reflected somewhere in the application. However, it shouldn’t be reflected in the module structure unless that structure is consistent with information hiding (perhaps the different stages use totally different information). When designing modules, focus on the knowledge that’s needed to perform each task, not the order in which tasks occur.\n\n> 顺序通常很重要，因此它将反映在应用程序中的某个位置。但是，除非该结构与信息隐藏保持一致（也许不同阶段使用完全不同的信息），否则不应将其反映在模块结构中。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。\n\nimg Red Flag: Temporal Decomposition img\n\nIn temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.\n\n> 在时间分解中，执行顺序反映在代码结构中：在不同时间发生的操作在不同的方法或类中。如果在执行的不同点使用相同的知识，则会在多个位置对其进行编码，从而导致信息泄漏。\n\n## 5.4 Example: HTTP server 示例：HTTP 服务器\n\nTo illustrate the issues in information hiding, let’s consider the design decisions made by students implementing the HTTP protocol in a software design course. It’s useful to see both the things they did well and they areas where they had problems.\n\n> 为了说明信息隐藏中的问题，让我们考虑由学生在软件设计课程中实现 HTTP 协议的设计决策。看到他们做得好的事情以及遇到问题的地方都是很有用的。\n\nHTTP is a mechanism used by Web browsers to communicate with Web servers. When a user clicks on a link in a Web browser or submits a form, the browser uses HTTP to send a request over the network to a Web server. Once the server has processed the request, it sends a response back to the browser; the response normally contains a new Web page to display. The HTTP protocol specifies the format of requests and responses, both of which are represented textually. Figure 5.1 shows a sample HTTP request describing a form submission. The students in the course were asked to implement one or more classes to make it easy for Web servers to receive incoming HTTP requests and send responses.\n\n> HTTP 是 Web 浏览器用来与 Web 服务器通信的机制。当用户单击 Web 浏览器中的链接或提交表单时，浏览器使用 HTTP 通过网络将请求发送到 Web 服务器。服务器处理完请求后，会将响应发送回浏览器。该响应通常包含要显示的新网页。HTTP 协议指定了请求和响应的格式，两者均以文本形式表示。图 5.1 显示了描述表单提交的 HTTP 请求示例。要求课程中的学生实施一门或多门课程，以使 Web 服务器可以轻松地接收传入的 HTTP 请求并发送响应。\n\n![](../../img/figures/00014.gif)\n\nFigure 5.1: A POST request in the HTTP protocol consists of text sent over a TCP socket. Each request contains an initial line, a collection of headers terminated by an empty line, and an optional body. The initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender. Each header line consists of a name such as Content-Length followed by its value. For this request, the body contains additional parameters (comment and priority).\n\n> 图 5.1：HTTP 协议中的 POST 请求包含通过 TCP 套接字发送的文本。每个请求都包含一个初始行，一个由空行终止的标头集合以及一个可选主体。初始行包含请求类型（POST 用于提交表单数据），指示操作（/注释/创建）和可选参数的 URL（photo_id 的值为 246）以及发送者使用的 HTTP 协议版本。每个标题行由一个名称（例如 Content-Length）及其后的值组成。对于此请求，正文包含其他参数（注释和优先级）。\n\n## 5.5 Example: too many classes 示例：太多的类\n\nThe most common mistake made by students was to divide their code into a large number of shallow classes, which led to information leakage between the classes. One team used two different classes for receiving HTTP requests; the first class read the request from the network connection into a string, and the second class parsed the string. This is an example of a temporal decomposition (“first we read the request, then we parse it”). Information leakage occurred because an HTTP request can’t be read without parsing much of the message; for example, the Content-Length header specifies the length of the request body, so the headers must be parsed in order to compute the total request length. As a result, both classes needed to understand most of the structure of HTTP requests, and parsing code was duplicated in both classes. This approach also created extra complexity for callers, who had to invoke two methods in different classes, in a particular order, to receive a request.\n\n> 学生最常犯的错误是将他们的代码分成大量的浅层类，这导致了类之间的信息泄漏。一个团队使用两种不同的类来接收 HTTP 请求。第一类将来自网络连接的请求读取为字符串，第二类将字符串解析。这是时间分解的一个示例（“首先读取请求，然后解析它”）。发生信息泄漏是因为无法解析大量消息就无法读取 HTTP 请求。例如，Content-Length 标头指定了请求主体的长度，因此必须对标头进行解析才能计算总请求长度。结果，这两个类都需要了解 HTTP 请求的大多数结构，并且解析代码在两个类中都是重复的。\n\nBecause the classes shared so much information, it would have been better to merge them into a single class that handles both request reading and parsing. This provides better information hiding, since it isolates all knowledge of the request format in one class, and it also provides a simpler interface to callers (just one method to invoke).\n\n> 由于这些类共享大量信息，因此最好将它们合并为一个同时处理请求读取和解析的类。由于它将请求格式的所有知识隔离在一个类中，因此它提供了更好的信息隐藏，并且还为调用者提供了一个更简单的接口（只是一种调用方法）。\n\nThis example illustrates a general theme in software design: information hiding can often be improved by making a class slightly larger. One reason for doing this is to bring together all of the code related to a particular capability (such as parsing an HTTP request), so that the resulting class contains everything related to that capability. A second reason for increasing the size of a class is to raise the level of the interface; for example, rather than having separate methods for each of three steps of a computation, have a single method that performs the entire computation. This can result in a simpler interface. Both of these benefits apply in the example of the previous paragraph: combining the classes brings together all of the code related to parsing an HTTP request, and it replaces two externally-visible methods with one. The combined class is deeper than the original classes.\n\n> 此示例说明了软件设计中的一般主题：通常可以通过使类稍大一些来改善信息隐藏。这样做的一个原因是将与特定功能相关的所有代码（例如，解析 HTTP 请求）组合在一起，以便生成的类包含与该功能相关的所有内容。增加类大小的第二个原因是提高接口的级别。例如，与其为计算的三个步骤中的每一个步骤使用单独的方法，不如使用一种方法来执行整个计算。这样可以简化界面。这两个优点都适用于上一段的示例：组合类将与解析 HTTP 请求相关的所有代码组合在一起，并且用一个替换了两个外部可见的方法。\n\nOf course, it is possible to take the notion of larger classes too far (such as a single class for the entire application). Chapter 9 will discuss conditions under which it makes sense to separate code into multiple smaller classes.\n\n> 当然，可以将较大的类的概念考虑得太远（例如整个应用程序的单个类）。第 9 章将讨论将代码分成多个较小的类的合理条件。\n\n## 5.6 Example: HTTP parameter handling 示例：HTTP 参数处理\n\nAfter an HTTP request has been received by a server, the server needs to access some of the information from the request. The code that handles the request in Figure 5.1 might need to know the value of the photo_id parameter. Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes, in the body (comment and priority in Figure 5.1). Each parameter has a name and a value. The values of parameters use a special encoding called URL encoding; for example, in the value for comment in Figure 5.1, “+” is used to represent a space character, and “%21” is used instead of “!”. In order to process a request, the server will need the values for some of the parameters, and it will want them in unencoded form.\n\n> 服务器收到 HTTP 请求后，服务器需要访问该请求中的某些信息。图 5.1 中处理请求的代码可能需要知道 photo_id 参数的值。参数可以在请求的第一行中指定（图 5.1 中的 photo_id），有时也可以在正文中指定（图 5.1 中的注释和优先级）。每个参数都有一个名称和一个值。参数的值使用一种称为 URL 编码的特殊编码。例如，在图 5.1 中的注释值中，“ +”代表空格字符，“％21”代替“！”。为了处理请求，服务器将需要某些参数的值，并且希望它们采用未编码的形式。\n\nMost of the student projects made two good choices with respect to parameter handling. First, they recognized that server applications don’t care whether a parameter is specified in the header line or the body of the request, so they hid this distinction from callers and merged the parameters from both locations together. Second, they hid knowledge of URL encoding: the HTTP parser decodes parameter values before returning them to the Web server, so that the value of the comment parameter in Figure 5.1 will be returned as “What a cute baby!”, not “What+a+cute+baby%21”). In both of these cases, information hiding resulted in simpler APIs for the code using the HTTP module.\n\n> 关于参数处理，大多数学生项目都做出了两个不错的选择。首先，他们认识到服务器应用程序不在乎是否在标题行或请求的正文中指定了参数，因此他们对调用者隐藏了这种区别，并将两个位置的参数合并在一起。其次，他们隐藏了 URL 编码的知识：HTTP 解析器在将参数值返回到 Web 服务器之前先对其进行解码，以便图 5.1 中的 comment 参数的值将返回 “What a cute baby!”，而不是 “What+a+cute+baby%21”）。在这两种情况下，信息隐藏都使使用 HTTP 模块的代码的 API 更加简单。\n\nHowever, most of the students used an interface for returning parameters that was too shallow, and this resulted in lost opportunities for information hiding. Most projects used an object of type HTTPRequest to hold the parsed HTTP request, and the HTTPRequest class had a single method like the following one to return parameters:\n\n> 但是，大多数学生使用的界面返回的参数太浅，这导致丢失信息隐藏的机会。大多数项目使用 HTTPRequest 类型的对象来保存已解析的 HTTP 请求，并且 HTTPRequest 类具有一种类似于以下方法的单个方法来返回参数：\n\n```java\npublic Map<String, String> getParams() {\n    return this.params;\n}\n```\n\nRather than returning a single parameter, the method returns a reference to the Map used internally to store all of the parameters. This method is shallow, and it exposes the internal representation used by the HTTPRequest class to store parameters. Any change to that representation will result in a change to the interface, which will require modifications to all callers. When implementations are modified, the changes often involve changes in the representation of key data structures (to improve performance, for example). Thus, it’s important to avoid exposing internal data structures as much as possible. This approach also makes more work for callers: a caller must first invoke getParams, then it must call another method to retrieve a specific parameter from the Map. Finally, callers must realize that they should not modify the Map returned by getParams, since that will affect the internal state of the HTTPRequest.\n\n> 该方法不是返回单个参数，而是返回内部用于存储所有参数的映射的引用。这个方法是浅层的，它公开了 HTTPRequest 类用来存储参数的内部表示。对该表示的任何更改都将导致接口的更改，这将需要对所有调用者进行修改。在修改实现时，更改通常涉及关键数据结构表示的更改(例如，为了提高性能)。因此，尽量避免暴露内部数据结构是很重要的。这种方法还为调用者提供了更多的工作:调用者必须首先调用 getParams，然后必须调用另一个方法来从映射中检索特定的参数。最后，调用者必须意识到他们不应该修改 getParams 返回的映射，因为这会影响 HTTPRequest 的内部状态。\n\nHere is a better interface for retrieving parameter values:\n\n> 这是一个用于检索参数值的更好的接口：\n\n```java\npublic String getParameter(String name) { ... }\n\npublic int getIntParameter(String name) { ... }\n```\n\ngetParameter returns a parameter value as a string. It provides a slightly deeper interface than getParams above; more importantly, it hides the internal representation of parameters. getIntParameter converts the value of a parameter from its string form in the HTTP request to an integer (e.g., the photo_id parameter in Figure 5.1). This saves the caller from having to request string-to-integer conversion separately, and hides that mechanism from the caller. Additional methods for other data types, such as getDoubleParameter, could be defined if needed. (All of these methods will throw exceptions if the desired parameter doesn’t exist, or if it can’t be converted to the requested type; the exception declarations have been omitted in the code above).\n\n> getParameter 以字符串形式返回参数值。它提供了一个比上面的 getParams 更深的接口；更重要的是，它隐藏了参数的内部表示。getIntParameter 将参数的值从 HTTP 请求中的字符串形式转换为整数（例如，图 5.1 中的 photo_id 参数）。这使调用者不必单独请求字符串到整数的转换，并且对调用者隐藏了该机制。如果需要，可以定义其他数据类型的其他方法，例如 getDoubleParameter。（如果所需的参数不存在，或者无法将其转换为所请求的类型，则所有这些方法都将引发异常；上面的代码中省略了异常声明）。\n\n## 5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值\n\nThe HTTP projects also had to provide support for generating HTTP responses. The most common mistake students made in this area was inadequate defaults. Each HTTP response must specify an HTTP protocol version; one team required callers to specify this version explicitly when creating a response object. However, the response version must correspond to that in the request object, and the request must already be passed as an argument when sending the response (it indicates where to send the response). Thus, it makes more sense for the HTTP classes to provide the response version automatically. The caller is unlikely to know what version to specify, and if the caller does specify a value, it probably results in information leakage between the HTTP library and the caller. HTTP responses also include a Date header specifying the time when the response was sent; the HTTP library should provide a sensible default for this as well.\n\n> HTTP 项目还必须提供对生成 HTTP 响应的支持。学生在该领域中最常见的错误是默认值不足。每个 HTTP 响应必须指定一个 HTTP 协议版本。一个团队要求呼叫者在创建响应对象时明确指定此版本。但是，响应版本必须与请求对象中的版本相对应，并且在发送响应时必须已将请求作为参数传递（它指示将响应发送到何处）。因此，HTTP 类自动提供响应版本更为有意义。调用者不太可能知道要指定哪个版本，并且如果调用者确实指定了一个值，则可能导致 HTTP 库和调用者之间的信息泄漏。HTTP 响应还包括一个 Date 标头，用于指定发送响应的时间；HTTP 库也应该为此提供一个合理的默认值。\n\nDefaults illustrate the principle that interfaces should be designed to make the common case as simple as possible. They are also an example of partial information hiding: in the normal case, the caller need not be aware of the existence of the defaulted item. In the rare cases where a caller needs to override a default, it will have to know about the value, and it can invoke a special method to modify it.\n\n> 默认值说明了应该设计接口以使常见情况尽可能简单的原则。它们还是隐藏部分信息的一个示例：在正常情况下，调用者无需知道默认项的存在。在极少数情况下，调用方需要覆盖默认值，它必须知道该值，并且可以调用特殊方法来对其进行修改。\n\nWhenever possible, classes should “do the right thing” without being explicitly asked. Defaults are an example of this. The Java I/O example on page 26 illustrates this point in a negative way. Buffering in file I/O is so universally desirable that noone should ever have to ask explicitly for it, or even be aware of its existence; the I/O classes should do the right thing and provide it automatically. The best features are the ones you get without even knowing they exist.\n\n> 只要有可能，类就应该“做正确的事”，而无需明确要求。默认值就是一个例子。第 26 页上的 Java I/O 示例以负面方式说明了这一点。普遍希望在文件 I/O 中缓冲，以至于没有人需要明确要求它，甚至不知道它的存在。I/O 类应该做正确的事情并自动提供它。最好的功能是您甚至不知道它们存在的功能。\n\nimg Red Flag: Overexposure img\n\nIf the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.\n\n> 如果常用功能的 API 迫使用户了解很少使用的其他功能，则这会增加不需要很少使用功能的用户的认知负担。\n\n## 5.8 Information hiding within a class 信息隐藏在班级中\n\nThe examples in this chapter focused on information hiding as it relates to the externally visible APIs for classes, but information hiding can also be applied at other levels in the system, such as within a class. Try to design the private methods within a class so that each method encapsulates some information or capability and hides it from the rest of the class. In addition, try to minimize the number of places where each instance variable is used. Some variables may need to be accessed widely across the class, but others may be needed in only a few places; if you can reduce the number of places where a variable is used, you will eliminate dependencies within the class and reduce its complexity.\n\n> 本章中的示例着重于信息隐藏，因为它与类的外部可见 API 有关，但是信息隐藏也可以应用于系统中的其他级别，例如类内。尝试在一个类中设计私有方法，以便每个方法都封装一些信息或功能，并将其隐藏在类的其余部分中。此外，请尽量减少使用每个实例变量的位置数量。有些变量可能需要在整个班级中广泛使用，但是其他变量可能只需要在少数地方使用；如果可以减少使用变量的位置的数量，则将消除类内的依赖关系并降低其复杂性。\n\n## 5.9 Taking it too far 走得太远\n\nInformation hiding only makes sense when the information being hidden is not needed outside its module. If the information is needed outside the module, then you must not hide it. Suppose that the performance of a module is affected by certain configuration parameters, and that different uses of the module will require different settings of the parameters. In this case it is important that the parameters are exposed in the interface of the module, so that they can be turned appropriately. As a software designer, your goal should be to minimize the amount of information needed outside a module; for example, if a module can automatically adjust its configuration, that is better than exposing configuration parameters. But, it’s important to recognize which information is needed outside a module and make sure it is exposed.\n\n> 仅当在其模块外部不需要隐藏信息时，隐藏信息才有意义。如果模块外部需要该信息，则不得隐藏它。假设模块的性能受某些配置参数的影响，并且模块的不同用途将需要对参数进行不同的设置。在这种情况下，将参数暴露在模块的界面中很重要，以便可以对其进行适当的旋转。作为软件设计师，您的目标应该是最大程度地减少模块外部所需的信息量。例如，如果模块可以自动调整其配置，那将比公开配置参数更好。但是，重要的是要识别模块外部需要哪些信息，并确保将其公开。\n\n## 5.10 Conclusion 结论\n\nInformation hiding and deep modules are closely related. If a module hides a lot of information, that tends to increase the amount of functionality provided by the module while also reducing its interface. This makes the module deeper. Conversely, if a module doesn’t hide much information, then either it doesn’t have much functionality, or it has a complex interface; either way, the module is shallow.\n\n> 信息隐藏和深层模块密切相关。如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。相反，如果一个模块没有隐藏太多信息，则它要么功能不多，要么接口复杂。无论哪种方式，模块都是浅的。\n\nWhen decomposing a system into modules, try not to be influenced by the order in which operations will occur at runtime; that will lead you down the path of temporal decomposition, which will result in information leakage and shallow modules. Instead, think about the different pieces of knowledge that are needed to carry out the tasks of your application, and design each module to encapsulate one or a few of those pieces of knowledge. This will produce a clean and simple design with deep modules.\n\n> 将系统分解为模块时，请尽量不要受运行时操作顺序的影响。这将使您沿着时间分解的路径前进，这将导致信息泄漏和模块浅。相反，请考虑执行应用程序任务所需的不同知识，并设计每个模块以封装这些知识中的一个或几个。这将产生带有深色模块的干净简单的设计。\n\n1David Parnas, “On the Criteria to be Used in Decomposing Systems into Modules,” Communications of the ACM, December 1972.\n\n> 1 David Parnas，“关于将系统分解为模块的标准”，ACM 通讯，1972 年 12 月。\n","slug":"软件设计的哲学-ch5","published":1,"updated":"2021-02-16T04:59:33.340Z","_id":"ckl7iw2vw000jkiiyg30b174k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>信息隐藏(和泄漏)</p>\n<a id=\"more\"></a>\n<h1 id=\"第-5-章-信息隐藏-和泄漏\"><a href=\"#第-5-章-信息隐藏-和泄漏\" class=\"headerlink\" title=\"第 5 章 信息隐藏(和泄漏)\"></a>第 5 章 信息隐藏(和泄漏)</h1><blockquote>\n<p>Chapter 5 Information Hiding (and Leakage)</p>\n</blockquote>\n<p>Chapter 4 argued that modules should be deep. This chapter, and the next few that follow, discuss techniques for creating deep modules.</p>\n<blockquote>\n<p>第四章认为模块应该很深。本章及随后的其他章节讨论了创建深层模块的技术。</p>\n</blockquote>\n<h2 id=\"5-1-Information-hiding-信息隐藏\"><a href=\"#5-1-Information-hiding-信息隐藏\" class=\"headerlink\" title=\"5.1 Information hiding 信息隐藏\"></a>5.1 Information hiding 信息隐藏</h2><p>The most important technique for achieving deep modules is information hiding. This technique was first described by David Parnas1. The basic idea is that each module should encapsulate a few pieces of knowledge, which represent design decisions. The knowledge is embedded in the module’s implementation but does not appear in its interface, so it is not visible to other modules.</p>\n<blockquote>\n<p>实现深层模块最重要的技术是信息隐藏。该技术最早由 David Parnas1 描述。基本思想是每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其界面中，因此其他模块不可见。</p>\n</blockquote>\n<p>The information hidden within a module usually consists of details about how to implement some mechanism. Here are some examples of information that might be hidden within a module:</p>\n<blockquote>\n<p>隐藏在模块中的信息通常包含有关如何实现某种机制的详细信息。以下是一些可能隐藏在模块中的信息示例：</p>\n</blockquote>\n<ul>\n<li>How to store information in a B-tree, and how to access it efficiently.</li>\n<li>How to identify the physical disk block corresponding to each logical block within a file.</li>\n<li>How to implement the TCP network protocol.</li>\n<li>How to schedule threads on a multi-core processor.</li>\n<li>How to parse JSON documents.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>如何在 B 树中存储信息，以及如何有效地访问它。</li>\n<li>如何识别与文件中每个逻辑块相对应的物理磁盘块。</li>\n<li>如何实现 TCP 网络协议。</li>\n<li>如何在多核处理器上调度线程。</li>\n<li>如何解析 JSON 文档。</li>\n</ul>\n</blockquote>\n<p>The hidden information includes data structures and algorithms related to the mechanism. It can also include lower-level details such as the size of a page, and it can include higher-level concepts that are more abstract, such as an assumption that most files are small.</p>\n<blockquote>\n<p>隐藏的信息包括与该机制有关的数据结构和算法。它还可以包含较低级别的详细信息（例如页面大小），还可以包含更抽象的较高级别的概念，例如大多数文件较小的假设。</p>\n</blockquote>\n<p>Information hiding reduces complexity in two ways. First, it simplifies the interface to a module. The interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the cognitive load on developers who use the module. For instance, a developer using a B-tree class need not worry about the ideal fanout for nodes in the tree or how to keep the tree balanced. Second, information hiding makes it easier to evolve the system. If a piece of information is hidden, there are no dependencies on that information outside the module containing the information, so a design change related to that information will affect only the one module. For example, if the TCP protocol changes (to introduce a new mechanism for congestion control, for instance), the protocol’s implementation will have to be modified, but no changes should be needed in higher-level code that uses TCP to send and receive data.</p>\n<blockquote>\n<p>信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。例如，使用 B-tree 类的开发人员不需要考虑树中节点的理想扇出，也不需要考虑如何保持树的平衡。其次，信息隐藏使系统更容易演化。如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖，因此与该信息相关的设计更改将只影响一个模块。例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改。</p>\n</blockquote>\n<p>When designing a new module, you should think carefully about what information can be hidden in that module. If you can hide more information, you should also be able to simplify the module’s interface, and this makes the module deeper.</p>\n<blockquote>\n<p>设计新模块时，应仔细考虑可以在该模块中隐藏哪些信息。如果您可以隐藏更多信息，则还应该能够简化模块的界面，这会使模块更深。</p>\n</blockquote>\n<p>Note: hiding variables and methods in a class by declaring them private isn’t the same thing as information hiding. Private elements can help with information hiding, since they make it impossible for the items to be accessed directly from outside the class. However, information about the private items can still be exposed through public methods such as getter and setter methods. When this happens the nature and usage of the variables are just as exposed as if the variables were public.</p>\n<blockquote>\n<p>注意：通过声明变量和方法为私有来隐藏类中的变量和方法与信息隐藏不是同一回事。私有元素可以帮助隐藏信息，因为它们使无法从类外部直接访问项目。但是，有关私人物品的信息仍可以通过公共方法（如 getter 和 setter 方法）公开。发生这种情况时，变量的性质和用法就如同变量是公开的一样暴露。</p>\n</blockquote>\n<p>The best form of information hiding is when information is totally hidden within a module, so that it is irrelevant and invisible to users of the module. However, partial information hiding also has value. For example, if a particular feature or piece of information is only needed by a few of a class’s users, and it is accessed through separate methods so that it isn’t visible in the most common use cases, then that information is mostly hidden. Such information will create fewer dependencies than information that is visible to every user of the class.</p>\n<blockquote>\n<p>信息隐藏的最佳形式是将信息完全隐藏在模块中，从而使该信息对模块的用户无关且不可见。但是，部分信息隐藏也具有价值。例如，如果某个类的某些用户仅需要特定的功能或信息，并且可以通过单独的方法对其进行访问，以使其在最常见的用例中不可见，则该信息通常会被隐藏。与类的每个用户可见的信息相比，此类信息将创建更少的依赖项。</p>\n</blockquote>\n<h2 id=\"5-2-Information-leakage-信息泄漏\"><a href=\"#5-2-Information-leakage-信息泄漏\" class=\"headerlink\" title=\"5.2 Information leakage 信息泄漏\"></a>5.2 Information leakage 信息泄漏</h2><p>The opposite of information hiding is information leakage. Information leakage occurs when a design decision is reflected in multiple modules. This creates a dependency between the modules: any change to that design decision will require changes to all of the involved modules. If a piece of information is reflected in the interface for a module, then by definition it has been leaked; thus, simpler interfaces tend to correlate with better information hiding. However, information can be leaked even if it doesn’t appear in a module’s interface. Suppose two classes both have knowledge of a particular file format (perhaps one class reads files in that format and the other class writes them). Even if neither class exposes that information in its interface, they both depend on the file format: if the format changes, both classes will need to be modified. Back-door leakage like this is more pernicious than leakage through an interface, because it isn’t obvious.</p>\n<blockquote>\n<p>信息隐藏的反面是信息泄漏。当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了依赖关系：对该设计决策的任何更改都将要求对所有涉及的模块进行更改。如果一条信息反映在模块的界面中，则根据定义，该信息已经泄漏；因此，更简单的界面往往与更好的信息隐藏相关。但是，即使信息未出现在模块的界面中，也可能会泄漏信息。假设两个类都具有特定文件格式的知识（也许一个类读取该格式的文件，而另一个类写入它们）。即使两个类都不在其接口中公开该信息，它们都取决于文件格式：如果格式更改，则两个类都将需要修改。</p>\n</blockquote>\n<p>Information leakage is one of the most important red flags in software design. One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage. If you encounter information leakage between classes, ask yourself “How can I reorganize these classes so that this particular piece of knowledge only affects a single class?” If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class. Another possible approach is to pull the information out of all of the affected classes and create a new class that encapsulates just that information. However, this approach will be effective only if you can find a simple interface that abstracts away from the details; if the new class exposes most of the knowledge through its interface, then it won’t provide much value (you’ve simply replaced back-door leakage with leakage through an interface).</p>\n<blockquote>\n<p>信息泄漏是软件设计中最重要的危险信号之一。作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类?”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)。</p>\n</blockquote>\n<p>img Red Flag: Information Leakage img</p>\n<p>Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.</p>\n<blockquote>\n<p>当在多个地方使用相同的知识时，例如两个都理解特定类型文件格式的不同类，就会发生信息泄漏。</p>\n</blockquote>\n<h2 id=\"5-3-Temporal-decomposition-时间分解\"><a href=\"#5-3-Temporal-decomposition-时间分解\" class=\"headerlink\" title=\"5.3 Temporal decomposition 时间分解\"></a>5.3 Temporal decomposition 时间分解</h2><p>One common cause of information leakage is a design style I call temporal decomposition. In temporal decomposition, the structure of a system corresponds to the time order in which operations will occur. Consider an application that reads a file in a particular format, modifies the contents of the file, and then writes the file out again. With temporal decomposition, this application might be broken into three classes: one to read the file, another to perform the modifications, and a third to write out the new version. Both the file reading and file writing steps have knowledge about the file format, which results in information leakage. The solution is to combine the core mechanisms for reading and writing files into a single class. This class will get used during both the reading and writing phases of the application. It’s easy to fall into the trap of temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest themselves at several different times over the life of the application; as a result, temporal decomposition often results in information leakage.</p>\n<blockquote>\n<p>信息泄漏的一个常见原因是我称为时间分解的设计风格。在时间分解中，系统的结构对应于操作将发生的时间顺序。考虑一个应用程序，该应用程序以特定格式读取文件，修改文件内容，然后再次将文件写出。通过时间分解，该应用程序可以分为三类：一类用于读取文件，另一类用于执行修改，第三类用于写出新版本。文件读取和文件写入步骤都具有有关文件格式的知识，这会导致信息泄漏。解决方案是将用于读写文件的核心机制结合到一个类中。该类将在应用程序的读取和写入阶段使用。很容易陷入时间分解的陷阱，因为在编写代码时通常会想到必须执行操作的顺序。但是，大多数设计决策会在应用程序的整个生命周期中的多个不同时刻表现出来。结果，时间分解常常导致信息泄漏。</p>\n</blockquote>\n<p>Order usually does matter, so it will be reflected somewhere in the application. However, it shouldn’t be reflected in the module structure unless that structure is consistent with information hiding (perhaps the different stages use totally different information). When designing modules, focus on the knowledge that’s needed to perform each task, not the order in which tasks occur.</p>\n<blockquote>\n<p>顺序通常很重要，因此它将反映在应用程序中的某个位置。但是，除非该结构与信息隐藏保持一致（也许不同阶段使用完全不同的信息），否则不应将其反映在模块结构中。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。</p>\n</blockquote>\n<p>img Red Flag: Temporal Decomposition img</p>\n<p>In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.</p>\n<blockquote>\n<p>在时间分解中，执行顺序反映在代码结构中：在不同时间发生的操作在不同的方法或类中。如果在执行的不同点使用相同的知识，则会在多个位置对其进行编码，从而导致信息泄漏。</p>\n</blockquote>\n<h2 id=\"5-4-Example-HTTP-server-示例：HTTP-服务器\"><a href=\"#5-4-Example-HTTP-server-示例：HTTP-服务器\" class=\"headerlink\" title=\"5.4 Example: HTTP server 示例：HTTP 服务器\"></a>5.4 Example: HTTP server 示例：HTTP 服务器</h2><p>To illustrate the issues in information hiding, let’s consider the design decisions made by students implementing the HTTP protocol in a software design course. It’s useful to see both the things they did well and they areas where they had problems.</p>\n<blockquote>\n<p>为了说明信息隐藏中的问题，让我们考虑由学生在软件设计课程中实现 HTTP 协议的设计决策。看到他们做得好的事情以及遇到问题的地方都是很有用的。</p>\n</blockquote>\n<p>HTTP is a mechanism used by Web browsers to communicate with Web servers. When a user clicks on a link in a Web browser or submits a form, the browser uses HTTP to send a request over the network to a Web server. Once the server has processed the request, it sends a response back to the browser; the response normally contains a new Web page to display. The HTTP protocol specifies the format of requests and responses, both of which are represented textually. Figure 5.1 shows a sample HTTP request describing a form submission. The students in the course were asked to implement one or more classes to make it easy for Web servers to receive incoming HTTP requests and send responses.</p>\n<blockquote>\n<p>HTTP 是 Web 浏览器用来与 Web 服务器通信的机制。当用户单击 Web 浏览器中的链接或提交表单时，浏览器使用 HTTP 通过网络将请求发送到 Web 服务器。服务器处理完请求后，会将响应发送回浏览器。该响应通常包含要显示的新网页。HTTP 协议指定了请求和响应的格式，两者均以文本形式表示。图 5.1 显示了描述表单提交的 HTTP 请求示例。要求课程中的学生实施一门或多门课程，以使 Web 服务器可以轻松地接收传入的 HTTP 请求并发送响应。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00014.gif\" alt=\"\"></p>\n<p>Figure 5.1: A POST request in the HTTP protocol consists of text sent over a TCP socket. Each request contains an initial line, a collection of headers terminated by an empty line, and an optional body. The initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender. Each header line consists of a name such as Content-Length followed by its value. For this request, the body contains additional parameters (comment and priority).</p>\n<blockquote>\n<p>图 5.1：HTTP 协议中的 POST 请求包含通过 TCP 套接字发送的文本。每个请求都包含一个初始行，一个由空行终止的标头集合以及一个可选主体。初始行包含请求类型（POST 用于提交表单数据），指示操作（/注释/创建）和可选参数的 URL（photo_id 的值为 246）以及发送者使用的 HTTP 协议版本。每个标题行由一个名称（例如 Content-Length）及其后的值组成。对于此请求，正文包含其他参数（注释和优先级）。</p>\n</blockquote>\n<h2 id=\"5-5-Example-too-many-classes-示例：太多的类\"><a href=\"#5-5-Example-too-many-classes-示例：太多的类\" class=\"headerlink\" title=\"5.5 Example: too many classes 示例：太多的类\"></a>5.5 Example: too many classes 示例：太多的类</h2><p>The most common mistake made by students was to divide their code into a large number of shallow classes, which led to information leakage between the classes. One team used two different classes for receiving HTTP requests; the first class read the request from the network connection into a string, and the second class parsed the string. This is an example of a temporal decomposition (“first we read the request, then we parse it”). Information leakage occurred because an HTTP request can’t be read without parsing much of the message; for example, the Content-Length header specifies the length of the request body, so the headers must be parsed in order to compute the total request length. As a result, both classes needed to understand most of the structure of HTTP requests, and parsing code was duplicated in both classes. This approach also created extra complexity for callers, who had to invoke two methods in different classes, in a particular order, to receive a request.</p>\n<blockquote>\n<p>学生最常犯的错误是将他们的代码分成大量的浅层类，这导致了类之间的信息泄漏。一个团队使用两种不同的类来接收 HTTP 请求。第一类将来自网络连接的请求读取为字符串，第二类将字符串解析。这是时间分解的一个示例（“首先读取请求，然后解析它”）。发生信息泄漏是因为无法解析大量消息就无法读取 HTTP 请求。例如，Content-Length 标头指定了请求主体的长度，因此必须对标头进行解析才能计算总请求长度。结果，这两个类都需要了解 HTTP 请求的大多数结构，并且解析代码在两个类中都是重复的。</p>\n</blockquote>\n<p>Because the classes shared so much information, it would have been better to merge them into a single class that handles both request reading and parsing. This provides better information hiding, since it isolates all knowledge of the request format in one class, and it also provides a simpler interface to callers (just one method to invoke).</p>\n<blockquote>\n<p>由于这些类共享大量信息，因此最好将它们合并为一个同时处理请求读取和解析的类。由于它将请求格式的所有知识隔离在一个类中，因此它提供了更好的信息隐藏，并且还为调用者提供了一个更简单的接口（只是一种调用方法）。</p>\n</blockquote>\n<p>This example illustrates a general theme in software design: information hiding can often be improved by making a class slightly larger. One reason for doing this is to bring together all of the code related to a particular capability (such as parsing an HTTP request), so that the resulting class contains everything related to that capability. A second reason for increasing the size of a class is to raise the level of the interface; for example, rather than having separate methods for each of three steps of a computation, have a single method that performs the entire computation. This can result in a simpler interface. Both of these benefits apply in the example of the previous paragraph: combining the classes brings together all of the code related to parsing an HTTP request, and it replaces two externally-visible methods with one. The combined class is deeper than the original classes.</p>\n<blockquote>\n<p>此示例说明了软件设计中的一般主题：通常可以通过使类稍大一些来改善信息隐藏。这样做的一个原因是将与特定功能相关的所有代码（例如，解析 HTTP 请求）组合在一起，以便生成的类包含与该功能相关的所有内容。增加类大小的第二个原因是提高接口的级别。例如，与其为计算的三个步骤中的每一个步骤使用单独的方法，不如使用一种方法来执行整个计算。这样可以简化界面。这两个优点都适用于上一段的示例：组合类将与解析 HTTP 请求相关的所有代码组合在一起，并且用一个替换了两个外部可见的方法。</p>\n</blockquote>\n<p>Of course, it is possible to take the notion of larger classes too far (such as a single class for the entire application). Chapter 9 will discuss conditions under which it makes sense to separate code into multiple smaller classes.</p>\n<blockquote>\n<p>当然，可以将较大的类的概念考虑得太远（例如整个应用程序的单个类）。第 9 章将讨论将代码分成多个较小的类的合理条件。</p>\n</blockquote>\n<h2 id=\"5-6-Example-HTTP-parameter-handling-示例：HTTP-参数处理\"><a href=\"#5-6-Example-HTTP-parameter-handling-示例：HTTP-参数处理\" class=\"headerlink\" title=\"5.6 Example: HTTP parameter handling 示例：HTTP 参数处理\"></a>5.6 Example: HTTP parameter handling 示例：HTTP 参数处理</h2><p>After an HTTP request has been received by a server, the server needs to access some of the information from the request. The code that handles the request in Figure 5.1 might need to know the value of the photo_id parameter. Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes, in the body (comment and priority in Figure 5.1). Each parameter has a name and a value. The values of parameters use a special encoding called URL encoding; for example, in the value for comment in Figure 5.1, “+” is used to represent a space character, and “%21” is used instead of “!”. In order to process a request, the server will need the values for some of the parameters, and it will want them in unencoded form.</p>\n<blockquote>\n<p>服务器收到 HTTP 请求后，服务器需要访问该请求中的某些信息。图 5.1 中处理请求的代码可能需要知道 photo_id 参数的值。参数可以在请求的第一行中指定（图 5.1 中的 photo_id），有时也可以在正文中指定（图 5.1 中的注释和优先级）。每个参数都有一个名称和一个值。参数的值使用一种称为 URL 编码的特殊编码。例如，在图 5.1 中的注释值中，“ +”代表空格字符，“％21”代替“！”。为了处理请求，服务器将需要某些参数的值，并且希望它们采用未编码的形式。</p>\n</blockquote>\n<p>Most of the student projects made two good choices with respect to parameter handling. First, they recognized that server applications don’t care whether a parameter is specified in the header line or the body of the request, so they hid this distinction from callers and merged the parameters from both locations together. Second, they hid knowledge of URL encoding: the HTTP parser decodes parameter values before returning them to the Web server, so that the value of the comment parameter in Figure 5.1 will be returned as “What a cute baby!”, not “What+a+cute+baby%21”). In both of these cases, information hiding resulted in simpler APIs for the code using the HTTP module.</p>\n<blockquote>\n<p>关于参数处理，大多数学生项目都做出了两个不错的选择。首先，他们认识到服务器应用程序不在乎是否在标题行或请求的正文中指定了参数，因此他们对调用者隐藏了这种区别，并将两个位置的参数合并在一起。其次，他们隐藏了 URL 编码的知识：HTTP 解析器在将参数值返回到 Web 服务器之前先对其进行解码，以便图 5.1 中的 comment 参数的值将返回 “What a cute baby!”，而不是 “What+a+cute+baby%21”）。在这两种情况下，信息隐藏都使使用 HTTP 模块的代码的 API 更加简单。</p>\n</blockquote>\n<p>However, most of the students used an interface for returning parameters that was too shallow, and this resulted in lost opportunities for information hiding. Most projects used an object of type HTTPRequest to hold the parsed HTTP request, and the HTTPRequest class had a single method like the following one to return parameters:</p>\n<blockquote>\n<p>但是，大多数学生使用的界面返回的参数太浅，这导致丢失信息隐藏的机会。大多数项目使用 HTTPRequest 类型的对象来保存已解析的 HTTP 请求，并且 HTTPRequest 类具有一种类似于以下方法的单个方法来返回参数：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title\">getParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rather than returning a single parameter, the method returns a reference to the Map used internally to store all of the parameters. This method is shallow, and it exposes the internal representation used by the HTTPRequest class to store parameters. Any change to that representation will result in a change to the interface, which will require modifications to all callers. When implementations are modified, the changes often involve changes in the representation of key data structures (to improve performance, for example). Thus, it’s important to avoid exposing internal data structures as much as possible. This approach also makes more work for callers: a caller must first invoke getParams, then it must call another method to retrieve a specific parameter from the Map. Finally, callers must realize that they should not modify the Map returned by getParams, since that will affect the internal state of the HTTPRequest.</p>\n<blockquote>\n<p>该方法不是返回单个参数，而是返回内部用于存储所有参数的映射的引用。这个方法是浅层的，它公开了 HTTPRequest 类用来存储参数的内部表示。对该表示的任何更改都将导致接口的更改，这将需要对所有调用者进行修改。在修改实现时，更改通常涉及关键数据结构表示的更改(例如，为了提高性能)。因此，尽量避免暴露内部数据结构是很重要的。这种方法还为调用者提供了更多的工作:调用者必须首先调用 getParams，然后必须调用另一个方法来从映射中检索特定的参数。最后，调用者必须意识到他们不应该修改 getParams 返回的映射，因为这会影响 HTTPRequest 的内部状态。</p>\n</blockquote>\n<p>Here is a better interface for retrieving parameter values:</p>\n<blockquote>\n<p>这是一个用于检索参数值的更好的接口：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getParameter</span><span class=\"params\">(String name)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntParameter</span><span class=\"params\">(String name)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>getParameter returns a parameter value as a string. It provides a slightly deeper interface than getParams above; more importantly, it hides the internal representation of parameters. getIntParameter converts the value of a parameter from its string form in the HTTP request to an integer (e.g., the photo_id parameter in Figure 5.1). This saves the caller from having to request string-to-integer conversion separately, and hides that mechanism from the caller. Additional methods for other data types, such as getDoubleParameter, could be defined if needed. (All of these methods will throw exceptions if the desired parameter doesn’t exist, or if it can’t be converted to the requested type; the exception declarations have been omitted in the code above).</p>\n<blockquote>\n<p>getParameter 以字符串形式返回参数值。它提供了一个比上面的 getParams 更深的接口；更重要的是，它隐藏了参数的内部表示。getIntParameter 将参数的值从 HTTP 请求中的字符串形式转换为整数（例如，图 5.1 中的 photo_id 参数）。这使调用者不必单独请求字符串到整数的转换，并且对调用者隐藏了该机制。如果需要，可以定义其他数据类型的其他方法，例如 getDoubleParameter。（如果所需的参数不存在，或者无法将其转换为所请求的类型，则所有这些方法都将引发异常；上面的代码中省略了异常声明）。</p>\n</blockquote>\n<h2 id=\"5-7-Example-defaults-in-HTTP-responses-示例：HTTP-响应中的默认值\"><a href=\"#5-7-Example-defaults-in-HTTP-responses-示例：HTTP-响应中的默认值\" class=\"headerlink\" title=\"5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值\"></a>5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值</h2><p>The HTTP projects also had to provide support for generating HTTP responses. The most common mistake students made in this area was inadequate defaults. Each HTTP response must specify an HTTP protocol version; one team required callers to specify this version explicitly when creating a response object. However, the response version must correspond to that in the request object, and the request must already be passed as an argument when sending the response (it indicates where to send the response). Thus, it makes more sense for the HTTP classes to provide the response version automatically. The caller is unlikely to know what version to specify, and if the caller does specify a value, it probably results in information leakage between the HTTP library and the caller. HTTP responses also include a Date header specifying the time when the response was sent; the HTTP library should provide a sensible default for this as well.</p>\n<blockquote>\n<p>HTTP 项目还必须提供对生成 HTTP 响应的支持。学生在该领域中最常见的错误是默认值不足。每个 HTTP 响应必须指定一个 HTTP 协议版本。一个团队要求呼叫者在创建响应对象时明确指定此版本。但是，响应版本必须与请求对象中的版本相对应，并且在发送响应时必须已将请求作为参数传递（它指示将响应发送到何处）。因此，HTTP 类自动提供响应版本更为有意义。调用者不太可能知道要指定哪个版本，并且如果调用者确实指定了一个值，则可能导致 HTTP 库和调用者之间的信息泄漏。HTTP 响应还包括一个 Date 标头，用于指定发送响应的时间；HTTP 库也应该为此提供一个合理的默认值。</p>\n</blockquote>\n<p>Defaults illustrate the principle that interfaces should be designed to make the common case as simple as possible. They are also an example of partial information hiding: in the normal case, the caller need not be aware of the existence of the defaulted item. In the rare cases where a caller needs to override a default, it will have to know about the value, and it can invoke a special method to modify it.</p>\n<blockquote>\n<p>默认值说明了应该设计接口以使常见情况尽可能简单的原则。它们还是隐藏部分信息的一个示例：在正常情况下，调用者无需知道默认项的存在。在极少数情况下，调用方需要覆盖默认值，它必须知道该值，并且可以调用特殊方法来对其进行修改。</p>\n</blockquote>\n<p>Whenever possible, classes should “do the right thing” without being explicitly asked. Defaults are an example of this. The Java I/O example on page 26 illustrates this point in a negative way. Buffering in file I/O is so universally desirable that noone should ever have to ask explicitly for it, or even be aware of its existence; the I/O classes should do the right thing and provide it automatically. The best features are the ones you get without even knowing they exist.</p>\n<blockquote>\n<p>只要有可能，类就应该“做正确的事”，而无需明确要求。默认值就是一个例子。第 26 页上的 Java I/O 示例以负面方式说明了这一点。普遍希望在文件 I/O 中缓冲，以至于没有人需要明确要求它，甚至不知道它的存在。I/O 类应该做正确的事情并自动提供它。最好的功能是您甚至不知道它们存在的功能。</p>\n</blockquote>\n<p>img Red Flag: Overexposure img</p>\n<p>If the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.</p>\n<blockquote>\n<p>如果常用功能的 API 迫使用户了解很少使用的其他功能，则这会增加不需要很少使用功能的用户的认知负担。</p>\n</blockquote>\n<h2 id=\"5-8-Information-hiding-within-a-class-信息隐藏在班级中\"><a href=\"#5-8-Information-hiding-within-a-class-信息隐藏在班级中\" class=\"headerlink\" title=\"5.8 Information hiding within a class 信息隐藏在班级中\"></a>5.8 Information hiding within a class 信息隐藏在班级中</h2><p>The examples in this chapter focused on information hiding as it relates to the externally visible APIs for classes, but information hiding can also be applied at other levels in the system, such as within a class. Try to design the private methods within a class so that each method encapsulates some information or capability and hides it from the rest of the class. In addition, try to minimize the number of places where each instance variable is used. Some variables may need to be accessed widely across the class, but others may be needed in only a few places; if you can reduce the number of places where a variable is used, you will eliminate dependencies within the class and reduce its complexity.</p>\n<blockquote>\n<p>本章中的示例着重于信息隐藏，因为它与类的外部可见 API 有关，但是信息隐藏也可以应用于系统中的其他级别，例如类内。尝试在一个类中设计私有方法，以便每个方法都封装一些信息或功能，并将其隐藏在类的其余部分中。此外，请尽量减少使用每个实例变量的位置数量。有些变量可能需要在整个班级中广泛使用，但是其他变量可能只需要在少数地方使用；如果可以减少使用变量的位置的数量，则将消除类内的依赖关系并降低其复杂性。</p>\n</blockquote>\n<h2 id=\"5-9-Taking-it-too-far-走得太远\"><a href=\"#5-9-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"5.9 Taking it too far 走得太远\"></a>5.9 Taking it too far 走得太远</h2><p>Information hiding only makes sense when the information being hidden is not needed outside its module. If the information is needed outside the module, then you must not hide it. Suppose that the performance of a module is affected by certain configuration parameters, and that different uses of the module will require different settings of the parameters. In this case it is important that the parameters are exposed in the interface of the module, so that they can be turned appropriately. As a software designer, your goal should be to minimize the amount of information needed outside a module; for example, if a module can automatically adjust its configuration, that is better than exposing configuration parameters. But, it’s important to recognize which information is needed outside a module and make sure it is exposed.</p>\n<blockquote>\n<p>仅当在其模块外部不需要隐藏信息时，隐藏信息才有意义。如果模块外部需要该信息，则不得隐藏它。假设模块的性能受某些配置参数的影响，并且模块的不同用途将需要对参数进行不同的设置。在这种情况下，将参数暴露在模块的界面中很重要，以便可以对其进行适当的旋转。作为软件设计师，您的目标应该是最大程度地减少模块外部所需的信息量。例如，如果模块可以自动调整其配置，那将比公开配置参数更好。但是，重要的是要识别模块外部需要哪些信息，并确保将其公开。</p>\n</blockquote>\n<h2 id=\"5-10-Conclusion-结论\"><a href=\"#5-10-Conclusion-结论\" class=\"headerlink\" title=\"5.10 Conclusion 结论\"></a>5.10 Conclusion 结论</h2><p>Information hiding and deep modules are closely related. If a module hides a lot of information, that tends to increase the amount of functionality provided by the module while also reducing its interface. This makes the module deeper. Conversely, if a module doesn’t hide much information, then either it doesn’t have much functionality, or it has a complex interface; either way, the module is shallow.</p>\n<blockquote>\n<p>信息隐藏和深层模块密切相关。如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。相反，如果一个模块没有隐藏太多信息，则它要么功能不多，要么接口复杂。无论哪种方式，模块都是浅的。</p>\n</blockquote>\n<p>When decomposing a system into modules, try not to be influenced by the order in which operations will occur at runtime; that will lead you down the path of temporal decomposition, which will result in information leakage and shallow modules. Instead, think about the different pieces of knowledge that are needed to carry out the tasks of your application, and design each module to encapsulate one or a few of those pieces of knowledge. This will produce a clean and simple design with deep modules.</p>\n<blockquote>\n<p>将系统分解为模块时，请尽量不要受运行时操作顺序的影响。这将使您沿着时间分解的路径前进，这将导致信息泄漏和模块浅。相反，请考虑执行应用程序任务所需的不同知识，并设计每个模块以封装这些知识中的一个或几个。这将产生带有深色模块的干净简单的设计。</p>\n</blockquote>\n<p>1David Parnas, “On the Criteria to be Used in Decomposing Systems into Modules,” Communications of the ACM, December 1972.</p>\n<blockquote>\n<p>1 David Parnas，“关于将系统分解为模块的标准”，ACM 通讯，1972 年 12 月。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>信息隐藏(和泄漏)</p>","more":"<h1 id=\"第-5-章-信息隐藏-和泄漏\"><a href=\"#第-5-章-信息隐藏-和泄漏\" class=\"headerlink\" title=\"第 5 章 信息隐藏(和泄漏)\"></a>第 5 章 信息隐藏(和泄漏)</h1><blockquote>\n<p>Chapter 5 Information Hiding (and Leakage)</p>\n</blockquote>\n<p>Chapter 4 argued that modules should be deep. This chapter, and the next few that follow, discuss techniques for creating deep modules.</p>\n<blockquote>\n<p>第四章认为模块应该很深。本章及随后的其他章节讨论了创建深层模块的技术。</p>\n</blockquote>\n<h2 id=\"5-1-Information-hiding-信息隐藏\"><a href=\"#5-1-Information-hiding-信息隐藏\" class=\"headerlink\" title=\"5.1 Information hiding 信息隐藏\"></a>5.1 Information hiding 信息隐藏</h2><p>The most important technique for achieving deep modules is information hiding. This technique was first described by David Parnas1. The basic idea is that each module should encapsulate a few pieces of knowledge, which represent design decisions. The knowledge is embedded in the module’s implementation but does not appear in its interface, so it is not visible to other modules.</p>\n<blockquote>\n<p>实现深层模块最重要的技术是信息隐藏。该技术最早由 David Parnas1 描述。基本思想是每个模块应封装一些知识，这些知识代表设计决策。该知识嵌入在模块的实现中，但不会出现在其界面中，因此其他模块不可见。</p>\n</blockquote>\n<p>The information hidden within a module usually consists of details about how to implement some mechanism. Here are some examples of information that might be hidden within a module:</p>\n<blockquote>\n<p>隐藏在模块中的信息通常包含有关如何实现某种机制的详细信息。以下是一些可能隐藏在模块中的信息示例：</p>\n</blockquote>\n<ul>\n<li>How to store information in a B-tree, and how to access it efficiently.</li>\n<li>How to identify the physical disk block corresponding to each logical block within a file.</li>\n<li>How to implement the TCP network protocol.</li>\n<li>How to schedule threads on a multi-core processor.</li>\n<li>How to parse JSON documents.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>如何在 B 树中存储信息，以及如何有效地访问它。</li>\n<li>如何识别与文件中每个逻辑块相对应的物理磁盘块。</li>\n<li>如何实现 TCP 网络协议。</li>\n<li>如何在多核处理器上调度线程。</li>\n<li>如何解析 JSON 文档。</li>\n</ul>\n</blockquote>\n<p>The hidden information includes data structures and algorithms related to the mechanism. It can also include lower-level details such as the size of a page, and it can include higher-level concepts that are more abstract, such as an assumption that most files are small.</p>\n<blockquote>\n<p>隐藏的信息包括与该机制有关的数据结构和算法。它还可以包含较低级别的详细信息（例如页面大小），还可以包含更抽象的较高级别的概念，例如大多数文件较小的假设。</p>\n</blockquote>\n<p>Information hiding reduces complexity in two ways. First, it simplifies the interface to a module. The interface reflects a simpler, more abstract view of the module’s functionality and hides the details; this reduces the cognitive load on developers who use the module. For instance, a developer using a B-tree class need not worry about the ideal fanout for nodes in the tree or how to keep the tree balanced. Second, information hiding makes it easier to evolve the system. If a piece of information is hidden, there are no dependencies on that information outside the module containing the information, so a design change related to that information will affect only the one module. For example, if the TCP protocol changes (to introduce a new mechanism for congestion control, for instance), the protocol’s implementation will have to be modified, but no changes should be needed in higher-level code that uses TCP to send and receive data.</p>\n<blockquote>\n<p>信息隐藏在两个方面降低了复杂性。首先，它将接口简化为模块。接口反映了模块功能的更简单、更抽象的视图，并隐藏了细节;这减少了使用该模块的开发人员的认知负担。例如，使用 B-tree 类的开发人员不需要考虑树中节点的理想扇出，也不需要考虑如何保持树的平衡。其次，信息隐藏使系统更容易演化。如果隐藏了一段信息，那么在包含该信息的模块之外就不存在对该信息的依赖，因此与该信息相关的设计更改将只影响一个模块。例如，如果 TCP 协议发生了变化(例如，为了引入一种新的拥塞控制机制)，协议的实现就必须进行修改，但是在使用 TCP 发送和接收数据的高级代码中不需要进行任何修改。</p>\n</blockquote>\n<p>When designing a new module, you should think carefully about what information can be hidden in that module. If you can hide more information, you should also be able to simplify the module’s interface, and this makes the module deeper.</p>\n<blockquote>\n<p>设计新模块时，应仔细考虑可以在该模块中隐藏哪些信息。如果您可以隐藏更多信息，则还应该能够简化模块的界面，这会使模块更深。</p>\n</blockquote>\n<p>Note: hiding variables and methods in a class by declaring them private isn’t the same thing as information hiding. Private elements can help with information hiding, since they make it impossible for the items to be accessed directly from outside the class. However, information about the private items can still be exposed through public methods such as getter and setter methods. When this happens the nature and usage of the variables are just as exposed as if the variables were public.</p>\n<blockquote>\n<p>注意：通过声明变量和方法为私有来隐藏类中的变量和方法与信息隐藏不是同一回事。私有元素可以帮助隐藏信息，因为它们使无法从类外部直接访问项目。但是，有关私人物品的信息仍可以通过公共方法（如 getter 和 setter 方法）公开。发生这种情况时，变量的性质和用法就如同变量是公开的一样暴露。</p>\n</blockquote>\n<p>The best form of information hiding is when information is totally hidden within a module, so that it is irrelevant and invisible to users of the module. However, partial information hiding also has value. For example, if a particular feature or piece of information is only needed by a few of a class’s users, and it is accessed through separate methods so that it isn’t visible in the most common use cases, then that information is mostly hidden. Such information will create fewer dependencies than information that is visible to every user of the class.</p>\n<blockquote>\n<p>信息隐藏的最佳形式是将信息完全隐藏在模块中，从而使该信息对模块的用户无关且不可见。但是，部分信息隐藏也具有价值。例如，如果某个类的某些用户仅需要特定的功能或信息，并且可以通过单独的方法对其进行访问，以使其在最常见的用例中不可见，则该信息通常会被隐藏。与类的每个用户可见的信息相比，此类信息将创建更少的依赖项。</p>\n</blockquote>\n<h2 id=\"5-2-Information-leakage-信息泄漏\"><a href=\"#5-2-Information-leakage-信息泄漏\" class=\"headerlink\" title=\"5.2 Information leakage 信息泄漏\"></a>5.2 Information leakage 信息泄漏</h2><p>The opposite of information hiding is information leakage. Information leakage occurs when a design decision is reflected in multiple modules. This creates a dependency between the modules: any change to that design decision will require changes to all of the involved modules. If a piece of information is reflected in the interface for a module, then by definition it has been leaked; thus, simpler interfaces tend to correlate with better information hiding. However, information can be leaked even if it doesn’t appear in a module’s interface. Suppose two classes both have knowledge of a particular file format (perhaps one class reads files in that format and the other class writes them). Even if neither class exposes that information in its interface, they both depend on the file format: if the format changes, both classes will need to be modified. Back-door leakage like this is more pernicious than leakage through an interface, because it isn’t obvious.</p>\n<blockquote>\n<p>信息隐藏的反面是信息泄漏。当一个设计决策反映在多个模块中时，就会发生信息泄漏。这在模块之间创建了依赖关系：对该设计决策的任何更改都将要求对所有涉及的模块进行更改。如果一条信息反映在模块的界面中，则根据定义，该信息已经泄漏；因此，更简单的界面往往与更好的信息隐藏相关。但是，即使信息未出现在模块的界面中，也可能会泄漏信息。假设两个类都具有特定文件格式的知识（也许一个类读取该格式的文件，而另一个类写入它们）。即使两个类都不在其接口中公开该信息，它们都取决于文件格式：如果格式更改，则两个类都将需要修改。</p>\n</blockquote>\n<p>Information leakage is one of the most important red flags in software design. One of the best skills you can learn as a software designer is a high level of sensitivity to information leakage. If you encounter information leakage between classes, ask yourself “How can I reorganize these classes so that this particular piece of knowledge only affects a single class?” If the affected classes are relatively small and closely tied to the leaked information, it may make sense to merge them into a single class. Another possible approach is to pull the information out of all of the affected classes and create a new class that encapsulates just that information. However, this approach will be effective only if you can find a simple interface that abstracts away from the details; if the new class exposes most of the knowledge through its interface, then it won’t provide much value (you’ve simply replaced back-door leakage with leakage through an interface).</p>\n<blockquote>\n<p>信息泄漏是软件设计中最重要的危险信号之一。作为一个软件设计师，你能学到的最好的技能之一就是对信息泄露的高度敏感性。如果您在类之间遇到信息泄漏，请自问“我如何才能重新组织这些类，使这些特定的知识只影响一个类?”如果受影响的类相对较小，并且与泄漏的信息紧密相关，那么将它们合并到一个类中是有意义的。另一种可能的方法是从所有受影响的类中提取信息，并创建一个只封装这些信息的新类。但是，这种方法只有在您能够找到一个从细节中抽象出来的简单接口时才有效;如果新类通过其接口公开了大部分知识，那么它就不会提供太多的价值(您只是用通过接口的泄漏替换了后门泄漏)。</p>\n</blockquote>\n<p>img Red Flag: Information Leakage img</p>\n<p>Information leakage occurs when the same knowledge is used in multiple places, such as two different classes that both understand the format of a particular type of file.</p>\n<blockquote>\n<p>当在多个地方使用相同的知识时，例如两个都理解特定类型文件格式的不同类，就会发生信息泄漏。</p>\n</blockquote>\n<h2 id=\"5-3-Temporal-decomposition-时间分解\"><a href=\"#5-3-Temporal-decomposition-时间分解\" class=\"headerlink\" title=\"5.3 Temporal decomposition 时间分解\"></a>5.3 Temporal decomposition 时间分解</h2><p>One common cause of information leakage is a design style I call temporal decomposition. In temporal decomposition, the structure of a system corresponds to the time order in which operations will occur. Consider an application that reads a file in a particular format, modifies the contents of the file, and then writes the file out again. With temporal decomposition, this application might be broken into three classes: one to read the file, another to perform the modifications, and a third to write out the new version. Both the file reading and file writing steps have knowledge about the file format, which results in information leakage. The solution is to combine the core mechanisms for reading and writing files into a single class. This class will get used during both the reading and writing phases of the application. It’s easy to fall into the trap of temporal decomposition, because the order in which operations must occur is often on your mind when you code. However, most design decisions manifest themselves at several different times over the life of the application; as a result, temporal decomposition often results in information leakage.</p>\n<blockquote>\n<p>信息泄漏的一个常见原因是我称为时间分解的设计风格。在时间分解中，系统的结构对应于操作将发生的时间顺序。考虑一个应用程序，该应用程序以特定格式读取文件，修改文件内容，然后再次将文件写出。通过时间分解，该应用程序可以分为三类：一类用于读取文件，另一类用于执行修改，第三类用于写出新版本。文件读取和文件写入步骤都具有有关文件格式的知识，这会导致信息泄漏。解决方案是将用于读写文件的核心机制结合到一个类中。该类将在应用程序的读取和写入阶段使用。很容易陷入时间分解的陷阱，因为在编写代码时通常会想到必须执行操作的顺序。但是，大多数设计决策会在应用程序的整个生命周期中的多个不同时刻表现出来。结果，时间分解常常导致信息泄漏。</p>\n</blockquote>\n<p>Order usually does matter, so it will be reflected somewhere in the application. However, it shouldn’t be reflected in the module structure unless that structure is consistent with information hiding (perhaps the different stages use totally different information). When designing modules, focus on the knowledge that’s needed to perform each task, not the order in which tasks occur.</p>\n<blockquote>\n<p>顺序通常很重要，因此它将反映在应用程序中的某个位置。但是，除非该结构与信息隐藏保持一致（也许不同阶段使用完全不同的信息），否则不应将其反映在模块结构中。在设计模块时，应专注于执行每个任务所需的知识，而不是任务发生的顺序。</p>\n</blockquote>\n<p>img Red Flag: Temporal Decomposition img</p>\n<p>In temporal decomposition, execution order is reflected in the code structure: operations that happen at different times are in different methods or classes. If the same knowledge is used at different points in execution, it gets encoded in multiple places, resulting in information leakage.</p>\n<blockquote>\n<p>在时间分解中，执行顺序反映在代码结构中：在不同时间发生的操作在不同的方法或类中。如果在执行的不同点使用相同的知识，则会在多个位置对其进行编码，从而导致信息泄漏。</p>\n</blockquote>\n<h2 id=\"5-4-Example-HTTP-server-示例：HTTP-服务器\"><a href=\"#5-4-Example-HTTP-server-示例：HTTP-服务器\" class=\"headerlink\" title=\"5.4 Example: HTTP server 示例：HTTP 服务器\"></a>5.4 Example: HTTP server 示例：HTTP 服务器</h2><p>To illustrate the issues in information hiding, let’s consider the design decisions made by students implementing the HTTP protocol in a software design course. It’s useful to see both the things they did well and they areas where they had problems.</p>\n<blockquote>\n<p>为了说明信息隐藏中的问题，让我们考虑由学生在软件设计课程中实现 HTTP 协议的设计决策。看到他们做得好的事情以及遇到问题的地方都是很有用的。</p>\n</blockquote>\n<p>HTTP is a mechanism used by Web browsers to communicate with Web servers. When a user clicks on a link in a Web browser or submits a form, the browser uses HTTP to send a request over the network to a Web server. Once the server has processed the request, it sends a response back to the browser; the response normally contains a new Web page to display. The HTTP protocol specifies the format of requests and responses, both of which are represented textually. Figure 5.1 shows a sample HTTP request describing a form submission. The students in the course were asked to implement one or more classes to make it easy for Web servers to receive incoming HTTP requests and send responses.</p>\n<blockquote>\n<p>HTTP 是 Web 浏览器用来与 Web 服务器通信的机制。当用户单击 Web 浏览器中的链接或提交表单时，浏览器使用 HTTP 通过网络将请求发送到 Web 服务器。服务器处理完请求后，会将响应发送回浏览器。该响应通常包含要显示的新网页。HTTP 协议指定了请求和响应的格式，两者均以文本形式表示。图 5.1 显示了描述表单提交的 HTTP 请求示例。要求课程中的学生实施一门或多门课程，以使 Web 服务器可以轻松地接收传入的 HTTP 请求并发送响应。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00014.gif\" alt=\"\"></p>\n<p>Figure 5.1: A POST request in the HTTP protocol consists of text sent over a TCP socket. Each request contains an initial line, a collection of headers terminated by an empty line, and an optional body. The initial line contains the request type (POST is used for submitting form data), a URL indicating an operation (/comments/create) and optional parameters (photo_id has the value 246), and the HTTP protocol version used by the sender. Each header line consists of a name such as Content-Length followed by its value. For this request, the body contains additional parameters (comment and priority).</p>\n<blockquote>\n<p>图 5.1：HTTP 协议中的 POST 请求包含通过 TCP 套接字发送的文本。每个请求都包含一个初始行，一个由空行终止的标头集合以及一个可选主体。初始行包含请求类型（POST 用于提交表单数据），指示操作（/注释/创建）和可选参数的 URL（photo_id 的值为 246）以及发送者使用的 HTTP 协议版本。每个标题行由一个名称（例如 Content-Length）及其后的值组成。对于此请求，正文包含其他参数（注释和优先级）。</p>\n</blockquote>\n<h2 id=\"5-5-Example-too-many-classes-示例：太多的类\"><a href=\"#5-5-Example-too-many-classes-示例：太多的类\" class=\"headerlink\" title=\"5.5 Example: too many classes 示例：太多的类\"></a>5.5 Example: too many classes 示例：太多的类</h2><p>The most common mistake made by students was to divide their code into a large number of shallow classes, which led to information leakage between the classes. One team used two different classes for receiving HTTP requests; the first class read the request from the network connection into a string, and the second class parsed the string. This is an example of a temporal decomposition (“first we read the request, then we parse it”). Information leakage occurred because an HTTP request can’t be read without parsing much of the message; for example, the Content-Length header specifies the length of the request body, so the headers must be parsed in order to compute the total request length. As a result, both classes needed to understand most of the structure of HTTP requests, and parsing code was duplicated in both classes. This approach also created extra complexity for callers, who had to invoke two methods in different classes, in a particular order, to receive a request.</p>\n<blockquote>\n<p>学生最常犯的错误是将他们的代码分成大量的浅层类，这导致了类之间的信息泄漏。一个团队使用两种不同的类来接收 HTTP 请求。第一类将来自网络连接的请求读取为字符串，第二类将字符串解析。这是时间分解的一个示例（“首先读取请求，然后解析它”）。发生信息泄漏是因为无法解析大量消息就无法读取 HTTP 请求。例如，Content-Length 标头指定了请求主体的长度，因此必须对标头进行解析才能计算总请求长度。结果，这两个类都需要了解 HTTP 请求的大多数结构，并且解析代码在两个类中都是重复的。</p>\n</blockquote>\n<p>Because the classes shared so much information, it would have been better to merge them into a single class that handles both request reading and parsing. This provides better information hiding, since it isolates all knowledge of the request format in one class, and it also provides a simpler interface to callers (just one method to invoke).</p>\n<blockquote>\n<p>由于这些类共享大量信息，因此最好将它们合并为一个同时处理请求读取和解析的类。由于它将请求格式的所有知识隔离在一个类中，因此它提供了更好的信息隐藏，并且还为调用者提供了一个更简单的接口（只是一种调用方法）。</p>\n</blockquote>\n<p>This example illustrates a general theme in software design: information hiding can often be improved by making a class slightly larger. One reason for doing this is to bring together all of the code related to a particular capability (such as parsing an HTTP request), so that the resulting class contains everything related to that capability. A second reason for increasing the size of a class is to raise the level of the interface; for example, rather than having separate methods for each of three steps of a computation, have a single method that performs the entire computation. This can result in a simpler interface. Both of these benefits apply in the example of the previous paragraph: combining the classes brings together all of the code related to parsing an HTTP request, and it replaces two externally-visible methods with one. The combined class is deeper than the original classes.</p>\n<blockquote>\n<p>此示例说明了软件设计中的一般主题：通常可以通过使类稍大一些来改善信息隐藏。这样做的一个原因是将与特定功能相关的所有代码（例如，解析 HTTP 请求）组合在一起，以便生成的类包含与该功能相关的所有内容。增加类大小的第二个原因是提高接口的级别。例如，与其为计算的三个步骤中的每一个步骤使用单独的方法，不如使用一种方法来执行整个计算。这样可以简化界面。这两个优点都适用于上一段的示例：组合类将与解析 HTTP 请求相关的所有代码组合在一起，并且用一个替换了两个外部可见的方法。</p>\n</blockquote>\n<p>Of course, it is possible to take the notion of larger classes too far (such as a single class for the entire application). Chapter 9 will discuss conditions under which it makes sense to separate code into multiple smaller classes.</p>\n<blockquote>\n<p>当然，可以将较大的类的概念考虑得太远（例如整个应用程序的单个类）。第 9 章将讨论将代码分成多个较小的类的合理条件。</p>\n</blockquote>\n<h2 id=\"5-6-Example-HTTP-parameter-handling-示例：HTTP-参数处理\"><a href=\"#5-6-Example-HTTP-parameter-handling-示例：HTTP-参数处理\" class=\"headerlink\" title=\"5.6 Example: HTTP parameter handling 示例：HTTP 参数处理\"></a>5.6 Example: HTTP parameter handling 示例：HTTP 参数处理</h2><p>After an HTTP request has been received by a server, the server needs to access some of the information from the request. The code that handles the request in Figure 5.1 might need to know the value of the photo_id parameter. Parameters can be specified in the first line of the request (photo_id in Figure 5.1) or, sometimes, in the body (comment and priority in Figure 5.1). Each parameter has a name and a value. The values of parameters use a special encoding called URL encoding; for example, in the value for comment in Figure 5.1, “+” is used to represent a space character, and “%21” is used instead of “!”. In order to process a request, the server will need the values for some of the parameters, and it will want them in unencoded form.</p>\n<blockquote>\n<p>服务器收到 HTTP 请求后，服务器需要访问该请求中的某些信息。图 5.1 中处理请求的代码可能需要知道 photo_id 参数的值。参数可以在请求的第一行中指定（图 5.1 中的 photo_id），有时也可以在正文中指定（图 5.1 中的注释和优先级）。每个参数都有一个名称和一个值。参数的值使用一种称为 URL 编码的特殊编码。例如，在图 5.1 中的注释值中，“ +”代表空格字符，“％21”代替“！”。为了处理请求，服务器将需要某些参数的值，并且希望它们采用未编码的形式。</p>\n</blockquote>\n<p>Most of the student projects made two good choices with respect to parameter handling. First, they recognized that server applications don’t care whether a parameter is specified in the header line or the body of the request, so they hid this distinction from callers and merged the parameters from both locations together. Second, they hid knowledge of URL encoding: the HTTP parser decodes parameter values before returning them to the Web server, so that the value of the comment parameter in Figure 5.1 will be returned as “What a cute baby!”, not “What+a+cute+baby%21”). In both of these cases, information hiding resulted in simpler APIs for the code using the HTTP module.</p>\n<blockquote>\n<p>关于参数处理，大多数学生项目都做出了两个不错的选择。首先，他们认识到服务器应用程序不在乎是否在标题行或请求的正文中指定了参数，因此他们对调用者隐藏了这种区别，并将两个位置的参数合并在一起。其次，他们隐藏了 URL 编码的知识：HTTP 解析器在将参数值返回到 Web 服务器之前先对其进行解码，以便图 5.1 中的 comment 参数的值将返回 “What a cute baby!”，而不是 “What+a+cute+baby%21”）。在这两种情况下，信息隐藏都使使用 HTTP 模块的代码的 API 更加简单。</p>\n</blockquote>\n<p>However, most of the students used an interface for returning parameters that was too shallow, and this resulted in lost opportunities for information hiding. Most projects used an object of type HTTPRequest to hold the parsed HTTP request, and the HTTPRequest class had a single method like the following one to return parameters:</p>\n<blockquote>\n<p>但是，大多数学生使用的界面返回的参数太浅，这导致丢失信息隐藏的机会。大多数项目使用 HTTPRequest 类型的对象来保存已解析的 HTTP 请求，并且 HTTPRequest 类具有一种类似于以下方法的单个方法来返回参数：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, String&gt; <span class=\"title\">getParams</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.params;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rather than returning a single parameter, the method returns a reference to the Map used internally to store all of the parameters. This method is shallow, and it exposes the internal representation used by the HTTPRequest class to store parameters. Any change to that representation will result in a change to the interface, which will require modifications to all callers. When implementations are modified, the changes often involve changes in the representation of key data structures (to improve performance, for example). Thus, it’s important to avoid exposing internal data structures as much as possible. This approach also makes more work for callers: a caller must first invoke getParams, then it must call another method to retrieve a specific parameter from the Map. Finally, callers must realize that they should not modify the Map returned by getParams, since that will affect the internal state of the HTTPRequest.</p>\n<blockquote>\n<p>该方法不是返回单个参数，而是返回内部用于存储所有参数的映射的引用。这个方法是浅层的，它公开了 HTTPRequest 类用来存储参数的内部表示。对该表示的任何更改都将导致接口的更改，这将需要对所有调用者进行修改。在修改实现时，更改通常涉及关键数据结构表示的更改(例如，为了提高性能)。因此，尽量避免暴露内部数据结构是很重要的。这种方法还为调用者提供了更多的工作:调用者必须首先调用 getParams，然后必须调用另一个方法来从映射中检索特定的参数。最后，调用者必须意识到他们不应该修改 getParams 返回的映射，因为这会影响 HTTPRequest 的内部状态。</p>\n</blockquote>\n<p>Here is a better interface for retrieving parameter values:</p>\n<blockquote>\n<p>这是一个用于检索参数值的更好的接口：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getParameter</span><span class=\"params\">(String name)</span> </span>&#123; ... &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getIntParameter</span><span class=\"params\">(String name)</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>getParameter returns a parameter value as a string. It provides a slightly deeper interface than getParams above; more importantly, it hides the internal representation of parameters. getIntParameter converts the value of a parameter from its string form in the HTTP request to an integer (e.g., the photo_id parameter in Figure 5.1). This saves the caller from having to request string-to-integer conversion separately, and hides that mechanism from the caller. Additional methods for other data types, such as getDoubleParameter, could be defined if needed. (All of these methods will throw exceptions if the desired parameter doesn’t exist, or if it can’t be converted to the requested type; the exception declarations have been omitted in the code above).</p>\n<blockquote>\n<p>getParameter 以字符串形式返回参数值。它提供了一个比上面的 getParams 更深的接口；更重要的是，它隐藏了参数的内部表示。getIntParameter 将参数的值从 HTTP 请求中的字符串形式转换为整数（例如，图 5.1 中的 photo_id 参数）。这使调用者不必单独请求字符串到整数的转换，并且对调用者隐藏了该机制。如果需要，可以定义其他数据类型的其他方法，例如 getDoubleParameter。（如果所需的参数不存在，或者无法将其转换为所请求的类型，则所有这些方法都将引发异常；上面的代码中省略了异常声明）。</p>\n</blockquote>\n<h2 id=\"5-7-Example-defaults-in-HTTP-responses-示例：HTTP-响应中的默认值\"><a href=\"#5-7-Example-defaults-in-HTTP-responses-示例：HTTP-响应中的默认值\" class=\"headerlink\" title=\"5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值\"></a>5.7 Example: defaults in HTTP responses 示例：HTTP 响应中的默认值</h2><p>The HTTP projects also had to provide support for generating HTTP responses. The most common mistake students made in this area was inadequate defaults. Each HTTP response must specify an HTTP protocol version; one team required callers to specify this version explicitly when creating a response object. However, the response version must correspond to that in the request object, and the request must already be passed as an argument when sending the response (it indicates where to send the response). Thus, it makes more sense for the HTTP classes to provide the response version automatically. The caller is unlikely to know what version to specify, and if the caller does specify a value, it probably results in information leakage between the HTTP library and the caller. HTTP responses also include a Date header specifying the time when the response was sent; the HTTP library should provide a sensible default for this as well.</p>\n<blockquote>\n<p>HTTP 项目还必须提供对生成 HTTP 响应的支持。学生在该领域中最常见的错误是默认值不足。每个 HTTP 响应必须指定一个 HTTP 协议版本。一个团队要求呼叫者在创建响应对象时明确指定此版本。但是，响应版本必须与请求对象中的版本相对应，并且在发送响应时必须已将请求作为参数传递（它指示将响应发送到何处）。因此，HTTP 类自动提供响应版本更为有意义。调用者不太可能知道要指定哪个版本，并且如果调用者确实指定了一个值，则可能导致 HTTP 库和调用者之间的信息泄漏。HTTP 响应还包括一个 Date 标头，用于指定发送响应的时间；HTTP 库也应该为此提供一个合理的默认值。</p>\n</blockquote>\n<p>Defaults illustrate the principle that interfaces should be designed to make the common case as simple as possible. They are also an example of partial information hiding: in the normal case, the caller need not be aware of the existence of the defaulted item. In the rare cases where a caller needs to override a default, it will have to know about the value, and it can invoke a special method to modify it.</p>\n<blockquote>\n<p>默认值说明了应该设计接口以使常见情况尽可能简单的原则。它们还是隐藏部分信息的一个示例：在正常情况下，调用者无需知道默认项的存在。在极少数情况下，调用方需要覆盖默认值，它必须知道该值，并且可以调用特殊方法来对其进行修改。</p>\n</blockquote>\n<p>Whenever possible, classes should “do the right thing” without being explicitly asked. Defaults are an example of this. The Java I/O example on page 26 illustrates this point in a negative way. Buffering in file I/O is so universally desirable that noone should ever have to ask explicitly for it, or even be aware of its existence; the I/O classes should do the right thing and provide it automatically. The best features are the ones you get without even knowing they exist.</p>\n<blockquote>\n<p>只要有可能，类就应该“做正确的事”，而无需明确要求。默认值就是一个例子。第 26 页上的 Java I/O 示例以负面方式说明了这一点。普遍希望在文件 I/O 中缓冲，以至于没有人需要明确要求它，甚至不知道它的存在。I/O 类应该做正确的事情并自动提供它。最好的功能是您甚至不知道它们存在的功能。</p>\n</blockquote>\n<p>img Red Flag: Overexposure img</p>\n<p>If the API for a commonly used feature forces users to learn about other features that are rarely used, this increases the cognitive load on users who don’t need the rarely used features.</p>\n<blockquote>\n<p>如果常用功能的 API 迫使用户了解很少使用的其他功能，则这会增加不需要很少使用功能的用户的认知负担。</p>\n</blockquote>\n<h2 id=\"5-8-Information-hiding-within-a-class-信息隐藏在班级中\"><a href=\"#5-8-Information-hiding-within-a-class-信息隐藏在班级中\" class=\"headerlink\" title=\"5.8 Information hiding within a class 信息隐藏在班级中\"></a>5.8 Information hiding within a class 信息隐藏在班级中</h2><p>The examples in this chapter focused on information hiding as it relates to the externally visible APIs for classes, but information hiding can also be applied at other levels in the system, such as within a class. Try to design the private methods within a class so that each method encapsulates some information or capability and hides it from the rest of the class. In addition, try to minimize the number of places where each instance variable is used. Some variables may need to be accessed widely across the class, but others may be needed in only a few places; if you can reduce the number of places where a variable is used, you will eliminate dependencies within the class and reduce its complexity.</p>\n<blockquote>\n<p>本章中的示例着重于信息隐藏，因为它与类的外部可见 API 有关，但是信息隐藏也可以应用于系统中的其他级别，例如类内。尝试在一个类中设计私有方法，以便每个方法都封装一些信息或功能，并将其隐藏在类的其余部分中。此外，请尽量减少使用每个实例变量的位置数量。有些变量可能需要在整个班级中广泛使用，但是其他变量可能只需要在少数地方使用；如果可以减少使用变量的位置的数量，则将消除类内的依赖关系并降低其复杂性。</p>\n</blockquote>\n<h2 id=\"5-9-Taking-it-too-far-走得太远\"><a href=\"#5-9-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"5.9 Taking it too far 走得太远\"></a>5.9 Taking it too far 走得太远</h2><p>Information hiding only makes sense when the information being hidden is not needed outside its module. If the information is needed outside the module, then you must not hide it. Suppose that the performance of a module is affected by certain configuration parameters, and that different uses of the module will require different settings of the parameters. In this case it is important that the parameters are exposed in the interface of the module, so that they can be turned appropriately. As a software designer, your goal should be to minimize the amount of information needed outside a module; for example, if a module can automatically adjust its configuration, that is better than exposing configuration parameters. But, it’s important to recognize which information is needed outside a module and make sure it is exposed.</p>\n<blockquote>\n<p>仅当在其模块外部不需要隐藏信息时，隐藏信息才有意义。如果模块外部需要该信息，则不得隐藏它。假设模块的性能受某些配置参数的影响，并且模块的不同用途将需要对参数进行不同的设置。在这种情况下，将参数暴露在模块的界面中很重要，以便可以对其进行适当的旋转。作为软件设计师，您的目标应该是最大程度地减少模块外部所需的信息量。例如，如果模块可以自动调整其配置，那将比公开配置参数更好。但是，重要的是要识别模块外部需要哪些信息，并确保将其公开。</p>\n</blockquote>\n<h2 id=\"5-10-Conclusion-结论\"><a href=\"#5-10-Conclusion-结论\" class=\"headerlink\" title=\"5.10 Conclusion 结论\"></a>5.10 Conclusion 结论</h2><p>Information hiding and deep modules are closely related. If a module hides a lot of information, that tends to increase the amount of functionality provided by the module while also reducing its interface. This makes the module deeper. Conversely, if a module doesn’t hide much information, then either it doesn’t have much functionality, or it has a complex interface; either way, the module is shallow.</p>\n<blockquote>\n<p>信息隐藏和深层模块密切相关。如果模块隐藏了很多信息，则往往会增加模块提供的功能，同时还会减少其接口。这使模块更深。相反，如果一个模块没有隐藏太多信息，则它要么功能不多，要么接口复杂。无论哪种方式，模块都是浅的。</p>\n</blockquote>\n<p>When decomposing a system into modules, try not to be influenced by the order in which operations will occur at runtime; that will lead you down the path of temporal decomposition, which will result in information leakage and shallow modules. Instead, think about the different pieces of knowledge that are needed to carry out the tasks of your application, and design each module to encapsulate one or a few of those pieces of knowledge. This will produce a clean and simple design with deep modules.</p>\n<blockquote>\n<p>将系统分解为模块时，请尽量不要受运行时操作顺序的影响。这将使您沿着时间分解的路径前进，这将导致信息泄漏和模块浅。相反，请考虑执行应用程序任务所需的不同知识，并设计每个模块以封装这些知识中的一个或几个。这将产生带有深色模块的干净简单的设计。</p>\n</blockquote>\n<p>1David Parnas, “On the Criteria to be Used in Decomposing Systems into Modules,” Communications of the ACM, December 1972.</p>\n<blockquote>\n<p>1 David Parnas，“关于将系统分解为模块的标准”，ACM 通讯，1972 年 12 月。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch20","date":"2021-02-19T16:00:00.000Z","_content":"设计性能\n<!-- more -->\n# 第 20 章 设计性能\n\n> Chapter 20 Designing for Performance\n\nUp until this point, the discussion of software design has focused on complexity; the goal has been to make software as simple and understandable as possible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a system’s design, but it usually makes systems faster.\n\n> 到目前为止，关于软件设计的讨论都集中在复杂性上。目标是使软件尽可能简单易懂。但是，如果您在需要快速的系统上工作，该怎么办？性能方面的考虑应如何影响设计过程？本章讨论如何在不牺牲简洁设计的情况下实现高性能。最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。\n\n## 20.1 How to think about performance 如何考虑性能\n\nThe first question to address is “how much should you worry about performance during the normal development process?” If you try to optimize every statement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the “optimizations” won’t actually help performance. On the other hand, if you completely ignore performance issues, it’s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5–10x slower than it needs to be. In this “death by a thousand cuts” scenario it’s hard to come back later and improve the performance, because there is no single improvement that will have much impact.\n\n> 要解决的第一个问题是“您在正常的开发过程中应该为性能多少担心？” 如果您尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果您完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。\n\nThe best approach is something between these extremes, where you use basic knowledge of performance to choose design alternatives that are “naturally efficient” yet also clean and simple. The key is to develop an awareness of which operations are fundamentally expensive. Here are a few examples of operations that are relatively expensive today:\n\n> 最好的方法是介于这两种极端之间，在这种极端情况下，您可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：\n\n- Network communication: even within a datacenter, a round-trip message exchange can take 10–50 µs, which is tens of thousands of instruction times. Wide-area round-trips can take 10–100 ms.\n- I/O to secondary storage: disk I/O operations typically take 5–10 ms, which is millions of instruction times. Flash storage takes 10–100 µs. New emerging nonvolatile memories may be as fast as 1 µs, but this is still around 2000 instruction times.\n- Dynamic memory allocation (malloc in C, new in C++ or Java) typically involves significant overhead for allocation, freeing, and garbage collection.\n- Cache misses: fetching data from DRAM into an on-chip processor cache takes a few hundred instruction times; in many programs, overall performance is determined as much by cache misses as by computational costs.\n\n---\n\n> - 网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。\n> - I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。\n> - 动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。\n> - 高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。\n\nThe best way to learn which things are expensive is to run micro-benchmarks (small programs that measure the cost of a single operation in isolation). In the RAMCloud project, we created a simple program that provides a framework for microbenchmarks. It took a few days to create the framework, but the framework makes it possible to add new micro-benchmarks in five or ten minutes. This has allowed us to accumulate dozens of micro-benchmarks. We use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.\n\n> 了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。\n\nOnce you have a general sense for what is expensive and what is cheap, you can use that information to choose cheap operations whenever possible. In many cases, a more efficient approach will be just as simple as a slower approach. For example, when storing a large collection of objects that will be looked up using a key value, you could use either a hash table or an ordered map. Both are commonly available in library packages, and both are simple and clean to use. However, hash tables can easily be 5–10x faster. Thus, you should always use a hash table unless you need the ordering properties provided by the map.\n\n> 一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要地图提供的排序属性，否则应始终使用哈希表。\n\nAs another example, consider allocating an array of structures in a language such as C or C++. There are two ways you can do this. One way is for the array to hold pointers to structures, in which case you must first allocate space for the array, then allocate space for each individual structure. It is much more efficient to store the structures in the array itself, so you only allocate one large block for everything.\n\n> 作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，您必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此您只为所有内容分配一个大块。\n\nIf the only way to improve efficiency is by adding complexity, then the choice is more difficult. If the more efficient design adds only a small amount of complexity, and if the complexity is hidden, so it doesn’t affect any interfaces, then it may be worthwhile (but beware: complexity is incremental). If the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem. However, if you have clear evidence that performance will be important in a particular situation, then you might as well implement the faster approach immediately.\n\n> 如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果您有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。\n\nIn the RAMCloud project one of our overall goals was to provide the lowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking, which allowed RAMCloud to bypass the kernel and communicate directly with the network interface controller to send and receive packets. We made this decision even though it added complexity, because we knew from prior measurements that kernel-based networking would be too slow to meet our needs. In most of the rest of the RAMCloud system we were able to design for simplicity; getting this one big issue “right” made many other things easier.\n\n> 在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。\n\nIn general, simpler code tends to run faster than complex code. If you have defined away special cases and exceptions, then no code is needed to check for those cases and the system runs faster. Deep classes are more efficient than shallow ones, because they get more work done for each method call. Shallow classes result in more layer crossings, and each layer crossing adds overhead.\n\n> 通常，较简单的代码往往比复杂的代码运行更快。如果您定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。\n\n## 20.2 Measure before modifying 修改前的度量\n\nBut suppose that your system is still too slow, even though you have designed it as described above. It’s tempting to rush off and start making performance tweaks, based on your intuitions about what is slow. Don’t do this! Programmers’ intuitions about performance are unreliable. This is true even for experienced developers. If you start making changes based on intuition, you’ll waste time on things that don’t actually improve performance, and you’ll probably make the system more complicated in the process.\n\n> 但是，即使您如上所述进行设计，也请假设您的系统仍然太慢。根据您对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果您开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。\n\nBefore making any changes, measure the system’s existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact. It isn’t sufficient just to measure the top-level system performance. This may tell you that the system is too slow, but it won’t tell you why. You’ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement. The second purpose of the measurements is to provide a baseline, so that you can re-measure performance after making your changes to ensure that performance actually improved. If the changes didn’t make a measurable difference in performance, then back them out (unless they made the system simpler). There’s no point in retaining complexity unless it provides a significant speedup.\n\n> 进行任何更改之前，请测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。您需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及您有改进想法的地方。测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。\n\n## 20.3 Design around the critical path 围绕关键路径进行设计\n\nAt this point, let’s assume that you have carefully analyzed performance and have identified a piece of code that is slow enough to affect the overall system performance. The best way to improve its performance is with a “fundamental” change, such as introducing a cache, or using a different algorithmic approach (balanced tree vs. list, for instance). Our decision to bypass the kernel for network communication in RAMCloud is an example of a fundamental fix. If you can identify a fundamental fix, then you can implement it using the design techniques discussed in previous chapters.\n\n> 在这一点上，我们假设您已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果您可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。\n\nUnfortunately, situations will sometimes arise where there isn’t a fundamental fix. This brings us to the core issue for this chapter, which is how to redesign an existing piece of code so that it runs faster. This should be your last resort, and it shouldn’t happen often, but there are cases where it can make a big difference. The key idea is to design the code around the critical path.\n\n> 不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是您的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。\n\nStart off by asking yourself what is the smallest amount of code that must be executed to carry out the desired task in the common case. Disregard any existing code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case. The current code is probably cluttered with special cases; ignore them in this exercise. The current code might pass through several method calls on the critical path; imagine instead that you could put all the relevant code in a single method. The current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path. For example, it may make sense to combine multiple variables into a single value. Assume that you could completely redesign the system in order to minimize the code that must be executed for the critical path. Let’s call this code “the ideal.”\n\n> 首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下您正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，您可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设您可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。\n\nThe ideal code probably clashes with your existing class structure, and it may not be practical, but it provides a good target: this represents the simplest and fastest that the code can ever be. The next step is to look for a new design that comes as close as possible to the ideal while still having a clean structure. You can apply all of the design ideas from previous chapters of this book, but with the additional constraint of keeping the ideal code (mostly) intact. You may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it’s OK to introduce an extra method call to a general-purpose hash table class. In my experience it’s almost always possible to find a design that is clean and simple, yet comes very close to the ideal.\n\n> 理想的代码可能会与您现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。您可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。您可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。\n\nOne of the most important things that happens in this process is to remove special cases from the critical path. When code is slow, it’s often because it must handle a variety of situations, and the code gets structured to simplify the handling of all the different cases. Each special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally, there will be a single if statement at the beginning, which detects all special cases with one test. In the normal case, only this one test will need to be made, after which the the critical path can be executed with no additional tests for special cases. If the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it. Performance isn’t as important for special cases, so you can structure the special-case code for simplicity rather than performance.\n\n> 在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此您可以为简化而不是性能来构造特殊情况的代码。\n\n## 20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区\n\nLet’s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.\n\n> 让我们考虑一个示例，其中 RAMCloud 存储系统的 Buffer 类经过优化，以使大多数常见操作的速度提高约 2 倍。\n\nRAMCloud uses Buffer objects to manage variable-length arrays of memory, such as request and response messages for remote procedure calls. Buffers are designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguous chunks of memory, as shown in Figure 20.1. A Buffer is created by appending chunks of data. Each chunk is either external or internal. If a chunk is external, its storage is owned by the caller; the Buffer keeps a reference to this storage. External chunks are typically used for large chunks in order to avoid memory copies. If a chunk is internal, the Buffer owns the storage for the chunk; data supplied by the caller is copied into the Buffer’s internal storage. Each Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks. If this space is exhausted, then the Buffer creates additional allocations, which must be freed when the Buffer is destroyed. Internal chunks are convenient for small chunks where the memory copying costs are negligible. Figure 20.1 shows a Buffer with 5 chunks: the first chunk is internal, the next two are external, and the final two chunks are internal.\n\n> RAMCloud 使用 Buffer 对象管理可变长度的内存数组，例如远程过程调用的请求和响应消息。缓冲区旨在减少内存复制和动态存储分配的开销。缓冲区存储看似线性的字节数组，但是为了提高效率，它允许将底层存储划分为多个不连续的内存块，如图 20.1 所示。通过附加数据块来创建缓冲区。每个块都是外部的或内部的。如果块在外部，则其存储由调用方拥有；缓冲区保留对此存储的引用。外部块通常用于大型块，以避免内存复制。如果内部有块，则 Buffer 拥有该块的存储；调用者提供的数据将被复制到缓冲区的内部存储器中。每个缓冲区包含一个小的内置分配，这是一个内存块，可用于存储内部块。如果此空间已用完，则缓冲区将创建其他分配，销毁缓冲区时必须释放这些分配。内部块对于内存复制成本可忽略不计的小块很方便。图 20.1 显示了具有 5 个块的 Buffer：第一个块是内部的，接下来的两个块是外部的，最后两个块是内部的。\n\n![](../../img/figures/00022.jpeg)\n\nFigure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes. Internal chunks are owned by the Buffer and freed when the Buffer is destroyed; external chunks are not owned by the Buffer.\n\n> 图 20.1：Buffer 对象使用内存块的集合来存储看似线性字节数组。内部块由 Buffer 拥有，并在 Buffer 销毁时释放；外部块不属于缓冲区。\n\nThe Buffer class itself represents a “fundamental fix,” in that it eliminates expensive memory copies that would have been required without it. For example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks. The first chunk is an internal one that contains the header; the second chunk is an external one that refers to the object contents in the RAMCloud storage system. The response can be collected in the Buffer without copying the large object.\n\n> Buffer 类本身代表“根本性的修补程序”，因为它消除了没有它就需要的昂贵的内存副本。例如，在 RAMCloud 存储系统中组装包含短标头和大对象内容的响应消息时，RAMCloud 使用带有两个块的 Buffer。第一个块是包含头的内部块；第二个块是一个外部块，它引用 RAMCloud 存储系统中的对象内容。可以在不复制大对象的情况下将响应收集到缓冲区中。\n\nAside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation. Over time, however, we noticed Buffers being used in more and more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performance of the Buffer class.\n\n> 除了允许不连续块的基本方法外，我们没有尝试在原始实现中优化 Buffer 类的代码。但是，随着时间的流逝，我们注意到缓冲区越来越多地被使用。例如，在每个远程过程调用的执行期间，至少创建四个缓冲区。最终，很明显，加速 Buffer 的实现可能会对整体系统性能产生显着影响。我们决定看看是否可以提高 Buffer 类的性能。\n\nThe most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk. This happens, for example, when creating headers for request and response messages. We decided to use this operation as the critical path for optimization. In the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer. However, this is only possible if the last existing chunk is internal, and if there is enough space in its allocation to accommodate the new data. The ideal code would perform a single check to confirm that the simple approach is possible, then it would adjust the size of the existing chunk.\n\n> Buffer 最常见的操作是使用内部块为少量新数据分配空间。例如，在为请求和响应消息创建标题时，就会发生这种情况。我们决定将此操作用作优化的关键路径。在最简单的情况下，可以通过扩大 Buffer 中最后存在的块来分配空间。但是，只有在最后一个现有块位于内部，并且其分配中有足够的空间来容纳新数据时，才有可能这样做。理想的代码将执行一次检查以确认简单方法是否可行，然后将调整现有块的大小。\n\nFigure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc. In the fastest possible case, Buffer::alloc calls Buffer:: allocateAppend, which calls Buffer::Allocation::allocateAppend. From a performance standpoint, this code has two problems. The first problem is that numerous special cases are checked individually:\n\n> 图 20.2 显示了关键路径的原始代码，该代码以 Buffer :: alloc 方法开头。在最快的情况下，Buffer :: alloc 调用 Buffer :: allocateAppend，后者调用 Buffer :: Allocation :: allocateAppend。从性能的角度来看，此代码有两个问题。第一个问题是要单独检查许多特殊情况：\n\n- Buffer::allocateAppend checks to see if the Buffer currently has any allocations.\n- The code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.\n- Buffer::alloc tests the return value from Buffer::allocAppend to confirm yet again that the allocation succeeded.\n\n---\n\n> - Buffer::allocateAppend 检查缓冲区当前是否有任何分配。\n> - 代码检查两次以查看当前分配是否有足够的空间容纳新数据：一次在 Buffer::Allocation::allocateAppend 中，一次在其返回值由 Buffer::allocateAppend 测试时。\n> - Buffer::alloc 测试 Buffer::allocAppend 的返回值，以再次确认分配成功。\n\nFurthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This results in additional checks. Overall, this code tests 6 distinct conditions in the critical path.\n\n> 此外，该代码没有尝试直接扩展最后一个块，而是在不考虑最后一个块的情况下分配了新空间。然后，Buffer::alloc 检查该空间是否恰好与最后一块相邻，在这种情况下，它将新空间与现有块合并。这导致其他检查。总体而言，此代码测试关键路径中的 6 种不同条件。\n\nThe second problem with the original code is that it has too many layers, all of which are shallow. This is both a performance problem and a design problem. The critical path makes two additional method calls in addition to the original invocation of Buffer::alloc. Each method call takes additional time, and the result of each call must be checked by its caller, which results in more special cases to consider. Chapter 7 discussed how abstractions should normally change as you pass from one layer to another, but all three of the methods in Figure 20.2 have identical signatures and they provide essentially the same abstraction; this is a red flag. Buffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed. The extra layers make the code both slower and more complicated.\n\n> 原始代码的第二个问题是它具有太多的层，所有层都很浅。这既是性能问题，也是设计问题。关键路径除了对 Buffer::alloc 的原始调用之外，还进行了另外两个方法调用。每个方法调用花费额外的时间，并且每个调用的结果必须由其调用者检查，这导致需要考虑更多特殊情况。第 7 章讨论了当您从一层传递到另一层时，抽象通常应该如何变化，但是图 20.2 中的所有三种方法都具有相同的签名，并且它们提供了基本相同的抽象。这是一个危险信号。Buffer::allocateAppend 几乎是一个传递方法；它的唯一作用是在需要时创建新的分配。额外的层使代码既慢又复杂。\n\nTo fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths. We considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer. For each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case. Then we designed the rest of the class around these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and created deeper internal abstractions. The refactored class is 20% smaller than the original version (1476 lines of code, versus 1886 lines in the original).\n\n> 为了解决这些问题，我们重构了 Buffer 类，使其设计围绕最关键性能的路径进行。我们不仅考虑了上面的分配代码，还考虑了其 ​​ 他几种常用的执行路径，例如检索当前存储在 Buffer 中的数据的字节总数。对于这些关键路径中的每一个，我们试图确定在通常情况下必须执行的最少代码量。然后，我们围绕这些关键路径设计了课程的其余部分。我们还应用了本书中的设计原则来简化整个类。例如，我们消除了浅层并创建了更深的内部抽象。重构的类比原始版本小 20％（1476 行代码，而原始版本为 1886 行）。\n\n![](../../img/figures/00023.gif)\n\nFigure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.\n\n> 图 20.2：使用内部块在 Buffer 的末尾分配新空间的原始代码。\n\n![](../../img/figures/00024.gif)\n\nFigure 20.3: The new code for allocating new space in an internal chunk of a Buffer.\n\n> 图 20.3：用于在 Buffer 的内部块中分配新空间的新代码。\n\nFigure 20.3 shows the new critical path for allocating internal space in a Buffer. The new code is not only faster, but it is also easier to read, since it avoids shallow abstractions. The entire path is handled in a single method, and it uses a single test to rule out all of the special cases. The new code introduces a new instance variable, extraAppendBytes, in order to simplify the critical path. This variable keeps track of how much unused space is available immediately after the last chunk in the Buffer. If there is no space available, or if the last chunk in the Buffer isn’t an internal chunk, or if the Buffer contains no chunks at all, then extraAppendBytes is zero. The code in Figure 20.3 represents the least possible amount of code to handle this common case.\n\n> 图 20.3 显示了用于在 Buffer 中分配内部空间的新关键路径。新代码不仅速度更快，而且更容易阅读，因为它避免了浅层抽象。整个路径使用单一方法处理，并且使用单一测试排除所有特殊情况。新代码引入了新的实例变量 extraAppendBytes，以简化关键路径。此变量跟踪缓冲区中最后一个块之后立即有多少未使用空间可用。如果没有可用空间，或者 Buffer 中的最后一个块不是内部块，或者 Buffer 根本不包含任何块，则 extraAppendBytes 为零。图 20.3 中的代码表示处理这种常见情况的最少代码量。\n\nNote: the update to totalLength could have been eliminated by recomputing the total Buffer length from the individual chunks whenever it is needed. However, this approach would be expensive for a large Buffer with many chunks, and fetching the total Buffer length is another common operation. Thus, we chose to add a small amount of extra overhead to alloc in order to ensure that the Buffer length is always immediately available.\n\n> 注意：只要需要，就可以通过重新计算各个块的总缓冲区长度来消除对 totalLength 的更新。但是，这种方法对于具有许多块的大型 Buffer 而言将是昂贵的，并且获取 Buffer 的总长度是另一种常见的操作。因此，我们选择添加少量额外的开销来分配，以确保 Buffer 长度始终立即可用。\n\nThe new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns. Many other Buffer operations also speeded up because of the revisions. For example, the time to construct a new Buffer, append a small chunk in internal storage, and destroy the Buffer dropped from 24 ns to 12 ns.\n\n> 新代码的速度约为旧代码的两倍：使用内部存储将 1 字节字符串附加到缓冲区的总时间从 8.8 ns 降低到 4.75 ns。由于修订，许多其他缓冲区操作也加快了速度。例如，构建新缓冲区，在内部存储中附加一小块并销毁缓冲区所需的时间从 24 ns 降至 12 ns。\n\n## 20.5 Conclusion 结论\n\nThe most important overall lesson from this chapter is that clean design and high performance are compatible. The Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probably be fast enough that you don’t have to worry much about performance in the first place. In the few cases where you do need to optimize performance, the key is simplicity again: find the critical paths that are most important for performance and make them as simple as possible.\n\n> 本章最重要的总体教训是，干净的设计和高性能是兼容的。重写 Buffer 类可将其性能提高 2 倍，同时简化其设计并将代码大小减少 20％。复杂的代码通常会很慢，因为它会执行多余或多余的工作。另一方面，如果您编写干净，简单的代码，则系统可能会足够快，因此您一开始就不必担心性能。在少数需要优化性能的情况下，关键再次是简单性：找到对性能最重要的关键路径并使它们尽可能简单。\n","source":"_posts/软件设计的哲学-ch20.md","raw":"---\ntitle: 软件设计的哲学 - ch20\ndate: 2021-02-20\ntags: 软件设计的哲学 软件开发 方法论\n---\n设计性能\n<!-- more -->\n# 第 20 章 设计性能\n\n> Chapter 20 Designing for Performance\n\nUp until this point, the discussion of software design has focused on complexity; the goal has been to make software as simple and understandable as possible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a system’s design, but it usually makes systems faster.\n\n> 到目前为止，关于软件设计的讨论都集中在复杂性上。目标是使软件尽可能简单易懂。但是，如果您在需要快速的系统上工作，该怎么办？性能方面的考虑应如何影响设计过程？本章讨论如何在不牺牲简洁设计的情况下实现高性能。最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。\n\n## 20.1 How to think about performance 如何考虑性能\n\nThe first question to address is “how much should you worry about performance during the normal development process?” If you try to optimize every statement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the “optimizations” won’t actually help performance. On the other hand, if you completely ignore performance issues, it’s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5–10x slower than it needs to be. In this “death by a thousand cuts” scenario it’s hard to come back later and improve the performance, because there is no single improvement that will have much impact.\n\n> 要解决的第一个问题是“您在正常的开发过程中应该为性能多少担心？” 如果您尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果您完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。\n\nThe best approach is something between these extremes, where you use basic knowledge of performance to choose design alternatives that are “naturally efficient” yet also clean and simple. The key is to develop an awareness of which operations are fundamentally expensive. Here are a few examples of operations that are relatively expensive today:\n\n> 最好的方法是介于这两种极端之间，在这种极端情况下，您可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：\n\n- Network communication: even within a datacenter, a round-trip message exchange can take 10–50 µs, which is tens of thousands of instruction times. Wide-area round-trips can take 10–100 ms.\n- I/O to secondary storage: disk I/O operations typically take 5–10 ms, which is millions of instruction times. Flash storage takes 10–100 µs. New emerging nonvolatile memories may be as fast as 1 µs, but this is still around 2000 instruction times.\n- Dynamic memory allocation (malloc in C, new in C++ or Java) typically involves significant overhead for allocation, freeing, and garbage collection.\n- Cache misses: fetching data from DRAM into an on-chip processor cache takes a few hundred instruction times; in many programs, overall performance is determined as much by cache misses as by computational costs.\n\n---\n\n> - 网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。\n> - I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。\n> - 动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。\n> - 高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。\n\nThe best way to learn which things are expensive is to run micro-benchmarks (small programs that measure the cost of a single operation in isolation). In the RAMCloud project, we created a simple program that provides a framework for microbenchmarks. It took a few days to create the framework, but the framework makes it possible to add new micro-benchmarks in five or ten minutes. This has allowed us to accumulate dozens of micro-benchmarks. We use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.\n\n> 了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。\n\nOnce you have a general sense for what is expensive and what is cheap, you can use that information to choose cheap operations whenever possible. In many cases, a more efficient approach will be just as simple as a slower approach. For example, when storing a large collection of objects that will be looked up using a key value, you could use either a hash table or an ordered map. Both are commonly available in library packages, and both are simple and clean to use. However, hash tables can easily be 5–10x faster. Thus, you should always use a hash table unless you need the ordering properties provided by the map.\n\n> 一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要地图提供的排序属性，否则应始终使用哈希表。\n\nAs another example, consider allocating an array of structures in a language such as C or C++. There are two ways you can do this. One way is for the array to hold pointers to structures, in which case you must first allocate space for the array, then allocate space for each individual structure. It is much more efficient to store the structures in the array itself, so you only allocate one large block for everything.\n\n> 作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，您必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此您只为所有内容分配一个大块。\n\nIf the only way to improve efficiency is by adding complexity, then the choice is more difficult. If the more efficient design adds only a small amount of complexity, and if the complexity is hidden, so it doesn’t affect any interfaces, then it may be worthwhile (but beware: complexity is incremental). If the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem. However, if you have clear evidence that performance will be important in a particular situation, then you might as well implement the faster approach immediately.\n\n> 如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果您有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。\n\nIn the RAMCloud project one of our overall goals was to provide the lowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking, which allowed RAMCloud to bypass the kernel and communicate directly with the network interface controller to send and receive packets. We made this decision even though it added complexity, because we knew from prior measurements that kernel-based networking would be too slow to meet our needs. In most of the rest of the RAMCloud system we were able to design for simplicity; getting this one big issue “right” made many other things easier.\n\n> 在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。\n\nIn general, simpler code tends to run faster than complex code. If you have defined away special cases and exceptions, then no code is needed to check for those cases and the system runs faster. Deep classes are more efficient than shallow ones, because they get more work done for each method call. Shallow classes result in more layer crossings, and each layer crossing adds overhead.\n\n> 通常，较简单的代码往往比复杂的代码运行更快。如果您定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。\n\n## 20.2 Measure before modifying 修改前的度量\n\nBut suppose that your system is still too slow, even though you have designed it as described above. It’s tempting to rush off and start making performance tweaks, based on your intuitions about what is slow. Don’t do this! Programmers’ intuitions about performance are unreliable. This is true even for experienced developers. If you start making changes based on intuition, you’ll waste time on things that don’t actually improve performance, and you’ll probably make the system more complicated in the process.\n\n> 但是，即使您如上所述进行设计，也请假设您的系统仍然太慢。根据您对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果您开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。\n\nBefore making any changes, measure the system’s existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact. It isn’t sufficient just to measure the top-level system performance. This may tell you that the system is too slow, but it won’t tell you why. You’ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement. The second purpose of the measurements is to provide a baseline, so that you can re-measure performance after making your changes to ensure that performance actually improved. If the changes didn’t make a measurable difference in performance, then back them out (unless they made the system simpler). There’s no point in retaining complexity unless it provides a significant speedup.\n\n> 进行任何更改之前，请测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。您需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及您有改进想法的地方。测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。\n\n## 20.3 Design around the critical path 围绕关键路径进行设计\n\nAt this point, let’s assume that you have carefully analyzed performance and have identified a piece of code that is slow enough to affect the overall system performance. The best way to improve its performance is with a “fundamental” change, such as introducing a cache, or using a different algorithmic approach (balanced tree vs. list, for instance). Our decision to bypass the kernel for network communication in RAMCloud is an example of a fundamental fix. If you can identify a fundamental fix, then you can implement it using the design techniques discussed in previous chapters.\n\n> 在这一点上，我们假设您已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果您可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。\n\nUnfortunately, situations will sometimes arise where there isn’t a fundamental fix. This brings us to the core issue for this chapter, which is how to redesign an existing piece of code so that it runs faster. This should be your last resort, and it shouldn’t happen often, but there are cases where it can make a big difference. The key idea is to design the code around the critical path.\n\n> 不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是您的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。\n\nStart off by asking yourself what is the smallest amount of code that must be executed to carry out the desired task in the common case. Disregard any existing code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case. The current code is probably cluttered with special cases; ignore them in this exercise. The current code might pass through several method calls on the critical path; imagine instead that you could put all the relevant code in a single method. The current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path. For example, it may make sense to combine multiple variables into a single value. Assume that you could completely redesign the system in order to minimize the code that must be executed for the critical path. Let’s call this code “the ideal.”\n\n> 首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下您正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，您可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设您可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。\n\nThe ideal code probably clashes with your existing class structure, and it may not be practical, but it provides a good target: this represents the simplest and fastest that the code can ever be. The next step is to look for a new design that comes as close as possible to the ideal while still having a clean structure. You can apply all of the design ideas from previous chapters of this book, but with the additional constraint of keeping the ideal code (mostly) intact. You may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it’s OK to introduce an extra method call to a general-purpose hash table class. In my experience it’s almost always possible to find a design that is clean and simple, yet comes very close to the ideal.\n\n> 理想的代码可能会与您现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。您可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。您可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。\n\nOne of the most important things that happens in this process is to remove special cases from the critical path. When code is slow, it’s often because it must handle a variety of situations, and the code gets structured to simplify the handling of all the different cases. Each special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally, there will be a single if statement at the beginning, which detects all special cases with one test. In the normal case, only this one test will need to be made, after which the the critical path can be executed with no additional tests for special cases. If the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it. Performance isn’t as important for special cases, so you can structure the special-case code for simplicity rather than performance.\n\n> 在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此您可以为简化而不是性能来构造特殊情况的代码。\n\n## 20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区\n\nLet’s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.\n\n> 让我们考虑一个示例，其中 RAMCloud 存储系统的 Buffer 类经过优化，以使大多数常见操作的速度提高约 2 倍。\n\nRAMCloud uses Buffer objects to manage variable-length arrays of memory, such as request and response messages for remote procedure calls. Buffers are designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguous chunks of memory, as shown in Figure 20.1. A Buffer is created by appending chunks of data. Each chunk is either external or internal. If a chunk is external, its storage is owned by the caller; the Buffer keeps a reference to this storage. External chunks are typically used for large chunks in order to avoid memory copies. If a chunk is internal, the Buffer owns the storage for the chunk; data supplied by the caller is copied into the Buffer’s internal storage. Each Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks. If this space is exhausted, then the Buffer creates additional allocations, which must be freed when the Buffer is destroyed. Internal chunks are convenient for small chunks where the memory copying costs are negligible. Figure 20.1 shows a Buffer with 5 chunks: the first chunk is internal, the next two are external, and the final two chunks are internal.\n\n> RAMCloud 使用 Buffer 对象管理可变长度的内存数组，例如远程过程调用的请求和响应消息。缓冲区旨在减少内存复制和动态存储分配的开销。缓冲区存储看似线性的字节数组，但是为了提高效率，它允许将底层存储划分为多个不连续的内存块，如图 20.1 所示。通过附加数据块来创建缓冲区。每个块都是外部的或内部的。如果块在外部，则其存储由调用方拥有；缓冲区保留对此存储的引用。外部块通常用于大型块，以避免内存复制。如果内部有块，则 Buffer 拥有该块的存储；调用者提供的数据将被复制到缓冲区的内部存储器中。每个缓冲区包含一个小的内置分配，这是一个内存块，可用于存储内部块。如果此空间已用完，则缓冲区将创建其他分配，销毁缓冲区时必须释放这些分配。内部块对于内存复制成本可忽略不计的小块很方便。图 20.1 显示了具有 5 个块的 Buffer：第一个块是内部的，接下来的两个块是外部的，最后两个块是内部的。\n\n![](../../img/figures/00022.jpeg)\n\nFigure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes. Internal chunks are owned by the Buffer and freed when the Buffer is destroyed; external chunks are not owned by the Buffer.\n\n> 图 20.1：Buffer 对象使用内存块的集合来存储看似线性字节数组。内部块由 Buffer 拥有，并在 Buffer 销毁时释放；外部块不属于缓冲区。\n\nThe Buffer class itself represents a “fundamental fix,” in that it eliminates expensive memory copies that would have been required without it. For example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks. The first chunk is an internal one that contains the header; the second chunk is an external one that refers to the object contents in the RAMCloud storage system. The response can be collected in the Buffer without copying the large object.\n\n> Buffer 类本身代表“根本性的修补程序”，因为它消除了没有它就需要的昂贵的内存副本。例如，在 RAMCloud 存储系统中组装包含短标头和大对象内容的响应消息时，RAMCloud 使用带有两个块的 Buffer。第一个块是包含头的内部块；第二个块是一个外部块，它引用 RAMCloud 存储系统中的对象内容。可以在不复制大对象的情况下将响应收集到缓冲区中。\n\nAside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation. Over time, however, we noticed Buffers being used in more and more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performance of the Buffer class.\n\n> 除了允许不连续块的基本方法外，我们没有尝试在原始实现中优化 Buffer 类的代码。但是，随着时间的流逝，我们注意到缓冲区越来越多地被使用。例如，在每个远程过程调用的执行期间，至少创建四个缓冲区。最终，很明显，加速 Buffer 的实现可能会对整体系统性能产生显着影响。我们决定看看是否可以提高 Buffer 类的性能。\n\nThe most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk. This happens, for example, when creating headers for request and response messages. We decided to use this operation as the critical path for optimization. In the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer. However, this is only possible if the last existing chunk is internal, and if there is enough space in its allocation to accommodate the new data. The ideal code would perform a single check to confirm that the simple approach is possible, then it would adjust the size of the existing chunk.\n\n> Buffer 最常见的操作是使用内部块为少量新数据分配空间。例如，在为请求和响应消息创建标题时，就会发生这种情况。我们决定将此操作用作优化的关键路径。在最简单的情况下，可以通过扩大 Buffer 中最后存在的块来分配空间。但是，只有在最后一个现有块位于内部，并且其分配中有足够的空间来容纳新数据时，才有可能这样做。理想的代码将执行一次检查以确认简单方法是否可行，然后将调整现有块的大小。\n\nFigure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc. In the fastest possible case, Buffer::alloc calls Buffer:: allocateAppend, which calls Buffer::Allocation::allocateAppend. From a performance standpoint, this code has two problems. The first problem is that numerous special cases are checked individually:\n\n> 图 20.2 显示了关键路径的原始代码，该代码以 Buffer :: alloc 方法开头。在最快的情况下，Buffer :: alloc 调用 Buffer :: allocateAppend，后者调用 Buffer :: Allocation :: allocateAppend。从性能的角度来看，此代码有两个问题。第一个问题是要单独检查许多特殊情况：\n\n- Buffer::allocateAppend checks to see if the Buffer currently has any allocations.\n- The code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.\n- Buffer::alloc tests the return value from Buffer::allocAppend to confirm yet again that the allocation succeeded.\n\n---\n\n> - Buffer::allocateAppend 检查缓冲区当前是否有任何分配。\n> - 代码检查两次以查看当前分配是否有足够的空间容纳新数据：一次在 Buffer::Allocation::allocateAppend 中，一次在其返回值由 Buffer::allocateAppend 测试时。\n> - Buffer::alloc 测试 Buffer::allocAppend 的返回值，以再次确认分配成功。\n\nFurthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This results in additional checks. Overall, this code tests 6 distinct conditions in the critical path.\n\n> 此外，该代码没有尝试直接扩展最后一个块，而是在不考虑最后一个块的情况下分配了新空间。然后，Buffer::alloc 检查该空间是否恰好与最后一块相邻，在这种情况下，它将新空间与现有块合并。这导致其他检查。总体而言，此代码测试关键路径中的 6 种不同条件。\n\nThe second problem with the original code is that it has too many layers, all of which are shallow. This is both a performance problem and a design problem. The critical path makes two additional method calls in addition to the original invocation of Buffer::alloc. Each method call takes additional time, and the result of each call must be checked by its caller, which results in more special cases to consider. Chapter 7 discussed how abstractions should normally change as you pass from one layer to another, but all three of the methods in Figure 20.2 have identical signatures and they provide essentially the same abstraction; this is a red flag. Buffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed. The extra layers make the code both slower and more complicated.\n\n> 原始代码的第二个问题是它具有太多的层，所有层都很浅。这既是性能问题，也是设计问题。关键路径除了对 Buffer::alloc 的原始调用之外，还进行了另外两个方法调用。每个方法调用花费额外的时间，并且每个调用的结果必须由其调用者检查，这导致需要考虑更多特殊情况。第 7 章讨论了当您从一层传递到另一层时，抽象通常应该如何变化，但是图 20.2 中的所有三种方法都具有相同的签名，并且它们提供了基本相同的抽象。这是一个危险信号。Buffer::allocateAppend 几乎是一个传递方法；它的唯一作用是在需要时创建新的分配。额外的层使代码既慢又复杂。\n\nTo fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths. We considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer. For each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case. Then we designed the rest of the class around these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and created deeper internal abstractions. The refactored class is 20% smaller than the original version (1476 lines of code, versus 1886 lines in the original).\n\n> 为了解决这些问题，我们重构了 Buffer 类，使其设计围绕最关键性能的路径进行。我们不仅考虑了上面的分配代码，还考虑了其 ​​ 他几种常用的执行路径，例如检索当前存储在 Buffer 中的数据的字节总数。对于这些关键路径中的每一个，我们试图确定在通常情况下必须执行的最少代码量。然后，我们围绕这些关键路径设计了课程的其余部分。我们还应用了本书中的设计原则来简化整个类。例如，我们消除了浅层并创建了更深的内部抽象。重构的类比原始版本小 20％（1476 行代码，而原始版本为 1886 行）。\n\n![](../../img/figures/00023.gif)\n\nFigure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.\n\n> 图 20.2：使用内部块在 Buffer 的末尾分配新空间的原始代码。\n\n![](../../img/figures/00024.gif)\n\nFigure 20.3: The new code for allocating new space in an internal chunk of a Buffer.\n\n> 图 20.3：用于在 Buffer 的内部块中分配新空间的新代码。\n\nFigure 20.3 shows the new critical path for allocating internal space in a Buffer. The new code is not only faster, but it is also easier to read, since it avoids shallow abstractions. The entire path is handled in a single method, and it uses a single test to rule out all of the special cases. The new code introduces a new instance variable, extraAppendBytes, in order to simplify the critical path. This variable keeps track of how much unused space is available immediately after the last chunk in the Buffer. If there is no space available, or if the last chunk in the Buffer isn’t an internal chunk, or if the Buffer contains no chunks at all, then extraAppendBytes is zero. The code in Figure 20.3 represents the least possible amount of code to handle this common case.\n\n> 图 20.3 显示了用于在 Buffer 中分配内部空间的新关键路径。新代码不仅速度更快，而且更容易阅读，因为它避免了浅层抽象。整个路径使用单一方法处理，并且使用单一测试排除所有特殊情况。新代码引入了新的实例变量 extraAppendBytes，以简化关键路径。此变量跟踪缓冲区中最后一个块之后立即有多少未使用空间可用。如果没有可用空间，或者 Buffer 中的最后一个块不是内部块，或者 Buffer 根本不包含任何块，则 extraAppendBytes 为零。图 20.3 中的代码表示处理这种常见情况的最少代码量。\n\nNote: the update to totalLength could have been eliminated by recomputing the total Buffer length from the individual chunks whenever it is needed. However, this approach would be expensive for a large Buffer with many chunks, and fetching the total Buffer length is another common operation. Thus, we chose to add a small amount of extra overhead to alloc in order to ensure that the Buffer length is always immediately available.\n\n> 注意：只要需要，就可以通过重新计算各个块的总缓冲区长度来消除对 totalLength 的更新。但是，这种方法对于具有许多块的大型 Buffer 而言将是昂贵的，并且获取 Buffer 的总长度是另一种常见的操作。因此，我们选择添加少量额外的开销来分配，以确保 Buffer 长度始终立即可用。\n\nThe new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns. Many other Buffer operations also speeded up because of the revisions. For example, the time to construct a new Buffer, append a small chunk in internal storage, and destroy the Buffer dropped from 24 ns to 12 ns.\n\n> 新代码的速度约为旧代码的两倍：使用内部存储将 1 字节字符串附加到缓冲区的总时间从 8.8 ns 降低到 4.75 ns。由于修订，许多其他缓冲区操作也加快了速度。例如，构建新缓冲区，在内部存储中附加一小块并销毁缓冲区所需的时间从 24 ns 降至 12 ns。\n\n## 20.5 Conclusion 结论\n\nThe most important overall lesson from this chapter is that clean design and high performance are compatible. The Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probably be fast enough that you don’t have to worry much about performance in the first place. In the few cases where you do need to optimize performance, the key is simplicity again: find the critical paths that are most important for performance and make them as simple as possible.\n\n> 本章最重要的总体教训是，干净的设计和高性能是兼容的。重写 Buffer 类可将其性能提高 2 倍，同时简化其设计并将代码大小减少 20％。复杂的代码通常会很慢，因为它会执行多余或多余的工作。另一方面，如果您编写干净，简单的代码，则系统可能会足够快，因此您一开始就不必担心性能。在少数需要优化性能的情况下，关键再次是简单性：找到对性能最重要的关键路径并使它们尽可能简单。\n","slug":"软件设计的哲学-ch20","published":1,"updated":"2021-02-16T04:51:02.862Z","_id":"ckl7iw2vw000lkiiy6ltj7e3e","comments":1,"layout":"post","photos":[],"link":"","content":"<p>设计性能</p>\n<a id=\"more\"></a>\n<h1 id=\"第-20-章-设计性能\"><a href=\"#第-20-章-设计性能\" class=\"headerlink\" title=\"第 20 章 设计性能\"></a>第 20 章 设计性能</h1><blockquote>\n<p>Chapter 20 Designing for Performance</p>\n</blockquote>\n<p>Up until this point, the discussion of software design has focused on complexity; the goal has been to make software as simple and understandable as possible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a system’s design, but it usually makes systems faster.</p>\n<blockquote>\n<p>到目前为止，关于软件设计的讨论都集中在复杂性上。目标是使软件尽可能简单易懂。但是，如果您在需要快速的系统上工作，该怎么办？性能方面的考虑应如何影响设计过程？本章讨论如何在不牺牲简洁设计的情况下实现高性能。最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。</p>\n</blockquote>\n<h2 id=\"20-1-How-to-think-about-performance-如何考虑性能\"><a href=\"#20-1-How-to-think-about-performance-如何考虑性能\" class=\"headerlink\" title=\"20.1 How to think about performance 如何考虑性能\"></a>20.1 How to think about performance 如何考虑性能</h2><p>The first question to address is “how much should you worry about performance during the normal development process?” If you try to optimize every statement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the “optimizations” won’t actually help performance. On the other hand, if you completely ignore performance issues, it’s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5–10x slower than it needs to be. In this “death by a thousand cuts” scenario it’s hard to come back later and improve the performance, because there is no single improvement that will have much impact.</p>\n<blockquote>\n<p>要解决的第一个问题是“您在正常的开发过程中应该为性能多少担心？” 如果您尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果您完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。</p>\n</blockquote>\n<p>The best approach is something between these extremes, where you use basic knowledge of performance to choose design alternatives that are “naturally efficient” yet also clean and simple. The key is to develop an awareness of which operations are fundamentally expensive. Here are a few examples of operations that are relatively expensive today:</p>\n<blockquote>\n<p>最好的方法是介于这两种极端之间，在这种极端情况下，您可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：</p>\n</blockquote>\n<ul>\n<li>Network communication: even within a datacenter, a round-trip message exchange can take 10–50 µs, which is tens of thousands of instruction times. Wide-area round-trips can take 10–100 ms.</li>\n<li>I/O to secondary storage: disk I/O operations typically take 5–10 ms, which is millions of instruction times. Flash storage takes 10–100 µs. New emerging nonvolatile memories may be as fast as 1 µs, but this is still around 2000 instruction times.</li>\n<li>Dynamic memory allocation (malloc in C, new in C++ or Java) typically involves significant overhead for allocation, freeing, and garbage collection.</li>\n<li>Cache misses: fetching data from DRAM into an on-chip processor cache takes a few hundred instruction times; in many programs, overall performance is determined as much by cache misses as by computational costs.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。</li>\n<li>I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。</li>\n<li>动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。</li>\n<li>高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。</li>\n</ul>\n</blockquote>\n<p>The best way to learn which things are expensive is to run micro-benchmarks (small programs that measure the cost of a single operation in isolation). In the RAMCloud project, we created a simple program that provides a framework for microbenchmarks. It took a few days to create the framework, but the framework makes it possible to add new micro-benchmarks in five or ten minutes. This has allowed us to accumulate dozens of micro-benchmarks. We use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.</p>\n<blockquote>\n<p>了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。</p>\n</blockquote>\n<p>Once you have a general sense for what is expensive and what is cheap, you can use that information to choose cheap operations whenever possible. In many cases, a more efficient approach will be just as simple as a slower approach. For example, when storing a large collection of objects that will be looked up using a key value, you could use either a hash table or an ordered map. Both are commonly available in library packages, and both are simple and clean to use. However, hash tables can easily be 5–10x faster. Thus, you should always use a hash table unless you need the ordering properties provided by the map.</p>\n<blockquote>\n<p>一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要地图提供的排序属性，否则应始终使用哈希表。</p>\n</blockquote>\n<p>As another example, consider allocating an array of structures in a language such as C or C++. There are two ways you can do this. One way is for the array to hold pointers to structures, in which case you must first allocate space for the array, then allocate space for each individual structure. It is much more efficient to store the structures in the array itself, so you only allocate one large block for everything.</p>\n<blockquote>\n<p>作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，您必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此您只为所有内容分配一个大块。</p>\n</blockquote>\n<p>If the only way to improve efficiency is by adding complexity, then the choice is more difficult. If the more efficient design adds only a small amount of complexity, and if the complexity is hidden, so it doesn’t affect any interfaces, then it may be worthwhile (but beware: complexity is incremental). If the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem. However, if you have clear evidence that performance will be important in a particular situation, then you might as well implement the faster approach immediately.</p>\n<blockquote>\n<p>如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果您有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。</p>\n</blockquote>\n<p>In the RAMCloud project one of our overall goals was to provide the lowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking, which allowed RAMCloud to bypass the kernel and communicate directly with the network interface controller to send and receive packets. We made this decision even though it added complexity, because we knew from prior measurements that kernel-based networking would be too slow to meet our needs. In most of the rest of the RAMCloud system we were able to design for simplicity; getting this one big issue “right” made many other things easier.</p>\n<blockquote>\n<p>在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。</p>\n</blockquote>\n<p>In general, simpler code tends to run faster than complex code. If you have defined away special cases and exceptions, then no code is needed to check for those cases and the system runs faster. Deep classes are more efficient than shallow ones, because they get more work done for each method call. Shallow classes result in more layer crossings, and each layer crossing adds overhead.</p>\n<blockquote>\n<p>通常，较简单的代码往往比复杂的代码运行更快。如果您定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。</p>\n</blockquote>\n<h2 id=\"20-2-Measure-before-modifying-修改前的度量\"><a href=\"#20-2-Measure-before-modifying-修改前的度量\" class=\"headerlink\" title=\"20.2 Measure before modifying 修改前的度量\"></a>20.2 Measure before modifying 修改前的度量</h2><p>But suppose that your system is still too slow, even though you have designed it as described above. It’s tempting to rush off and start making performance tweaks, based on your intuitions about what is slow. Don’t do this! Programmers’ intuitions about performance are unreliable. This is true even for experienced developers. If you start making changes based on intuition, you’ll waste time on things that don’t actually improve performance, and you’ll probably make the system more complicated in the process.</p>\n<blockquote>\n<p>但是，即使您如上所述进行设计，也请假设您的系统仍然太慢。根据您对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果您开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。</p>\n</blockquote>\n<p>Before making any changes, measure the system’s existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact. It isn’t sufficient just to measure the top-level system performance. This may tell you that the system is too slow, but it won’t tell you why. You’ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement. The second purpose of the measurements is to provide a baseline, so that you can re-measure performance after making your changes to ensure that performance actually improved. If the changes didn’t make a measurable difference in performance, then back them out (unless they made the system simpler). There’s no point in retaining complexity unless it provides a significant speedup.</p>\n<blockquote>\n<p>进行任何更改之前，请测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。您需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及您有改进想法的地方。测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。</p>\n</blockquote>\n<h2 id=\"20-3-Design-around-the-critical-path-围绕关键路径进行设计\"><a href=\"#20-3-Design-around-the-critical-path-围绕关键路径进行设计\" class=\"headerlink\" title=\"20.3 Design around the critical path 围绕关键路径进行设计\"></a>20.3 Design around the critical path 围绕关键路径进行设计</h2><p>At this point, let’s assume that you have carefully analyzed performance and have identified a piece of code that is slow enough to affect the overall system performance. The best way to improve its performance is with a “fundamental” change, such as introducing a cache, or using a different algorithmic approach (balanced tree vs. list, for instance). Our decision to bypass the kernel for network communication in RAMCloud is an example of a fundamental fix. If you can identify a fundamental fix, then you can implement it using the design techniques discussed in previous chapters.</p>\n<blockquote>\n<p>在这一点上，我们假设您已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果您可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。</p>\n</blockquote>\n<p>Unfortunately, situations will sometimes arise where there isn’t a fundamental fix. This brings us to the core issue for this chapter, which is how to redesign an existing piece of code so that it runs faster. This should be your last resort, and it shouldn’t happen often, but there are cases where it can make a big difference. The key idea is to design the code around the critical path.</p>\n<blockquote>\n<p>不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是您的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。</p>\n</blockquote>\n<p>Start off by asking yourself what is the smallest amount of code that must be executed to carry out the desired task in the common case. Disregard any existing code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case. The current code is probably cluttered with special cases; ignore them in this exercise. The current code might pass through several method calls on the critical path; imagine instead that you could put all the relevant code in a single method. The current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path. For example, it may make sense to combine multiple variables into a single value. Assume that you could completely redesign the system in order to minimize the code that must be executed for the critical path. Let’s call this code “the ideal.”</p>\n<blockquote>\n<p>首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下您正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，您可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设您可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。</p>\n</blockquote>\n<p>The ideal code probably clashes with your existing class structure, and it may not be practical, but it provides a good target: this represents the simplest and fastest that the code can ever be. The next step is to look for a new design that comes as close as possible to the ideal while still having a clean structure. You can apply all of the design ideas from previous chapters of this book, but with the additional constraint of keeping the ideal code (mostly) intact. You may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it’s OK to introduce an extra method call to a general-purpose hash table class. In my experience it’s almost always possible to find a design that is clean and simple, yet comes very close to the ideal.</p>\n<blockquote>\n<p>理想的代码可能会与您现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。您可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。您可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。</p>\n</blockquote>\n<p>One of the most important things that happens in this process is to remove special cases from the critical path. When code is slow, it’s often because it must handle a variety of situations, and the code gets structured to simplify the handling of all the different cases. Each special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally, there will be a single if statement at the beginning, which detects all special cases with one test. In the normal case, only this one test will need to be made, after which the the critical path can be executed with no additional tests for special cases. If the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it. Performance isn’t as important for special cases, so you can structure the special-case code for simplicity rather than performance.</p>\n<blockquote>\n<p>在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此您可以为简化而不是性能来构造特殊情况的代码。</p>\n</blockquote>\n<h2 id=\"20-4-An-example-RAMCloud-Buffers-示例：RAMCloud-缓冲区\"><a href=\"#20-4-An-example-RAMCloud-Buffers-示例：RAMCloud-缓冲区\" class=\"headerlink\" title=\"20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区\"></a>20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区</h2><p>Let’s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.</p>\n<blockquote>\n<p>让我们考虑一个示例，其中 RAMCloud 存储系统的 Buffer 类经过优化，以使大多数常见操作的速度提高约 2 倍。</p>\n</blockquote>\n<p>RAMCloud uses Buffer objects to manage variable-length arrays of memory, such as request and response messages for remote procedure calls. Buffers are designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguous chunks of memory, as shown in Figure 20.1. A Buffer is created by appending chunks of data. Each chunk is either external or internal. If a chunk is external, its storage is owned by the caller; the Buffer keeps a reference to this storage. External chunks are typically used for large chunks in order to avoid memory copies. If a chunk is internal, the Buffer owns the storage for the chunk; data supplied by the caller is copied into the Buffer’s internal storage. Each Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks. If this space is exhausted, then the Buffer creates additional allocations, which must be freed when the Buffer is destroyed. Internal chunks are convenient for small chunks where the memory copying costs are negligible. Figure 20.1 shows a Buffer with 5 chunks: the first chunk is internal, the next two are external, and the final two chunks are internal.</p>\n<blockquote>\n<p>RAMCloud 使用 Buffer 对象管理可变长度的内存数组，例如远程过程调用的请求和响应消息。缓冲区旨在减少内存复制和动态存储分配的开销。缓冲区存储看似线性的字节数组，但是为了提高效率，它允许将底层存储划分为多个不连续的内存块，如图 20.1 所示。通过附加数据块来创建缓冲区。每个块都是外部的或内部的。如果块在外部，则其存储由调用方拥有；缓冲区保留对此存储的引用。外部块通常用于大型块，以避免内存复制。如果内部有块，则 Buffer 拥有该块的存储；调用者提供的数据将被复制到缓冲区的内部存储器中。每个缓冲区包含一个小的内置分配，这是一个内存块，可用于存储内部块。如果此空间已用完，则缓冲区将创建其他分配，销毁缓冲区时必须释放这些分配。内部块对于内存复制成本可忽略不计的小块很方便。图 20.1 显示了具有 5 个块的 Buffer：第一个块是内部的，接下来的两个块是外部的，最后两个块是内部的。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00022.jpeg\" alt=\"\"></p>\n<p>Figure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes. Internal chunks are owned by the Buffer and freed when the Buffer is destroyed; external chunks are not owned by the Buffer.</p>\n<blockquote>\n<p>图 20.1：Buffer 对象使用内存块的集合来存储看似线性字节数组。内部块由 Buffer 拥有，并在 Buffer 销毁时释放；外部块不属于缓冲区。</p>\n</blockquote>\n<p>The Buffer class itself represents a “fundamental fix,” in that it eliminates expensive memory copies that would have been required without it. For example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks. The first chunk is an internal one that contains the header; the second chunk is an external one that refers to the object contents in the RAMCloud storage system. The response can be collected in the Buffer without copying the large object.</p>\n<blockquote>\n<p>Buffer 类本身代表“根本性的修补程序”，因为它消除了没有它就需要的昂贵的内存副本。例如，在 RAMCloud 存储系统中组装包含短标头和大对象内容的响应消息时，RAMCloud 使用带有两个块的 Buffer。第一个块是包含头的内部块；第二个块是一个外部块，它引用 RAMCloud 存储系统中的对象内容。可以在不复制大对象的情况下将响应收集到缓冲区中。</p>\n</blockquote>\n<p>Aside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation. Over time, however, we noticed Buffers being used in more and more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performance of the Buffer class.</p>\n<blockquote>\n<p>除了允许不连续块的基本方法外，我们没有尝试在原始实现中优化 Buffer 类的代码。但是，随着时间的流逝，我们注意到缓冲区越来越多地被使用。例如，在每个远程过程调用的执行期间，至少创建四个缓冲区。最终，很明显，加速 Buffer 的实现可能会对整体系统性能产生显着影响。我们决定看看是否可以提高 Buffer 类的性能。</p>\n</blockquote>\n<p>The most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk. This happens, for example, when creating headers for request and response messages. We decided to use this operation as the critical path for optimization. In the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer. However, this is only possible if the last existing chunk is internal, and if there is enough space in its allocation to accommodate the new data. The ideal code would perform a single check to confirm that the simple approach is possible, then it would adjust the size of the existing chunk.</p>\n<blockquote>\n<p>Buffer 最常见的操作是使用内部块为少量新数据分配空间。例如，在为请求和响应消息创建标题时，就会发生这种情况。我们决定将此操作用作优化的关键路径。在最简单的情况下，可以通过扩大 Buffer 中最后存在的块来分配空间。但是，只有在最后一个现有块位于内部，并且其分配中有足够的空间来容纳新数据时，才有可能这样做。理想的代码将执行一次检查以确认简单方法是否可行，然后将调整现有块的大小。</p>\n</blockquote>\n<p>Figure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc. In the fastest possible case, Buffer::alloc calls Buffer:: allocateAppend, which calls Buffer::Allocation::allocateAppend. From a performance standpoint, this code has two problems. The first problem is that numerous special cases are checked individually:</p>\n<blockquote>\n<p>图 20.2 显示了关键路径的原始代码，该代码以 Buffer :: alloc 方法开头。在最快的情况下，Buffer :: alloc 调用 Buffer :: allocateAppend，后者调用 Buffer :: Allocation :: allocateAppend。从性能的角度来看，此代码有两个问题。第一个问题是要单独检查许多特殊情况：</p>\n</blockquote>\n<ul>\n<li>Buffer::allocateAppend checks to see if the Buffer currently has any allocations.</li>\n<li>The code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.</li>\n<li>Buffer::alloc tests the return value from Buffer::allocAppend to confirm yet again that the allocation succeeded.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>Buffer::allocateAppend 检查缓冲区当前是否有任何分配。</li>\n<li>代码检查两次以查看当前分配是否有足够的空间容纳新数据：一次在 Buffer::Allocation::allocateAppend 中，一次在其返回值由 Buffer::allocateAppend 测试时。</li>\n<li>Buffer::alloc 测试 Buffer::allocAppend 的返回值，以再次确认分配成功。</li>\n</ul>\n</blockquote>\n<p>Furthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This results in additional checks. Overall, this code tests 6 distinct conditions in the critical path.</p>\n<blockquote>\n<p>此外，该代码没有尝试直接扩展最后一个块，而是在不考虑最后一个块的情况下分配了新空间。然后，Buffer::alloc 检查该空间是否恰好与最后一块相邻，在这种情况下，它将新空间与现有块合并。这导致其他检查。总体而言，此代码测试关键路径中的 6 种不同条件。</p>\n</blockquote>\n<p>The second problem with the original code is that it has too many layers, all of which are shallow. This is both a performance problem and a design problem. The critical path makes two additional method calls in addition to the original invocation of Buffer::alloc. Each method call takes additional time, and the result of each call must be checked by its caller, which results in more special cases to consider. Chapter 7 discussed how abstractions should normally change as you pass from one layer to another, but all three of the methods in Figure 20.2 have identical signatures and they provide essentially the same abstraction; this is a red flag. Buffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed. The extra layers make the code both slower and more complicated.</p>\n<blockquote>\n<p>原始代码的第二个问题是它具有太多的层，所有层都很浅。这既是性能问题，也是设计问题。关键路径除了对 Buffer::alloc 的原始调用之外，还进行了另外两个方法调用。每个方法调用花费额外的时间，并且每个调用的结果必须由其调用者检查，这导致需要考虑更多特殊情况。第 7 章讨论了当您从一层传递到另一层时，抽象通常应该如何变化，但是图 20.2 中的所有三种方法都具有相同的签名，并且它们提供了基本相同的抽象。这是一个危险信号。Buffer::allocateAppend 几乎是一个传递方法；它的唯一作用是在需要时创建新的分配。额外的层使代码既慢又复杂。</p>\n</blockquote>\n<p>To fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths. We considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer. For each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case. Then we designed the rest of the class around these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and created deeper internal abstractions. The refactored class is 20% smaller than the original version (1476 lines of code, versus 1886 lines in the original).</p>\n<blockquote>\n<p>为了解决这些问题，我们重构了 Buffer 类，使其设计围绕最关键性能的路径进行。我们不仅考虑了上面的分配代码，还考虑了其 ​​ 他几种常用的执行路径，例如检索当前存储在 Buffer 中的数据的字节总数。对于这些关键路径中的每一个，我们试图确定在通常情况下必须执行的最少代码量。然后，我们围绕这些关键路径设计了课程的其余部分。我们还应用了本书中的设计原则来简化整个类。例如，我们消除了浅层并创建了更深的内部抽象。重构的类比原始版本小 20％（1476 行代码，而原始版本为 1886 行）。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00023.gif\" alt=\"\"></p>\n<p>Figure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.</p>\n<blockquote>\n<p>图 20.2：使用内部块在 Buffer 的末尾分配新空间的原始代码。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00024.gif\" alt=\"\"></p>\n<p>Figure 20.3: The new code for allocating new space in an internal chunk of a Buffer.</p>\n<blockquote>\n<p>图 20.3：用于在 Buffer 的内部块中分配新空间的新代码。</p>\n</blockquote>\n<p>Figure 20.3 shows the new critical path for allocating internal space in a Buffer. The new code is not only faster, but it is also easier to read, since it avoids shallow abstractions. The entire path is handled in a single method, and it uses a single test to rule out all of the special cases. The new code introduces a new instance variable, extraAppendBytes, in order to simplify the critical path. This variable keeps track of how much unused space is available immediately after the last chunk in the Buffer. If there is no space available, or if the last chunk in the Buffer isn’t an internal chunk, or if the Buffer contains no chunks at all, then extraAppendBytes is zero. The code in Figure 20.3 represents the least possible amount of code to handle this common case.</p>\n<blockquote>\n<p>图 20.3 显示了用于在 Buffer 中分配内部空间的新关键路径。新代码不仅速度更快，而且更容易阅读，因为它避免了浅层抽象。整个路径使用单一方法处理，并且使用单一测试排除所有特殊情况。新代码引入了新的实例变量 extraAppendBytes，以简化关键路径。此变量跟踪缓冲区中最后一个块之后立即有多少未使用空间可用。如果没有可用空间，或者 Buffer 中的最后一个块不是内部块，或者 Buffer 根本不包含任何块，则 extraAppendBytes 为零。图 20.3 中的代码表示处理这种常见情况的最少代码量。</p>\n</blockquote>\n<p>Note: the update to totalLength could have been eliminated by recomputing the total Buffer length from the individual chunks whenever it is needed. However, this approach would be expensive for a large Buffer with many chunks, and fetching the total Buffer length is another common operation. Thus, we chose to add a small amount of extra overhead to alloc in order to ensure that the Buffer length is always immediately available.</p>\n<blockquote>\n<p>注意：只要需要，就可以通过重新计算各个块的总缓冲区长度来消除对 totalLength 的更新。但是，这种方法对于具有许多块的大型 Buffer 而言将是昂贵的，并且获取 Buffer 的总长度是另一种常见的操作。因此，我们选择添加少量额外的开销来分配，以确保 Buffer 长度始终立即可用。</p>\n</blockquote>\n<p>The new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns. Many other Buffer operations also speeded up because of the revisions. For example, the time to construct a new Buffer, append a small chunk in internal storage, and destroy the Buffer dropped from 24 ns to 12 ns.</p>\n<blockquote>\n<p>新代码的速度约为旧代码的两倍：使用内部存储将 1 字节字符串附加到缓冲区的总时间从 8.8 ns 降低到 4.75 ns。由于修订，许多其他缓冲区操作也加快了速度。例如，构建新缓冲区，在内部存储中附加一小块并销毁缓冲区所需的时间从 24 ns 降至 12 ns。</p>\n</blockquote>\n<h2 id=\"20-5-Conclusion-结论\"><a href=\"#20-5-Conclusion-结论\" class=\"headerlink\" title=\"20.5 Conclusion 结论\"></a>20.5 Conclusion 结论</h2><p>The most important overall lesson from this chapter is that clean design and high performance are compatible. The Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probably be fast enough that you don’t have to worry much about performance in the first place. In the few cases where you do need to optimize performance, the key is simplicity again: find the critical paths that are most important for performance and make them as simple as possible.</p>\n<blockquote>\n<p>本章最重要的总体教训是，干净的设计和高性能是兼容的。重写 Buffer 类可将其性能提高 2 倍，同时简化其设计并将代码大小减少 20％。复杂的代码通常会很慢，因为它会执行多余或多余的工作。另一方面，如果您编写干净，简单的代码，则系统可能会足够快，因此您一开始就不必担心性能。在少数需要优化性能的情况下，关键再次是简单性：找到对性能最重要的关键路径并使它们尽可能简单。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>设计性能</p>","more":"<h1 id=\"第-20-章-设计性能\"><a href=\"#第-20-章-设计性能\" class=\"headerlink\" title=\"第 20 章 设计性能\"></a>第 20 章 设计性能</h1><blockquote>\n<p>Chapter 20 Designing for Performance</p>\n</blockquote>\n<p>Up until this point, the discussion of software design has focused on complexity; the goal has been to make software as simple and understandable as possible. But what if you are working on a system that needs to be fast? How should performance considerations affect the design process? This chapter discusses how to achieve high performance without sacrificing clean design. The most important idea is still simplicity: not only does simplicity improve a system’s design, but it usually makes systems faster.</p>\n<blockquote>\n<p>到目前为止，关于软件设计的讨论都集中在复杂性上。目标是使软件尽可能简单易懂。但是，如果您在需要快速的系统上工作，该怎么办？性能方面的考虑应如何影响设计过程？本章讨论如何在不牺牲简洁设计的情况下实现高性能。最重要的想法仍然是简单性：简单性不仅可以改善系统的设计，而且通常可以使系统更快。</p>\n</blockquote>\n<h2 id=\"20-1-How-to-think-about-performance-如何考虑性能\"><a href=\"#20-1-How-to-think-about-performance-如何考虑性能\" class=\"headerlink\" title=\"20.1 How to think about performance 如何考虑性能\"></a>20.1 How to think about performance 如何考虑性能</h2><p>The first question to address is “how much should you worry about performance during the normal development process?” If you try to optimize every statement for maximum speed, it will slow down development and create a lot of unnecessary complexity. Furthermore, many of the “optimizations” won’t actually help performance. On the other hand, if you completely ignore performance issues, it’s easy to end up with a large number of significant inefficiencies spread throughout the code; the resulting system can easily be 5–10x slower than it needs to be. In this “death by a thousand cuts” scenario it’s hard to come back later and improve the performance, because there is no single improvement that will have much impact.</p>\n<blockquote>\n<p>要解决的第一个问题是“您在正常的开发过程中应该为性能多少担心？” 如果您尝试优化每条语句以获得最大速度，则它将减慢开发速度并产生许多不必要的复杂性。此外，许多“优化”实际上对性能没有帮助。另一方面，如果您完全忽略了性能问题，则很容易导致遍及整个代码的大量效率低下。结果系统很容易比所需的速度慢 5–10 倍。在这种“千刀砍死”的情况下，以后很难再回来提高性能了，因为没有单一的改进会产生很大的影响。</p>\n</blockquote>\n<p>The best approach is something between these extremes, where you use basic knowledge of performance to choose design alternatives that are “naturally efficient” yet also clean and simple. The key is to develop an awareness of which operations are fundamentally expensive. Here are a few examples of operations that are relatively expensive today:</p>\n<blockquote>\n<p>最好的方法是介于这两种极端之间，在这种极端情况下，您可以使用性能的基本知识来选择“自然高效”但又干净又简单的设计替代方案。关键是要了解哪些操作根本是昂贵的。以下是一些今天相对昂贵的操作示例：</p>\n</blockquote>\n<ul>\n<li>Network communication: even within a datacenter, a round-trip message exchange can take 10–50 µs, which is tens of thousands of instruction times. Wide-area round-trips can take 10–100 ms.</li>\n<li>I/O to secondary storage: disk I/O operations typically take 5–10 ms, which is millions of instruction times. Flash storage takes 10–100 µs. New emerging nonvolatile memories may be as fast as 1 µs, but this is still around 2000 instruction times.</li>\n<li>Dynamic memory allocation (malloc in C, new in C++ or Java) typically involves significant overhead for allocation, freeing, and garbage collection.</li>\n<li>Cache misses: fetching data from DRAM into an on-chip processor cache takes a few hundred instruction times; in many programs, overall performance is determined as much by cache misses as by computational costs.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>网络通信：即使在数据中心内，往返消息交换也可能花费 10–50 µs，这是数以万计的指令时间。广域往返可能需要 10 到 100 毫秒。</li>\n<li>I/O 到辅助存储：磁盘 I/O 操作通常需要 5 到 10 毫秒，这是数百万条指令时间。闪存存储需要 10–100 µs。新出现的非易失性存储器的速度可能高达 1 µs，但这仍约为 2000 条指令时间。</li>\n<li>动态内存分配（C 语言中的 malloc，C ++或 Java 中的新增功能）通常涉及分配，释放和垃圾回收的大量开销。</li>\n<li>高速缓存未命中：将数据从 DRAM 提取到片上处理器高速缓存中需要数百条指令时间；在许多程序中，整体性能取决于缓存未命中和计算成本。</li>\n</ul>\n</blockquote>\n<p>The best way to learn which things are expensive is to run micro-benchmarks (small programs that measure the cost of a single operation in isolation). In the RAMCloud project, we created a simple program that provides a framework for microbenchmarks. It took a few days to create the framework, but the framework makes it possible to add new micro-benchmarks in five or ten minutes. This has allowed us to accumulate dozens of micro-benchmarks. We use these both to understand the performance of existing libraries used in RAMCloud, and also to measure the performance of new classes written for RAMCloud.</p>\n<blockquote>\n<p>了解哪些东西最昂贵的最好方法是运行微基准测试（小型程序，这些程序单独测量单个操作的成本）。在 RAMCloud 项目中，我们创建了一个简单的程序，该程序提供了微基准测试的框架。创建该框架花了几天时间，但是该框架使在五到十分钟内添加新的微基准成为可能。这使我们积累了几十个微基准。我们既可以使用它们来了解 RAMCloud 中使用的现有库的性能，也可以衡量为 RAMCloud 编写的新类的性能。</p>\n</blockquote>\n<p>Once you have a general sense for what is expensive and what is cheap, you can use that information to choose cheap operations whenever possible. In many cases, a more efficient approach will be just as simple as a slower approach. For example, when storing a large collection of objects that will be looked up using a key value, you could use either a hash table or an ordered map. Both are commonly available in library packages, and both are simple and clean to use. However, hash tables can easily be 5–10x faster. Thus, you should always use a hash table unless you need the ordering properties provided by the map.</p>\n<blockquote>\n<p>一旦对什么是昂贵和什么便宜有了一般的认识，就可以使用该信息尽可能地选择便宜的业务。在许多情况下，更有效的方法将与较慢的方法一样简单。例如，当存储将使用键值查找的大量对象时，可以使用哈希表或有序映射。两者都通常在库包中提供，并且都简单易用。但是，哈希表可以轻松地快 5-10 倍。因此，除非需要地图提供的排序属性，否则应始终使用哈希表。</p>\n</blockquote>\n<p>As another example, consider allocating an array of structures in a language such as C or C++. There are two ways you can do this. One way is for the array to hold pointers to structures, in which case you must first allocate space for the array, then allocate space for each individual structure. It is much more efficient to store the structures in the array itself, so you only allocate one large block for everything.</p>\n<blockquote>\n<p>作为另一个示例，请考虑使用诸如 C 或 C ++之类的语言分配结构数组。有两种方法可以执行此操作。一种方法是让数组保留指向结构的指针，在这种情况下，您必须首先为数组分配空间，然后为每个单独的结构分配空间。将结构存储在数组本身中效率要高得多，因此您只为所有内容分配一个大块。</p>\n</blockquote>\n<p>If the only way to improve efficiency is by adding complexity, then the choice is more difficult. If the more efficient design adds only a small amount of complexity, and if the complexity is hidden, so it doesn’t affect any interfaces, then it may be worthwhile (but beware: complexity is incremental). If the faster design adds a lot of implementation complexity, or if it results in more complicated interfaces, then it may be better to start off with the simpler approach and optimize later if performance turns out to be a problem. However, if you have clear evidence that performance will be important in a particular situation, then you might as well implement the faster approach immediately.</p>\n<blockquote>\n<p>如果提高效率的唯一方法是增加复杂性，那么选择就更加困难。如果更高效的设计仅增加了少量复杂性，并且复杂性是隐藏的，因此它不影响任何接口，那么它可能是值得的（但要注意：复杂性是递增的）。如果更快的设计增加了很多实现复杂性，或者导致更复杂的接口，那么最好是从更简单的方法开始，然后在性能出现问题时进行优化。但是，如果您有明确的证据表明性能在特定情况下很重要，那么您最好立即实施更快的方法。</p>\n</blockquote>\n<p>In the RAMCloud project one of our overall goals was to provide the lowest possible latency for client machines accessing the storage system over a datacenter network. As a result, we decided to use special hardware for networking, which allowed RAMCloud to bypass the kernel and communicate directly with the network interface controller to send and receive packets. We made this decision even though it added complexity, because we knew from prior measurements that kernel-based networking would be too slow to meet our needs. In most of the rest of the RAMCloud system we were able to design for simplicity; getting this one big issue “right” made many other things easier.</p>\n<blockquote>\n<p>在 RAMCloud 项目中，我们的总体目标之一是为客户端计算机通过数据中心网络访问存储系统提供尽可能低的延迟。结果，我们决定使用特殊的硬件进行联网，从而使 RAMCloud 绕过内核并直接与网络接口控制器进行通信以发送和接收数据包。即使增加了复杂性，我们还是做出了这个决定，因为我们从先前的测量中知道，基于内核的网络太慢了，无法满足我们的需求。在其余的 RAMCloud 系统中，我们能够进行简单设计。解决这个大问题“对”使其他事情变得更加容易。</p>\n</blockquote>\n<p>In general, simpler code tends to run faster than complex code. If you have defined away special cases and exceptions, then no code is needed to check for those cases and the system runs faster. Deep classes are more efficient than shallow ones, because they get more work done for each method call. Shallow classes result in more layer crossings, and each layer crossing adds overhead.</p>\n<blockquote>\n<p>通常，较简单的代码往往比复杂的代码运行更快。如果您定义了特殊情况和例外，则无需代码即可检查这些情况，并且系统运行速度更快。深层类比浅层类更有效，因为它们为每个方法调用完成了更多工作。浅类会导致更多的层交叉，并且每个层交叉都会增加开销。</p>\n</blockquote>\n<h2 id=\"20-2-Measure-before-modifying-修改前的度量\"><a href=\"#20-2-Measure-before-modifying-修改前的度量\" class=\"headerlink\" title=\"20.2 Measure before modifying 修改前的度量\"></a>20.2 Measure before modifying 修改前的度量</h2><p>But suppose that your system is still too slow, even though you have designed it as described above. It’s tempting to rush off and start making performance tweaks, based on your intuitions about what is slow. Don’t do this! Programmers’ intuitions about performance are unreliable. This is true even for experienced developers. If you start making changes based on intuition, you’ll waste time on things that don’t actually improve performance, and you’ll probably make the system more complicated in the process.</p>\n<blockquote>\n<p>但是，即使您如上所述进行设计，也请假设您的系统仍然太慢。根据您对慢速运动的直觉，急于着手开始进行性能调整。不要这样！程序员对性能的直觉是不可靠的。即使对于有经验的开发人员也是如此。如果您开始根据直觉进行更改，则会浪费时间在实际上无法提高性能的事情上，并且可能会使系统变得更加复杂。</p>\n</blockquote>\n<p>Before making any changes, measure the system’s existing behavior. This serves two purposes. First, the measurements will identify the places where performance tuning will have the biggest impact. It isn’t sufficient just to measure the top-level system performance. This may tell you that the system is too slow, but it won’t tell you why. You’ll need to measure deeper to identify in detail the factors that contribute to overall performance; the goal is to identify a small number of very specific places where the system is currently spending a lot of time, and where you have ideas for improvement. The second purpose of the measurements is to provide a baseline, so that you can re-measure performance after making your changes to ensure that performance actually improved. If the changes didn’t make a measurable difference in performance, then back them out (unless they made the system simpler). There’s no point in retaining complexity unless it provides a significant speedup.</p>\n<blockquote>\n<p>进行任何更改之前，请测量系统的现有行为。这有两个目的。首先，这些测量将确定性能调整将产生最大影响的地方。仅仅测量顶级系统性能是不够的。这可能会告诉您系统速度太慢，但不会告诉您原因。您需要进行更深入的衡量，以详细确定影响整体绩效的因素；目标是确定系统当前花费大量时间的少量非常具体的地方，以及您有改进想法的地方。测量的第二个目的是提供基线，以便您可以在进行更改后重新测量性能，以确保性能得到实际改善。如果这些更改并未在效果上带来可衡量的变化，然后将其退出（除非它们使系统更简单）。除非能够显着提高速度，否则保持复杂性毫无意义。</p>\n</blockquote>\n<h2 id=\"20-3-Design-around-the-critical-path-围绕关键路径进行设计\"><a href=\"#20-3-Design-around-the-critical-path-围绕关键路径进行设计\" class=\"headerlink\" title=\"20.3 Design around the critical path 围绕关键路径进行设计\"></a>20.3 Design around the critical path 围绕关键路径进行设计</h2><p>At this point, let’s assume that you have carefully analyzed performance and have identified a piece of code that is slow enough to affect the overall system performance. The best way to improve its performance is with a “fundamental” change, such as introducing a cache, or using a different algorithmic approach (balanced tree vs. list, for instance). Our decision to bypass the kernel for network communication in RAMCloud is an example of a fundamental fix. If you can identify a fundamental fix, then you can implement it using the design techniques discussed in previous chapters.</p>\n<blockquote>\n<p>在这一点上，我们假设您已经仔细分析了性能，并确定了一段缓慢的代码来影响整个系统的性能。改善其性能的最佳方法是进行“根本”更改，例如引入缓存，或使用其他算法方法（例如，平衡树与列表）。我们决定绕过内核进行 RAMCloud 中的网络通信的决定是一个基本修补程序的示例。如果您可以确定基本修复程序，则可以使用前面各章中讨论的设计技术来实施它。</p>\n</blockquote>\n<p>Unfortunately, situations will sometimes arise where there isn’t a fundamental fix. This brings us to the core issue for this chapter, which is how to redesign an existing piece of code so that it runs faster. This should be your last resort, and it shouldn’t happen often, but there are cases where it can make a big difference. The key idea is to design the code around the critical path.</p>\n<blockquote>\n<p>不幸的是，有时会出现一些根本无法解决的情况。这将我们带到本章的核心问题，即如何重新设计现有代码，使其运行更快。这应该是您的不得已的方法，并且不应该经常发生，但是在某些情况下它可能会带来很大的不同。关键思想是围绕关键路径设计代码。</p>\n</blockquote>\n<p>Start off by asking yourself what is the smallest amount of code that must be executed to carry out the desired task in the common case. Disregard any existing code structure. Imagine instead that you are writing a new method that implements just the critical path, which is the minimum amount of code that must be executed in the the most common case. The current code is probably cluttered with special cases; ignore them in this exercise. The current code might pass through several method calls on the critical path; imagine instead that you could put all the relevant code in a single method. The current code may also use a variety of variables and data structures; consider only the data needed for the critical path, and assume whatever data structure is most convenient for the critical path. For example, it may make sense to combine multiple variables into a single value. Assume that you could completely redesign the system in order to minimize the code that must be executed for the critical path. Let’s call this code “the ideal.”</p>\n<blockquote>\n<p>首先，问自己在通常情况下执行所需任务必须执行的最少代码量是多少。忽略任何现有的代码结构。相反，想象一下您正在编写一个仅实现关键路径的新方法，这是在最常见的情况下必须执行的最少代码量。当前的代码可能充满特殊情况。在此练习中，请忽略它们。当前的代码可能会在关键路径上通过多个方法调用。想象一下，您可以将所有相关代码放在一个方法中。当前代码还可以使用各种变量和数据结构。仅考虑关键路径所需的数据，并假定最适合关键路径的任何数据结构。例如，将多个变量合并为一个值可能很有意义。假设您可以完全重新设计系统，以最大程度地减少必须为关键路径执行的代码。我们将此代码称为“理想”。</p>\n</blockquote>\n<p>The ideal code probably clashes with your existing class structure, and it may not be practical, but it provides a good target: this represents the simplest and fastest that the code can ever be. The next step is to look for a new design that comes as close as possible to the ideal while still having a clean structure. You can apply all of the design ideas from previous chapters of this book, but with the additional constraint of keeping the ideal code (mostly) intact. You may have to add a bit of extra code to the ideal in order to allow clean abstractions; for example, if the code involves a hash table lookup, it’s OK to introduce an extra method call to a general-purpose hash table class. In my experience it’s almost always possible to find a design that is clean and simple, yet comes very close to the ideal.</p>\n<blockquote>\n<p>理想的代码可能会与您现有的类结构冲突，并且可能不切实际，但它提供了一个很好的目标：这代表了代码可能是最简单，最快的。下一步是寻找一种新设计，使其尽可能接近理想状态，同时又要保持干净的结构。您可以应用本书前面各章中的所有设计思想，但要保持（最好）保持理想代码的附加约束。您可能需要在理想情况下添加一些额外的代码，以允许使用简洁的抽象。例如，如果代码涉及哈希表查找，则可以向通用哈希表类引入额外的方法调用。以我的经验，几乎总是可以找到干净简洁的设计，但非常接近理想。</p>\n</blockquote>\n<p>One of the most important things that happens in this process is to remove special cases from the critical path. When code is slow, it’s often because it must handle a variety of situations, and the code gets structured to simplify the handling of all the different cases. Each special case adds a little bit of code to the critical path, in the form of extra conditional statements and/or method calls. Each of these additions makes the code a bit slower. When redesigning for performance, try to minimize the number of special cases you must check. Ideally, there will be a single if statement at the beginning, which detects all special cases with one test. In the normal case, only this one test will need to be made, after which the the critical path can be executed with no additional tests for special cases. If the initial test fails (which means a special case has occurred) the code can branch to a separate place off the critical path to handle it. Performance isn’t as important for special cases, so you can structure the special-case code for simplicity rather than performance.</p>\n<blockquote>\n<p>在此过程中发生的最重要的事情之一是从关键路径中除去特殊情况。当代码运行缓慢时，通常是因为它必须处理各种情况，并且代码经过结构化以简化所有不同情况的处理。每个特殊情况都以额外的条件语句和/或方法调用的形式向关键路径添加了一些代码。这些添加中的每一个都会使代码变慢。重新设计性能时，请尝试减少必须检查的特殊情况的数量。理想情况下，开头应该有一个 if 语句，该语句可以通过一个测试检测所有特殊情况。在正常情况下，只需要进行一项测试，之后就可以执行关键路径，而对于特殊情况则无需进行其他测试。如果初始测试失败（这意味着发生了特殊情况），则代码可以分支到关键路径之外的单独位置以进行处理。对于特殊情况，性能并不是那么重要，因此您可以为简化而不是性能来构造特殊情况的代码。</p>\n</blockquote>\n<h2 id=\"20-4-An-example-RAMCloud-Buffers-示例：RAMCloud-缓冲区\"><a href=\"#20-4-An-example-RAMCloud-Buffers-示例：RAMCloud-缓冲区\" class=\"headerlink\" title=\"20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区\"></a>20.4 An example: RAMCloud Buffers 示例：RAMCloud 缓冲区</h2><p>Let’s consider an example, in which the Buffer class of the RAMCloud storage system was optimized to achieve a speedup of about 2x for the most common operations.</p>\n<blockquote>\n<p>让我们考虑一个示例，其中 RAMCloud 存储系统的 Buffer 类经过优化，以使大多数常见操作的速度提高约 2 倍。</p>\n</blockquote>\n<p>RAMCloud uses Buffer objects to manage variable-length arrays of memory, such as request and response messages for remote procedure calls. Buffers are designed to reduce overheads from memory copying and dynamic storage allocation. A Buffer stores what appears to be a linear array of bytes, but for efficiency it allows the underlying storage to be divided into multiple discontiguous chunks of memory, as shown in Figure 20.1. A Buffer is created by appending chunks of data. Each chunk is either external or internal. If a chunk is external, its storage is owned by the caller; the Buffer keeps a reference to this storage. External chunks are typically used for large chunks in order to avoid memory copies. If a chunk is internal, the Buffer owns the storage for the chunk; data supplied by the caller is copied into the Buffer’s internal storage. Each Buffer contains a small built-in allocation, which is a block of memory available for storing internal chunks. If this space is exhausted, then the Buffer creates additional allocations, which must be freed when the Buffer is destroyed. Internal chunks are convenient for small chunks where the memory copying costs are negligible. Figure 20.1 shows a Buffer with 5 chunks: the first chunk is internal, the next two are external, and the final two chunks are internal.</p>\n<blockquote>\n<p>RAMCloud 使用 Buffer 对象管理可变长度的内存数组，例如远程过程调用的请求和响应消息。缓冲区旨在减少内存复制和动态存储分配的开销。缓冲区存储看似线性的字节数组，但是为了提高效率，它允许将底层存储划分为多个不连续的内存块，如图 20.1 所示。通过附加数据块来创建缓冲区。每个块都是外部的或内部的。如果块在外部，则其存储由调用方拥有；缓冲区保留对此存储的引用。外部块通常用于大型块，以避免内存复制。如果内部有块，则 Buffer 拥有该块的存储；调用者提供的数据将被复制到缓冲区的内部存储器中。每个缓冲区包含一个小的内置分配，这是一个内存块，可用于存储内部块。如果此空间已用完，则缓冲区将创建其他分配，销毁缓冲区时必须释放这些分配。内部块对于内存复制成本可忽略不计的小块很方便。图 20.1 显示了具有 5 个块的 Buffer：第一个块是内部的，接下来的两个块是外部的，最后两个块是内部的。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00022.jpeg\" alt=\"\"></p>\n<p>Figure 20.1: A Buffer object uses a collection of memory chunks to store what appears to be a linear array of bytes. Internal chunks are owned by the Buffer and freed when the Buffer is destroyed; external chunks are not owned by the Buffer.</p>\n<blockquote>\n<p>图 20.1：Buffer 对象使用内存块的集合来存储看似线性字节数组。内部块由 Buffer 拥有，并在 Buffer 销毁时释放；外部块不属于缓冲区。</p>\n</blockquote>\n<p>The Buffer class itself represents a “fundamental fix,” in that it eliminates expensive memory copies that would have been required without it. For example, when assembling a response message containing a short header and the contents of a large object in the RAMCloud storage system, RAMCloud uses a Buffer with two chunks. The first chunk is an internal one that contains the header; the second chunk is an external one that refers to the object contents in the RAMCloud storage system. The response can be collected in the Buffer without copying the large object.</p>\n<blockquote>\n<p>Buffer 类本身代表“根本性的修补程序”，因为它消除了没有它就需要的昂贵的内存副本。例如，在 RAMCloud 存储系统中组装包含短标头和大对象内容的响应消息时，RAMCloud 使用带有两个块的 Buffer。第一个块是包含头的内部块；第二个块是一个外部块，它引用 RAMCloud 存储系统中的对象内容。可以在不复制大对象的情况下将响应收集到缓冲区中。</p>\n</blockquote>\n<p>Aside from the fundamental approach of allowing discontiguous chunks, we did not attempt to optimize the code of the Buffer class in the original implementation. Over time, however, we noticed Buffers being used in more and more situations; for example, at least four Buffers are created during the execution of each remote procedure call. Eventually, it became clear that speeding up the implementation of Buffer could have a noticeable impact on overall system performance. We decided to see if we could improve the performance of the Buffer class.</p>\n<blockquote>\n<p>除了允许不连续块的基本方法外，我们没有尝试在原始实现中优化 Buffer 类的代码。但是，随着时间的流逝，我们注意到缓冲区越来越多地被使用。例如，在每个远程过程调用的执行期间，至少创建四个缓冲区。最终，很明显，加速 Buffer 的实现可能会对整体系统性能产生显着影响。我们决定看看是否可以提高 Buffer 类的性能。</p>\n</blockquote>\n<p>The most common operation for Buffer is to allocate space for a small amount of new data using an internal chunk. This happens, for example, when creating headers for request and response messages. We decided to use this operation as the critical path for optimization. In the simplest possible case, the space can be allocated by enlarging the last existing chunk in the Buffer. However, this is only possible if the last existing chunk is internal, and if there is enough space in its allocation to accommodate the new data. The ideal code would perform a single check to confirm that the simple approach is possible, then it would adjust the size of the existing chunk.</p>\n<blockquote>\n<p>Buffer 最常见的操作是使用内部块为少量新数据分配空间。例如，在为请求和响应消息创建标题时，就会发生这种情况。我们决定将此操作用作优化的关键路径。在最简单的情况下，可以通过扩大 Buffer 中最后存在的块来分配空间。但是，只有在最后一个现有块位于内部，并且其分配中有足够的空间来容纳新数据时，才有可能这样做。理想的代码将执行一次检查以确认简单方法是否可行，然后将调整现有块的大小。</p>\n</blockquote>\n<p>Figure 20.2 shows the original code for the critical path, which starts with the method Buffer::alloc. In the fastest possible case, Buffer::alloc calls Buffer:: allocateAppend, which calls Buffer::Allocation::allocateAppend. From a performance standpoint, this code has two problems. The first problem is that numerous special cases are checked individually:</p>\n<blockquote>\n<p>图 20.2 显示了关键路径的原始代码，该代码以 Buffer :: alloc 方法开头。在最快的情况下，Buffer :: alloc 调用 Buffer :: allocateAppend，后者调用 Buffer :: Allocation :: allocateAppend。从性能的角度来看，此代码有两个问题。第一个问题是要单独检查许多特殊情况：</p>\n</blockquote>\n<ul>\n<li>Buffer::allocateAppend checks to see if the Buffer currently has any allocations.</li>\n<li>The code checks twice to see if the current allocation has enough room for the new data: once in Buffer::Allocation::allocateAppend, and again when its return value is tested by Buffer::allocateAppend.</li>\n<li>Buffer::alloc tests the return value from Buffer::allocAppend to confirm yet again that the allocation succeeded.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>Buffer::allocateAppend 检查缓冲区当前是否有任何分配。</li>\n<li>代码检查两次以查看当前分配是否有足够的空间容纳新数据：一次在 Buffer::Allocation::allocateAppend 中，一次在其返回值由 Buffer::allocateAppend 测试时。</li>\n<li>Buffer::alloc 测试 Buffer::allocAppend 的返回值，以再次确认分配成功。</li>\n</ul>\n</blockquote>\n<p>Furthermore, rather than trying to expand the last chunk directly, the code allocates new space without any consideration of the last chunk. Then Buffer::alloc checks to see if that space happens to be adjacent to the last chunk, in which case it merges the new space with the existing chunk. This results in additional checks. Overall, this code tests 6 distinct conditions in the critical path.</p>\n<blockquote>\n<p>此外，该代码没有尝试直接扩展最后一个块，而是在不考虑最后一个块的情况下分配了新空间。然后，Buffer::alloc 检查该空间是否恰好与最后一块相邻，在这种情况下，它将新空间与现有块合并。这导致其他检查。总体而言，此代码测试关键路径中的 6 种不同条件。</p>\n</blockquote>\n<p>The second problem with the original code is that it has too many layers, all of which are shallow. This is both a performance problem and a design problem. The critical path makes two additional method calls in addition to the original invocation of Buffer::alloc. Each method call takes additional time, and the result of each call must be checked by its caller, which results in more special cases to consider. Chapter 7 discussed how abstractions should normally change as you pass from one layer to another, but all three of the methods in Figure 20.2 have identical signatures and they provide essentially the same abstraction; this is a red flag. Buffer::allocateAppend is nearly a pass-though method; its only contribution is to create a new allocation if needed. The extra layers make the code both slower and more complicated.</p>\n<blockquote>\n<p>原始代码的第二个问题是它具有太多的层，所有层都很浅。这既是性能问题，也是设计问题。关键路径除了对 Buffer::alloc 的原始调用之外，还进行了另外两个方法调用。每个方法调用花费额外的时间，并且每个调用的结果必须由其调用者检查，这导致需要考虑更多特殊情况。第 7 章讨论了当您从一层传递到另一层时，抽象通常应该如何变化，但是图 20.2 中的所有三种方法都具有相同的签名，并且它们提供了基本相同的抽象。这是一个危险信号。Buffer::allocateAppend 几乎是一个传递方法；它的唯一作用是在需要时创建新的分配。额外的层使代码既慢又复杂。</p>\n</blockquote>\n<p>To fix these problems, we refactored the Buffer class so that its design is centered around the most performance-critical paths. We considered not just the allocation code above but several other commonly executed paths, such as retrieving the total number of bytes of data currently stored in a Buffer. For each of these critical paths, we tried to identify the smallest amount of code that must be executed in the common case. Then we designed the rest of the class around these critical paths. We also applied the design principles from this book to simplify the class in general. For example, we eliminated shallow layers and created deeper internal abstractions. The refactored class is 20% smaller than the original version (1476 lines of code, versus 1886 lines in the original).</p>\n<blockquote>\n<p>为了解决这些问题，我们重构了 Buffer 类，使其设计围绕最关键性能的路径进行。我们不仅考虑了上面的分配代码，还考虑了其 ​​ 他几种常用的执行路径，例如检索当前存储在 Buffer 中的数据的字节总数。对于这些关键路径中的每一个，我们试图确定在通常情况下必须执行的最少代码量。然后，我们围绕这些关键路径设计了课程的其余部分。我们还应用了本书中的设计原则来简化整个类。例如，我们消除了浅层并创建了更深的内部抽象。重构的类比原始版本小 20％（1476 行代码，而原始版本为 1886 行）。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00023.gif\" alt=\"\"></p>\n<p>Figure 20.2: The original code for allocating new space at the end of a Buffer, using an internal chunk.</p>\n<blockquote>\n<p>图 20.2：使用内部块在 Buffer 的末尾分配新空间的原始代码。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00024.gif\" alt=\"\"></p>\n<p>Figure 20.3: The new code for allocating new space in an internal chunk of a Buffer.</p>\n<blockquote>\n<p>图 20.3：用于在 Buffer 的内部块中分配新空间的新代码。</p>\n</blockquote>\n<p>Figure 20.3 shows the new critical path for allocating internal space in a Buffer. The new code is not only faster, but it is also easier to read, since it avoids shallow abstractions. The entire path is handled in a single method, and it uses a single test to rule out all of the special cases. The new code introduces a new instance variable, extraAppendBytes, in order to simplify the critical path. This variable keeps track of how much unused space is available immediately after the last chunk in the Buffer. If there is no space available, or if the last chunk in the Buffer isn’t an internal chunk, or if the Buffer contains no chunks at all, then extraAppendBytes is zero. The code in Figure 20.3 represents the least possible amount of code to handle this common case.</p>\n<blockquote>\n<p>图 20.3 显示了用于在 Buffer 中分配内部空间的新关键路径。新代码不仅速度更快，而且更容易阅读，因为它避免了浅层抽象。整个路径使用单一方法处理，并且使用单一测试排除所有特殊情况。新代码引入了新的实例变量 extraAppendBytes，以简化关键路径。此变量跟踪缓冲区中最后一个块之后立即有多少未使用空间可用。如果没有可用空间，或者 Buffer 中的最后一个块不是内部块，或者 Buffer 根本不包含任何块，则 extraAppendBytes 为零。图 20.3 中的代码表示处理这种常见情况的最少代码量。</p>\n</blockquote>\n<p>Note: the update to totalLength could have been eliminated by recomputing the total Buffer length from the individual chunks whenever it is needed. However, this approach would be expensive for a large Buffer with many chunks, and fetching the total Buffer length is another common operation. Thus, we chose to add a small amount of extra overhead to alloc in order to ensure that the Buffer length is always immediately available.</p>\n<blockquote>\n<p>注意：只要需要，就可以通过重新计算各个块的总缓冲区长度来消除对 totalLength 的更新。但是，这种方法对于具有许多块的大型 Buffer 而言将是昂贵的，并且获取 Buffer 的总长度是另一种常见的操作。因此，我们选择添加少量额外的开销来分配，以确保 Buffer 长度始终立即可用。</p>\n</blockquote>\n<p>The new code is about twice as fast as the old code: the total time to append a 1-byte string to a Buffer using internal storage dropped from 8.8 ns to 4.75 ns. Many other Buffer operations also speeded up because of the revisions. For example, the time to construct a new Buffer, append a small chunk in internal storage, and destroy the Buffer dropped from 24 ns to 12 ns.</p>\n<blockquote>\n<p>新代码的速度约为旧代码的两倍：使用内部存储将 1 字节字符串附加到缓冲区的总时间从 8.8 ns 降低到 4.75 ns。由于修订，许多其他缓冲区操作也加快了速度。例如，构建新缓冲区，在内部存储中附加一小块并销毁缓冲区所需的时间从 24 ns 降至 12 ns。</p>\n</blockquote>\n<h2 id=\"20-5-Conclusion-结论\"><a href=\"#20-5-Conclusion-结论\" class=\"headerlink\" title=\"20.5 Conclusion 结论\"></a>20.5 Conclusion 结论</h2><p>The most important overall lesson from this chapter is that clean design and high performance are compatible. The Buffer class rewrite improved its performance by a factor of 2 while simplifying its design and reducing code size by 20%. Complicated code tends to be slow because it does extraneous or redundant work. On the other hand, if you write clean, simple code, your system will probably be fast enough that you don’t have to worry much about performance in the first place. In the few cases where you do need to optimize performance, the key is simplicity again: find the critical paths that are most important for performance and make them as simple as possible.</p>\n<blockquote>\n<p>本章最重要的总体教训是，干净的设计和高性能是兼容的。重写 Buffer 类可将其性能提高 2 倍，同时简化其设计并将代码大小减少 20％。复杂的代码通常会很慢，因为它会执行多余或多余的工作。另一方面，如果您编写干净，简单的代码，则系统可能会足够快，因此您一开始就不必担心性能。在少数需要优化性能的情况下，关键再次是简单性：找到对性能最重要的关键路径并使它们尽可能简单。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch9","date":"2021-02-08T16:00:00.000Z","_content":"在一起更好还是分开更好？\n<!-- more -->\n# 第 9 章 在一起更好还是分开更好？\n\n> Chapter 9 Better Together Or Better Apart?\n\nOne of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated? This question applies at all levels in a system, such as functions, methods, classes, and services. For example, should buffering be included in the class that provides stream-oriented file I/O, or should it be in a separate class? Should the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)? This chapter discusses the factors to consider when making these decisions. Some of these factors have already been discussed in previous chapters, but they will be revisited here for completeness.\n\n> 软件设计中最基本的问题之一是：给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？这个问题适用于系统中的所有级别，例如功能，方法，类和服务。例如，应该在提供面向流的文件 I/O 的类中包括缓冲，还是应该在单独的类中？HTTP 请求的解析应该完全在一种方法中实现，还是应该在多个方法（甚至多个类）之间划分？本章讨论做出这些决定时要考虑的因素。这些因素中的一些已经在前面的章节中进行了讨论，但是为了完整起见，这里将对其进行重新讨论。\n\nWhen deciding whether to combine or separate, the goal is to reduce the complexity of the system as a whole and improve its modularity. It might appear that the best way to achieve this goal is to divide the system into a large number of small components: the smaller the components, the simpler each individual component is likely to be. However, the act of subdividing creates additional complexity that was not present before subdivision:\n\n> 在决定是合并还是分开时，目标是降低整个系统的复杂性并改善其模块化。看来实现此目标的最佳方法是将系统划分为大量的小组件：组件越小，每个单独的组件可能越简单。但是，细分的行为会带来额外的复杂性，而这在细分之前是不存在的：\n\n- Some complexity comes just from the number of components: the more components, the harder to keep track of them all and the harder to find a desired component within the large collection. Subdivision usually results in more interfaces, and every new interface adds complexity.\n- Subdivision can result in additional code to manage the components. For example, a piece of code that used a single object before subdivision might now have to manage multiple objects.\n- Subdivision creates separation: the subdivided components will be farther apart than they were before subdivision. For example, methods that were together in a single class before subdivision may be in different classes after subdivision, and possibly in different files. Separation makes it harder for developers to see the components at the same time, or even to be aware of their existence. If the components are truly independent, then separation is good: it allows the developer to focus on a single component at a time, without being distracted by the other components. On the other hand, if there are dependencies between the components, then separation is bad: developers will end up flipping back and forth between the components. Even worse, they may not be aware of the dependencies, which can lead to bugs.\n- Subdivision can result in duplication: code that was present in a single instance before subdivision may need to be present in each of the subdivided components.\n\n---\n\n> - 一些组件的复杂性仅来自组件的数量：组件越多，就越难以追踪所有组件，也就越难在大型集合中找到所需的组件。细分通常会导致更多接口，并且每个新接口都会增加复杂性。\n> - 细分可能会导致附加代码来管理组件。例如，在细分之前使用单个对象的一段代码现在可能必须管理多个对象。\n> - 细分产生分离：细分后的组件将比细分前的组件相距更远。例如，在细分之前位于单个类中的方法可能在细分之后位于不同的类中，并且可能在不同的文件中。分离使开发人员更难于同时查看这些组件，甚至很难知道它们的存在。如果组件真正独立，那么分离是好的：它使开发人员可以一次专注于单个组件，而不会被其他组件分散注意力。另一方面，如果组件之间存在依赖性，则分离是不好的：开发人员最终将在组件之间来回翻转。更糟糕的是，他们可能不了解依赖关系，这可能导致错误。\n> - 细分可能导致重复：细分之前的单个实例中存在的代码可能需要存在于每个细分的组件中。\n\nBringing pieces of code together is most beneficial if they are closely related. If the pieces are unrelated, they are probably better off apart. Here are a few indications that two pieces of code are related:\n\n> 如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开。以下是两个代码相关的一些提示：\n\n- They share information; for example, both pieces of code might depend on the syntax of a particular type of document.\n- They are used together: anyone using one of the pieces of code is likely to use the other as well. This form of relationship is only compelling if it is bidirectional. As a counter-example, a disk block cache will almost always involve a hash table, but hash tables can be used in many situations that don’t involve block caches; thus, these modules should be separate.\n- They overlap conceptually, in that there is a simple higher-level category that includes both of the pieces of code. For example, searching for a substring and case conversion both fall under the category of string manipulation; flow control and reliable delivery both fall under the category of network communication.\n- It is hard to understand one of the pieces of code without looking at the other.\n\n---\n\n> - 他们共享信息；例如，这两段代码都可能取决于特定类型文档的语法。\n> - 它们一起使用：任何使用其中一段代码的人都可能同时使用另一段代码。这种关系形式只有在双向关系中才具有吸引力。作为反例，磁盘块高速缓存几乎总是包含哈希表，但是哈希表可以在许多不涉及块高速缓存的情况下使用。因此，这些模块应该分开。\n> - 它们在概念上重叠，因为存在一个简单的更高级别的类别，其中包括这两段代码。例如，搜索子字符串和大小写转换都属于字符串操作类别。流控制和可靠的交付都属于网络通信的范畴。\n> - 不看其中的一段代码就很难理解。\n\nThe rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.\n\n> 本章的其余部分使用更具体的规则以及示例来说明何时将代码段组合在一起以及何时将它们分开是有意义的。\n\n## 9.1 Bring together if information is shared 如果信息共享则汇聚在一起\n\nSection 5.4 introduced this principle in the context of a project implementing an HTTP server. In its first implementation, the project used two different methods in different classes to read in and parse HTTP requests. The first method read the text of an incoming request from a network socket and placed it in a string object. The second method parsed the string to extract the various components of the request. With this decomposition, both of the methods ended up with considerable knowledge of the format of HTTP requests: the first method was only trying to read the request, not parse it, but it couldn’t identify the end of the request without doing most of the work of parsing it (for example, it had to parse header lines in order to identify the header containing the overall request length). Because of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.\n\n> 5.4 节在实现 HTTP 服务器的项目上下文中介绍了此原理。在其第一个实现中，该项目在不同的类中使用了两种不同的方法来读取和解析 HTTP 请求。第一种方法从网络套接字读取传入请求的文本，并将其放置在字符串对象中。第二种方法解析字符串以提取请求的各个组成部分。经过这种分解，这两种方法最终都对 HTTP 请求的格式有了相当的了解：第一种方法只是尝试读取请求，而不是解析请求，但是如果不执行大多数操作，就无法确定请求的结束解析它的工作（例如，它必须解析标头行才能识别包含整个请求长度的标头）。由于此共享信息，最好在同一位置读取和解析请求；当两个类合而为一时，代码变得更短，更简单。\n\n## 9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面\n\nWhen two or more modules are combined into a single module, it may be possible to define an interface for the new module that is simpler or easier to use than the original interfaces. This often happens when the original modules each implement part of the solution to a problem. In the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second. When the methods were combined, these interfaces were eliminated.\n\n> 当两个或多个模块组合成一个模块时，可以为新模块定义一个比原始接口更简单或更易于使用的接口。当原始模块各自实现问题解决方案的一部分时，通常会发生这种情况。在上一部分的 HTTP 服务器示例中，原始方法需要一个接口来从第一个方法返回 HTTP 请求字符串并将其传递给第二个方法。当这些方法结合在一起时，这些接口就被淘汰了。\n\nIn addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them. The Java I/O library illustrates this opportunity. If the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering. A combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.\n\n> 另外，将两个或更多类的功能组合在一起时，可能会自动执行某些功能，因此大多数用户无需了解它们。Java I/O 库说明了这种机会。如果将 FileInputStream 和 BufferedInputStream 类组合在一起，并且默认情况下提供了缓冲，则绝大多数用户甚至都不需要知道缓冲的存在。组合的 FileInputStream 类可能提供禁用或替换默认缓冲机制的方法，但是大多数用户不需要了解它们。\n\n## 9.3 Bring together to eliminate duplication 消除重复\n\nIf you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeated code out into a separate method and replace the repeated code snippets with calls to the method. This approach is most effective if the repeated code snippet is long and the replacement method has a simple signature. If the snippet is only one or two lines long, there may not be much benefit in replacing it with a method call. If the snippet interacts in complex ways with its environment (such as by accessing numerous local variables), then the replacement method might require a complex signature (such as many pass-by-reference arguments), which would reduce its value.\n\n> 如果发现反复重复相同的代码模式，请查看是否可以重新组织代码以消除重复。一种方法是将重复的代码分解为一个单独的方法，并用对该方法的调用替换重复的代码段。如果重复的代码段很长并且替换方法具有简单的签名，则此方法最有效。如果代码段只有一两行，那么用方法调用替换它可能不会有太多好处。如果代码段与其环境以复杂的方式进行交互（例如，通过访问多个局部变量），则替换方法可能需要复杂的签名（例如，许多“按引用传递”参数），这会降低其价值。\n\nAnother way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writing a method that needs to return errors at several different points, and the same cleanup actions need to be performed at each of these points before returning (see Figure 9.1 for an example). If the programming language supports goto, you can move the cleanup code to the very end of the method and then goto that snippet at each of the points where an error return is required, as in Figure 9.2. Goto statements are generally considered a bad idea, and they can result in indecipherable code if used indiscriminately, but they are useful in situations like this where they are used to escape from nested code.\n\n> 消除重复的另一种方法是重构代码，使相关代码段仅需要在一个地方执行。假设您正在编写一种方法，该方法需要在几个不同的点返回错误，并且在返回之前需要在每个这些点执行相同的清除操作（示例请参见图 9.1）。如果编程语言支持 goto，则可以将清除代码移到方法的最后，然后在需要返回错误的每个点处转到该片段，如图 9.2 所示。Goto 语句通常被认为是一个坏主意，如果不加选择地使用它们，可能会导致无法识别的代码，但是在诸如此类的情况下，它们可用于从嵌套代码中转义，因此它们非常有用。\n\n## 9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码\n\nIf a module contains a mechanism that can be used for several different purposes, then it should provide just that one general-purpose mechanism. It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typically one associated with the particular purpose). The GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the selection) were implemented in the user interface module. This approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.\n\n> 如果模块包含可用于多种不同目的的机制，则它应仅提供一种通用机制。它不应包含专门针对特定用途的机制的代码，也不应包含其他通用机制。与通用机制关联的专用代码通常应放在不同的模块中（通常是与特定用途关联的模块）。第 6 章中的 GUI 编辑器讨论阐明了这一原理：最佳设计是文本类提供通用文本操作，而特定于用户界面的操作（例如删除所选内容）则在用户界面模块中实现。\n\nimg Red Flag: Repetition img\n\nIf the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.\n\n> 如果相同的代码（或几乎相同的代码）一遍又一遍地出现，那是一个危险信号，您没有找到正确的抽象。\n\n![](../../img/figures/00017.gif)\n\nFigure 9.1: This code processes incoming network packets of different types; for each type, if the packet is too short for that type, a message gets logged. In this version of the code, the LOG statement is duplicated for several different packet types.\n\n> 图 9.1：此代码处理不同类型的传入网络数据包。对于每种类型，如果数据包对于该类型而言太短，则会记录一条消息。在此版本的代码中，LOG 语句对于几种不同的数据包类型是重复的。\n\n![](../../img/figures/00018.gif)\n\nFigure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement.\n\n> 图 9.2：对图 9.1 中的代码进行了重新组织，因此只有 LOG 语句的一个副本。\n\nIn general, the lower layers of a system tend to be more general-purpose and the upper layers more special-purpose. For example, the topmost layer of an application consists of features totally specific to that application. The way to separate special-purpose code from general-purpose code is to pull the special-purpose code upwards, into the higher layers, leaving the lower layers general-purpose. When you encounter a class that includes both general-purpose and special-purpose features for the same abstraction, see if the class can be separated into two classes, one containing the general-purpose features, and the other layered on top of it to provide the special-purpose features.\n\n> 通常，系统的下层倾向于更通用，而上层则更专用。例如，应用程序的最顶层包含完全特定于该应用程序的功能。将专用代码与通用代码分开的方法是将专用代码向上拉到较高的层，而将较低的层保留为通用。当您遇到同时包含通用功能和专用功能的同一类的类时，请查看该类是否可以分为两个类，一个包含通用功能，另一个在其上分层以提供特殊功能\n\n## 9.5 Example: insertion cursor and selection 示例：插入光标和选择\n\nThe next sections work through three examples that illustrate the principles discussed above. In two of the examples the best approach is to separate the relevant pieces of code; in the third example it is better to join them together.\n\n> 下一节将通过三个示例说明上述原理。在两个示例中，最好的方法是分离相关的代码段。在第三个示例中，最好将它们结合在一起。\n\nThe first example consists of the insertion cursor and the selection in the GUI editor project from Chapter 6. The editor displayed a blinking vertical line indicating where text typed by the user would appear in the document. It also displayed a highlighted range of characters called the selection, which was used for copying or deleting text. The insertion cursor was always visible, but there could be times when no text was selected. If the selection existed, the insertion cursor was always positioned at one end of it.\n\n> 第一个示例由插入光标和第 6 章的 GUI 编辑器项目中的选择组成。编辑器显示闪烁的垂直线，指示用户键入的文本将出现在文档中的何处。它还显示了一个突出显示的字符范围，称为选择，用于复制或删除文本。插入光标始终可见，但是有时可能没有选择文本。如果存在选择，则插入光标始终位于其一端。\n\nThe selection and insertion cursor are related in some ways. For example, the cursor is always positioned at one end of the selection, and the cursor and selection tend to be manipulated together: clicking and dragging the mouse sets both of them, and text insertion first deletes the selected text, if there is any, and then inserts new text at the cursor position. Thus, it might seem logical to use a single object to manage both the selection and the cursor, and one project team took this approach. The object stored two positions in the file, along with booleans indicating which end was the cursor and whether the selection existed.\n\n> 选择和插入光标在某些方面相关。例如，光标始终位于所选内容的一端，并且倾向于将光标和所选内容一起操作：单击并拖动鼠标将它们都设置，然后插入文本会首先删除所选的文本（如果有），然后在光标位置插入新文本。因此，使用单个对象管理选择和光标似乎合乎逻辑，并且一个项目团队采用了这种方法。该对象在文件中存储了两个位置，以及布尔值，它们指示光标的哪一端以及选择是否存在。\n\nHowever, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text). The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separate entity, but instead had to store a boolean indicating which end of the selection was the cursor. In order to retrieve the cursor position, the combined object had to first test the boolean and then choose the appropriate end of the selection.\n\n> 但是，合并的对象很尴尬。它对高级代码没有任何好处，因为高级代码仍然需要将选择和游标视为不同的实体，并且对它们进行单独操作（在插入文本期间，它首先在组合对象上调用一个方法来删除选定的文本；然后调用另一个方法来检索光标位置，以插入新文本）。实际上，组合对象比单独的对象实现起来要复杂得多。它避免了将光标位置存储为单独的实体，而是不得不存储一个布尔值，该布尔值指示选择的哪一端是光标。为了检索光标位置，组合对象必须首先测试布尔值，然后选择选择的适当结尾。\n\nimg Red Flag: Special-General Mixture img\n\nThis red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.\n\n> 当通用机制还包含专门用于该机制的特定用途的代码时，就会出现此红色标志。这使该机制更加复杂，并在该机制与特定用例之间造成了信息泄漏：对用例的未来修改也可能需要对基础机制进行更改。\n\nIn this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler. Separate objects provided a simpler interface than a combined object from which selection and cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectly through a selection and a boolean. In fact, in the revised version no special classes were used for either the selection or the cursor. Instead, a new Position class was introduced to represent a location in the file (a line number and character within line). The selection was represented with two Positions and the cursor with one. Positions also found other uses in the project. This example also demonstrates the benefits of a lower-level but more general-purpose interface, which were discussed in Chapter 6.\n\n> 在这种情况下，选择和光标之间的关联度不足以将它们组合在一起。当修改代码以分隔选择和光标时，用法和实现都变得更加简单。与必须从中提取选择和光标信息的组合对象相比，单独的对象提供了更简单的界面。游标的实现也变得更加简单，因为游标的位置是直接表示的，而不是通过选择和布尔值间接表示的。实际上，在修订版中，没有特殊的类用于选择或游标。相反，引入了一个新的 Position 类来表示文件中的位置（行号和行内的字符）。选择用两个位置表示，光标用一个位置表示。职位还在项目中找到了其他用途。\n\n## 9.6 Example: separate class for logging 示例：用于记录的单独类\n\nThe second example involved error logging in a student project. A class contained several code sequences like the following:\n\n> 第二个示例涉及学生项目中的错误记录。一个类包含几个代码序列，如下所示：\n\n```java\ntry {\n    rpcConn = connectionPool.getConnection(dest);\n} catch (IOException e) {\n    NetworkErrorLogger.logRpcOpenError(req, dest, e);\n    return null;\n}\n```\n\nRather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked. The error logging class was defined at the end of the same source file:\n\n> 而不是在检测到错误时记录错误，而是调用特殊错误记录类中的单独方法。错误记录类是在同一源文件的末尾定义的：\n\n```java\nprivate static class NetworkErrorLogger {\n    /**\n    *  Output information relevant to an error that occurs when trying\n    *  to open a connection to send an RPC.\n    *\n    *  @param req\n    *       The RPC request that would have been sent through the connection\n    *  @param dest\n    *       The destination of the RPC\n    *  @param e\n    *       The caught error\n    */\n    public static void logRpcOpenError(RpcRequest req, AddrPortTuple dest, Exception e) {\n        logger.log(Level.WARNING, \"Cannot send message: \" + req + \". \\n\" + \"Unable to find or open connection to \" + dest + \" :\" + e);\n    }\n...\n}\n```\n\nThe NetworkErrorLogger class contained several methods such as logRpcSendError and logRpcReceiveError, each of which logged a different kind of error.\n\n> NetworkErrorLogger 类包含几个方法，例如 logRpcSendError 和 logRpcReceiveError，每个方法都记录了不同类型的错误。\n\nThis separation added complexity with no benefit. The logging methods were shallow: most consisted of a single line of code, but they required a considerable amount of documentation. Each method was only invoked in a single place. The logging methods were highly dependent on their invocations: someone reading the invocation would most likely flip over to the logging method to make sure that the right information was being logged; similarly, someone reading the logging method would probably flip over to the invocation site to understand the purpose of the method.\n\n> 这种分离增加了复杂性，没有任何好处。日志记录方法很浅：大多数只包含一行代码，但是它们需要大量的文档。每个方法仅在单个位置调用。日志记录方法高度依赖于它们的调用：读取调用的人很可能会切换到日志记录方法，以确保记录了正确的信息。同样，阅读日志记录方法的人可能会转到调用站点以了解该方法的目的。\n\nIn this example, it would be better to eliminate the logging methods and place the logging statements at the locations where the errors were detected. This would make the code easier to read and eliminate the interfaces required for the logging methods.\n\n> 在此示例中，最好消除日志记录方法，并将日志记录语句放置在检测到错误的位置。这将使代码更易于阅读，并消除了日志记录方法所需的接口。\n\n## 9.7 Example: editor undo mechanism 示例：编辑器撤消机制\n\nIn the GUI editor project from Section 6.2, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view. For example, if a user selected some text, deleted it, scrolled to a different place in the file, and then invoked undo, the editor had to restore its state to what it was just before the deletion. This included restoring the deleted text, selecting it again, and also making the selected text visible in the window.\n\n> 在 6.2 节的 GUI 编辑器项目中，要求之一是支持多级撤消/重做，不仅要更改文本本身，还要更改选择，插入光标和视图。例如，如果用户选择了一些文本，将其删除，滚动到文件中的其他位置，然后调用 undo，则编辑器必须将其状态恢复为删除前的状态。这包括还原已删除的文本，再次选择它，并使所选的文本在窗口中可见。\n\nSome of the student projects implemented the entire undo mechanism as part of the text class. The text class maintained a list of all the undoable changes. It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list. When undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list. For entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.\n\n> 一些学生项目将整个撤消机制实现为文本类的一部分。文本类维护所有不可撤消更改的列表。每当更改文本时，它将自动将条目添加到此列表中。为了更改选择，插入光标和视图，用户界面代码调用了文本类中的其他方法，然后将这些更改的条目添加到撤消列表中。当用户请求撤消或重做时，用户界面代码将调用文本类中的方法，该方法然后处理撤消列表中的条目。对于与文本相关的条目，它更新了文本类的内部。对于与其他事物（例如选择）相关的条目，将调用返回到用户界面代码的文本类来执行撤消或重做。\n\nThis approach resulted in an awkward set of features in the text class. The core of undo/redo consists of a general-purpose mechanism for managing a list of actions that have been executed and stepping through them during undo and redo operations. The core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection. The special-purpose undo handlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth. If a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition, the general-purpose undo core had little to do with the general-purpose text facilities in the class.\n\n> 这种方法在文本类中导致了一系列尴尬的功能。撤消/重做的核心由通用机制组成，用于管理已执行的动作列表，并在撤消和重做操作期间逐步执行这些动作。核心与专用处理程序一起位于 text 类中，该专用处理程序对诸如文本和选择之类的特定内容实现了撤消和重做。用于选择和光标的专用撤消处理程序与文本类中的任何其他内容均无关。它们导致文本类和用户界面之间的信息泄漏，以及每个模块中来回传递撤消信息的额外方法。如果将来将新的可撤消实体添加到系统中，则将需要更改文本类，包括特定于该实体的新方法。\n\nThese problems can be solved by extracting the general-purpose core of the undo/redo mechanism and placing it in a separate class:\n\n> 通过提取撤消/重做机制的通用核心并将其放在单独的类中，可以解决这些问题：\n\n```java\npublic class History {\n    public interface Action {\n        public void redo();\n        public void undo();\n    }\n    History() {...}\n    void addAction(Action action) {...}\n    void addFence() {...}\n    void undo() {...}\n    void redo() {...}\n}\n```\n\nIn this design, the History class manages a collection of objects that implement the interface History.Action. Each History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation. The History class knows nothing about the information stored in the actions or how they implement their undo and redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.\n\n> 在此设计中，History 类管理实现接口 History.Action 的对象的集合。每个 History.Action 描述一个操作，例如插入文本或更改光标位置，并且它提供了可以撤消或重做该操作的方法。History 类对操作中存储的信息或它们如何实现其撤消和重做方法一无所知。历史记录维护一个历史记录列表，该列表描述了应用程序整个生命周期中执行的所有操作，并且它提供了撤消和重做方法，以响应用户请求的撤消和重做而在列表中前后移动，并在应用程序中调用撤消和重做方法。历史动作。\n\nHistory.Actions are special-purpose objects: each one understands a particular kind of undoable operation. They are implemented outside the History class, in modules that understand particular kinds of undoable actions. The text class might implement UndoableInsert and UndoableDelete objects to describe text insertions and deletions. Whenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list. The editor’s user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selection and insertion cursor.\n\n> 历史。动作是特殊目的的对象：每个人都了解一种特殊的不可操作。它们在 History 类之外的模块中实现，这些模块可以理解特定类型的可撤销操作。文本类可能实现 UndoableInsert 和 UndoableDelete 对象，以描述文本的插入和删除。每当插入文本时，文本类都会创建一个描述该插入的新 UndoableInsert 对象，并调用 History.addAction 将其添加到历史列表中。编辑器的用户界面代码可能会创建 UndoableSelection 和 UndoableCursor 对象，这些对象描述对选择和插入光标的更改。\n\nThe History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor. There are a number of ways to group actions; the History class uses fences, which are markers placed in the history list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence. The placement of fences is determined by higher-level code by invoking History.addFence.\n\n> History 类还允许对操作进行分组，例如，来自用户的单个撤消请求可以恢复已删除的文本，重新选择已删除的文本以及重新放置插入光标。有多种将动作分组的方法。历史记录类使用围栏，围栏是放置在历史记录列表中的标记，用于分隔相关动作的组。每次对 History.redo 的调用都会向后浏览历史记录列表，撤消操作，直到到达下一个栅栏。围栏的位置由更高级别的代码通过调用 History.addFence 确定。\n\nThis approach divides the functionality of undo into three categories, each of which is implemented in a different place:\n\n> 这种方法将撤消功能分为三类，每类都在不同的地方实现：\n\nA general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).\nThe specifics of particular actions (implemented by a variety of classes, each of which understands a small number of action types).\nThe policy for grouping actions (implemented by high-level user interface code to provide the right overall application behavior).\nEach of these categories can be implemented without any understanding of the other categories. The History class does not know what kind of actions are being undone; it could be used in a variety of applications. Each action class understands only a single kind of action, and neither the History class nor the action classes needs to be aware of the policy for grouping actions.\n\n> 一种用于管理和分组动作以及调用撤消/重做操作的通用机制（由 History 类实现）。特定操作的细节（由各种类实现，每个类都了解少量的操作类型）。分组操作的策略（由高级用户界面代码实现，以提供正确的整体应用程序行为）。这些类别中的每一个都可以在不了解其他类别的情况下实施。历史课不知道要撤消哪种操作；它可以用于多种应用。每个动作类仅理解一种动作，并且历史记录类和动作类都不需要知道将动作分组的策略。\n\nThe key design decision was the one that separated the general-purpose part of the undo mechanism from the special-purpose parts and put the general-purpose part in a class by itself. Once that was done, the rest of the design fell out naturally.\n\n> 关键的设计决策是将撤消机制的通用部分与专用部分分开，然后将通用部分单独放在一个类中的决定。一旦完成，其余的设计就会自然消失。\n\nNote: the suggestion to separate general-purpose code from special-purpose code refers to code related to a particular mechanism. For example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list). However, it often makes sense to combine special-purpose code for one mechanism with general-purpose code for another. The text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special-purpose because it only handles undo operations for text modifications. It doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.\n\n> 注意:将通用代码与专用代码分离的建议是指与特定机制相关的代码。例如，特殊用途的撤消代码(例如撤消文本插入的代码)应该与通用用途的撤消代码(例如管理历史记录列表的代码)分开。然而，将一种机制的专用代码与另一种机制的通用代码组合起来通常是有意义的。text 类就是这样一个例子:它实现了一种管理文本的通用机制，但是它包含了与撤销相关的专用代码。撤消代码是专用的，因为它只处理文本修改的撤消操作。将这段代码与 History 类中通用的 undo 基础结构结合在一起是没有意义的，但是将它放在 text 类中是有意义的，因为它与其他文本函数密切相关。\n\n## 9.8 Splitting and joining methods 拆分和合并方法\n\nThe issue of when to subdivide applies not just to classes, but also to methods: are there times when it is better to divide an existing method into multiple smaller methods? Or, should two smaller methods be combined into one larger one? Long methods tend to be more difficult to understand than shorter ones, so many people argue that length alone is a good justification for breaking up a method. Students in classes are often given rigid criteria, such as “Split up any method longer than 20 lines!”\n\n> 何时细分的问题不仅适用于类，而且还适用于方法：是否有时最好将现有方法分为多个较小的方法？还是应该将两种较小的方法合并为一种较大的方法？长方法比短方法更难于理解，因此许多人认为仅长度是分解方法的一个很好的理由。课堂上的学生通常会获得严格的标准，例如“拆分超过 20 行的任何方法！”\n\nHowever, length by itself is rarely a good reason for splitting up a method. In general, developers tend to break up methods too much. Splitting up a method introduces additional interfaces, which add to complexity. It also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related. You shouldn’t break up a method unless it makes the overall system simpler; I’ll discuss how this might happen below.\n\n> 但是，长度本身很少是拆分方法的一个很好的理由。通常，开发人员倾向于过多地分解方法。拆分方法会引入其他接口，从而增加了复杂性。它还将原始方法的各个部分分开，如果这些部分实际上是相关的，则使代码更难阅读。您不应该分解一种方法，除非它使整个系统更加简单；我将在下面讨论这种情况。\n\nLong methods aren’t always bad. For example, suppose a method contains five 20-line blocks of code that are executed in order. If the blocks are relatively independent, then the method can be read and understood one block at a time; there’s not much benefit in moving each of the blocks into a separate method. If the blocks have complex interactions, it’s even more important to keep them together so readers can see all of the code at once; if each block is in a separate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundreds of lines of code are fine if they have a simple signature and are easy to read. These methods are deep (lots of functionality, simple interface), which is good.\n\n> 长方法并不总是坏的。例如，假设一个方法包含按顺序执行的五个 20 行代码块。如果这些块是相对独立的，则可以一次读取并理解该方法的一个块。将每个块移动到单独的方法中并没有太大的好处。如果这些块具有复杂的交互作用，则将它们保持在一起就显得尤为重要，这样读者就可以一次看到所有代码。如果每个块使用单独的方法，则读者将不得不在这些扩展方法之间来回切换，以了解它们如何协同工作。如果方法具有简单的签名并且易于阅读，则包含数百行代码的方法就可以了。这些方法很深入（很多功能，简单的界面），很好。\n\n![](../../img/figures/00019.jpeg)\n\nFigure 9.3: A method (a) can be split either by by extracting a subtask (b) or by dividing its functionality into two separate methods (c). A method should not be split if it results in shallow methods, as in (d).\n\n> 图 9.3：方法（a）可以通过提取子任务（b）或将其功能划分为两个单独的方法（c）进行拆分。如果方法导致浅层方法，则不应拆分该方法，如（d）所示。\n\nWhen designing methods, the most important goal is to provide clean and simple abstractions. Each method should do one thing and do it completely. The method should have a clean and simple interface, so that users don’t need to have much information in their heads in order to use it correctly. The method should be deep: its interface should be much simpler than its implementation. If a method has all of these properties, then it probably doesn’t matter whether it is long or not.\n\n> 设计方法时，最重要的目标是提供简洁的抽象。每种方法都应该做一件事并且完全做到这一点。该方法应该具有简洁的界面，以便用户无需费神就可以正确使用它。该方法应该很深：其接口应该比其实现简单得多。如果一个方法具有所有这些属性，那么它的长短与否可能无关紧要。\n\nSplitting up a method only makes sense if it results in cleaner abstractions, overall. There are two ways to do this, which are diagrammed in Figure 9.3. The best way is by factoring out a subtask into a separate method, as shown in Figure 9.3(b). The subdivision results in a child method containing the subtask and a parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the original method. This form of subdivision makes sense if there is a subtask that is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesn’t need to know anything about the parent method and (b) someone reading the parent method doesn’t need to understand the implementation of the child method. Typically this means that the child method is relatively general-purpose: it could conceivably be used by other methods besides the parent. If you make a split of this form and then find yourself flipping back and forth between the parent and child to understand how they work together, that is a red flag (“Conjoined Methods”) indicating that the split was probably a bad idea.\n\n> 总体而言，拆分方法只有在其导致更抽象的抽象时才有意义。有两种方法可以做到这一点，如图 9.3 所示。最佳方法是将子任务分解为单独的方法，如图 9.3（b）所示。该细分产生一个包含该子任务的子方法和一个包含原始方法其余部分的父方法；父级调用子级。新的父方法的接口与原始方法的接口相同。如果存在一个与原始方法的其余部分完全可分离的子任务，则这种细分形式是有意义的，这意味着（a）读取子方法的某人不需要了解有关父方法的任何信息，以及（b）某人在阅读父方法不需要了解子方法的实现。通常，这意味着子方法是相对通用的：可以想象除父方法外，其他方法也可以使用它。如果您对这种形式进行拆分，然后发现自己在父母和孩子之间来回翻转以了解他们如何一起工作，那是一个红色标记（“联合方法”），表明拆分可能不是一个好主意。\n\nThe second way to break up a method is to split it into two separate methods, each visible to callers of the original method, as in Figure 9.3(c). This makes sense if the original method had an overly complex interface because it tried to do multiple things that were not closely related. If this is the case, it may be possible to divide the method’s functionality into two or more smaller methods, each of which has only a part of the original method’s functionality. If you make a split like this, the interface for each of the resulting methods should be simpler than the interface of the original method. Ideally, most callers should only need to invoke one of the two new methods; if callers must invoke both of the new methods, then that adds complexity, which makes it less likely that the split is a good idea. The new methods will be more focused in what they do. It is a good sign if the new methods are more general-purpose than the original method (i.e., you can imagine using them separately in other situations).\n\n> 分解方法的第二种方法是将其拆分为两个单独的方法，每个方法对原始方法的调用者可见，如图 9.3（c）所示。如果原始方法的接口过于复杂，这是有道理的，因为该接口试图执行不密切相关的多项操作。在这种情况下，可以将方法的功能划分为两个或更多个较小的方法，每个方法仅具有原始方法功能的一部分。如果进行这样的拆分，则每个结果方法的接口应该比原始方法的接口更简单。理想情况下，大多数调用者只需要调用两个新方法之一即可；如果调用者必须同时调用这两个新方法，则将增加复杂性，从而降低拆分是个好主意的可能性。新方法将更加专注于它们的工作。如果新方法比原始方法更具通用性，那么这是一个好兆头（例如，您可以想象在其他情况下单独使用它们）。\n\nSplits of the form shown in Figure 9.3(c) don’t make sense very often, because they result in callers having to deal with multiple methods instead of one. When you split this way, you run the risk of ending up with several shallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods, passing state back and forth between them, then splitting is not a good idea. If you’re considering a split like the one in Figure 9.3(c), you should judge it based on whether it simplifies things for callers.\n\n> 图 9.3（c）所示形式的拆分并不是很有意义，因为它们导致调用者不得不处理多个方法而不是一个方法。当您以这种方式拆分时，您可能会遇到几种浅层方法的风险，如图 9.3（d）所示。如果调用者必须调用每个单独的方法，并在它们之间来回传递状态，则拆分不是一个好主意。如果您正在考虑像图 9.3（c）所示的拆分，则应基于它是否简化了呼叫者的情况来进行判断。\n\nThere are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it might eliminate dependencies between the original methods, or intermediate data structures; it might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place; or it might result in a simpler interface, as discussed in Section 9.2.\n\n> 在某些情况下，通过将方法结合在一起可以简化系统。例如，连接方法可以用一种更深的方法代替两种浅的方法。它可以消除重复的代码；它可以消除原始方法或中间数据结构之间的依赖关系；它可能导致更好的封装，从而使以前在多个位置存在的知识现在被隔离在一个位置；否则可能会导致界面更简单，如 9.2 节所述。\n\nimg Red Flag: Conjoined Methods img\n\nIt should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.\n\n> 应该有可能独立地理解每种方法。如果您不能不理解另一种方法的实现而无法理解一种方法的实现，那就是一个危险信号。该危险信号也可以在其他情况下发生：如果两段代码在物理上是分开的，但是只有通过查看另一段代码才能理解它们，这就是危险信号。\n\n## 9.9 Conclusion 结论\n\nThe decision to split or join modules should be based on complexity. Pick the structure that results in the best information hiding, the fewest dependencies, and the deepest interfaces.\n\n> 拆分或加入模块的决定应基于复杂性。选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口。\n","source":"_posts/软件设计的哲学-ch9.md","raw":"---\ntitle: 软件设计的哲学 - ch9\ndate: 2021-02-9\ntags: 软件设计的哲学 软件开发 方法论\n---\n在一起更好还是分开更好？\n<!-- more -->\n# 第 9 章 在一起更好还是分开更好？\n\n> Chapter 9 Better Together Or Better Apart?\n\nOne of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated? This question applies at all levels in a system, such as functions, methods, classes, and services. For example, should buffering be included in the class that provides stream-oriented file I/O, or should it be in a separate class? Should the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)? This chapter discusses the factors to consider when making these decisions. Some of these factors have already been discussed in previous chapters, but they will be revisited here for completeness.\n\n> 软件设计中最基本的问题之一是：给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？这个问题适用于系统中的所有级别，例如功能，方法，类和服务。例如，应该在提供面向流的文件 I/O 的类中包括缓冲，还是应该在单独的类中？HTTP 请求的解析应该完全在一种方法中实现，还是应该在多个方法（甚至多个类）之间划分？本章讨论做出这些决定时要考虑的因素。这些因素中的一些已经在前面的章节中进行了讨论，但是为了完整起见，这里将对其进行重新讨论。\n\nWhen deciding whether to combine or separate, the goal is to reduce the complexity of the system as a whole and improve its modularity. It might appear that the best way to achieve this goal is to divide the system into a large number of small components: the smaller the components, the simpler each individual component is likely to be. However, the act of subdividing creates additional complexity that was not present before subdivision:\n\n> 在决定是合并还是分开时，目标是降低整个系统的复杂性并改善其模块化。看来实现此目标的最佳方法是将系统划分为大量的小组件：组件越小，每个单独的组件可能越简单。但是，细分的行为会带来额外的复杂性，而这在细分之前是不存在的：\n\n- Some complexity comes just from the number of components: the more components, the harder to keep track of them all and the harder to find a desired component within the large collection. Subdivision usually results in more interfaces, and every new interface adds complexity.\n- Subdivision can result in additional code to manage the components. For example, a piece of code that used a single object before subdivision might now have to manage multiple objects.\n- Subdivision creates separation: the subdivided components will be farther apart than they were before subdivision. For example, methods that were together in a single class before subdivision may be in different classes after subdivision, and possibly in different files. Separation makes it harder for developers to see the components at the same time, or even to be aware of their existence. If the components are truly independent, then separation is good: it allows the developer to focus on a single component at a time, without being distracted by the other components. On the other hand, if there are dependencies between the components, then separation is bad: developers will end up flipping back and forth between the components. Even worse, they may not be aware of the dependencies, which can lead to bugs.\n- Subdivision can result in duplication: code that was present in a single instance before subdivision may need to be present in each of the subdivided components.\n\n---\n\n> - 一些组件的复杂性仅来自组件的数量：组件越多，就越难以追踪所有组件，也就越难在大型集合中找到所需的组件。细分通常会导致更多接口，并且每个新接口都会增加复杂性。\n> - 细分可能会导致附加代码来管理组件。例如，在细分之前使用单个对象的一段代码现在可能必须管理多个对象。\n> - 细分产生分离：细分后的组件将比细分前的组件相距更远。例如，在细分之前位于单个类中的方法可能在细分之后位于不同的类中，并且可能在不同的文件中。分离使开发人员更难于同时查看这些组件，甚至很难知道它们的存在。如果组件真正独立，那么分离是好的：它使开发人员可以一次专注于单个组件，而不会被其他组件分散注意力。另一方面，如果组件之间存在依赖性，则分离是不好的：开发人员最终将在组件之间来回翻转。更糟糕的是，他们可能不了解依赖关系，这可能导致错误。\n> - 细分可能导致重复：细分之前的单个实例中存在的代码可能需要存在于每个细分的组件中。\n\nBringing pieces of code together is most beneficial if they are closely related. If the pieces are unrelated, they are probably better off apart. Here are a few indications that two pieces of code are related:\n\n> 如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开。以下是两个代码相关的一些提示：\n\n- They share information; for example, both pieces of code might depend on the syntax of a particular type of document.\n- They are used together: anyone using one of the pieces of code is likely to use the other as well. This form of relationship is only compelling if it is bidirectional. As a counter-example, a disk block cache will almost always involve a hash table, but hash tables can be used in many situations that don’t involve block caches; thus, these modules should be separate.\n- They overlap conceptually, in that there is a simple higher-level category that includes both of the pieces of code. For example, searching for a substring and case conversion both fall under the category of string manipulation; flow control and reliable delivery both fall under the category of network communication.\n- It is hard to understand one of the pieces of code without looking at the other.\n\n---\n\n> - 他们共享信息；例如，这两段代码都可能取决于特定类型文档的语法。\n> - 它们一起使用：任何使用其中一段代码的人都可能同时使用另一段代码。这种关系形式只有在双向关系中才具有吸引力。作为反例，磁盘块高速缓存几乎总是包含哈希表，但是哈希表可以在许多不涉及块高速缓存的情况下使用。因此，这些模块应该分开。\n> - 它们在概念上重叠，因为存在一个简单的更高级别的类别，其中包括这两段代码。例如，搜索子字符串和大小写转换都属于字符串操作类别。流控制和可靠的交付都属于网络通信的范畴。\n> - 不看其中的一段代码就很难理解。\n\nThe rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.\n\n> 本章的其余部分使用更具体的规则以及示例来说明何时将代码段组合在一起以及何时将它们分开是有意义的。\n\n## 9.1 Bring together if information is shared 如果信息共享则汇聚在一起\n\nSection 5.4 introduced this principle in the context of a project implementing an HTTP server. In its first implementation, the project used two different methods in different classes to read in and parse HTTP requests. The first method read the text of an incoming request from a network socket and placed it in a string object. The second method parsed the string to extract the various components of the request. With this decomposition, both of the methods ended up with considerable knowledge of the format of HTTP requests: the first method was only trying to read the request, not parse it, but it couldn’t identify the end of the request without doing most of the work of parsing it (for example, it had to parse header lines in order to identify the header containing the overall request length). Because of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.\n\n> 5.4 节在实现 HTTP 服务器的项目上下文中介绍了此原理。在其第一个实现中，该项目在不同的类中使用了两种不同的方法来读取和解析 HTTP 请求。第一种方法从网络套接字读取传入请求的文本，并将其放置在字符串对象中。第二种方法解析字符串以提取请求的各个组成部分。经过这种分解，这两种方法最终都对 HTTP 请求的格式有了相当的了解：第一种方法只是尝试读取请求，而不是解析请求，但是如果不执行大多数操作，就无法确定请求的结束解析它的工作（例如，它必须解析标头行才能识别包含整个请求长度的标头）。由于此共享信息，最好在同一位置读取和解析请求；当两个类合而为一时，代码变得更短，更简单。\n\n## 9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面\n\nWhen two or more modules are combined into a single module, it may be possible to define an interface for the new module that is simpler or easier to use than the original interfaces. This often happens when the original modules each implement part of the solution to a problem. In the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second. When the methods were combined, these interfaces were eliminated.\n\n> 当两个或多个模块组合成一个模块时，可以为新模块定义一个比原始接口更简单或更易于使用的接口。当原始模块各自实现问题解决方案的一部分时，通常会发生这种情况。在上一部分的 HTTP 服务器示例中，原始方法需要一个接口来从第一个方法返回 HTTP 请求字符串并将其传递给第二个方法。当这些方法结合在一起时，这些接口就被淘汰了。\n\nIn addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them. The Java I/O library illustrates this opportunity. If the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering. A combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.\n\n> 另外，将两个或更多类的功能组合在一起时，可能会自动执行某些功能，因此大多数用户无需了解它们。Java I/O 库说明了这种机会。如果将 FileInputStream 和 BufferedInputStream 类组合在一起，并且默认情况下提供了缓冲，则绝大多数用户甚至都不需要知道缓冲的存在。组合的 FileInputStream 类可能提供禁用或替换默认缓冲机制的方法，但是大多数用户不需要了解它们。\n\n## 9.3 Bring together to eliminate duplication 消除重复\n\nIf you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeated code out into a separate method and replace the repeated code snippets with calls to the method. This approach is most effective if the repeated code snippet is long and the replacement method has a simple signature. If the snippet is only one or two lines long, there may not be much benefit in replacing it with a method call. If the snippet interacts in complex ways with its environment (such as by accessing numerous local variables), then the replacement method might require a complex signature (such as many pass-by-reference arguments), which would reduce its value.\n\n> 如果发现反复重复相同的代码模式，请查看是否可以重新组织代码以消除重复。一种方法是将重复的代码分解为一个单独的方法，并用对该方法的调用替换重复的代码段。如果重复的代码段很长并且替换方法具有简单的签名，则此方法最有效。如果代码段只有一两行，那么用方法调用替换它可能不会有太多好处。如果代码段与其环境以复杂的方式进行交互（例如，通过访问多个局部变量），则替换方法可能需要复杂的签名（例如，许多“按引用传递”参数），这会降低其价值。\n\nAnother way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writing a method that needs to return errors at several different points, and the same cleanup actions need to be performed at each of these points before returning (see Figure 9.1 for an example). If the programming language supports goto, you can move the cleanup code to the very end of the method and then goto that snippet at each of the points where an error return is required, as in Figure 9.2. Goto statements are generally considered a bad idea, and they can result in indecipherable code if used indiscriminately, but they are useful in situations like this where they are used to escape from nested code.\n\n> 消除重复的另一种方法是重构代码，使相关代码段仅需要在一个地方执行。假设您正在编写一种方法，该方法需要在几个不同的点返回错误，并且在返回之前需要在每个这些点执行相同的清除操作（示例请参见图 9.1）。如果编程语言支持 goto，则可以将清除代码移到方法的最后，然后在需要返回错误的每个点处转到该片段，如图 9.2 所示。Goto 语句通常被认为是一个坏主意，如果不加选择地使用它们，可能会导致无法识别的代码，但是在诸如此类的情况下，它们可用于从嵌套代码中转义，因此它们非常有用。\n\n## 9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码\n\nIf a module contains a mechanism that can be used for several different purposes, then it should provide just that one general-purpose mechanism. It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typically one associated with the particular purpose). The GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the selection) were implemented in the user interface module. This approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.\n\n> 如果模块包含可用于多种不同目的的机制，则它应仅提供一种通用机制。它不应包含专门针对特定用途的机制的代码，也不应包含其他通用机制。与通用机制关联的专用代码通常应放在不同的模块中（通常是与特定用途关联的模块）。第 6 章中的 GUI 编辑器讨论阐明了这一原理：最佳设计是文本类提供通用文本操作，而特定于用户界面的操作（例如删除所选内容）则在用户界面模块中实现。\n\nimg Red Flag: Repetition img\n\nIf the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.\n\n> 如果相同的代码（或几乎相同的代码）一遍又一遍地出现，那是一个危险信号，您没有找到正确的抽象。\n\n![](../../img/figures/00017.gif)\n\nFigure 9.1: This code processes incoming network packets of different types; for each type, if the packet is too short for that type, a message gets logged. In this version of the code, the LOG statement is duplicated for several different packet types.\n\n> 图 9.1：此代码处理不同类型的传入网络数据包。对于每种类型，如果数据包对于该类型而言太短，则会记录一条消息。在此版本的代码中，LOG 语句对于几种不同的数据包类型是重复的。\n\n![](../../img/figures/00018.gif)\n\nFigure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement.\n\n> 图 9.2：对图 9.1 中的代码进行了重新组织，因此只有 LOG 语句的一个副本。\n\nIn general, the lower layers of a system tend to be more general-purpose and the upper layers more special-purpose. For example, the topmost layer of an application consists of features totally specific to that application. The way to separate special-purpose code from general-purpose code is to pull the special-purpose code upwards, into the higher layers, leaving the lower layers general-purpose. When you encounter a class that includes both general-purpose and special-purpose features for the same abstraction, see if the class can be separated into two classes, one containing the general-purpose features, and the other layered on top of it to provide the special-purpose features.\n\n> 通常，系统的下层倾向于更通用，而上层则更专用。例如，应用程序的最顶层包含完全特定于该应用程序的功能。将专用代码与通用代码分开的方法是将专用代码向上拉到较高的层，而将较低的层保留为通用。当您遇到同时包含通用功能和专用功能的同一类的类时，请查看该类是否可以分为两个类，一个包含通用功能，另一个在其上分层以提供特殊功能\n\n## 9.5 Example: insertion cursor and selection 示例：插入光标和选择\n\nThe next sections work through three examples that illustrate the principles discussed above. In two of the examples the best approach is to separate the relevant pieces of code; in the third example it is better to join them together.\n\n> 下一节将通过三个示例说明上述原理。在两个示例中，最好的方法是分离相关的代码段。在第三个示例中，最好将它们结合在一起。\n\nThe first example consists of the insertion cursor and the selection in the GUI editor project from Chapter 6. The editor displayed a blinking vertical line indicating where text typed by the user would appear in the document. It also displayed a highlighted range of characters called the selection, which was used for copying or deleting text. The insertion cursor was always visible, but there could be times when no text was selected. If the selection existed, the insertion cursor was always positioned at one end of it.\n\n> 第一个示例由插入光标和第 6 章的 GUI 编辑器项目中的选择组成。编辑器显示闪烁的垂直线，指示用户键入的文本将出现在文档中的何处。它还显示了一个突出显示的字符范围，称为选择，用于复制或删除文本。插入光标始终可见，但是有时可能没有选择文本。如果存在选择，则插入光标始终位于其一端。\n\nThe selection and insertion cursor are related in some ways. For example, the cursor is always positioned at one end of the selection, and the cursor and selection tend to be manipulated together: clicking and dragging the mouse sets both of them, and text insertion first deletes the selected text, if there is any, and then inserts new text at the cursor position. Thus, it might seem logical to use a single object to manage both the selection and the cursor, and one project team took this approach. The object stored two positions in the file, along with booleans indicating which end was the cursor and whether the selection existed.\n\n> 选择和插入光标在某些方面相关。例如，光标始终位于所选内容的一端，并且倾向于将光标和所选内容一起操作：单击并拖动鼠标将它们都设置，然后插入文本会首先删除所选的文本（如果有），然后在光标位置插入新文本。因此，使用单个对象管理选择和光标似乎合乎逻辑，并且一个项目团队采用了这种方法。该对象在文件中存储了两个位置，以及布尔值，它们指示光标的哪一端以及选择是否存在。\n\nHowever, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text). The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separate entity, but instead had to store a boolean indicating which end of the selection was the cursor. In order to retrieve the cursor position, the combined object had to first test the boolean and then choose the appropriate end of the selection.\n\n> 但是，合并的对象很尴尬。它对高级代码没有任何好处，因为高级代码仍然需要将选择和游标视为不同的实体，并且对它们进行单独操作（在插入文本期间，它首先在组合对象上调用一个方法来删除选定的文本；然后调用另一个方法来检索光标位置，以插入新文本）。实际上，组合对象比单独的对象实现起来要复杂得多。它避免了将光标位置存储为单独的实体，而是不得不存储一个布尔值，该布尔值指示选择的哪一端是光标。为了检索光标位置，组合对象必须首先测试布尔值，然后选择选择的适当结尾。\n\nimg Red Flag: Special-General Mixture img\n\nThis red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.\n\n> 当通用机制还包含专门用于该机制的特定用途的代码时，就会出现此红色标志。这使该机制更加复杂，并在该机制与特定用例之间造成了信息泄漏：对用例的未来修改也可能需要对基础机制进行更改。\n\nIn this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler. Separate objects provided a simpler interface than a combined object from which selection and cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectly through a selection and a boolean. In fact, in the revised version no special classes were used for either the selection or the cursor. Instead, a new Position class was introduced to represent a location in the file (a line number and character within line). The selection was represented with two Positions and the cursor with one. Positions also found other uses in the project. This example also demonstrates the benefits of a lower-level but more general-purpose interface, which were discussed in Chapter 6.\n\n> 在这种情况下，选择和光标之间的关联度不足以将它们组合在一起。当修改代码以分隔选择和光标时，用法和实现都变得更加简单。与必须从中提取选择和光标信息的组合对象相比，单独的对象提供了更简单的界面。游标的实现也变得更加简单，因为游标的位置是直接表示的，而不是通过选择和布尔值间接表示的。实际上，在修订版中，没有特殊的类用于选择或游标。相反，引入了一个新的 Position 类来表示文件中的位置（行号和行内的字符）。选择用两个位置表示，光标用一个位置表示。职位还在项目中找到了其他用途。\n\n## 9.6 Example: separate class for logging 示例：用于记录的单独类\n\nThe second example involved error logging in a student project. A class contained several code sequences like the following:\n\n> 第二个示例涉及学生项目中的错误记录。一个类包含几个代码序列，如下所示：\n\n```java\ntry {\n    rpcConn = connectionPool.getConnection(dest);\n} catch (IOException e) {\n    NetworkErrorLogger.logRpcOpenError(req, dest, e);\n    return null;\n}\n```\n\nRather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked. The error logging class was defined at the end of the same source file:\n\n> 而不是在检测到错误时记录错误，而是调用特殊错误记录类中的单独方法。错误记录类是在同一源文件的末尾定义的：\n\n```java\nprivate static class NetworkErrorLogger {\n    /**\n    *  Output information relevant to an error that occurs when trying\n    *  to open a connection to send an RPC.\n    *\n    *  @param req\n    *       The RPC request that would have been sent through the connection\n    *  @param dest\n    *       The destination of the RPC\n    *  @param e\n    *       The caught error\n    */\n    public static void logRpcOpenError(RpcRequest req, AddrPortTuple dest, Exception e) {\n        logger.log(Level.WARNING, \"Cannot send message: \" + req + \". \\n\" + \"Unable to find or open connection to \" + dest + \" :\" + e);\n    }\n...\n}\n```\n\nThe NetworkErrorLogger class contained several methods such as logRpcSendError and logRpcReceiveError, each of which logged a different kind of error.\n\n> NetworkErrorLogger 类包含几个方法，例如 logRpcSendError 和 logRpcReceiveError，每个方法都记录了不同类型的错误。\n\nThis separation added complexity with no benefit. The logging methods were shallow: most consisted of a single line of code, but they required a considerable amount of documentation. Each method was only invoked in a single place. The logging methods were highly dependent on their invocations: someone reading the invocation would most likely flip over to the logging method to make sure that the right information was being logged; similarly, someone reading the logging method would probably flip over to the invocation site to understand the purpose of the method.\n\n> 这种分离增加了复杂性，没有任何好处。日志记录方法很浅：大多数只包含一行代码，但是它们需要大量的文档。每个方法仅在单个位置调用。日志记录方法高度依赖于它们的调用：读取调用的人很可能会切换到日志记录方法，以确保记录了正确的信息。同样，阅读日志记录方法的人可能会转到调用站点以了解该方法的目的。\n\nIn this example, it would be better to eliminate the logging methods and place the logging statements at the locations where the errors were detected. This would make the code easier to read and eliminate the interfaces required for the logging methods.\n\n> 在此示例中，最好消除日志记录方法，并将日志记录语句放置在检测到错误的位置。这将使代码更易于阅读，并消除了日志记录方法所需的接口。\n\n## 9.7 Example: editor undo mechanism 示例：编辑器撤消机制\n\nIn the GUI editor project from Section 6.2, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view. For example, if a user selected some text, deleted it, scrolled to a different place in the file, and then invoked undo, the editor had to restore its state to what it was just before the deletion. This included restoring the deleted text, selecting it again, and also making the selected text visible in the window.\n\n> 在 6.2 节的 GUI 编辑器项目中，要求之一是支持多级撤消/重做，不仅要更改文本本身，还要更改选择，插入光标和视图。例如，如果用户选择了一些文本，将其删除，滚动到文件中的其他位置，然后调用 undo，则编辑器必须将其状态恢复为删除前的状态。这包括还原已删除的文本，再次选择它，并使所选的文本在窗口中可见。\n\nSome of the student projects implemented the entire undo mechanism as part of the text class. The text class maintained a list of all the undoable changes. It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list. When undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list. For entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.\n\n> 一些学生项目将整个撤消机制实现为文本类的一部分。文本类维护所有不可撤消更改的列表。每当更改文本时，它将自动将条目添加到此列表中。为了更改选择，插入光标和视图，用户界面代码调用了文本类中的其他方法，然后将这些更改的条目添加到撤消列表中。当用户请求撤消或重做时，用户界面代码将调用文本类中的方法，该方法然后处理撤消列表中的条目。对于与文本相关的条目，它更新了文本类的内部。对于与其他事物（例如选择）相关的条目，将调用返回到用户界面代码的文本类来执行撤消或重做。\n\nThis approach resulted in an awkward set of features in the text class. The core of undo/redo consists of a general-purpose mechanism for managing a list of actions that have been executed and stepping through them during undo and redo operations. The core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection. The special-purpose undo handlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth. If a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition, the general-purpose undo core had little to do with the general-purpose text facilities in the class.\n\n> 这种方法在文本类中导致了一系列尴尬的功能。撤消/重做的核心由通用机制组成，用于管理已执行的动作列表，并在撤消和重做操作期间逐步执行这些动作。核心与专用处理程序一起位于 text 类中，该专用处理程序对诸如文本和选择之类的特定内容实现了撤消和重做。用于选择和光标的专用撤消处理程序与文本类中的任何其他内容均无关。它们导致文本类和用户界面之间的信息泄漏，以及每个模块中来回传递撤消信息的额外方法。如果将来将新的可撤消实体添加到系统中，则将需要更改文本类，包括特定于该实体的新方法。\n\nThese problems can be solved by extracting the general-purpose core of the undo/redo mechanism and placing it in a separate class:\n\n> 通过提取撤消/重做机制的通用核心并将其放在单独的类中，可以解决这些问题：\n\n```java\npublic class History {\n    public interface Action {\n        public void redo();\n        public void undo();\n    }\n    History() {...}\n    void addAction(Action action) {...}\n    void addFence() {...}\n    void undo() {...}\n    void redo() {...}\n}\n```\n\nIn this design, the History class manages a collection of objects that implement the interface History.Action. Each History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation. The History class knows nothing about the information stored in the actions or how they implement their undo and redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.\n\n> 在此设计中，History 类管理实现接口 History.Action 的对象的集合。每个 History.Action 描述一个操作，例如插入文本或更改光标位置，并且它提供了可以撤消或重做该操作的方法。History 类对操作中存储的信息或它们如何实现其撤消和重做方法一无所知。历史记录维护一个历史记录列表，该列表描述了应用程序整个生命周期中执行的所有操作，并且它提供了撤消和重做方法，以响应用户请求的撤消和重做而在列表中前后移动，并在应用程序中调用撤消和重做方法。历史动作。\n\nHistory.Actions are special-purpose objects: each one understands a particular kind of undoable operation. They are implemented outside the History class, in modules that understand particular kinds of undoable actions. The text class might implement UndoableInsert and UndoableDelete objects to describe text insertions and deletions. Whenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list. The editor’s user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selection and insertion cursor.\n\n> 历史。动作是特殊目的的对象：每个人都了解一种特殊的不可操作。它们在 History 类之外的模块中实现，这些模块可以理解特定类型的可撤销操作。文本类可能实现 UndoableInsert 和 UndoableDelete 对象，以描述文本的插入和删除。每当插入文本时，文本类都会创建一个描述该插入的新 UndoableInsert 对象，并调用 History.addAction 将其添加到历史列表中。编辑器的用户界面代码可能会创建 UndoableSelection 和 UndoableCursor 对象，这些对象描述对选择和插入光标的更改。\n\nThe History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor. There are a number of ways to group actions; the History class uses fences, which are markers placed in the history list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence. The placement of fences is determined by higher-level code by invoking History.addFence.\n\n> History 类还允许对操作进行分组，例如，来自用户的单个撤消请求可以恢复已删除的文本，重新选择已删除的文本以及重新放置插入光标。有多种将动作分组的方法。历史记录类使用围栏，围栏是放置在历史记录列表中的标记，用于分隔相关动作的组。每次对 History.redo 的调用都会向后浏览历史记录列表，撤消操作，直到到达下一个栅栏。围栏的位置由更高级别的代码通过调用 History.addFence 确定。\n\nThis approach divides the functionality of undo into three categories, each of which is implemented in a different place:\n\n> 这种方法将撤消功能分为三类，每类都在不同的地方实现：\n\nA general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).\nThe specifics of particular actions (implemented by a variety of classes, each of which understands a small number of action types).\nThe policy for grouping actions (implemented by high-level user interface code to provide the right overall application behavior).\nEach of these categories can be implemented without any understanding of the other categories. The History class does not know what kind of actions are being undone; it could be used in a variety of applications. Each action class understands only a single kind of action, and neither the History class nor the action classes needs to be aware of the policy for grouping actions.\n\n> 一种用于管理和分组动作以及调用撤消/重做操作的通用机制（由 History 类实现）。特定操作的细节（由各种类实现，每个类都了解少量的操作类型）。分组操作的策略（由高级用户界面代码实现，以提供正确的整体应用程序行为）。这些类别中的每一个都可以在不了解其他类别的情况下实施。历史课不知道要撤消哪种操作；它可以用于多种应用。每个动作类仅理解一种动作，并且历史记录类和动作类都不需要知道将动作分组的策略。\n\nThe key design decision was the one that separated the general-purpose part of the undo mechanism from the special-purpose parts and put the general-purpose part in a class by itself. Once that was done, the rest of the design fell out naturally.\n\n> 关键的设计决策是将撤消机制的通用部分与专用部分分开，然后将通用部分单独放在一个类中的决定。一旦完成，其余的设计就会自然消失。\n\nNote: the suggestion to separate general-purpose code from special-purpose code refers to code related to a particular mechanism. For example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list). However, it often makes sense to combine special-purpose code for one mechanism with general-purpose code for another. The text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special-purpose because it only handles undo operations for text modifications. It doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.\n\n> 注意:将通用代码与专用代码分离的建议是指与特定机制相关的代码。例如，特殊用途的撤消代码(例如撤消文本插入的代码)应该与通用用途的撤消代码(例如管理历史记录列表的代码)分开。然而，将一种机制的专用代码与另一种机制的通用代码组合起来通常是有意义的。text 类就是这样一个例子:它实现了一种管理文本的通用机制，但是它包含了与撤销相关的专用代码。撤消代码是专用的，因为它只处理文本修改的撤消操作。将这段代码与 History 类中通用的 undo 基础结构结合在一起是没有意义的，但是将它放在 text 类中是有意义的，因为它与其他文本函数密切相关。\n\n## 9.8 Splitting and joining methods 拆分和合并方法\n\nThe issue of when to subdivide applies not just to classes, but also to methods: are there times when it is better to divide an existing method into multiple smaller methods? Or, should two smaller methods be combined into one larger one? Long methods tend to be more difficult to understand than shorter ones, so many people argue that length alone is a good justification for breaking up a method. Students in classes are often given rigid criteria, such as “Split up any method longer than 20 lines!”\n\n> 何时细分的问题不仅适用于类，而且还适用于方法：是否有时最好将现有方法分为多个较小的方法？还是应该将两种较小的方法合并为一种较大的方法？长方法比短方法更难于理解，因此许多人认为仅长度是分解方法的一个很好的理由。课堂上的学生通常会获得严格的标准，例如“拆分超过 20 行的任何方法！”\n\nHowever, length by itself is rarely a good reason for splitting up a method. In general, developers tend to break up methods too much. Splitting up a method introduces additional interfaces, which add to complexity. It also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related. You shouldn’t break up a method unless it makes the overall system simpler; I’ll discuss how this might happen below.\n\n> 但是，长度本身很少是拆分方法的一个很好的理由。通常，开发人员倾向于过多地分解方法。拆分方法会引入其他接口，从而增加了复杂性。它还将原始方法的各个部分分开，如果这些部分实际上是相关的，则使代码更难阅读。您不应该分解一种方法，除非它使整个系统更加简单；我将在下面讨论这种情况。\n\nLong methods aren’t always bad. For example, suppose a method contains five 20-line blocks of code that are executed in order. If the blocks are relatively independent, then the method can be read and understood one block at a time; there’s not much benefit in moving each of the blocks into a separate method. If the blocks have complex interactions, it’s even more important to keep them together so readers can see all of the code at once; if each block is in a separate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundreds of lines of code are fine if they have a simple signature and are easy to read. These methods are deep (lots of functionality, simple interface), which is good.\n\n> 长方法并不总是坏的。例如，假设一个方法包含按顺序执行的五个 20 行代码块。如果这些块是相对独立的，则可以一次读取并理解该方法的一个块。将每个块移动到单独的方法中并没有太大的好处。如果这些块具有复杂的交互作用，则将它们保持在一起就显得尤为重要，这样读者就可以一次看到所有代码。如果每个块使用单独的方法，则读者将不得不在这些扩展方法之间来回切换，以了解它们如何协同工作。如果方法具有简单的签名并且易于阅读，则包含数百行代码的方法就可以了。这些方法很深入（很多功能，简单的界面），很好。\n\n![](../../img/figures/00019.jpeg)\n\nFigure 9.3: A method (a) can be split either by by extracting a subtask (b) or by dividing its functionality into two separate methods (c). A method should not be split if it results in shallow methods, as in (d).\n\n> 图 9.3：方法（a）可以通过提取子任务（b）或将其功能划分为两个单独的方法（c）进行拆分。如果方法导致浅层方法，则不应拆分该方法，如（d）所示。\n\nWhen designing methods, the most important goal is to provide clean and simple abstractions. Each method should do one thing and do it completely. The method should have a clean and simple interface, so that users don’t need to have much information in their heads in order to use it correctly. The method should be deep: its interface should be much simpler than its implementation. If a method has all of these properties, then it probably doesn’t matter whether it is long or not.\n\n> 设计方法时，最重要的目标是提供简洁的抽象。每种方法都应该做一件事并且完全做到这一点。该方法应该具有简洁的界面，以便用户无需费神就可以正确使用它。该方法应该很深：其接口应该比其实现简单得多。如果一个方法具有所有这些属性，那么它的长短与否可能无关紧要。\n\nSplitting up a method only makes sense if it results in cleaner abstractions, overall. There are two ways to do this, which are diagrammed in Figure 9.3. The best way is by factoring out a subtask into a separate method, as shown in Figure 9.3(b). The subdivision results in a child method containing the subtask and a parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the original method. This form of subdivision makes sense if there is a subtask that is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesn’t need to know anything about the parent method and (b) someone reading the parent method doesn’t need to understand the implementation of the child method. Typically this means that the child method is relatively general-purpose: it could conceivably be used by other methods besides the parent. If you make a split of this form and then find yourself flipping back and forth between the parent and child to understand how they work together, that is a red flag (“Conjoined Methods”) indicating that the split was probably a bad idea.\n\n> 总体而言，拆分方法只有在其导致更抽象的抽象时才有意义。有两种方法可以做到这一点，如图 9.3 所示。最佳方法是将子任务分解为单独的方法，如图 9.3（b）所示。该细分产生一个包含该子任务的子方法和一个包含原始方法其余部分的父方法；父级调用子级。新的父方法的接口与原始方法的接口相同。如果存在一个与原始方法的其余部分完全可分离的子任务，则这种细分形式是有意义的，这意味着（a）读取子方法的某人不需要了解有关父方法的任何信息，以及（b）某人在阅读父方法不需要了解子方法的实现。通常，这意味着子方法是相对通用的：可以想象除父方法外，其他方法也可以使用它。如果您对这种形式进行拆分，然后发现自己在父母和孩子之间来回翻转以了解他们如何一起工作，那是一个红色标记（“联合方法”），表明拆分可能不是一个好主意。\n\nThe second way to break up a method is to split it into two separate methods, each visible to callers of the original method, as in Figure 9.3(c). This makes sense if the original method had an overly complex interface because it tried to do multiple things that were not closely related. If this is the case, it may be possible to divide the method’s functionality into two or more smaller methods, each of which has only a part of the original method’s functionality. If you make a split like this, the interface for each of the resulting methods should be simpler than the interface of the original method. Ideally, most callers should only need to invoke one of the two new methods; if callers must invoke both of the new methods, then that adds complexity, which makes it less likely that the split is a good idea. The new methods will be more focused in what they do. It is a good sign if the new methods are more general-purpose than the original method (i.e., you can imagine using them separately in other situations).\n\n> 分解方法的第二种方法是将其拆分为两个单独的方法，每个方法对原始方法的调用者可见，如图 9.3（c）所示。如果原始方法的接口过于复杂，这是有道理的，因为该接口试图执行不密切相关的多项操作。在这种情况下，可以将方法的功能划分为两个或更多个较小的方法，每个方法仅具有原始方法功能的一部分。如果进行这样的拆分，则每个结果方法的接口应该比原始方法的接口更简单。理想情况下，大多数调用者只需要调用两个新方法之一即可；如果调用者必须同时调用这两个新方法，则将增加复杂性，从而降低拆分是个好主意的可能性。新方法将更加专注于它们的工作。如果新方法比原始方法更具通用性，那么这是一个好兆头（例如，您可以想象在其他情况下单独使用它们）。\n\nSplits of the form shown in Figure 9.3(c) don’t make sense very often, because they result in callers having to deal with multiple methods instead of one. When you split this way, you run the risk of ending up with several shallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods, passing state back and forth between them, then splitting is not a good idea. If you’re considering a split like the one in Figure 9.3(c), you should judge it based on whether it simplifies things for callers.\n\n> 图 9.3（c）所示形式的拆分并不是很有意义，因为它们导致调用者不得不处理多个方法而不是一个方法。当您以这种方式拆分时，您可能会遇到几种浅层方法的风险，如图 9.3（d）所示。如果调用者必须调用每个单独的方法，并在它们之间来回传递状态，则拆分不是一个好主意。如果您正在考虑像图 9.3（c）所示的拆分，则应基于它是否简化了呼叫者的情况来进行判断。\n\nThere are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it might eliminate dependencies between the original methods, or intermediate data structures; it might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place; or it might result in a simpler interface, as discussed in Section 9.2.\n\n> 在某些情况下，通过将方法结合在一起可以简化系统。例如，连接方法可以用一种更深的方法代替两种浅的方法。它可以消除重复的代码；它可以消除原始方法或中间数据结构之间的依赖关系；它可能导致更好的封装，从而使以前在多个位置存在的知识现在被隔离在一个位置；否则可能会导致界面更简单，如 9.2 节所述。\n\nimg Red Flag: Conjoined Methods img\n\nIt should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.\n\n> 应该有可能独立地理解每种方法。如果您不能不理解另一种方法的实现而无法理解一种方法的实现，那就是一个危险信号。该危险信号也可以在其他情况下发生：如果两段代码在物理上是分开的，但是只有通过查看另一段代码才能理解它们，这就是危险信号。\n\n## 9.9 Conclusion 结论\n\nThe decision to split or join modules should be based on complexity. Pick the structure that results in the best information hiding, the fewest dependencies, and the deepest interfaces.\n\n> 拆分或加入模块的决定应基于复杂性。选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口。\n","slug":"软件设计的哲学-ch9","published":1,"updated":"2021-02-16T04:53:54.868Z","_id":"ckl7iw2w2000okiiydzl660cd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在一起更好还是分开更好？</p>\n<a id=\"more\"></a>\n<h1 id=\"第-9-章-在一起更好还是分开更好？\"><a href=\"#第-9-章-在一起更好还是分开更好？\" class=\"headerlink\" title=\"第 9 章 在一起更好还是分开更好？\"></a>第 9 章 在一起更好还是分开更好？</h1><blockquote>\n<p>Chapter 9 Better Together Or Better Apart?</p>\n</blockquote>\n<p>One of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated? This question applies at all levels in a system, such as functions, methods, classes, and services. For example, should buffering be included in the class that provides stream-oriented file I/O, or should it be in a separate class? Should the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)? This chapter discusses the factors to consider when making these decisions. Some of these factors have already been discussed in previous chapters, but they will be revisited here for completeness.</p>\n<blockquote>\n<p>软件设计中最基本的问题之一是：给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？这个问题适用于系统中的所有级别，例如功能，方法，类和服务。例如，应该在提供面向流的文件 I/O 的类中包括缓冲，还是应该在单独的类中？HTTP 请求的解析应该完全在一种方法中实现，还是应该在多个方法（甚至多个类）之间划分？本章讨论做出这些决定时要考虑的因素。这些因素中的一些已经在前面的章节中进行了讨论，但是为了完整起见，这里将对其进行重新讨论。</p>\n</blockquote>\n<p>When deciding whether to combine or separate, the goal is to reduce the complexity of the system as a whole and improve its modularity. It might appear that the best way to achieve this goal is to divide the system into a large number of small components: the smaller the components, the simpler each individual component is likely to be. However, the act of subdividing creates additional complexity that was not present before subdivision:</p>\n<blockquote>\n<p>在决定是合并还是分开时，目标是降低整个系统的复杂性并改善其模块化。看来实现此目标的最佳方法是将系统划分为大量的小组件：组件越小，每个单独的组件可能越简单。但是，细分的行为会带来额外的复杂性，而这在细分之前是不存在的：</p>\n</blockquote>\n<ul>\n<li>Some complexity comes just from the number of components: the more components, the harder to keep track of them all and the harder to find a desired component within the large collection. Subdivision usually results in more interfaces, and every new interface adds complexity.</li>\n<li>Subdivision can result in additional code to manage the components. For example, a piece of code that used a single object before subdivision might now have to manage multiple objects.</li>\n<li>Subdivision creates separation: the subdivided components will be farther apart than they were before subdivision. For example, methods that were together in a single class before subdivision may be in different classes after subdivision, and possibly in different files. Separation makes it harder for developers to see the components at the same time, or even to be aware of their existence. If the components are truly independent, then separation is good: it allows the developer to focus on a single component at a time, without being distracted by the other components. On the other hand, if there are dependencies between the components, then separation is bad: developers will end up flipping back and forth between the components. Even worse, they may not be aware of the dependencies, which can lead to bugs.</li>\n<li>Subdivision can result in duplication: code that was present in a single instance before subdivision may need to be present in each of the subdivided components.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>一些组件的复杂性仅来自组件的数量：组件越多，就越难以追踪所有组件，也就越难在大型集合中找到所需的组件。细分通常会导致更多接口，并且每个新接口都会增加复杂性。</li>\n<li>细分可能会导致附加代码来管理组件。例如，在细分之前使用单个对象的一段代码现在可能必须管理多个对象。</li>\n<li>细分产生分离：细分后的组件将比细分前的组件相距更远。例如，在细分之前位于单个类中的方法可能在细分之后位于不同的类中，并且可能在不同的文件中。分离使开发人员更难于同时查看这些组件，甚至很难知道它们的存在。如果组件真正独立，那么分离是好的：它使开发人员可以一次专注于单个组件，而不会被其他组件分散注意力。另一方面，如果组件之间存在依赖性，则分离是不好的：开发人员最终将在组件之间来回翻转。更糟糕的是，他们可能不了解依赖关系，这可能导致错误。</li>\n<li>细分可能导致重复：细分之前的单个实例中存在的代码可能需要存在于每个细分的组件中。</li>\n</ul>\n</blockquote>\n<p>Bringing pieces of code together is most beneficial if they are closely related. If the pieces are unrelated, they are probably better off apart. Here are a few indications that two pieces of code are related:</p>\n<blockquote>\n<p>如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开。以下是两个代码相关的一些提示：</p>\n</blockquote>\n<ul>\n<li>They share information; for example, both pieces of code might depend on the syntax of a particular type of document.</li>\n<li>They are used together: anyone using one of the pieces of code is likely to use the other as well. This form of relationship is only compelling if it is bidirectional. As a counter-example, a disk block cache will almost always involve a hash table, but hash tables can be used in many situations that don’t involve block caches; thus, these modules should be separate.</li>\n<li>They overlap conceptually, in that there is a simple higher-level category that includes both of the pieces of code. For example, searching for a substring and case conversion both fall under the category of string manipulation; flow control and reliable delivery both fall under the category of network communication.</li>\n<li>It is hard to understand one of the pieces of code without looking at the other.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>他们共享信息；例如，这两段代码都可能取决于特定类型文档的语法。</li>\n<li>它们一起使用：任何使用其中一段代码的人都可能同时使用另一段代码。这种关系形式只有在双向关系中才具有吸引力。作为反例，磁盘块高速缓存几乎总是包含哈希表，但是哈希表可以在许多不涉及块高速缓存的情况下使用。因此，这些模块应该分开。</li>\n<li>它们在概念上重叠，因为存在一个简单的更高级别的类别，其中包括这两段代码。例如，搜索子字符串和大小写转换都属于字符串操作类别。流控制和可靠的交付都属于网络通信的范畴。</li>\n<li>不看其中的一段代码就很难理解。</li>\n</ul>\n</blockquote>\n<p>The rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.</p>\n<blockquote>\n<p>本章的其余部分使用更具体的规则以及示例来说明何时将代码段组合在一起以及何时将它们分开是有意义的。</p>\n</blockquote>\n<h2 id=\"9-1-Bring-together-if-information-is-shared-如果信息共享则汇聚在一起\"><a href=\"#9-1-Bring-together-if-information-is-shared-如果信息共享则汇聚在一起\" class=\"headerlink\" title=\"9.1 Bring together if information is shared 如果信息共享则汇聚在一起\"></a>9.1 Bring together if information is shared 如果信息共享则汇聚在一起</h2><p>Section 5.4 introduced this principle in the context of a project implementing an HTTP server. In its first implementation, the project used two different methods in different classes to read in and parse HTTP requests. The first method read the text of an incoming request from a network socket and placed it in a string object. The second method parsed the string to extract the various components of the request. With this decomposition, both of the methods ended up with considerable knowledge of the format of HTTP requests: the first method was only trying to read the request, not parse it, but it couldn’t identify the end of the request without doing most of the work of parsing it (for example, it had to parse header lines in order to identify the header containing the overall request length). Because of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.</p>\n<blockquote>\n<p>5.4 节在实现 HTTP 服务器的项目上下文中介绍了此原理。在其第一个实现中，该项目在不同的类中使用了两种不同的方法来读取和解析 HTTP 请求。第一种方法从网络套接字读取传入请求的文本，并将其放置在字符串对象中。第二种方法解析字符串以提取请求的各个组成部分。经过这种分解，这两种方法最终都对 HTTP 请求的格式有了相当的了解：第一种方法只是尝试读取请求，而不是解析请求，但是如果不执行大多数操作，就无法确定请求的结束解析它的工作（例如，它必须解析标头行才能识别包含整个请求长度的标头）。由于此共享信息，最好在同一位置读取和解析请求；当两个类合而为一时，代码变得更短，更简单。</p>\n</blockquote>\n<h2 id=\"9-2-Bring-together-if-it-will-simplify-the-interface-汇集在一起-​​-是否可以简化界面\"><a href=\"#9-2-Bring-together-if-it-will-simplify-the-interface-汇集在一起-​​-是否可以简化界面\" class=\"headerlink\" title=\"9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面\"></a>9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面</h2><p>When two or more modules are combined into a single module, it may be possible to define an interface for the new module that is simpler or easier to use than the original interfaces. This often happens when the original modules each implement part of the solution to a problem. In the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second. When the methods were combined, these interfaces were eliminated.</p>\n<blockquote>\n<p>当两个或多个模块组合成一个模块时，可以为新模块定义一个比原始接口更简单或更易于使用的接口。当原始模块各自实现问题解决方案的一部分时，通常会发生这种情况。在上一部分的 HTTP 服务器示例中，原始方法需要一个接口来从第一个方法返回 HTTP 请求字符串并将其传递给第二个方法。当这些方法结合在一起时，这些接口就被淘汰了。</p>\n</blockquote>\n<p>In addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them. The Java I/O library illustrates this opportunity. If the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering. A combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.</p>\n<blockquote>\n<p>另外，将两个或更多类的功能组合在一起时，可能会自动执行某些功能，因此大多数用户无需了解它们。Java I/O 库说明了这种机会。如果将 FileInputStream 和 BufferedInputStream 类组合在一起，并且默认情况下提供了缓冲，则绝大多数用户甚至都不需要知道缓冲的存在。组合的 FileInputStream 类可能提供禁用或替换默认缓冲机制的方法，但是大多数用户不需要了解它们。</p>\n</blockquote>\n<h2 id=\"9-3-Bring-together-to-eliminate-duplication-消除重复\"><a href=\"#9-3-Bring-together-to-eliminate-duplication-消除重复\" class=\"headerlink\" title=\"9.3 Bring together to eliminate duplication 消除重复\"></a>9.3 Bring together to eliminate duplication 消除重复</h2><p>If you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeated code out into a separate method and replace the repeated code snippets with calls to the method. This approach is most effective if the repeated code snippet is long and the replacement method has a simple signature. If the snippet is only one or two lines long, there may not be much benefit in replacing it with a method call. If the snippet interacts in complex ways with its environment (such as by accessing numerous local variables), then the replacement method might require a complex signature (such as many pass-by-reference arguments), which would reduce its value.</p>\n<blockquote>\n<p>如果发现反复重复相同的代码模式，请查看是否可以重新组织代码以消除重复。一种方法是将重复的代码分解为一个单独的方法，并用对该方法的调用替换重复的代码段。如果重复的代码段很长并且替换方法具有简单的签名，则此方法最有效。如果代码段只有一两行，那么用方法调用替换它可能不会有太多好处。如果代码段与其环境以复杂的方式进行交互（例如，通过访问多个局部变量），则替换方法可能需要复杂的签名（例如，许多“按引用传递”参数），这会降低其价值。</p>\n</blockquote>\n<p>Another way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writing a method that needs to return errors at several different points, and the same cleanup actions need to be performed at each of these points before returning (see Figure 9.1 for an example). If the programming language supports goto, you can move the cleanup code to the very end of the method and then goto that snippet at each of the points where an error return is required, as in Figure 9.2. Goto statements are generally considered a bad idea, and they can result in indecipherable code if used indiscriminately, but they are useful in situations like this where they are used to escape from nested code.</p>\n<blockquote>\n<p>消除重复的另一种方法是重构代码，使相关代码段仅需要在一个地方执行。假设您正在编写一种方法，该方法需要在几个不同的点返回错误，并且在返回之前需要在每个这些点执行相同的清除操作（示例请参见图 9.1）。如果编程语言支持 goto，则可以将清除代码移到方法的最后，然后在需要返回错误的每个点处转到该片段，如图 9.2 所示。Goto 语句通常被认为是一个坏主意，如果不加选择地使用它们，可能会导致无法识别的代码，但是在诸如此类的情况下，它们可用于从嵌套代码中转义，因此它们非常有用。</p>\n</blockquote>\n<h2 id=\"9-4-Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码\"><a href=\"#9-4-Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码\" class=\"headerlink\" title=\"9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码\"></a>9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码</h2><p>If a module contains a mechanism that can be used for several different purposes, then it should provide just that one general-purpose mechanism. It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typically one associated with the particular purpose). The GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the selection) were implemented in the user interface module. This approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.</p>\n<blockquote>\n<p>如果模块包含可用于多种不同目的的机制，则它应仅提供一种通用机制。它不应包含专门针对特定用途的机制的代码，也不应包含其他通用机制。与通用机制关联的专用代码通常应放在不同的模块中（通常是与特定用途关联的模块）。第 6 章中的 GUI 编辑器讨论阐明了这一原理：最佳设计是文本类提供通用文本操作，而特定于用户界面的操作（例如删除所选内容）则在用户界面模块中实现。</p>\n</blockquote>\n<p>img Red Flag: Repetition img</p>\n<p>If the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.</p>\n<blockquote>\n<p>如果相同的代码（或几乎相同的代码）一遍又一遍地出现，那是一个危险信号，您没有找到正确的抽象。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00017.gif\" alt=\"\"></p>\n<p>Figure 9.1: This code processes incoming network packets of different types; for each type, if the packet is too short for that type, a message gets logged. In this version of the code, the LOG statement is duplicated for several different packet types.</p>\n<blockquote>\n<p>图 9.1：此代码处理不同类型的传入网络数据包。对于每种类型，如果数据包对于该类型而言太短，则会记录一条消息。在此版本的代码中，LOG 语句对于几种不同的数据包类型是重复的。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00018.gif\" alt=\"\"></p>\n<p>Figure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement.</p>\n<blockquote>\n<p>图 9.2：对图 9.1 中的代码进行了重新组织，因此只有 LOG 语句的一个副本。</p>\n</blockquote>\n<p>In general, the lower layers of a system tend to be more general-purpose and the upper layers more special-purpose. For example, the topmost layer of an application consists of features totally specific to that application. The way to separate special-purpose code from general-purpose code is to pull the special-purpose code upwards, into the higher layers, leaving the lower layers general-purpose. When you encounter a class that includes both general-purpose and special-purpose features for the same abstraction, see if the class can be separated into two classes, one containing the general-purpose features, and the other layered on top of it to provide the special-purpose features.</p>\n<blockquote>\n<p>通常，系统的下层倾向于更通用，而上层则更专用。例如，应用程序的最顶层包含完全特定于该应用程序的功能。将专用代码与通用代码分开的方法是将专用代码向上拉到较高的层，而将较低的层保留为通用。当您遇到同时包含通用功能和专用功能的同一类的类时，请查看该类是否可以分为两个类，一个包含通用功能，另一个在其上分层以提供特殊功能</p>\n</blockquote>\n<h2 id=\"9-5-Example-insertion-cursor-and-selection-示例：插入光标和选择\"><a href=\"#9-5-Example-insertion-cursor-and-selection-示例：插入光标和选择\" class=\"headerlink\" title=\"9.5 Example: insertion cursor and selection 示例：插入光标和选择\"></a>9.5 Example: insertion cursor and selection 示例：插入光标和选择</h2><p>The next sections work through three examples that illustrate the principles discussed above. In two of the examples the best approach is to separate the relevant pieces of code; in the third example it is better to join them together.</p>\n<blockquote>\n<p>下一节将通过三个示例说明上述原理。在两个示例中，最好的方法是分离相关的代码段。在第三个示例中，最好将它们结合在一起。</p>\n</blockquote>\n<p>The first example consists of the insertion cursor and the selection in the GUI editor project from Chapter 6. The editor displayed a blinking vertical line indicating where text typed by the user would appear in the document. It also displayed a highlighted range of characters called the selection, which was used for copying or deleting text. The insertion cursor was always visible, but there could be times when no text was selected. If the selection existed, the insertion cursor was always positioned at one end of it.</p>\n<blockquote>\n<p>第一个示例由插入光标和第 6 章的 GUI 编辑器项目中的选择组成。编辑器显示闪烁的垂直线，指示用户键入的文本将出现在文档中的何处。它还显示了一个突出显示的字符范围，称为选择，用于复制或删除文本。插入光标始终可见，但是有时可能没有选择文本。如果存在选择，则插入光标始终位于其一端。</p>\n</blockquote>\n<p>The selection and insertion cursor are related in some ways. For example, the cursor is always positioned at one end of the selection, and the cursor and selection tend to be manipulated together: clicking and dragging the mouse sets both of them, and text insertion first deletes the selected text, if there is any, and then inserts new text at the cursor position. Thus, it might seem logical to use a single object to manage both the selection and the cursor, and one project team took this approach. The object stored two positions in the file, along with booleans indicating which end was the cursor and whether the selection existed.</p>\n<blockquote>\n<p>选择和插入光标在某些方面相关。例如，光标始终位于所选内容的一端，并且倾向于将光标和所选内容一起操作：单击并拖动鼠标将它们都设置，然后插入文本会首先删除所选的文本（如果有），然后在光标位置插入新文本。因此，使用单个对象管理选择和光标似乎合乎逻辑，并且一个项目团队采用了这种方法。该对象在文件中存储了两个位置，以及布尔值，它们指示光标的哪一端以及选择是否存在。</p>\n</blockquote>\n<p>However, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text). The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separate entity, but instead had to store a boolean indicating which end of the selection was the cursor. In order to retrieve the cursor position, the combined object had to first test the boolean and then choose the appropriate end of the selection.</p>\n<blockquote>\n<p>但是，合并的对象很尴尬。它对高级代码没有任何好处，因为高级代码仍然需要将选择和游标视为不同的实体，并且对它们进行单独操作（在插入文本期间，它首先在组合对象上调用一个方法来删除选定的文本；然后调用另一个方法来检索光标位置，以插入新文本）。实际上，组合对象比单独的对象实现起来要复杂得多。它避免了将光标位置存储为单独的实体，而是不得不存储一个布尔值，该布尔值指示选择的哪一端是光标。为了检索光标位置，组合对象必须首先测试布尔值，然后选择选择的适当结尾。</p>\n</blockquote>\n<p>img Red Flag: Special-General Mixture img</p>\n<p>This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.</p>\n<blockquote>\n<p>当通用机制还包含专门用于该机制的特定用途的代码时，就会出现此红色标志。这使该机制更加复杂，并在该机制与特定用例之间造成了信息泄漏：对用例的未来修改也可能需要对基础机制进行更改。</p>\n</blockquote>\n<p>In this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler. Separate objects provided a simpler interface than a combined object from which selection and cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectly through a selection and a boolean. In fact, in the revised version no special classes were used for either the selection or the cursor. Instead, a new Position class was introduced to represent a location in the file (a line number and character within line). The selection was represented with two Positions and the cursor with one. Positions also found other uses in the project. This example also demonstrates the benefits of a lower-level but more general-purpose interface, which were discussed in Chapter 6.</p>\n<blockquote>\n<p>在这种情况下，选择和光标之间的关联度不足以将它们组合在一起。当修改代码以分隔选择和光标时，用法和实现都变得更加简单。与必须从中提取选择和光标信息的组合对象相比，单独的对象提供了更简单的界面。游标的实现也变得更加简单，因为游标的位置是直接表示的，而不是通过选择和布尔值间接表示的。实际上，在修订版中，没有特殊的类用于选择或游标。相反，引入了一个新的 Position 类来表示文件中的位置（行号和行内的字符）。选择用两个位置表示，光标用一个位置表示。职位还在项目中找到了其他用途。</p>\n</blockquote>\n<h2 id=\"9-6-Example-separate-class-for-logging-示例：用于记录的单独类\"><a href=\"#9-6-Example-separate-class-for-logging-示例：用于记录的单独类\" class=\"headerlink\" title=\"9.6 Example: separate class for logging 示例：用于记录的单独类\"></a>9.6 Example: separate class for logging 示例：用于记录的单独类</h2><p>The second example involved error logging in a student project. A class contained several code sequences like the following:</p>\n<blockquote>\n<p>第二个示例涉及学生项目中的错误记录。一个类包含几个代码序列，如下所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    rpcConn = connectionPool.getConnection(dest);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    NetworkErrorLogger.logRpcOpenError(req, dest, e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked. The error logging class was defined at the end of the same source file:</p>\n<blockquote>\n<p>而不是在检测到错误时记录错误，而是调用特殊错误记录类中的单独方法。错误记录类是在同一源文件的末尾定义的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkErrorLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Output information relevant to an error that occurs when trying</span></span><br><span class=\"line\"><span class=\"comment\">    *  to open a connection to send an RPC.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> req</span></span><br><span class=\"line\"><span class=\"comment\">    *       The RPC request that would have been sent through the connection</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> dest</span></span><br><span class=\"line\"><span class=\"comment\">    *       The destination of the RPC</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> e</span></span><br><span class=\"line\"><span class=\"comment\">    *       The caught error</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">logRpcOpenError</span><span class=\"params\">(RpcRequest req, AddrPortTuple dest, Exception e)</span> </span>&#123;</span><br><span class=\"line\">        logger.log(Level.WARNING, <span class=\"string\">\"Cannot send message: \"</span> + req + <span class=\"string\">\". \\n\"</span> + <span class=\"string\">\"Unable to find or open connection to \"</span> + dest + <span class=\"string\">\" :\"</span> + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The NetworkErrorLogger class contained several methods such as logRpcSendError and logRpcReceiveError, each of which logged a different kind of error.</p>\n<blockquote>\n<p>NetworkErrorLogger 类包含几个方法，例如 logRpcSendError 和 logRpcReceiveError，每个方法都记录了不同类型的错误。</p>\n</blockquote>\n<p>This separation added complexity with no benefit. The logging methods were shallow: most consisted of a single line of code, but they required a considerable amount of documentation. Each method was only invoked in a single place. The logging methods were highly dependent on their invocations: someone reading the invocation would most likely flip over to the logging method to make sure that the right information was being logged; similarly, someone reading the logging method would probably flip over to the invocation site to understand the purpose of the method.</p>\n<blockquote>\n<p>这种分离增加了复杂性，没有任何好处。日志记录方法很浅：大多数只包含一行代码，但是它们需要大量的文档。每个方法仅在单个位置调用。日志记录方法高度依赖于它们的调用：读取调用的人很可能会切换到日志记录方法，以确保记录了正确的信息。同样，阅读日志记录方法的人可能会转到调用站点以了解该方法的目的。</p>\n</blockquote>\n<p>In this example, it would be better to eliminate the logging methods and place the logging statements at the locations where the errors were detected. This would make the code easier to read and eliminate the interfaces required for the logging methods.</p>\n<blockquote>\n<p>在此示例中，最好消除日志记录方法，并将日志记录语句放置在检测到错误的位置。这将使代码更易于阅读，并消除了日志记录方法所需的接口。</p>\n</blockquote>\n<h2 id=\"9-7-Example-editor-undo-mechanism-示例：编辑器撤消机制\"><a href=\"#9-7-Example-editor-undo-mechanism-示例：编辑器撤消机制\" class=\"headerlink\" title=\"9.7 Example: editor undo mechanism 示例：编辑器撤消机制\"></a>9.7 Example: editor undo mechanism 示例：编辑器撤消机制</h2><p>In the GUI editor project from Section 6.2, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view. For example, if a user selected some text, deleted it, scrolled to a different place in the file, and then invoked undo, the editor had to restore its state to what it was just before the deletion. This included restoring the deleted text, selecting it again, and also making the selected text visible in the window.</p>\n<blockquote>\n<p>在 6.2 节的 GUI 编辑器项目中，要求之一是支持多级撤消/重做，不仅要更改文本本身，还要更改选择，插入光标和视图。例如，如果用户选择了一些文本，将其删除，滚动到文件中的其他位置，然后调用 undo，则编辑器必须将其状态恢复为删除前的状态。这包括还原已删除的文本，再次选择它，并使所选的文本在窗口中可见。</p>\n</blockquote>\n<p>Some of the student projects implemented the entire undo mechanism as part of the text class. The text class maintained a list of all the undoable changes. It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list. When undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list. For entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.</p>\n<blockquote>\n<p>一些学生项目将整个撤消机制实现为文本类的一部分。文本类维护所有不可撤消更改的列表。每当更改文本时，它将自动将条目添加到此列表中。为了更改选择，插入光标和视图，用户界面代码调用了文本类中的其他方法，然后将这些更改的条目添加到撤消列表中。当用户请求撤消或重做时，用户界面代码将调用文本类中的方法，该方法然后处理撤消列表中的条目。对于与文本相关的条目，它更新了文本类的内部。对于与其他事物（例如选择）相关的条目，将调用返回到用户界面代码的文本类来执行撤消或重做。</p>\n</blockquote>\n<p>This approach resulted in an awkward set of features in the text class. The core of undo/redo consists of a general-purpose mechanism for managing a list of actions that have been executed and stepping through them during undo and redo operations. The core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection. The special-purpose undo handlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth. If a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition, the general-purpose undo core had little to do with the general-purpose text facilities in the class.</p>\n<blockquote>\n<p>这种方法在文本类中导致了一系列尴尬的功能。撤消/重做的核心由通用机制组成，用于管理已执行的动作列表，并在撤消和重做操作期间逐步执行这些动作。核心与专用处理程序一起位于 text 类中，该专用处理程序对诸如文本和选择之类的特定内容实现了撤消和重做。用于选择和光标的专用撤消处理程序与文本类中的任何其他内容均无关。它们导致文本类和用户界面之间的信息泄漏，以及每个模块中来回传递撤消信息的额外方法。如果将来将新的可撤消实体添加到系统中，则将需要更改文本类，包括特定于该实体的新方法。</p>\n</blockquote>\n<p>These problems can be solved by extracting the general-purpose core of the undo/redo mechanism and placing it in a separate class:</p>\n<blockquote>\n<p>通过提取撤消/重做机制的通用核心并将其放在单独的类中，可以解决这些问题：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">History</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">redo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    History() &#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAction</span><span class=\"params\">(Action action)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addFence</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">redo</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>In this design, the History class manages a collection of objects that implement the interface History.Action. Each History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation. The History class knows nothing about the information stored in the actions or how they implement their undo and redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.</p>\n<blockquote>\n<p>在此设计中，History 类管理实现接口 History.Action 的对象的集合。每个 History.Action 描述一个操作，例如插入文本或更改光标位置，并且它提供了可以撤消或重做该操作的方法。History 类对操作中存储的信息或它们如何实现其撤消和重做方法一无所知。历史记录维护一个历史记录列表，该列表描述了应用程序整个生命周期中执行的所有操作，并且它提供了撤消和重做方法，以响应用户请求的撤消和重做而在列表中前后移动，并在应用程序中调用撤消和重做方法。历史动作。</p>\n</blockquote>\n<p>History.Actions are special-purpose objects: each one understands a particular kind of undoable operation. They are implemented outside the History class, in modules that understand particular kinds of undoable actions. The text class might implement UndoableInsert and UndoableDelete objects to describe text insertions and deletions. Whenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list. The editor’s user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selection and insertion cursor.</p>\n<blockquote>\n<p>历史。动作是特殊目的的对象：每个人都了解一种特殊的不可操作。它们在 History 类之外的模块中实现，这些模块可以理解特定类型的可撤销操作。文本类可能实现 UndoableInsert 和 UndoableDelete 对象，以描述文本的插入和删除。每当插入文本时，文本类都会创建一个描述该插入的新 UndoableInsert 对象，并调用 History.addAction 将其添加到历史列表中。编辑器的用户界面代码可能会创建 UndoableSelection 和 UndoableCursor 对象，这些对象描述对选择和插入光标的更改。</p>\n</blockquote>\n<p>The History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor. There are a number of ways to group actions; the History class uses fences, which are markers placed in the history list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence. The placement of fences is determined by higher-level code by invoking History.addFence.</p>\n<blockquote>\n<p>History 类还允许对操作进行分组，例如，来自用户的单个撤消请求可以恢复已删除的文本，重新选择已删除的文本以及重新放置插入光标。有多种将动作分组的方法。历史记录类使用围栏，围栏是放置在历史记录列表中的标记，用于分隔相关动作的组。每次对 History.redo 的调用都会向后浏览历史记录列表，撤消操作，直到到达下一个栅栏。围栏的位置由更高级别的代码通过调用 History.addFence 确定。</p>\n</blockquote>\n<p>This approach divides the functionality of undo into three categories, each of which is implemented in a different place:</p>\n<blockquote>\n<p>这种方法将撤消功能分为三类，每类都在不同的地方实现：</p>\n</blockquote>\n<p>A general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).<br>The specifics of particular actions (implemented by a variety of classes, each of which understands a small number of action types).<br>The policy for grouping actions (implemented by high-level user interface code to provide the right overall application behavior).<br>Each of these categories can be implemented without any understanding of the other categories. The History class does not know what kind of actions are being undone; it could be used in a variety of applications. Each action class understands only a single kind of action, and neither the History class nor the action classes needs to be aware of the policy for grouping actions.</p>\n<blockquote>\n<p>一种用于管理和分组动作以及调用撤消/重做操作的通用机制（由 History 类实现）。特定操作的细节（由各种类实现，每个类都了解少量的操作类型）。分组操作的策略（由高级用户界面代码实现，以提供正确的整体应用程序行为）。这些类别中的每一个都可以在不了解其他类别的情况下实施。历史课不知道要撤消哪种操作；它可以用于多种应用。每个动作类仅理解一种动作，并且历史记录类和动作类都不需要知道将动作分组的策略。</p>\n</blockquote>\n<p>The key design decision was the one that separated the general-purpose part of the undo mechanism from the special-purpose parts and put the general-purpose part in a class by itself. Once that was done, the rest of the design fell out naturally.</p>\n<blockquote>\n<p>关键的设计决策是将撤消机制的通用部分与专用部分分开，然后将通用部分单独放在一个类中的决定。一旦完成，其余的设计就会自然消失。</p>\n</blockquote>\n<p>Note: the suggestion to separate general-purpose code from special-purpose code refers to code related to a particular mechanism. For example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list). However, it often makes sense to combine special-purpose code for one mechanism with general-purpose code for another. The text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special-purpose because it only handles undo operations for text modifications. It doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.</p>\n<blockquote>\n<p>注意:将通用代码与专用代码分离的建议是指与特定机制相关的代码。例如，特殊用途的撤消代码(例如撤消文本插入的代码)应该与通用用途的撤消代码(例如管理历史记录列表的代码)分开。然而，将一种机制的专用代码与另一种机制的通用代码组合起来通常是有意义的。text 类就是这样一个例子:它实现了一种管理文本的通用机制，但是它包含了与撤销相关的专用代码。撤消代码是专用的，因为它只处理文本修改的撤消操作。将这段代码与 History 类中通用的 undo 基础结构结合在一起是没有意义的，但是将它放在 text 类中是有意义的，因为它与其他文本函数密切相关。</p>\n</blockquote>\n<h2 id=\"9-8-Splitting-and-joining-methods-拆分和合并方法\"><a href=\"#9-8-Splitting-and-joining-methods-拆分和合并方法\" class=\"headerlink\" title=\"9.8 Splitting and joining methods 拆分和合并方法\"></a>9.8 Splitting and joining methods 拆分和合并方法</h2><p>The issue of when to subdivide applies not just to classes, but also to methods: are there times when it is better to divide an existing method into multiple smaller methods? Or, should two smaller methods be combined into one larger one? Long methods tend to be more difficult to understand than shorter ones, so many people argue that length alone is a good justification for breaking up a method. Students in classes are often given rigid criteria, such as “Split up any method longer than 20 lines!”</p>\n<blockquote>\n<p>何时细分的问题不仅适用于类，而且还适用于方法：是否有时最好将现有方法分为多个较小的方法？还是应该将两种较小的方法合并为一种较大的方法？长方法比短方法更难于理解，因此许多人认为仅长度是分解方法的一个很好的理由。课堂上的学生通常会获得严格的标准，例如“拆分超过 20 行的任何方法！”</p>\n</blockquote>\n<p>However, length by itself is rarely a good reason for splitting up a method. In general, developers tend to break up methods too much. Splitting up a method introduces additional interfaces, which add to complexity. It also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related. You shouldn’t break up a method unless it makes the overall system simpler; I’ll discuss how this might happen below.</p>\n<blockquote>\n<p>但是，长度本身很少是拆分方法的一个很好的理由。通常，开发人员倾向于过多地分解方法。拆分方法会引入其他接口，从而增加了复杂性。它还将原始方法的各个部分分开，如果这些部分实际上是相关的，则使代码更难阅读。您不应该分解一种方法，除非它使整个系统更加简单；我将在下面讨论这种情况。</p>\n</blockquote>\n<p>Long methods aren’t always bad. For example, suppose a method contains five 20-line blocks of code that are executed in order. If the blocks are relatively independent, then the method can be read and understood one block at a time; there’s not much benefit in moving each of the blocks into a separate method. If the blocks have complex interactions, it’s even more important to keep them together so readers can see all of the code at once; if each block is in a separate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundreds of lines of code are fine if they have a simple signature and are easy to read. These methods are deep (lots of functionality, simple interface), which is good.</p>\n<blockquote>\n<p>长方法并不总是坏的。例如，假设一个方法包含按顺序执行的五个 20 行代码块。如果这些块是相对独立的，则可以一次读取并理解该方法的一个块。将每个块移动到单独的方法中并没有太大的好处。如果这些块具有复杂的交互作用，则将它们保持在一起就显得尤为重要，这样读者就可以一次看到所有代码。如果每个块使用单独的方法，则读者将不得不在这些扩展方法之间来回切换，以了解它们如何协同工作。如果方法具有简单的签名并且易于阅读，则包含数百行代码的方法就可以了。这些方法很深入（很多功能，简单的界面），很好。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00019.jpeg\" alt=\"\"></p>\n<p>Figure 9.3: A method (a) can be split either by by extracting a subtask (b) or by dividing its functionality into two separate methods (c). A method should not be split if it results in shallow methods, as in (d).</p>\n<blockquote>\n<p>图 9.3：方法（a）可以通过提取子任务（b）或将其功能划分为两个单独的方法（c）进行拆分。如果方法导致浅层方法，则不应拆分该方法，如（d）所示。</p>\n</blockquote>\n<p>When designing methods, the most important goal is to provide clean and simple abstractions. Each method should do one thing and do it completely. The method should have a clean and simple interface, so that users don’t need to have much information in their heads in order to use it correctly. The method should be deep: its interface should be much simpler than its implementation. If a method has all of these properties, then it probably doesn’t matter whether it is long or not.</p>\n<blockquote>\n<p>设计方法时，最重要的目标是提供简洁的抽象。每种方法都应该做一件事并且完全做到这一点。该方法应该具有简洁的界面，以便用户无需费神就可以正确使用它。该方法应该很深：其接口应该比其实现简单得多。如果一个方法具有所有这些属性，那么它的长短与否可能无关紧要。</p>\n</blockquote>\n<p>Splitting up a method only makes sense if it results in cleaner abstractions, overall. There are two ways to do this, which are diagrammed in Figure 9.3. The best way is by factoring out a subtask into a separate method, as shown in Figure 9.3(b). The subdivision results in a child method containing the subtask and a parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the original method. This form of subdivision makes sense if there is a subtask that is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesn’t need to know anything about the parent method and (b) someone reading the parent method doesn’t need to understand the implementation of the child method. Typically this means that the child method is relatively general-purpose: it could conceivably be used by other methods besides the parent. If you make a split of this form and then find yourself flipping back and forth between the parent and child to understand how they work together, that is a red flag (“Conjoined Methods”) indicating that the split was probably a bad idea.</p>\n<blockquote>\n<p>总体而言，拆分方法只有在其导致更抽象的抽象时才有意义。有两种方法可以做到这一点，如图 9.3 所示。最佳方法是将子任务分解为单独的方法，如图 9.3（b）所示。该细分产生一个包含该子任务的子方法和一个包含原始方法其余部分的父方法；父级调用子级。新的父方法的接口与原始方法的接口相同。如果存在一个与原始方法的其余部分完全可分离的子任务，则这种细分形式是有意义的，这意味着（a）读取子方法的某人不需要了解有关父方法的任何信息，以及（b）某人在阅读父方法不需要了解子方法的实现。通常，这意味着子方法是相对通用的：可以想象除父方法外，其他方法也可以使用它。如果您对这种形式进行拆分，然后发现自己在父母和孩子之间来回翻转以了解他们如何一起工作，那是一个红色标记（“联合方法”），表明拆分可能不是一个好主意。</p>\n</blockquote>\n<p>The second way to break up a method is to split it into two separate methods, each visible to callers of the original method, as in Figure 9.3(c). This makes sense if the original method had an overly complex interface because it tried to do multiple things that were not closely related. If this is the case, it may be possible to divide the method’s functionality into two or more smaller methods, each of which has only a part of the original method’s functionality. If you make a split like this, the interface for each of the resulting methods should be simpler than the interface of the original method. Ideally, most callers should only need to invoke one of the two new methods; if callers must invoke both of the new methods, then that adds complexity, which makes it less likely that the split is a good idea. The new methods will be more focused in what they do. It is a good sign if the new methods are more general-purpose than the original method (i.e., you can imagine using them separately in other situations).</p>\n<blockquote>\n<p>分解方法的第二种方法是将其拆分为两个单独的方法，每个方法对原始方法的调用者可见，如图 9.3（c）所示。如果原始方法的接口过于复杂，这是有道理的，因为该接口试图执行不密切相关的多项操作。在这种情况下，可以将方法的功能划分为两个或更多个较小的方法，每个方法仅具有原始方法功能的一部分。如果进行这样的拆分，则每个结果方法的接口应该比原始方法的接口更简单。理想情况下，大多数调用者只需要调用两个新方法之一即可；如果调用者必须同时调用这两个新方法，则将增加复杂性，从而降低拆分是个好主意的可能性。新方法将更加专注于它们的工作。如果新方法比原始方法更具通用性，那么这是一个好兆头（例如，您可以想象在其他情况下单独使用它们）。</p>\n</blockquote>\n<p>Splits of the form shown in Figure 9.3(c) don’t make sense very often, because they result in callers having to deal with multiple methods instead of one. When you split this way, you run the risk of ending up with several shallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods, passing state back and forth between them, then splitting is not a good idea. If you’re considering a split like the one in Figure 9.3(c), you should judge it based on whether it simplifies things for callers.</p>\n<blockquote>\n<p>图 9.3（c）所示形式的拆分并不是很有意义，因为它们导致调用者不得不处理多个方法而不是一个方法。当您以这种方式拆分时，您可能会遇到几种浅层方法的风险，如图 9.3（d）所示。如果调用者必须调用每个单独的方法，并在它们之间来回传递状态，则拆分不是一个好主意。如果您正在考虑像图 9.3（c）所示的拆分，则应基于它是否简化了呼叫者的情况来进行判断。</p>\n</blockquote>\n<p>There are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it might eliminate dependencies between the original methods, or intermediate data structures; it might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place; or it might result in a simpler interface, as discussed in Section 9.2.</p>\n<blockquote>\n<p>在某些情况下，通过将方法结合在一起可以简化系统。例如，连接方法可以用一种更深的方法代替两种浅的方法。它可以消除重复的代码；它可以消除原始方法或中间数据结构之间的依赖关系；它可能导致更好的封装，从而使以前在多个位置存在的知识现在被隔离在一个位置；否则可能会导致界面更简单，如 9.2 节所述。</p>\n</blockquote>\n<p>img Red Flag: Conjoined Methods img</p>\n<p>It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.</p>\n<blockquote>\n<p>应该有可能独立地理解每种方法。如果您不能不理解另一种方法的实现而无法理解一种方法的实现，那就是一个危险信号。该危险信号也可以在其他情况下发生：如果两段代码在物理上是分开的，但是只有通过查看另一段代码才能理解它们，这就是危险信号。</p>\n</blockquote>\n<h2 id=\"9-9-Conclusion-结论\"><a href=\"#9-9-Conclusion-结论\" class=\"headerlink\" title=\"9.9 Conclusion 结论\"></a>9.9 Conclusion 结论</h2><p>The decision to split or join modules should be based on complexity. Pick the structure that results in the best information hiding, the fewest dependencies, and the deepest interfaces.</p>\n<blockquote>\n<p>拆分或加入模块的决定应基于复杂性。选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>在一起更好还是分开更好？</p>","more":"<h1 id=\"第-9-章-在一起更好还是分开更好？\"><a href=\"#第-9-章-在一起更好还是分开更好？\" class=\"headerlink\" title=\"第 9 章 在一起更好还是分开更好？\"></a>第 9 章 在一起更好还是分开更好？</h1><blockquote>\n<p>Chapter 9 Better Together Or Better Apart?</p>\n</blockquote>\n<p>One of the most fundamental questions in software design is this: given two pieces of functionality, should they be implemented together in the same place, or should their implementations be separated? This question applies at all levels in a system, such as functions, methods, classes, and services. For example, should buffering be included in the class that provides stream-oriented file I/O, or should it be in a separate class? Should the parsing of an HTTP request be implemented entirely in one method, or should it be divided among multiple methods (or even multiple classes)? This chapter discusses the factors to consider when making these decisions. Some of these factors have already been discussed in previous chapters, but they will be revisited here for completeness.</p>\n<blockquote>\n<p>软件设计中最基本的问题之一是：给定两个功能，它们应该在同一位置一起实现，还是应该分开实现？这个问题适用于系统中的所有级别，例如功能，方法，类和服务。例如，应该在提供面向流的文件 I/O 的类中包括缓冲，还是应该在单独的类中？HTTP 请求的解析应该完全在一种方法中实现，还是应该在多个方法（甚至多个类）之间划分？本章讨论做出这些决定时要考虑的因素。这些因素中的一些已经在前面的章节中进行了讨论，但是为了完整起见，这里将对其进行重新讨论。</p>\n</blockquote>\n<p>When deciding whether to combine or separate, the goal is to reduce the complexity of the system as a whole and improve its modularity. It might appear that the best way to achieve this goal is to divide the system into a large number of small components: the smaller the components, the simpler each individual component is likely to be. However, the act of subdividing creates additional complexity that was not present before subdivision:</p>\n<blockquote>\n<p>在决定是合并还是分开时，目标是降低整个系统的复杂性并改善其模块化。看来实现此目标的最佳方法是将系统划分为大量的小组件：组件越小，每个单独的组件可能越简单。但是，细分的行为会带来额外的复杂性，而这在细分之前是不存在的：</p>\n</blockquote>\n<ul>\n<li>Some complexity comes just from the number of components: the more components, the harder to keep track of them all and the harder to find a desired component within the large collection. Subdivision usually results in more interfaces, and every new interface adds complexity.</li>\n<li>Subdivision can result in additional code to manage the components. For example, a piece of code that used a single object before subdivision might now have to manage multiple objects.</li>\n<li>Subdivision creates separation: the subdivided components will be farther apart than they were before subdivision. For example, methods that were together in a single class before subdivision may be in different classes after subdivision, and possibly in different files. Separation makes it harder for developers to see the components at the same time, or even to be aware of their existence. If the components are truly independent, then separation is good: it allows the developer to focus on a single component at a time, without being distracted by the other components. On the other hand, if there are dependencies between the components, then separation is bad: developers will end up flipping back and forth between the components. Even worse, they may not be aware of the dependencies, which can lead to bugs.</li>\n<li>Subdivision can result in duplication: code that was present in a single instance before subdivision may need to be present in each of the subdivided components.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>一些组件的复杂性仅来自组件的数量：组件越多，就越难以追踪所有组件，也就越难在大型集合中找到所需的组件。细分通常会导致更多接口，并且每个新接口都会增加复杂性。</li>\n<li>细分可能会导致附加代码来管理组件。例如，在细分之前使用单个对象的一段代码现在可能必须管理多个对象。</li>\n<li>细分产生分离：细分后的组件将比细分前的组件相距更远。例如，在细分之前位于单个类中的方法可能在细分之后位于不同的类中，并且可能在不同的文件中。分离使开发人员更难于同时查看这些组件，甚至很难知道它们的存在。如果组件真正独立，那么分离是好的：它使开发人员可以一次专注于单个组件，而不会被其他组件分散注意力。另一方面，如果组件之间存在依赖性，则分离是不好的：开发人员最终将在组件之间来回翻转。更糟糕的是，他们可能不了解依赖关系，这可能导致错误。</li>\n<li>细分可能导致重复：细分之前的单个实例中存在的代码可能需要存在于每个细分的组件中。</li>\n</ul>\n</blockquote>\n<p>Bringing pieces of code together is most beneficial if they are closely related. If the pieces are unrelated, they are probably better off apart. Here are a few indications that two pieces of code are related:</p>\n<blockquote>\n<p>如果它们紧密相关，则将代码段组合在一起是最有益的。如果各部分无关，则最好分开。以下是两个代码相关的一些提示：</p>\n</blockquote>\n<ul>\n<li>They share information; for example, both pieces of code might depend on the syntax of a particular type of document.</li>\n<li>They are used together: anyone using one of the pieces of code is likely to use the other as well. This form of relationship is only compelling if it is bidirectional. As a counter-example, a disk block cache will almost always involve a hash table, but hash tables can be used in many situations that don’t involve block caches; thus, these modules should be separate.</li>\n<li>They overlap conceptually, in that there is a simple higher-level category that includes both of the pieces of code. For example, searching for a substring and case conversion both fall under the category of string manipulation; flow control and reliable delivery both fall under the category of network communication.</li>\n<li>It is hard to understand one of the pieces of code without looking at the other.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>他们共享信息；例如，这两段代码都可能取决于特定类型文档的语法。</li>\n<li>它们一起使用：任何使用其中一段代码的人都可能同时使用另一段代码。这种关系形式只有在双向关系中才具有吸引力。作为反例，磁盘块高速缓存几乎总是包含哈希表，但是哈希表可以在许多不涉及块高速缓存的情况下使用。因此，这些模块应该分开。</li>\n<li>它们在概念上重叠，因为存在一个简单的更高级别的类别，其中包括这两段代码。例如，搜索子字符串和大小写转换都属于字符串操作类别。流控制和可靠的交付都属于网络通信的范畴。</li>\n<li>不看其中的一段代码就很难理解。</li>\n</ul>\n</blockquote>\n<p>The rest of this chapter uses more specific rules as well as examples to show when it makes sense to bring pieces of code together and when it makes sense to separate them.</p>\n<blockquote>\n<p>本章的其余部分使用更具体的规则以及示例来说明何时将代码段组合在一起以及何时将它们分开是有意义的。</p>\n</blockquote>\n<h2 id=\"9-1-Bring-together-if-information-is-shared-如果信息共享则汇聚在一起\"><a href=\"#9-1-Bring-together-if-information-is-shared-如果信息共享则汇聚在一起\" class=\"headerlink\" title=\"9.1 Bring together if information is shared 如果信息共享则汇聚在一起\"></a>9.1 Bring together if information is shared 如果信息共享则汇聚在一起</h2><p>Section 5.4 introduced this principle in the context of a project implementing an HTTP server. In its first implementation, the project used two different methods in different classes to read in and parse HTTP requests. The first method read the text of an incoming request from a network socket and placed it in a string object. The second method parsed the string to extract the various components of the request. With this decomposition, both of the methods ended up with considerable knowledge of the format of HTTP requests: the first method was only trying to read the request, not parse it, but it couldn’t identify the end of the request without doing most of the work of parsing it (for example, it had to parse header lines in order to identify the header containing the overall request length). Because of this shared information, it is better to both read and parse the request in the same place; when the two classes were combined into one, the code got shorter and simpler.</p>\n<blockquote>\n<p>5.4 节在实现 HTTP 服务器的项目上下文中介绍了此原理。在其第一个实现中，该项目在不同的类中使用了两种不同的方法来读取和解析 HTTP 请求。第一种方法从网络套接字读取传入请求的文本，并将其放置在字符串对象中。第二种方法解析字符串以提取请求的各个组成部分。经过这种分解，这两种方法最终都对 HTTP 请求的格式有了相当的了解：第一种方法只是尝试读取请求，而不是解析请求，但是如果不执行大多数操作，就无法确定请求的结束解析它的工作（例如，它必须解析标头行才能识别包含整个请求长度的标头）。由于此共享信息，最好在同一位置读取和解析请求；当两个类合而为一时，代码变得更短，更简单。</p>\n</blockquote>\n<h2 id=\"9-2-Bring-together-if-it-will-simplify-the-interface-汇集在一起-​​-是否可以简化界面\"><a href=\"#9-2-Bring-together-if-it-will-simplify-the-interface-汇集在一起-​​-是否可以简化界面\" class=\"headerlink\" title=\"9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面\"></a>9.2 Bring together if it will simplify the interface 汇集在一起 ​​ 是否可以简化界面</h2><p>When two or more modules are combined into a single module, it may be possible to define an interface for the new module that is simpler or easier to use than the original interfaces. This often happens when the original modules each implement part of the solution to a problem. In the HTTP server example from the preceding section, the original methods required an interface to return the HTTP request string from the first method and pass it to the second. When the methods were combined, these interfaces were eliminated.</p>\n<blockquote>\n<p>当两个或多个模块组合成一个模块时，可以为新模块定义一个比原始接口更简单或更易于使用的接口。当原始模块各自实现问题解决方案的一部分时，通常会发生这种情况。在上一部分的 HTTP 服务器示例中，原始方法需要一个接口来从第一个方法返回 HTTP 请求字符串并将其传递给第二个方法。当这些方法结合在一起时，这些接口就被淘汰了。</p>\n</blockquote>\n<p>In addition, when the functionality of two or more classes is combined, it may be possible to perform some functions automatically, so that most users need not be aware of them. The Java I/O library illustrates this opportunity. If the FileInputStream and BufferedInputStream classes were combined and buffering were provided by default, the vast majority of users would never even need to be aware of the existence of buffering. A combined FileInputStream class might provide methods to disable or replace the default buffering mechanism, but most users would not need to learn about them.</p>\n<blockquote>\n<p>另外，将两个或更多类的功能组合在一起时，可能会自动执行某些功能，因此大多数用户无需了解它们。Java I/O 库说明了这种机会。如果将 FileInputStream 和 BufferedInputStream 类组合在一起，并且默认情况下提供了缓冲，则绝大多数用户甚至都不需要知道缓冲的存在。组合的 FileInputStream 类可能提供禁用或替换默认缓冲机制的方法，但是大多数用户不需要了解它们。</p>\n</blockquote>\n<h2 id=\"9-3-Bring-together-to-eliminate-duplication-消除重复\"><a href=\"#9-3-Bring-together-to-eliminate-duplication-消除重复\" class=\"headerlink\" title=\"9.3 Bring together to eliminate duplication 消除重复\"></a>9.3 Bring together to eliminate duplication 消除重复</h2><p>If you find the same pattern of code repeated over and over, see if you can reorganize the code to eliminate the repetition. One approach is to factor the repeated code out into a separate method and replace the repeated code snippets with calls to the method. This approach is most effective if the repeated code snippet is long and the replacement method has a simple signature. If the snippet is only one or two lines long, there may not be much benefit in replacing it with a method call. If the snippet interacts in complex ways with its environment (such as by accessing numerous local variables), then the replacement method might require a complex signature (such as many pass-by-reference arguments), which would reduce its value.</p>\n<blockquote>\n<p>如果发现反复重复相同的代码模式，请查看是否可以重新组织代码以消除重复。一种方法是将重复的代码分解为一个单独的方法，并用对该方法的调用替换重复的代码段。如果重复的代码段很长并且替换方法具有简单的签名，则此方法最有效。如果代码段只有一两行，那么用方法调用替换它可能不会有太多好处。如果代码段与其环境以复杂的方式进行交互（例如，通过访问多个局部变量），则替换方法可能需要复杂的签名（例如，许多“按引用传递”参数），这会降低其价值。</p>\n</blockquote>\n<p>Another way to eliminate duplication is to refactor the code so that the snippet in question only needs to be executed in one place. Suppose you are writing a method that needs to return errors at several different points, and the same cleanup actions need to be performed at each of these points before returning (see Figure 9.1 for an example). If the programming language supports goto, you can move the cleanup code to the very end of the method and then goto that snippet at each of the points where an error return is required, as in Figure 9.2. Goto statements are generally considered a bad idea, and they can result in indecipherable code if used indiscriminately, but they are useful in situations like this where they are used to escape from nested code.</p>\n<blockquote>\n<p>消除重复的另一种方法是重构代码，使相关代码段仅需要在一个地方执行。假设您正在编写一种方法，该方法需要在几个不同的点返回错误，并且在返回之前需要在每个这些点执行相同的清除操作（示例请参见图 9.1）。如果编程语言支持 goto，则可以将清除代码移到方法的最后，然后在需要返回错误的每个点处转到该片段，如图 9.2 所示。Goto 语句通常被认为是一个坏主意，如果不加选择地使用它们，可能会导致无法识别的代码，但是在诸如此类的情况下，它们可用于从嵌套代码中转义，因此它们非常有用。</p>\n</blockquote>\n<h2 id=\"9-4-Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码\"><a href=\"#9-4-Separate-general-purpose-and-special-purpose-code-单独的通用代码和专用代码\" class=\"headerlink\" title=\"9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码\"></a>9.4 Separate general-purpose and special-purpose code 单独的通用代码和专用代码</h2><p>If a module contains a mechanism that can be used for several different purposes, then it should provide just that one general-purpose mechanism. It should not include code that specializes the mechanism for a particular use, nor should it contain other general-purpose mechanisms. Special-purpose code associated with a general-purpose mechanism should normally go in a different module (typically one associated with the particular purpose). The GUI editor discussion in Chapter 6 illustrated this principle: the best design was one where the text class provided general-purpose text operations, while operations particular to the user interface (such as deleting the selection) were implemented in the user interface module. This approach eliminated information leakage and additional interfaces that were present in an earlier design where the specialized user interface operations were implemented in the text class.</p>\n<blockquote>\n<p>如果模块包含可用于多种不同目的的机制，则它应仅提供一种通用机制。它不应包含专门针对特定用途的机制的代码，也不应包含其他通用机制。与通用机制关联的专用代码通常应放在不同的模块中（通常是与特定用途关联的模块）。第 6 章中的 GUI 编辑器讨论阐明了这一原理：最佳设计是文本类提供通用文本操作，而特定于用户界面的操作（例如删除所选内容）则在用户界面模块中实现。</p>\n</blockquote>\n<p>img Red Flag: Repetition img</p>\n<p>If the same piece of code (or code that is almost the same) appears over and over again, that’s a red flag that you haven’t found the right abstractions.</p>\n<blockquote>\n<p>如果相同的代码（或几乎相同的代码）一遍又一遍地出现，那是一个危险信号，您没有找到正确的抽象。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00017.gif\" alt=\"\"></p>\n<p>Figure 9.1: This code processes incoming network packets of different types; for each type, if the packet is too short for that type, a message gets logged. In this version of the code, the LOG statement is duplicated for several different packet types.</p>\n<blockquote>\n<p>图 9.1：此代码处理不同类型的传入网络数据包。对于每种类型，如果数据包对于该类型而言太短，则会记录一条消息。在此版本的代码中，LOG 语句对于几种不同的数据包类型是重复的。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00018.gif\" alt=\"\"></p>\n<p>Figure 9.2: A reorganization of the code from Figure 9.1 so that there is only one copy of the LOG statement.</p>\n<blockquote>\n<p>图 9.2：对图 9.1 中的代码进行了重新组织，因此只有 LOG 语句的一个副本。</p>\n</blockquote>\n<p>In general, the lower layers of a system tend to be more general-purpose and the upper layers more special-purpose. For example, the topmost layer of an application consists of features totally specific to that application. The way to separate special-purpose code from general-purpose code is to pull the special-purpose code upwards, into the higher layers, leaving the lower layers general-purpose. When you encounter a class that includes both general-purpose and special-purpose features for the same abstraction, see if the class can be separated into two classes, one containing the general-purpose features, and the other layered on top of it to provide the special-purpose features.</p>\n<blockquote>\n<p>通常，系统的下层倾向于更通用，而上层则更专用。例如，应用程序的最顶层包含完全特定于该应用程序的功能。将专用代码与通用代码分开的方法是将专用代码向上拉到较高的层，而将较低的层保留为通用。当您遇到同时包含通用功能和专用功能的同一类的类时，请查看该类是否可以分为两个类，一个包含通用功能，另一个在其上分层以提供特殊功能</p>\n</blockquote>\n<h2 id=\"9-5-Example-insertion-cursor-and-selection-示例：插入光标和选择\"><a href=\"#9-5-Example-insertion-cursor-and-selection-示例：插入光标和选择\" class=\"headerlink\" title=\"9.5 Example: insertion cursor and selection 示例：插入光标和选择\"></a>9.5 Example: insertion cursor and selection 示例：插入光标和选择</h2><p>The next sections work through three examples that illustrate the principles discussed above. In two of the examples the best approach is to separate the relevant pieces of code; in the third example it is better to join them together.</p>\n<blockquote>\n<p>下一节将通过三个示例说明上述原理。在两个示例中，最好的方法是分离相关的代码段。在第三个示例中，最好将它们结合在一起。</p>\n</blockquote>\n<p>The first example consists of the insertion cursor and the selection in the GUI editor project from Chapter 6. The editor displayed a blinking vertical line indicating where text typed by the user would appear in the document. It also displayed a highlighted range of characters called the selection, which was used for copying or deleting text. The insertion cursor was always visible, but there could be times when no text was selected. If the selection existed, the insertion cursor was always positioned at one end of it.</p>\n<blockquote>\n<p>第一个示例由插入光标和第 6 章的 GUI 编辑器项目中的选择组成。编辑器显示闪烁的垂直线，指示用户键入的文本将出现在文档中的何处。它还显示了一个突出显示的字符范围，称为选择，用于复制或删除文本。插入光标始终可见，但是有时可能没有选择文本。如果存在选择，则插入光标始终位于其一端。</p>\n</blockquote>\n<p>The selection and insertion cursor are related in some ways. For example, the cursor is always positioned at one end of the selection, and the cursor and selection tend to be manipulated together: clicking and dragging the mouse sets both of them, and text insertion first deletes the selected text, if there is any, and then inserts new text at the cursor position. Thus, it might seem logical to use a single object to manage both the selection and the cursor, and one project team took this approach. The object stored two positions in the file, along with booleans indicating which end was the cursor and whether the selection existed.</p>\n<blockquote>\n<p>选择和插入光标在某些方面相关。例如，光标始终位于所选内容的一端，并且倾向于将光标和所选内容一起操作：单击并拖动鼠标将它们都设置，然后插入文本会首先删除所选的文本（如果有），然后在光标位置插入新文本。因此，使用单个对象管理选择和光标似乎合乎逻辑，并且一个项目团队采用了这种方法。该对象在文件中存储了两个位置，以及布尔值，它们指示光标的哪一端以及选择是否存在。</p>\n</blockquote>\n<p>However, the combined object was awkward. It provided no benefit for higher-level code, since the higher-level code still needed to be aware of the selection and cursor as distinct entities, and it manipulated them separately (during text insertion, it first invoked a method on the combined object to delete the selected text; then it invoked another method to retrieve the cursor position in order to insert new text). The combined object was actually more complex to implement than separate objects. It avoided storing the cursor position as a separate entity, but instead had to store a boolean indicating which end of the selection was the cursor. In order to retrieve the cursor position, the combined object had to first test the boolean and then choose the appropriate end of the selection.</p>\n<blockquote>\n<p>但是，合并的对象很尴尬。它对高级代码没有任何好处，因为高级代码仍然需要将选择和游标视为不同的实体，并且对它们进行单独操作（在插入文本期间，它首先在组合对象上调用一个方法来删除选定的文本；然后调用另一个方法来检索光标位置，以插入新文本）。实际上，组合对象比单独的对象实现起来要复杂得多。它避免了将光标位置存储为单独的实体，而是不得不存储一个布尔值，该布尔值指示选择的哪一端是光标。为了检索光标位置，组合对象必须首先测试布尔值，然后选择选择的适当结尾。</p>\n</blockquote>\n<p>img Red Flag: Special-General Mixture img</p>\n<p>This red flag occurs when a general-purpose mechanism also contains code specialized for a particular use of that mechanism. This makes the mechanism more complicated and creates information leakage between the mechanism and the particular use case: future modifications to the use case are likely to require changes to the underlying mechanism as well.</p>\n<blockquote>\n<p>当通用机制还包含专门用于该机制的特定用途的代码时，就会出现此红色标志。这使该机制更加复杂，并在该机制与特定用例之间造成了信息泄漏：对用例的未来修改也可能需要对基础机制进行更改。</p>\n</blockquote>\n<p>In this case, the selection and cursor were not closely enough related to combine them. When the code was revised to separate the selection and the cursor, both the usage and the implementation became simpler. Separate objects provided a simpler interface than a combined object from which selection and cursor information had to be extracted. The cursor implementation also got simpler because the cursor position was represented directly, rather than indirectly through a selection and a boolean. In fact, in the revised version no special classes were used for either the selection or the cursor. Instead, a new Position class was introduced to represent a location in the file (a line number and character within line). The selection was represented with two Positions and the cursor with one. Positions also found other uses in the project. This example also demonstrates the benefits of a lower-level but more general-purpose interface, which were discussed in Chapter 6.</p>\n<blockquote>\n<p>在这种情况下，选择和光标之间的关联度不足以将它们组合在一起。当修改代码以分隔选择和光标时，用法和实现都变得更加简单。与必须从中提取选择和光标信息的组合对象相比，单独的对象提供了更简单的界面。游标的实现也变得更加简单，因为游标的位置是直接表示的，而不是通过选择和布尔值间接表示的。实际上，在修订版中，没有特殊的类用于选择或游标。相反，引入了一个新的 Position 类来表示文件中的位置（行号和行内的字符）。选择用两个位置表示，光标用一个位置表示。职位还在项目中找到了其他用途。</p>\n</blockquote>\n<h2 id=\"9-6-Example-separate-class-for-logging-示例：用于记录的单独类\"><a href=\"#9-6-Example-separate-class-for-logging-示例：用于记录的单独类\" class=\"headerlink\" title=\"9.6 Example: separate class for logging 示例：用于记录的单独类\"></a>9.6 Example: separate class for logging 示例：用于记录的单独类</h2><p>The second example involved error logging in a student project. A class contained several code sequences like the following:</p>\n<blockquote>\n<p>第二个示例涉及学生项目中的错误记录。一个类包含几个代码序列，如下所示：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    rpcConn = connectionPool.getConnection(dest);</span><br><span class=\"line\">&#125; <span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    NetworkErrorLogger.logRpcOpenError(req, dest, e);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Rather than logging the error at the point where it was detected, a separate method in a special error logging class was invoked. The error logging class was defined at the end of the same source file:</p>\n<blockquote>\n<p>而不是在检测到错误时记录错误，而是调用特殊错误记录类中的单独方法。错误记录类是在同一源文件的末尾定义的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NetworkErrorLogger</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">    *  Output information relevant to an error that occurs when trying</span></span><br><span class=\"line\"><span class=\"comment\">    *  to open a connection to send an RPC.</span></span><br><span class=\"line\"><span class=\"comment\">    *</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> req</span></span><br><span class=\"line\"><span class=\"comment\">    *       The RPC request that would have been sent through the connection</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> dest</span></span><br><span class=\"line\"><span class=\"comment\">    *       The destination of the RPC</span></span><br><span class=\"line\"><span class=\"comment\">    *  <span class=\"doctag\">@param</span> e</span></span><br><span class=\"line\"><span class=\"comment\">    *       The caught error</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">logRpcOpenError</span><span class=\"params\">(RpcRequest req, AddrPortTuple dest, Exception e)</span> </span>&#123;</span><br><span class=\"line\">        logger.log(Level.WARNING, <span class=\"string\">\"Cannot send message: \"</span> + req + <span class=\"string\">\". \\n\"</span> + <span class=\"string\">\"Unable to find or open connection to \"</span> + dest + <span class=\"string\">\" :\"</span> + e);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The NetworkErrorLogger class contained several methods such as logRpcSendError and logRpcReceiveError, each of which logged a different kind of error.</p>\n<blockquote>\n<p>NetworkErrorLogger 类包含几个方法，例如 logRpcSendError 和 logRpcReceiveError，每个方法都记录了不同类型的错误。</p>\n</blockquote>\n<p>This separation added complexity with no benefit. The logging methods were shallow: most consisted of a single line of code, but they required a considerable amount of documentation. Each method was only invoked in a single place. The logging methods were highly dependent on their invocations: someone reading the invocation would most likely flip over to the logging method to make sure that the right information was being logged; similarly, someone reading the logging method would probably flip over to the invocation site to understand the purpose of the method.</p>\n<blockquote>\n<p>这种分离增加了复杂性，没有任何好处。日志记录方法很浅：大多数只包含一行代码，但是它们需要大量的文档。每个方法仅在单个位置调用。日志记录方法高度依赖于它们的调用：读取调用的人很可能会切换到日志记录方法，以确保记录了正确的信息。同样，阅读日志记录方法的人可能会转到调用站点以了解该方法的目的。</p>\n</blockquote>\n<p>In this example, it would be better to eliminate the logging methods and place the logging statements at the locations where the errors were detected. This would make the code easier to read and eliminate the interfaces required for the logging methods.</p>\n<blockquote>\n<p>在此示例中，最好消除日志记录方法，并将日志记录语句放置在检测到错误的位置。这将使代码更易于阅读，并消除了日志记录方法所需的接口。</p>\n</blockquote>\n<h2 id=\"9-7-Example-editor-undo-mechanism-示例：编辑器撤消机制\"><a href=\"#9-7-Example-editor-undo-mechanism-示例：编辑器撤消机制\" class=\"headerlink\" title=\"9.7 Example: editor undo mechanism 示例：编辑器撤消机制\"></a>9.7 Example: editor undo mechanism 示例：编辑器撤消机制</h2><p>In the GUI editor project from Section 6.2, one of the requirements was to support multi-level undo/redo, not just for changes to the text itself, but also for changes in the selection, insertion cursor, and view. For example, if a user selected some text, deleted it, scrolled to a different place in the file, and then invoked undo, the editor had to restore its state to what it was just before the deletion. This included restoring the deleted text, selecting it again, and also making the selected text visible in the window.</p>\n<blockquote>\n<p>在 6.2 节的 GUI 编辑器项目中，要求之一是支持多级撤消/重做，不仅要更改文本本身，还要更改选择，插入光标和视图。例如，如果用户选择了一些文本，将其删除，滚动到文件中的其他位置，然后调用 undo，则编辑器必须将其状态恢复为删除前的状态。这包括还原已删除的文本，再次选择它，并使所选的文本在窗口中可见。</p>\n</blockquote>\n<p>Some of the student projects implemented the entire undo mechanism as part of the text class. The text class maintained a list of all the undoable changes. It automatically added entries to this list whenever the text was changed. For changes to the selection, insertion cursor, and view, the user interface code invoked additional methods in the text class, which then added entries for those changes to the undo list. When undo or redo was requested by the user, the user interface code invoked a method in the text class, which then processed the entries in the undo list. For entries related to text, it updated the internals of the text class; for entries related to other things, such as the selection, the text class called back to the user interface code to carry out the undo or redo.</p>\n<blockquote>\n<p>一些学生项目将整个撤消机制实现为文本类的一部分。文本类维护所有不可撤消更改的列表。每当更改文本时，它将自动将条目添加到此列表中。为了更改选择，插入光标和视图，用户界面代码调用了文本类中的其他方法，然后将这些更改的条目添加到撤消列表中。当用户请求撤消或重做时，用户界面代码将调用文本类中的方法，该方法然后处理撤消列表中的条目。对于与文本相关的条目，它更新了文本类的内部。对于与其他事物（例如选择）相关的条目，将调用返回到用户界面代码的文本类来执行撤消或重做。</p>\n</blockquote>\n<p>This approach resulted in an awkward set of features in the text class. The core of undo/redo consists of a general-purpose mechanism for managing a list of actions that have been executed and stepping through them during undo and redo operations. The core was located in the text class along with special-purpose handlers that implemented undo and redo for specific things such as text and the selection. The special-purpose undo handlers for the selection and the cursor had nothing to do with anything else in the text class; they resulted in information leakage between the text class and the user interface, as well as extra methods in each module to pass undo information back and forth. If a new sort of undoable entity were added to the system in the future, it would require changes to the text class, including new methods specific to that entity. In addition, the general-purpose undo core had little to do with the general-purpose text facilities in the class.</p>\n<blockquote>\n<p>这种方法在文本类中导致了一系列尴尬的功能。撤消/重做的核心由通用机制组成，用于管理已执行的动作列表，并在撤消和重做操作期间逐步执行这些动作。核心与专用处理程序一起位于 text 类中，该专用处理程序对诸如文本和选择之类的特定内容实现了撤消和重做。用于选择和光标的专用撤消处理程序与文本类中的任何其他内容均无关。它们导致文本类和用户界面之间的信息泄漏，以及每个模块中来回传递撤消信息的额外方法。如果将来将新的可撤消实体添加到系统中，则将需要更改文本类，包括特定于该实体的新方法。</p>\n</blockquote>\n<p>These problems can be solved by extracting the general-purpose core of the undo/redo mechanism and placing it in a separate class:</p>\n<blockquote>\n<p>通过提取撤消/重做机制的通用核心并将其放在单独的类中，可以解决这些问题：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">History</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Action</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">redo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    History() &#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addAction</span><span class=\"params\">(Action action)</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">addFence</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">undo</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">redo</span><span class=\"params\">()</span> </span>&#123;...&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>In this design, the History class manages a collection of objects that implement the interface History.Action. Each History.Action describes a single operation, such as a text insertion or a change in the cursor location, and it provides methods that can undo or redo the operation. The History class knows nothing about the information stored in the actions or how they implement their undo and redo methods. History maintains a history list describing all of the actions executed over the lifetime of an application, and it provides undo and redo methods that walk backwards and forwards through the list in response to user-requested undos and redos, calling undo and redo methods in the History.Actions.</p>\n<blockquote>\n<p>在此设计中，History 类管理实现接口 History.Action 的对象的集合。每个 History.Action 描述一个操作，例如插入文本或更改光标位置，并且它提供了可以撤消或重做该操作的方法。History 类对操作中存储的信息或它们如何实现其撤消和重做方法一无所知。历史记录维护一个历史记录列表，该列表描述了应用程序整个生命周期中执行的所有操作，并且它提供了撤消和重做方法，以响应用户请求的撤消和重做而在列表中前后移动，并在应用程序中调用撤消和重做方法。历史动作。</p>\n</blockquote>\n<p>History.Actions are special-purpose objects: each one understands a particular kind of undoable operation. They are implemented outside the History class, in modules that understand particular kinds of undoable actions. The text class might implement UndoableInsert and UndoableDelete objects to describe text insertions and deletions. Whenever it inserts text, the text class creates a new UndoableInsert object describing the insertion and invokes History.addAction to add it to the history list. The editor’s user interface code might create UndoableSelection and UndoableCursor objects that describe changes to the selection and insertion cursor.</p>\n<blockquote>\n<p>历史。动作是特殊目的的对象：每个人都了解一种特殊的不可操作。它们在 History 类之外的模块中实现，这些模块可以理解特定类型的可撤销操作。文本类可能实现 UndoableInsert 和 UndoableDelete 对象，以描述文本的插入和删除。每当插入文本时，文本类都会创建一个描述该插入的新 UndoableInsert 对象，并调用 History.addAction 将其添加到历史列表中。编辑器的用户界面代码可能会创建 UndoableSelection 和 UndoableCursor 对象，这些对象描述对选择和插入光标的更改。</p>\n</blockquote>\n<p>The History class also allows actions to be grouped so that, for example, a single undo request from the user can restore deleted text, reselect the deleted text, and reposition the insertion cursor. There are a number of ways to group actions; the History class uses fences, which are markers placed in the history list to separate groups of related actions. Each call to History.redo walks backwards through the history list, undoing actions until it reaches the next fence. The placement of fences is determined by higher-level code by invoking History.addFence.</p>\n<blockquote>\n<p>History 类还允许对操作进行分组，例如，来自用户的单个撤消请求可以恢复已删除的文本，重新选择已删除的文本以及重新放置插入光标。有多种将动作分组的方法。历史记录类使用围栏，围栏是放置在历史记录列表中的标记，用于分隔相关动作的组。每次对 History.redo 的调用都会向后浏览历史记录列表，撤消操作，直到到达下一个栅栏。围栏的位置由更高级别的代码通过调用 History.addFence 确定。</p>\n</blockquote>\n<p>This approach divides the functionality of undo into three categories, each of which is implemented in a different place:</p>\n<blockquote>\n<p>这种方法将撤消功能分为三类，每类都在不同的地方实现：</p>\n</blockquote>\n<p>A general-purpose mechanism for managing and grouping actions and invoking undo/redo operations (implemented by the History class).<br>The specifics of particular actions (implemented by a variety of classes, each of which understands a small number of action types).<br>The policy for grouping actions (implemented by high-level user interface code to provide the right overall application behavior).<br>Each of these categories can be implemented without any understanding of the other categories. The History class does not know what kind of actions are being undone; it could be used in a variety of applications. Each action class understands only a single kind of action, and neither the History class nor the action classes needs to be aware of the policy for grouping actions.</p>\n<blockquote>\n<p>一种用于管理和分组动作以及调用撤消/重做操作的通用机制（由 History 类实现）。特定操作的细节（由各种类实现，每个类都了解少量的操作类型）。分组操作的策略（由高级用户界面代码实现，以提供正确的整体应用程序行为）。这些类别中的每一个都可以在不了解其他类别的情况下实施。历史课不知道要撤消哪种操作；它可以用于多种应用。每个动作类仅理解一种动作，并且历史记录类和动作类都不需要知道将动作分组的策略。</p>\n</blockquote>\n<p>The key design decision was the one that separated the general-purpose part of the undo mechanism from the special-purpose parts and put the general-purpose part in a class by itself. Once that was done, the rest of the design fell out naturally.</p>\n<blockquote>\n<p>关键的设计决策是将撤消机制的通用部分与专用部分分开，然后将通用部分单独放在一个类中的决定。一旦完成，其余的设计就会自然消失。</p>\n</blockquote>\n<p>Note: the suggestion to separate general-purpose code from special-purpose code refers to code related to a particular mechanism. For example, special-purpose undo code (such as code to undo a text insertion) should be separated from general-purpose undo code (such as code to manage the history list). However, it often makes sense to combine special-purpose code for one mechanism with general-purpose code for another. The text class is an example of this: it implements a general-purpose mechanism for managing text, but it includes special-purpose code related to undoing. The undo code is special-purpose because it only handles undo operations for text modifications. It doesn’t make sense to combine this code with the general-purpose undo infrastructure in the History class, but it does make sense to put it in the text class, since it is closely related to other text functions.</p>\n<blockquote>\n<p>注意:将通用代码与专用代码分离的建议是指与特定机制相关的代码。例如，特殊用途的撤消代码(例如撤消文本插入的代码)应该与通用用途的撤消代码(例如管理历史记录列表的代码)分开。然而，将一种机制的专用代码与另一种机制的通用代码组合起来通常是有意义的。text 类就是这样一个例子:它实现了一种管理文本的通用机制，但是它包含了与撤销相关的专用代码。撤消代码是专用的，因为它只处理文本修改的撤消操作。将这段代码与 History 类中通用的 undo 基础结构结合在一起是没有意义的，但是将它放在 text 类中是有意义的，因为它与其他文本函数密切相关。</p>\n</blockquote>\n<h2 id=\"9-8-Splitting-and-joining-methods-拆分和合并方法\"><a href=\"#9-8-Splitting-and-joining-methods-拆分和合并方法\" class=\"headerlink\" title=\"9.8 Splitting and joining methods 拆分和合并方法\"></a>9.8 Splitting and joining methods 拆分和合并方法</h2><p>The issue of when to subdivide applies not just to classes, but also to methods: are there times when it is better to divide an existing method into multiple smaller methods? Or, should two smaller methods be combined into one larger one? Long methods tend to be more difficult to understand than shorter ones, so many people argue that length alone is a good justification for breaking up a method. Students in classes are often given rigid criteria, such as “Split up any method longer than 20 lines!”</p>\n<blockquote>\n<p>何时细分的问题不仅适用于类，而且还适用于方法：是否有时最好将现有方法分为多个较小的方法？还是应该将两种较小的方法合并为一种较大的方法？长方法比短方法更难于理解，因此许多人认为仅长度是分解方法的一个很好的理由。课堂上的学生通常会获得严格的标准，例如“拆分超过 20 行的任何方法！”</p>\n</blockquote>\n<p>However, length by itself is rarely a good reason for splitting up a method. In general, developers tend to break up methods too much. Splitting up a method introduces additional interfaces, which add to complexity. It also separates the pieces of the original method, which makes the code harder to read if the pieces are actually related. You shouldn’t break up a method unless it makes the overall system simpler; I’ll discuss how this might happen below.</p>\n<blockquote>\n<p>但是，长度本身很少是拆分方法的一个很好的理由。通常，开发人员倾向于过多地分解方法。拆分方法会引入其他接口，从而增加了复杂性。它还将原始方法的各个部分分开，如果这些部分实际上是相关的，则使代码更难阅读。您不应该分解一种方法，除非它使整个系统更加简单；我将在下面讨论这种情况。</p>\n</blockquote>\n<p>Long methods aren’t always bad. For example, suppose a method contains five 20-line blocks of code that are executed in order. If the blocks are relatively independent, then the method can be read and understood one block at a time; there’s not much benefit in moving each of the blocks into a separate method. If the blocks have complex interactions, it’s even more important to keep them together so readers can see all of the code at once; if each block is in a separate method, readers will have to flip back and forth between these spread-out methods in order to understand how they work together. Methods containing hundreds of lines of code are fine if they have a simple signature and are easy to read. These methods are deep (lots of functionality, simple interface), which is good.</p>\n<blockquote>\n<p>长方法并不总是坏的。例如，假设一个方法包含按顺序执行的五个 20 行代码块。如果这些块是相对独立的，则可以一次读取并理解该方法的一个块。将每个块移动到单独的方法中并没有太大的好处。如果这些块具有复杂的交互作用，则将它们保持在一起就显得尤为重要，这样读者就可以一次看到所有代码。如果每个块使用单独的方法，则读者将不得不在这些扩展方法之间来回切换，以了解它们如何协同工作。如果方法具有简单的签名并且易于阅读，则包含数百行代码的方法就可以了。这些方法很深入（很多功能，简单的界面），很好。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00019.jpeg\" alt=\"\"></p>\n<p>Figure 9.3: A method (a) can be split either by by extracting a subtask (b) or by dividing its functionality into two separate methods (c). A method should not be split if it results in shallow methods, as in (d).</p>\n<blockquote>\n<p>图 9.3：方法（a）可以通过提取子任务（b）或将其功能划分为两个单独的方法（c）进行拆分。如果方法导致浅层方法，则不应拆分该方法，如（d）所示。</p>\n</blockquote>\n<p>When designing methods, the most important goal is to provide clean and simple abstractions. Each method should do one thing and do it completely. The method should have a clean and simple interface, so that users don’t need to have much information in their heads in order to use it correctly. The method should be deep: its interface should be much simpler than its implementation. If a method has all of these properties, then it probably doesn’t matter whether it is long or not.</p>\n<blockquote>\n<p>设计方法时，最重要的目标是提供简洁的抽象。每种方法都应该做一件事并且完全做到这一点。该方法应该具有简洁的界面，以便用户无需费神就可以正确使用它。该方法应该很深：其接口应该比其实现简单得多。如果一个方法具有所有这些属性，那么它的长短与否可能无关紧要。</p>\n</blockquote>\n<p>Splitting up a method only makes sense if it results in cleaner abstractions, overall. There are two ways to do this, which are diagrammed in Figure 9.3. The best way is by factoring out a subtask into a separate method, as shown in Figure 9.3(b). The subdivision results in a child method containing the subtask and a parent method containing the remainder of the original method; the parent invokes the child. The interface of the new parent method is the same as the original method. This form of subdivision makes sense if there is a subtask that is cleanly separable from the rest of the original method, which means (a) someone reading the child method doesn’t need to know anything about the parent method and (b) someone reading the parent method doesn’t need to understand the implementation of the child method. Typically this means that the child method is relatively general-purpose: it could conceivably be used by other methods besides the parent. If you make a split of this form and then find yourself flipping back and forth between the parent and child to understand how they work together, that is a red flag (“Conjoined Methods”) indicating that the split was probably a bad idea.</p>\n<blockquote>\n<p>总体而言，拆分方法只有在其导致更抽象的抽象时才有意义。有两种方法可以做到这一点，如图 9.3 所示。最佳方法是将子任务分解为单独的方法，如图 9.3（b）所示。该细分产生一个包含该子任务的子方法和一个包含原始方法其余部分的父方法；父级调用子级。新的父方法的接口与原始方法的接口相同。如果存在一个与原始方法的其余部分完全可分离的子任务，则这种细分形式是有意义的，这意味着（a）读取子方法的某人不需要了解有关父方法的任何信息，以及（b）某人在阅读父方法不需要了解子方法的实现。通常，这意味着子方法是相对通用的：可以想象除父方法外，其他方法也可以使用它。如果您对这种形式进行拆分，然后发现自己在父母和孩子之间来回翻转以了解他们如何一起工作，那是一个红色标记（“联合方法”），表明拆分可能不是一个好主意。</p>\n</blockquote>\n<p>The second way to break up a method is to split it into two separate methods, each visible to callers of the original method, as in Figure 9.3(c). This makes sense if the original method had an overly complex interface because it tried to do multiple things that were not closely related. If this is the case, it may be possible to divide the method’s functionality into two or more smaller methods, each of which has only a part of the original method’s functionality. If you make a split like this, the interface for each of the resulting methods should be simpler than the interface of the original method. Ideally, most callers should only need to invoke one of the two new methods; if callers must invoke both of the new methods, then that adds complexity, which makes it less likely that the split is a good idea. The new methods will be more focused in what they do. It is a good sign if the new methods are more general-purpose than the original method (i.e., you can imagine using them separately in other situations).</p>\n<blockquote>\n<p>分解方法的第二种方法是将其拆分为两个单独的方法，每个方法对原始方法的调用者可见，如图 9.3（c）所示。如果原始方法的接口过于复杂，这是有道理的，因为该接口试图执行不密切相关的多项操作。在这种情况下，可以将方法的功能划分为两个或更多个较小的方法，每个方法仅具有原始方法功能的一部分。如果进行这样的拆分，则每个结果方法的接口应该比原始方法的接口更简单。理想情况下，大多数调用者只需要调用两个新方法之一即可；如果调用者必须同时调用这两个新方法，则将增加复杂性，从而降低拆分是个好主意的可能性。新方法将更加专注于它们的工作。如果新方法比原始方法更具通用性，那么这是一个好兆头（例如，您可以想象在其他情况下单独使用它们）。</p>\n</blockquote>\n<p>Splits of the form shown in Figure 9.3(c) don’t make sense very often, because they result in callers having to deal with multiple methods instead of one. When you split this way, you run the risk of ending up with several shallow methods, as in Figure 9.3(d). If the caller has to invoke each of the separate methods, passing state back and forth between them, then splitting is not a good idea. If you’re considering a split like the one in Figure 9.3(c), you should judge it based on whether it simplifies things for callers.</p>\n<blockquote>\n<p>图 9.3（c）所示形式的拆分并不是很有意义，因为它们导致调用者不得不处理多个方法而不是一个方法。当您以这种方式拆分时，您可能会遇到几种浅层方法的风险，如图 9.3（d）所示。如果调用者必须调用每个单独的方法，并在它们之间来回传递状态，则拆分不是一个好主意。如果您正在考虑像图 9.3（c）所示的拆分，则应基于它是否简化了呼叫者的情况来进行判断。</p>\n</blockquote>\n<p>There are also situations where a system can be made simpler by joining methods together. For example, joining methods might replace two shallow methods with one deeper method; it might eliminate duplication of code; it might eliminate dependencies between the original methods, or intermediate data structures; it might result in better encapsulation, so that knowledge that was previously present in multiple places is now isolated in a single place; or it might result in a simpler interface, as discussed in Section 9.2.</p>\n<blockquote>\n<p>在某些情况下，通过将方法结合在一起可以简化系统。例如，连接方法可以用一种更深的方法代替两种浅的方法。它可以消除重复的代码；它可以消除原始方法或中间数据结构之间的依赖关系；它可能导致更好的封装，从而使以前在多个位置存在的知识现在被隔离在一个位置；否则可能会导致界面更简单，如 9.2 节所述。</p>\n</blockquote>\n<p>img Red Flag: Conjoined Methods img</p>\n<p>It should be possible to understand each method independently. If you can’t understand the implementation of one method without also understanding the implementation of another, that’s a red flag. This red flag can occur in other contexts as well: if two pieces of code are physically separated, but each can only be understood by looking at the other, that is a red flag.</p>\n<blockquote>\n<p>应该有可能独立地理解每种方法。如果您不能不理解另一种方法的实现而无法理解一种方法的实现，那就是一个危险信号。该危险信号也可以在其他情况下发生：如果两段代码在物理上是分开的，但是只有通过查看另一段代码才能理解它们，这就是危险信号。</p>\n</blockquote>\n<h2 id=\"9-9-Conclusion-结论\"><a href=\"#9-9-Conclusion-结论\" class=\"headerlink\" title=\"9.9 Conclusion 结论\"></a>9.9 Conclusion 结论</h2><p>The decision to split or join modules should be based on complexity. Pick the structure that results in the best information hiding, the fewest dependencies, and the deepest interfaces.</p>\n<blockquote>\n<p>拆分或加入模块的决定应基于复杂性。选择一种结构，它可以隐藏最佳的信息，最少的依赖关系和最深的接口。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch10","date":"2021-02-09T16:00:00.000Z","_content":"定义不存在的错误\n<!-- more -->\n# 第 10 章 定义不存在的错误\n\n> Chapter 10 Define Errors Out Of Existence\n\nException handling is one of the worst sources of complexity in software systems. Code that deals with special conditions is inherently harder to write than code that deals with normal cases, and developers often define exceptions without considering how they will be handled. This chapter discusses why exceptions contribute disproportionately to complexity, then it shows how to simplify exception handling. The key overall lesson from this chapter is to reduce the number of places where exceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and there is no exceptional condition to report (hence the title of this chapter).\n\n> 异常处理是软件系统中最糟糕的复杂性来源之一。处理特殊情况的代码在本质上比处理正常情况的代码更难编写，并且开发人员经常在定义异常时不考虑异常的处理方式。本章讨论了为什么异常对复杂性的贡献不成比例，然后说明了如何简化异常处理。本章总的主要教训是减少必须处理异常的地方的数量。在许多情况下，可以修改操作的语义，以便正常行为可以处理所有情况，并且没有要报告的特殊条件（因此，本章标题）。\n\n## 10.1 Why exceptions add complexity 为什么异常会增加复杂性\n\nI use the term exception to refer to any uncommon condition that alters the normal flow of control in a program. Many programming languages include a formal exception mechanism that allows exceptions to be thrown by lower-level code and caught by enclosing code. However, exceptions can occur even without using a formal exception reporting mechanism, such as when a method returns a special value indicating that it didn’t complete its normal behavior. All of these forms of exceptions contribute to complexity.\n\n> 我使用“异常”一词来指代任何会改变程序中正常控制流程的不常见条件。许多编程语言都包含一种正式的异常机制，该机制允许异常由低级代码引发并由封闭代码捕获。但是，即使不使用正式的异常报告机制，异常也可能发生，例如，当某个方法返回一个特殊值指示其未完成其正常行为时。所有这些形式的异常都会增加复杂性。\n\nA particular piece of code may encounter exceptions in several different ways:\n\n> 一段特定的代码可能会以几种不同的方式遇到异常：\n\n- A caller may provide bad arguments or configuration information.\n- An invoked method may not be able to complete a requested operation. For example, an I/O operation may fail, or a required resource may not be available.\n- In a distributed system, network packets may be lost or delayed, servers may not respond in a timely fashion, or peers may communicate in unexpected ways.\n- The code may detect bugs, internal inconsistencies, or situations it is not prepared to handle.\n\n---\n\n> - 调用方可能会提供错误的参数或配置信息。\n> - 调用的方法可能无法完成请求的操作。例如，I/O 操作可能失败，或者所需的资源可能不可用。\n> - 在分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或者对等方可能会以意想不到的方式进行通信。\n> - 该代码可能会检测到错误，内部不一致或未准备处理的情况。\n\nLarge systems have to deal with many exceptional conditions, particularly if they are distributed or need to be fault-tolerant. Exception handling can account for a significant fraction of all the code in a system.\n\n> 大型系统必须应对许多特殊情况，特别是在它们是分布式的或需要容错的情况下。异常处理可以占系统中所有代码的很大一部分。\n\nException handling code is inherently more difficult to write than normal-case code. An exception disrupts the normal flow of the code; it usually means that something didn’t work as expected. When an exception occurs, the programmer can deal with it in two ways, each of which can be complicated. The first approach is to move forward and complete the work in progress in spite of the exception. For example, if a network packet is lost, it can be resent; if data is corrupted, perhaps it can be recovered from a redundant copy. The second approach is to abort the operation in progress and report the exception upwards. However, aborting can be complicated because the exception may have occurred at a point where system state is inconsistent (a data structure might have been partially initialized); the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.\n\n> 异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流;它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复数据。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化);异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。\n\nFurthermore, exception handling code creates opportunities for more exceptions. Consider the case of resending a lost network packet. Perhaps the packet wasn’t actually lost, but was simply delayed. In this case, resending the packet will result in duplicate packets arriving at the peer; this introduces a new exceptional condition that the peer must handle. Or, consider the case of recovering lost data from a redundant copy: what if the redundant copy has also been lost? Secondary exceptions occurring during recovery are often more subtle and complex than the primary exceptions. If an exception is handled by aborting the operation in progress, then this must be reported to the caller as another exception. To prevent an unending cascade of exceptions, the developer must eventually find a way to handle exceptions without introducing more exceptions.\n\n> 此外，异常处理代码为更多异常创造了机会。考虑重新发送丢失的网络数据包的情况。也许该数据包实际上并没有丢失，但是只是被延迟了。在这种情况下，重新发送数据包将导致重复的数据包到达对等方；这引入了对等方必须处理的新的例外条件。或者，考虑从冗余副本恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更加微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用方。为了防止无休止的异常级联，开发人员最终必须找到一种在不引入更多异常的情况下处理异常的方法。\n\nLanguage support for exceptions tends to be verbose and clunky, which makes exception handling code hard to read. For example, consider the following code, which reads a collection of tweets from a file using Java’s support for object serialization and deserialization:\n\n> 语言对异常的支持往往是冗长而笨拙的，这使得异常处理代码难以阅读。例如，考虑以下代码，该代码使用 Java 对对象序列化和反序列化的支持从文件中读取 tweet 的集合：\n\n```java\ntry (\n    FileInputStream fileStream = new FileInputStream(fileName);\n    BufferedInputStream bufferedStream = new BufferedInputStream(fileStream);\n    ObjectInputStream objectStream = new ObjectInputStream(bufferedStream);\n) {\n    for (int i = 0; i < tweetsPerFile; i++) {\n        tweets.add((Tweet) objectStream.readObject());\n    }\n}\ncatch (FileNotFoundException e) {\n    ...\n}\ncatch (ClassNotFoundException e) {\n    ...\n}\ncatch (EOFException e) {\n    // Not a problem: not all tweet files have full\n    // set of tweets.\n}\ncatch (IOException e) {\n    ...\n}\ncatch (ClassCastException e) {\n    ...\n}\n```\n\nJust the basic try-catch boilerplate accounts for more lines of code than the code for normal-case operation, without even considering the code that actually handles the exceptions. It is hard to relate the exception handling code to the normal-case code: for example, it’s not obvious where each exception is generated. An alternative approach is to break up the code into many distinct try blocks; in the extreme case there could be a try for each line of code that can generate an exception. This would make it clear where exceptions occur, but the try blocks themselves break up the flow of the code and make it harder to read; in addition, some exception handling code might end up duplicated in multiple try blocks.\n\n> 只是基本的 try-catch 样板代码比正常情况下的操作代码所占的代码行更多，甚至没有考虑实际处理异常的代码。很难将异常处理代码与普通情况代码相关联：例如，每个异常的生成位置都不明显。另一种方法是将代码分解为许多不同的 try 块。在极端情况下，可能会尝试尝试每行可能产生异常的代码。这样可以清楚地说明异常发生的位置，但是 try 块本身会破坏代码流，并使代码难以阅读。此外，某些异常处理代码可能最终会在多个 try 块中重复。\n\nIt’s difficult to ensure that exception handling code really works. Some exceptions, such as I/O errors, can’t easily be generated in a test environment, so it’s hard to test the code that handles them. Exceptions don’t occur very often in running systems, so exception handling code rarely executes. Bugs can go undetected for a long time, and when the exception handling code is finally needed, there’s a good chance that it won’t work (one of my favorite sayings: “code that hasn’t been executed doesn’t work”). A recent study found that more than 90% of catastrophic failures in distributed data-intensive systems were caused by incorrect error handling1. When exception handling code fails, it’s difficult to debug the problem, since it occurs so infrequently.\n\n> 确保异常处理代码真正起作用是困难的。某些异常（例如 I/O 错误）在测试环境中不易生成，因此很难测试处理它们的代码。异常在运行的系统中很少发生，因此异常处理代码很少执行。错误可能会长时间未被发现，并且当最终需要异常处理代码时，它很有可能无法正常工作（我最喜欢的一句话是：“未执行的代码无效”） 。最近的一项研究发现，分布式数据密集型系统中超过 90％的灾难性故障是由错误的错误处理引起的 1。当异常处理代码失败时，很难调试该问题，因为它很少发生。\n\n## 10.2 Too many exceptions 异常过多\n\nProgrammers exacerbate the problems related to exception handling by defining unnecessary exceptions. Most programmers are taught that it’s important to detect and report errors; they often interpret this to mean “the more errors detected, the better.” This leads to an over-defensive style where anything that looks even a bit suspicious is rejected with an exception, which results in a proliferation of unnecessary exceptions that increase the complexity of the system.\n\n> 程序员通过定义不必要的异常加剧了与异常处理有关的问题。告诉大多数程序员，检测和报告错误很重要。他们通常将其解释为“检测到的错误越多越好”。这导致了一种过分防御的风格，其中任何看起来甚至有点可疑的东西都被拒绝，并带有异常，这导致了不必要的异常的泛滥，从而增加了系统的复杂性。\n\nI made this mistake myself in the design of the Tcl scripting language. Tcl contains an unset command that can be used to remove a variable. I defined unset so that it throws an error if the variable doesn’t exist. At the time I thought that it must be a bug if someone tries to delete a variable that doesn’t exist, so Tcl should report it. However, one of the most common uses of unset is to clean up temporary state created by some previous operation. It’s often hard to predict exactly what state was created, particularly if the operation aborted partway through. Thus, the simplest thing is to delete all of the variables that might possibly have been created. The definition of unset makes this awkward: developers end up enclosing calls to unset in catch statements to catch and ignore errors thrown by unset. In retrospect, the definition of the unset command is one of the biggest mistakes I made in the design of Tcl.\n\n> 在设计 Tcl 脚本语言时，我自己就犯了这个错误。Tcl 包含一个未设置的命令，可用于删除变量。我定义了 unset 以便在变量不存在时抛出错误。当时我认为，如果有人试图删除一个不存在的变量，那么它一定是一个 bug，所以 Tcl 应该报告它。然而，unset 最常见的用途之一是清理以前操作创建的临时状态。通常很难准确地预测创建了什么状态，特别是在操作中途中止的情况下。因此，最简单的方法是删除可能已经创建的所有变量。unset 的定义使得这种情况很尴尬:开发人员最终会在 catch 语句中封装对 unset 的调用，以捕获并忽略 unset 抛出的错误。回顾过去，unset 命令的定义是我在 Tcl 设计中犯下的最大错误之一。\n\nIt’s tempting to use exceptions to avoid dealing with difficult situations: rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller. Some might argue that this approach empowers callers, since it allows each caller to handle the exception in a different way. However, if you are having trouble figuring out what to do for the particular situation, there’s a good chance that the caller won’t know what to do either. Generating an exception in a situation like this just passes the problem to someone else and adds to the system’s complexity.\n\n> 试图使用异常来避免处理困难的情况很诱人：与其想出一种干净的方法来处理它，不如抛出一个异常并将问题平移给调用者。有人可能会争辩说，这种方法可以赋予调用者权力，因为它允许每个调用者以不同的方式处理异常。但是，如果您在确定特定情况下该怎么做时遇到困难，则呼叫者很可能都不知道该怎么办。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。\n\nThe exceptions thrown by a class are part of its interface; classes with lots of exceptions have complex interfaces, and they are shallower than classes with fewer exceptions. An exception is a particularly complex element of an interface. It can propagate up through several stack levels before being caught, so it affects not just the method’s caller, but potentially also higher-level callers (and their interfaces).\n\n> 类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且比具有较少异常的类浅。异常是接口中特别复杂的元素。它可以在被捕获之前通过多个堆栈级别向上传播，因此它不仅影响方法的调用者，而且还可能影响更高级别的调用者（及其接口）。\n\nThrowing exceptions is easy; handling them is hard. Thus, the complexity of exceptions comes from the exception handling code. The best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled. The rest of this chapter will discuss four techniques for reducing the number of exception handlers.\n\n> 抛出异常很容易；处理它们很困难。因此，异常的复杂性来自异常处理代码。减少由异常处理引起的复杂性破坏的最佳方法是减少必须处理异常的位置的数量。本章的其余部分将讨论减少异常处理程序数量的四种技术。\n\n## 10.3 Define errors out of existence 定义错误不存在\n\nThe best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. This may seem sacrilegious, but it is very effective in practice. Consider the Tcl unset command discussed above. Rather than throwing an error when unset is asked to delete an unknown variable, it should have simply returned without doing anything. I should have changed the definition of unset slightly: rather than deleting a variable, unset should ensure that a variable no longer exists. With the first definition, unset can’t do its job if the variable doesn’t exist, so generating an exception makes sense. With the second definition, it is perfectly natural for unset to be invoked with the name of a variable that doesn’t exist. In this case, its work is already done, so it can simply return. There is no longer an error case to report.\n\n> 消除异常处理复杂性的最好方法是定义您的 API，以便没有异常要处理：定义错误而已。这似乎是牺牲品，但在实践中非常有效。考虑上面讨论的 Tcl unset 命令。而不是在要求 unset 删除未知变量时引发错误，它应该只是返回而无需执行任何操作。我应该稍微修改一下 unset 的定义：与其删除一个变量，不应该删除 unset 来确保一个变量不再存在。根据第一个定义，如果变量不存在，则 unset 不能执行其工作，因此生成异常是有意义的。使用第二个定义，使用不存在的变量名调用 unset 是很自然的。在这种情况下，它的工作已经完成，因此可以简单地返回。\n\n## 10.4 Example: file deletion in Windows 示例：Windows 中的文件删除\n\nFile deletion provides another example of how errors can be defined away. The Windows operating system does not permit a file to be deleted if it is open in a process. This is a continual source of frustration for developers and users. In order to delete a file that is in use, the user must search through the system to find the process that has the file open, and then kill that process. Sometimes users give up and reboot their system, just so they can delete a file.\n\n> 文件删除提供了如何定义错误的另一个示例。Windows 操作系统不允许删除文件（如果已在进程中打开文件）。对于开发人员和用户来说，这是不断沮丧的根源。为了删除正在使用的文件，用户必须在系统中搜索以找到已打开文件的进程，然后终止该进程。有时用户放弃并重新启动系统，只是为了删除文件。\n\nThe Unix operating system defines file deletion more elegantly. In Unix, if a file is open when it is deleted, Unix does not delete the file immediately. Instead, it marks the file for deletion, then the delete operation returns successfully. The file name has been removed from its directory, so no other processes can open the old file and a new file with the same name can be created, but the existing file data persists. Processes that already have the file open can continue to read it and write it normally. Once the file has been closed by all of the accessing processes, its data is freed.\n\n> Unix 操作系统更优雅地定义了文件删除。在 Unix 中，如果在删除文件时打开了文件，则 Unix 不会立即删除该文件。而是将文件标记为删除，然后删除操作成功返回。该文件名已从其目录中删除，因此其他进程无法打开该旧文件，并且可以创建具有相同名称的新文件，但现有文件数据将保留。已经打开文件的进程可以继续读取和正常写入文件。一旦所有访问进程都关闭了文件，便释放其数据。\n\nThe Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the delete succeeds, and the file will eventually be deleted. Second, deleting a file that’s in use does not create exceptions for the processes using the file. One possible approach to this problem would have been to delete the file immediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach would create new errors for those processes to handle. Instead, Unix allows them to keep accessing the file normally; delaying the file deletion defines errors out of existence.\n\n> Unix 方法定义了两种不同的错误。首先，如果文件当前正在使用中，则删除操作不再返回错误；删除成功，该文件最终将被删除。其次，删除正在使用的文件不会为使用该文件的进程创建例外。解决此问题的一种可能方法是立即删除文件并标记文件的所有打开以禁用它们。其他进程读取或写入已删除文件的任何尝试均将失败。但是，此方法将为那些要处理的过程创建新的错误。相反，Unix 允许他们继续正常访问文件。延迟文件删除将定义错误不存在。\n\nIt may seem strange that Unix allows a process to continue to read and write a doomed file, but I have never encountered a situation where this caused significant problems. The Unix definition of file deletion is much simpler to work with, both for developers and users, than the Windows definition.\n\n> Unix 允许进程继续读取和写入已损坏的文件可能看起来很奇怪，但是我从未遇到过引起严重问题的情况。对于开发人员和用户，Unix 删除文件的定义比 Windows 定义要容易得多。\n\n## 10.5 Example: Java substring method 示例：Java 子字符串方法\n\nAs a final example, consider the Java String class and its substring method. Given two indexes into a string, substring returns the substring starting at the character given by the first index and ending with the character just before the second index. However, if either index is outside the range of the string, then substring throws IndexOutOfBoundsException. This exception is unnecessary and complicates the use of this method. I often find myself in a situation where one or both of the indices may be outside the range of the string, and I would like to extract all of the characters in the string that overlap the specified range. Unfortunately, this requires me to check each of the indices and round them up to zero or down to the end of the string; a one-line method call now becomes 5–10 lines of code.\n\n> 作为最后一个示例，请考虑 Java String 类及其子字符串方法。给定一个字符串中的两个索引，substring 返回该子字符串，该字符串从第一个索引给定的字符开始，以第二个索引之前的字符结束。但是，如果两个索引中的任何一个都超出字符串的范围，则子字符串将引发 IndexOutOfBoundsException。此异常是不必要的，并且会使此方法的使用复杂化。我经常发现自己处于一个或两个索引可能不在字符串范围内的情况，并且我想提取字符串中与指定范围重叠的所有字符。不幸的是，这要求我检查每个索引并将它们向上舍入为零或向下舍入到字符串的末尾。现在，单行方法调用变成 5-10 行代码。\n\nThe Java substring method would be easier to use if it performed this adjustment automatically, so that it implemented the following API: “returns the characters of the string (if any) with index greater than or equal to beginIndex and less than endIndex.” This is a simple and natural API, and it defines the IndexOutOfBoundsException exception out of existence. The method’s behavior is now well-defined even if one or both of the indexes are negative, or if beginIndex is greater than endIndex. This approach simplifies the API for the method while increasing its functionality, so it makes the method deeper. Many other languages have taken the error-free approach; for example, Python returns an empty result for out-of-range list slices.\n\n> 如果 Java 子字符串方法自动执行此调整，则将更易于使用，因此它实现了以下 API：“返回索引大于或等于 beginIndex 且小于 endIndex 的字符串的字符（如果有）。” 这是一个简单自然的 API，它定义了 IndexOutOfBoundsException 异常。现在，即使一个或两个索引均为负，或者 beginIndex 大于 endIndex，该方法的行为也已明确定义。这种方法简化了方法的 API，同时增加了其功能，因此使方法更深。许多其他语言都采用了无错误的方法。例如，Python 对于超出范围的列表切片返回空结果。\n\nWhen I argue for defining errors out of existence, people sometimes counter that throwing errors will catch bugs; if errors are defined out of existence, won’t that result in buggier software? Perhaps this is why the Java developers decided that substring should throw exceptions. The error-ful approach may catch some bugs, but it also increases complexity, which results in other bugs. In the error-ful approach, developers must write additional code to avoid or ignore the errors, and this increases the likelihood of bugs; or, they may forget to write the additional code, in which case unexpected errors may be thrown at runtime. In contrast, defining errors out of existence simplifies APIs and it reduces the amount of code that must be written.\n\n> 当我主张定义错误而不再存在时，人们有时会反驳说抛出错误会捕获错误。如果错误定义不存在，那会不会导致 Buggier 软件出现？也许这就是 Java 开发人员决定子字符串应引发异常的原因。错误的方法可能会捕获一些错误，但也会增加复杂性，从而导致其他错误。在错误有效的方法中，开发人员必须编写额外的代码来避免或忽略错误，这增加了发生错误的可能性。或者，他们可能会忘记编写其他代码，在这种情况下，运行时可能会引发意外错误。相反，定义错误而不存在将简化 API，并减少必须编写的代码量。\n\nOverall, the best way to reduce bugs is to make software simpler.\n\n> 总体而言，减少错误的最好方法是简化软件。\n\n## 10.6 Mask exceptions 掩码异常\n\nThe second technique for reducing the number of places where exceptions must be handled is exception masking. With this approach, an exceptional condition is detected and handled at a low level in the system, so that higher levels of software need not be aware of the condition. Exception masking is particularly common in distributed systems. For instance, in a network transport protocol such as TCP, packets can be dropped for various reasons such as corruption and congestion. TCP masks packet loss by resending lost packets within its implementation, so all data eventually gets through and clients are unaware of the dropped packets.\n\n> 减少必须处理异常的地方数量的第二种技术是异常屏蔽。使用这种方法，可以在系统的较低级别上检测和处理异常情况，因此，更高级别的软件无需知道该情况。异常屏蔽在分布式系统中尤其常见。例如，在诸如 TCP 的网络传输协议中，由于各种原因（例如损坏和拥塞），可能会丢弃数据包。TCP 通过在其实现中重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将通过，并且客户端不知道丢失的数据包。\n\nA more controversial example of masking occurs in the NFS network file system. If an NFS file server crashes or fails to respond for any reason, clients reissue their requests to the server over and over again until the problem is eventually resolved. The low-level file system code on the client does not report any exceptions to the invoking application. The operation in progress (and hence the application) just hangs until the operation can complete successfully. If the hang lasts more than a short time, the NFS client prints messages on the user’s console of the form “NFS server xyzzy not responding still trying.”\n\n> NFS 网络文件系统中出现了一个更具争议性的屏蔽示例。如果 NFS 文件服务器由于任何原因崩溃或无法响应，客户端将一遍又一遍地向服务器发出请求，直到问题最终得到解决。客户端上的低级文件系统代码不会向调用应用程序报告任何异常。正在进行的操作（以及因此的应用程序）只是挂起，直到操作可以成功完成。如果挂起持续的时间不超过一小段时间，则 NFS 客户端将在用户控制台上以“ NFS 服务器 xyzzy 无法响应仍在尝试响应”的形式打印消息。\n\nNFS users often complain about the fact that their applications hang while waiting for an NFS server to resume normal operation. Many people have suggested that NFS should abort operations with an exception rather than hanging. However, reporting exceptions would make things worse, not better. There’s not much an application can do if it loses access to its files. One possibility would be for the application to retry the file operation, but this would still hang the application, and it’s easier to perform the retry in one place in the NFS layer, rather than at every file system call in every application (a compiler shouldn’t have to worry about this!). The other alternative is for applications to abort and return errors to their callers. It’s unlikely that the callers would know what to do either, so they would abort as well, resulting in a collapse of the user’s working environment. Users still wouldn’t be able to get any work done while the file server was down, and they would have to restart all of their applications once the file server came back to life.\n\n> NFS 用户经常抱怨这样的事实，即他们的应用程序在等待 NFS 服务器恢复正常运行时挂起。许多人建议 NFS 应该异常终止操作而不是挂起。但是，报告异常会使情况更糟，而不是更好。如果应用程序无法访问其文件，则无能为力。一种可能性是应用程序重试文件操作，但这仍然会使应用程序挂起，并且在 NFS 层中的一个位置执行重试会比在每个应用程序中的每个文件系统调用处执行重试更容易（编译器应不必为此担心！）。另一种选择是让应用程序中止并将错误返回给调用者。呼叫者不太可能知道该怎么做，因此他们也将中止，导致用户工作环境崩溃。用户在文件服务器关闭时仍然无法完成任何工作，并且一旦文件服务器恢复工作，他们将不得不重新启动所有应用程序。\n\nThus, the best alternative is for NFS to mask the errors and hang applications. With this approach, applications don’t need any code to deal with server problems, and they can resume seamlessly once the server comes back to life. If users get tired of waiting, they can always abort applications manually.\n\n> 因此，最好的替代方法是让 NFS 掩盖错误并挂起应用程序。通过这种方法，应用程序不需要任何代码来处理服务器问题，并且一旦服务器恢复运行，它们就可以无缝恢复。如果用户厌倦了等待，他们总是可以手动中止应用程序。\n\nException masking doesn’t work in all situations, but it is a powerful tool in the situations where it works. It results in deeper classes, since it reduces the class’s interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception. Exception masking is an example of pulling complexity downward.\n\n> 异常屏蔽并非在所有情况下都有效，但是在它起作用的情况下它是一个强大的工具。它导致了更深的类，因为它减少了类的界面（用户需要注意的异常更少）并以掩盖异常的代码形式添加了功能。异常屏蔽是降低复杂性的一个例子。\n\n## 10.7 Exception aggregation 异常聚集\n\nThe third technique for reducing complexity related to exceptions is exception aggregation. The idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.\n\n> 减少与异常相关的复杂性的第三种技术是异常聚合。异常聚合的思想是用一个代码段处理许多异常。与其为多个单独的异常编写不同的处理程序，不如用一个处理程序将它们全部处理在一个地方。\n\nConsider how to handle missing parameters in a Web server. A Web server implements a collection of URLs. When the server receives an incoming URL, it dispatches to a URL-specific service method to process that URL and generate a response. The URL contains various parameters that are used to generate the response. Each service method will call a lower-level method (let’s call it getParameter) to extract the parameters that it needs from the URL. If the URL does not contain the desired parameter, getParameter throws an exception.\n\n> 考虑如何处理 Web 服务器中缺少的参数。Web 服务器实现 URL 的集合。服务器收到传入的 URL 时，将分派到特定于 URL 的服务方法来处理该 URL 并生成响应。该 URL 包含用于生成响应的各种参数。每个服务方法都将调用一个较低层的方法（将其称为 getParameter）以从 URL 中提取所需的参数。如果 URL 不包含所需的参数，则 getParameter 会引发异常。\n\nWhen students in a software design class implemented such a server, many of them wrapped each distinct call to getParameter in a separate exception handler to catch NoSuchParameter exceptions, as in Figure 10.1. This resulted in a large number of handlers, all of which did essentially the same thing (generate an error response).\n\n> 当参加软件设计课程的学生实现这样的服务器时，他们中的许多人将对 getParameter 的每个不同调用包装在单独的异常处理程序中以捕获 NoSuchParameter 异常，如图 10.1 所示。这导致大量的处理程序，所有这些处理程序基本上都执行相同的操作（生成错误响应）。\n\n![](../../img/figures/00020.jpeg)\n\nFigure 10.1: The code at the top dispatches to one of several methods in a Web server, each of which handles a particular URL. Each of those methods (bottom) uses parameters from the incoming HTTP request. In this figure, there is a separate exception handler for each call to getParameter; this results in duplicated code.\n\n> 图 10.1：顶部的代码将分派给 Web 服务器中的几种方法之一，每种方法都处理一个特定的 URL。每个方法（底部）都使用传入 HTTP 请求中的参数。在此图中，每个对 getParameter 的调用都有一个单独的异常处理程序。这导致重复的代码。\n\nA better approach is to aggregate the exceptions. Instead of catching the exceptions in the individual service methods, let them propagate up to the top-level dispatch method for the Web server, as in Figure 10.2. A single handler in this method can catch all of the exceptions and generate an appropriate error response for missing parameters.\n\n> 更好的方法是汇总异常。让它们传播到 Web 服务器的顶级调度方法，而不是在单个服务方法中捕获异常，如图 10.2 所示。此方法中的单个处理程序可以捕获所有异常，并为丢失的参数生成适当的错误响应。\n\nThe aggregation approach can be taken even further in the Web example. There are many other errors besides missing parameters that can occur while processing a Web page; for example, a parameter might not have the right syntax (the service method expected an integer, but the value was “xyz”), or the user might not have permission for the requested operation. In each case, the error should result in an error response; the errors differ only in the error message to include in the response (“parameter 'quantity' not present in URL” or “bad value 'xyz' for 'quantity' parameter; must be positive integer”). Thus, all conditions resulting in an error response can be handled with a single top-level exception handler. The error message can be generated at the time the exception is thrown and included as a variable in the exception record; for example, getParameter will generate the “parameter 'quantity' not present in URL” message. The top-level handler extracts the message from the exception and incorporates it into the error response.\n\n> 在 Web 示例中甚至可以采用聚合方法。处理网页时，除了缺少参数外，还有许多其他错误；例如，参数可能没有正确的语法（服务方法应为整数，但值为“ xyz”），或者用户可能无权执行所请求的操作。在每种情况下，错误都应导致错误响应。错误仅在响应中包含的错误消息中有所不同（“ URL 中不存在参数'数量'”或“'数量'参数的错误值'xyz'；必须为正整数”）。因此，所有导致错误响应的条件都可以使用单个顶级异常处理程序进行处理。错误消息可以在引发异常时生成，并作为变量包含在异常记录中。例如，getParameter 将生成“ URL 中不存在的参数'数量'”消息。顶级处理程序从异常中提取消息，并将其合并到错误响应中。\n\n![](../../img/figures/00021.jpeg)\n\nFigure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter exceptions from all of the URL-specific methods.\n\n> 图 10.2：此代码在功能上等效于图 10.1，但是异常处理已聚合：分派器中的单个异常处理程序从所有特定于 URL 的方法中捕获所有 NoSuchParameter 异常。\n\nThe aggregation described in the preceding paragraph has good properties from the standpoint of encapsulation and information hiding. The top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception. The getParameter method encapsulates knowledge about how to extract a parameter from a URL, and it also knows how to describe extraction errors in a human-readable form. These two pieces of information are closely related, so it makes sense for them to be in the same place. However, getParameter knows nothing about the syntax of an HTTP error response. As new functionality is added to the Web server, new methods like getParameter may be created with their own errors. If the new methods throw exceptions in the same way as getParameter (by generating exceptions that inherit from the same superclass and including an error message in each exception), they can plug into the existing system with no other changes: the top-level handler will automatically generate error responses for them.\n\n> 从封装和信息隐藏的角度来看，上一段中描述的聚合具有良好的属性。顶级异常处理程序封装了有关如何生成错误响应的知识，但对特定错误一无所知。它仅使用异常中提供的错误消息。getParameter 方法封装了有关如何从 URL 提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两个信息密切相关，因此将它们放在同一位置是很有意义的。但是，getParameter 对 HTTP 错误响应的语法一无所知。随着向 Web 服务器中添加了新功能，可能会创建具有类似自身错误的新方法，如 getParameter。\n\nThis example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, it’s useful to define an exception that aborts the current request, cleans up the system’s state, and continues with the next request. The exception is caught in a single place near the top of the system’s request-handling loop. This exception can be thrown at any point in the processing of a request to abort the request; different subclasses of the exception can be defined for different conditions. Exceptions of this type should be clearly distinguished from exceptions that are fatal to the entire system.\n\n> 此示例说明了用于异常处理的通用设计模式。如果系统处理一系列请求，则定义一个异常以中止当前请求，清除系统状态并继续下一个请求非常有用。异常被捕获在系统请求处理循环顶部附近的单个位置。在处理中止请求的任何时候都可以抛出该异常。可以为不同的条件定义异常的不同子类。应该将这种类型的异常与对整个系统致命的异常区分开来。\n\nException aggregation works best if an exception propagates several levels up the stack before it is handled; this allows more exceptions from more methods to be handled in the same place. This is the opposite of exception masking: masking usually works best if an exception is handled in a low-level method. For masking, the low-level method is typically a library method used by many other methods, so allowing the exception to propagate would increase the number of places where it is handled. Masking and aggregation are similar in that both approaches position an exception handler where it can catch the most exceptions, eliminating many handlers that would otherwise need to be created.\n\n> 如果异常在处理之前在堆栈中传播了多个级别，则异常聚集最有效。这样可以在同一位置处理更多方法的更多异常。这与异常屏蔽相反：如果使用低级方法处理异常，则屏蔽通常效果最好。对于屏蔽，低级方法通常是许多其他方法使用的库方法，因此，允许传播异常会增加处理该异常的位置数。掩码和聚合的相似之处在于，这两种方法都将异常处理程序置于可以捕获最多异常的位置，从而消除了许多本来需要创建的处理程序。\n\nAnother example of exception aggregation occurs in the RAMCloud storage system for crash recovery. A RAMCloud system consists of a collection of storage servers that keep multiple copies of each object, so the system can recover from a variety of failures. For example, if a server crashes and loses all of its data, RAMCloud reconstructs the lost data using copies stored on other servers. Errors can also happen on a smaller scale; for example, a server may discover that an individual object is corrupted.\n\n> RAMCloud 存储系统中发生异常聚集的另一个示例是崩溃恢复。RAMCloud 系统由一组存储服务器组成，这些存储服务器保留每个对象的多个副本，因此系统可以从各种故障中恢复。例如，如果服务器崩溃并丢失其所有数据，RAMCloud 会使用存储在其他服务器上的副本来重建丢失的数据。错误也可能在较小的范围内发生。例如，服务器可能发现单个对象已损坏。\n\nRAMCloud does not have separate recovery mechanisms for each different kind of error. Instead, RAMCloud “promotes” many smaller errors into larger ones. RAMCloud could, in principle, handle a corrupted object by restoring that one object from a backup copy. However, it doesn’t do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloud uses this approach because crash recovery is quite complex and this approach minimized the number of different recovery mechanisms that had to be created. Creating a recovery mechanism for crashed servers was unavoidable, so RAMCloud uses the same mechanism for other kinds of recovery as well. This reduced the amount of code that had to be written, and it also meant that server crash recovery gets invoked more often. As a result, bugs in recovery are more likely to be discovered and fixed.\n\n> 对于每种不同类型的错误，RAMCloud 没有单独的恢复机制。相反，RAMCloud 将许多较小的错误“提升”为较大的错误。原则上，RAMCloud 可以通过从备份副本中恢复一个损坏的对象来处理这个损坏的对象。然而，它并不这样做。相反，如果它发现一个损坏的对象，它会使包含该对象的服务器崩溃。RAMCloud 使用这种方法是因为崩溃恢复非常复杂，而且这种方法最小化了必须创建的不同恢复机制的数量。为崩溃的服务器创建恢复机制是不可避免的，因此 RAMCloud 对其他类型的恢复也使用相同的机制。这减少了必须编写的代码量，而且这还意味着服务器崩溃恢复将更频繁地被调用。因此，恢复中的 bug 更有可能被发现和修复。\n\nOne disadvantage of promoting a corrupted object into a server crash is that it increases the cost of recovery considerably. This is not a problem in RAMCloud, since object corruption is quite rare. However, error promotion may not make sense for errors that happen frequently. As one example, it would not be practical to crash a server anytime one of its network packets is lost.\n\n> 将损坏的对象升级为服务器崩溃的一个缺点是，它大大增加了恢复成本。这在 RAMCloud 中不是问题，因为对象损坏非常罕见。但是，错误升级对于经常发生的错误可能没有意义。举一个例子，在服务器的任何网络数据包丢失时使服务器崩溃是不切实际的。\n\nOne way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations. This provides another illustration of the benefits of general-purpose mechanisms.\n\n> 考虑异常聚合的一种方法是，它用可以处理多种情况的单个通用机制替换了几种针对特定情况而量身定制的特殊用途的机制。这再次说明了通用机制的好处。\n\n## 10.8 Just crash? 崩溃了吗？\n\nThe fourth technique for reducing complexity related to exception handling is to crash the application. In most applications there will be certain errors that it’s not worth trying to handle. Typically, these errors are difficult or impossible to handle and don’t occur very often. The simplest thing to do in response to these errors is to print diagnostic information and then abort the application.\n\n> 减少与异常处理相关的复杂性的第四种技术是使应用程序崩溃。在大多数应用程序中，有些错误是不值得尝试的。通常，这些错误很难或不可能处理，而且很少发生。针对这些错误的最简单的操作是打印诊断信息，然后中止应用程序。\n\nOne example is “out of memory” errors that occur during storage allocation. Consider the malloc function in C, which returns NULL if it cannot allocate the desired block of memory. This is an unfortunate behavior, because it assumes that every single caller of malloc will check the return value and take appropriate action if there is no memory. Applications contain numerous calls to malloc, so checking the result after each call would add significant complexity. If a programmer forgets the check (which is fairly likely), then the application will dereference a null pointer if memory runs out, resulting in a crash that camouflages the real problem.\n\n> 一个示例是在存储分配期间发生的“内存不足”错误。考虑一下 C 语言中的 malloc 函数，如果它无法分配所需的内存块，则该函数将返回 NULL。这是一个不幸的行为，因为它假定 malloc 的每个调用者都将检查返回值并在没有内存的情况下采取适当的措施。应用程序包含许多对 malloc 的调用，因此在每次调用后检查结果将增加相当大的复杂性。如果程序员忘记了检查（这很有可能），那么如果内存用完，应用程序将取消引用空指针，从而导致崩溃，从而掩盖了实际问题。\n\nFurthermore, there isn’t much an application can do when it discovers that memory is exhausted. In principle the application could look for unneeded memory to free, but if the application had unneeded memory it could already have freed it, which would have prevented the out-of-memory error in the first place. Today’s systems have so much memory that memory almost never runs out; if it does, it usually indicates a bug in the application. Thus, it rarely make sense to try to handle out-of-memory errors; this creates too much complexity for too little benefit.\n\n> 此外，当应用程序发现内存已用完时，它无能为力。原则上，应用程序可以寻找不需要的内存以释放它，但是如果应用程序有不需要的内存，它可以已经释放它，这首先可以防止内存不足错误。当今的系统具有如此大的内存，以至于内存几乎永远不会耗尽。如果是这样，通常表明应用程序中存在错误。因此，尝试处理内存不足错误几乎没有道理。这会带来太多的复杂性，而带来的收益却太少。\n\nA better approach is to define a new method ckalloc, which calls malloc, checks the result, and aborts the application with an error message if memory is exhausted. The application never invokes malloc directly; it always invokes ckalloc.\n\n> 更好的方法是定义一个新的 ckalloc 方法，该方法调用 malloc，检查结果，并在内存耗尽时通过错误消息中止应用程序。该应用程序从不直接调用 malloc。它总是调用 ckalloc。\n\nIn newer languages such as C++ and Java, the new operator throws an exception if memory is exhausted. There’s not much point in catching this exception, since there’s a good chance that the exception handler will also try to allocate memory, which will also fail. Dynamically allocated memory is such a fundamental element of any modern application that it doesn’t make sense for the application to continue if memory is exhausted; it’s better to crash as soon as the error is detected.\n\n> 在较新的语言（例如 C ++和 Java）中，如果内存耗尽，则 new 运算符将引发异常。捕获此异常没有什么意义，因为异常处理程序很有可能还会尝试分配内存，这也会失败。动态分配的内存是任何现代应用程序中的基本元素，如果内存耗尽，则继续应用程序是没有意义的。最好在检测到错误后立即崩溃。\n\nThere are many other examples of errors where crashing the application makes sense. For most programs, if an I/O error occurs while reading or writing an open file (such as a disk hard error), or if a network socket cannot be opened, there’s not much the application can do to recover, so aborting with a clear error message is a sensible approach. These errors are infrequent, so they are unlikely to affect the overall usability of the application. Aborting with an error message is also appropriate if an application encounters an internal error such as an inconsistent data structure. Conditions like this probably indicate bugs in the program.\n\n> 还有许多其他错误示例，这些错误会使应用程序崩溃很有意义。对于大多数程序，如果在读取或写入打开的文件时发生 I/O 错误（例如磁盘硬错误），或者无法打开网络套接字，则应用程序无济于事，因此中止了操作。清除错误消息是一种明智的方法。这些错误很少发生，因此它们不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误（如数据结构不一致），则错误消息中止也是合适的。这样的条件可能表明程序中存在错误。\n\nWhether or not it is acceptable to crash on a particular error depends on the application. For a replicated storage system, it isn’t appropriate to abort on an I/O error. Instead, the system must use replicated data to recover any information that was lost. The recovery mechanisms will add considerable complexity to the program, but recovering lost data is an essential part of the value the system provides to its users.\n\n> 在特定错误上崩溃是否可以接受取决于应用程序。对于复制的存储系统，不适合因 I/O 错误而中止。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将给程序增加相当大的复杂性，但是恢复丢失的数据是系统为用户提供的价值的重要组成部分。\n\n## 10.9 Design special cases out of existence 设计特殊情况不存在\n\nFor the same reason that it makes sense to define errors out of existence, it also makes sense to define other special cases out of existence. Special cases can result in code that is riddled with if statements, which make the code hard to understand and lead to bugs. Thus, special cases should be eliminated wherever possible. The best way to do this is by designing the normal case in a way that automatically handles the special cases without any extra code.\n\n> 出于同样的原因，定义不存在的错误是有意义的，而定义其他不存在的特殊情况也是有意义的。特殊情况可能导致代码中混入 if 语句，这使代码难以理解并导致错误。因此，应尽可能消除特殊情况。做到这一点的最佳方法是设计一种普通情况，这种方式可以自动处理特殊情况而无需任何额外的代码。\n\nIn the text editor project described in Chapter 6, students had to implement a mechanism for selecting text and copying or deleting the selection. Most students introduced a state variable in their selection implementation to indicate whether or not the selection exists. They probably chose this approach because there are times when no selection is visible on the screen, so it seemed natural to represent this notion in the implementation. However, this approach resulted in numerous checks to detect the “no selection” condition and handle it specially.\n\n> 在第 6 章中描述的文本编辑器项目中，学生必须实现一种选择文本以及复制或删除所选内容的机制。大多数学生在他们的选择实现中引入了状态变量，以表明选择是否存在。他们之所以选择这种方法，是因为有时屏幕上看不到任何选择，因此在实现中似乎很自然地代表了这一概念。但是，这种方法导致大量检查以检测“无选择”条件并进行特殊处理。\n\nThe selection handling code can be simplified by eliminating the “no selection” special case, so that the selection always exists. When there is no selection visible on the screen, it can be represented internally with an empty selection, whose starting and ending positions are the same. With this approach, the selection management code can be written without any checks for “no selection”. When copying the selection, if the selection is empty then 0 bytes will be inserted at the new location (if implemented correctly, there will be no need to check for 0 bytes as a special case). Similarly, it should be possible to design the code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection, extract the portion of the line preceding the selection and concatenate it with the portion of the line following the selection to form the new line. If the selection is empty, this approach will regenerate the original line.\n\n> 通过消除“不选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，可以编写选择管理代码，而无需对“不选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节（如果正确实现，则在特殊情况下无需检查 0 字节）。同样，应该有可能设计用于删除选择的代码，以便无需任何特殊情况检查就可以处理空情况。在一行上考虑所有选择。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。\n\nThis example also illustrates the “different layer, different abstraction” idea from Chapter 7. The notion of “no selection” makes sense in terms of how the user thinks about the application’s interface, but that doesn’t mean it has to be represented explicitly inside the application. Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation.\n\n> 此示例还说明了第 7 章中的“不同的层，不同的抽象”概念。“无选择”的概念在用户对应用程序界面的看法方面很有意义，但这并不意味着必须明确表示它在应用程序内部。选择总是存在的，但有时是空的，因此是不可见的，这样可以简化实现。\n\n## 10.10 Taking it too far 走得太远\n\nDefining away exceptions, or masking them inside a module, only makes sense if the exception information isn’t needed outside the module. This was true for the examples in this chapter, such the Tcl unset command and the Java substring method; in the rare situations where a caller cares about the special cases detected by the exceptions, there are other ways for it to get this information.\n\n> 定义异常或将其屏蔽在模块内部，仅在模块外部不需要异常信息时才有意义。对于本章中的示例，例如 Tcl unset 命令和 Java 子字符串方法，都是如此。在极少数情况下，呼叫者关心异常检测到的特殊情况，还有其他方法可以获取此信息。\n\nHowever, it is possible to take this idea too far. In a module for network communication, a student team masked all network exceptions: if a network error occurred, the module caught it, discarded it, and continued as if there were no problem. This meant that applications using the module had no way to find out if messages were lost or a peer server failed; without this information, it was impossible to build robust applications. In this case, it is essential for the module to expose the exceptions, even though they add complexity to the module’s interface.\n\n> 但是，有可能使这个想法太过分。在用于网络通信的模块中，一个学生团队掩盖了所有网络异常：如果发生网络错误，则模块将其捕获，丢弃并继续进行，就好像没有问题一样。这意味着使用该模块的应用程序无法确定消息是否丢失或对等服务器是否发生故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，模块必须公开异常，即使它们增加了模块接口的复杂性。\n\nWith exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when something is important, it must be exposed.\n\n> 与软件设计中的许多其他领域一样，您必须确定哪些是重要的，哪些是不重要的。不重要的事物应该被隐藏起来，它们越多越好。但是，当某件事很重要时，必须将其暴露出来。\n\n## 10.11 Conclusion 结论\n\nSpecial cases of any form make code harder to understand and increase the likelihood of bugs. This chapter focused on exceptions, which are one of the most significant sources of special-case code, and discussed how to reduce the number of places where exceptions must be handled. The best way to do this is by redefining semantics to eliminate error conditions. For exceptions that can’t be defined away, you should look for opportunities to mask them at a low level, so their impact is limited, or aggregate several special-case handlers into a single more generic handler. Together, these techniques can have a significant impact on overall system complexity.\n\n> 任何形式的特殊情况都使代码更难以理解，并增加了发生错误的可能性。本章重点讨论异常，异常是特殊情况代码的最重要来源之一，并讨论了如何减少必须处理异常的地方的数量。做到这一点的最佳方法是重新定义语义以消除错误条件。对于无法定义的异常，您应该寻找机会将它们掩盖到较低的水平，以免影响有限，或者将多个特殊情况的处理程序聚合到一个更通用的处理程序中。总之，这些技术可能会对整体系统复杂性产生重大影响。\n\n1Ding Yuan et. al., “Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems,” 2014 USENIX Conference on Operating System Design and Implementation.\n\n> 1 丁元等 等人，“简单的测试可以防止最关键的故障：对分布式数据密集型系统中的生产故障的分析”，2014 USENIX 操作系统设计和实施大会。\n","source":"_posts/软件设计的哲学-ch10.md","raw":"---\ntitle: 软件设计的哲学 - ch10\ndate: 2021-02-10\ntags: 软件设计的哲学 软件开发 方法论\n---\n定义不存在的错误\n<!-- more -->\n# 第 10 章 定义不存在的错误\n\n> Chapter 10 Define Errors Out Of Existence\n\nException handling is one of the worst sources of complexity in software systems. Code that deals with special conditions is inherently harder to write than code that deals with normal cases, and developers often define exceptions without considering how they will be handled. This chapter discusses why exceptions contribute disproportionately to complexity, then it shows how to simplify exception handling. The key overall lesson from this chapter is to reduce the number of places where exceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and there is no exceptional condition to report (hence the title of this chapter).\n\n> 异常处理是软件系统中最糟糕的复杂性来源之一。处理特殊情况的代码在本质上比处理正常情况的代码更难编写，并且开发人员经常在定义异常时不考虑异常的处理方式。本章讨论了为什么异常对复杂性的贡献不成比例，然后说明了如何简化异常处理。本章总的主要教训是减少必须处理异常的地方的数量。在许多情况下，可以修改操作的语义，以便正常行为可以处理所有情况，并且没有要报告的特殊条件（因此，本章标题）。\n\n## 10.1 Why exceptions add complexity 为什么异常会增加复杂性\n\nI use the term exception to refer to any uncommon condition that alters the normal flow of control in a program. Many programming languages include a formal exception mechanism that allows exceptions to be thrown by lower-level code and caught by enclosing code. However, exceptions can occur even without using a formal exception reporting mechanism, such as when a method returns a special value indicating that it didn’t complete its normal behavior. All of these forms of exceptions contribute to complexity.\n\n> 我使用“异常”一词来指代任何会改变程序中正常控制流程的不常见条件。许多编程语言都包含一种正式的异常机制，该机制允许异常由低级代码引发并由封闭代码捕获。但是，即使不使用正式的异常报告机制，异常也可能发生，例如，当某个方法返回一个特殊值指示其未完成其正常行为时。所有这些形式的异常都会增加复杂性。\n\nA particular piece of code may encounter exceptions in several different ways:\n\n> 一段特定的代码可能会以几种不同的方式遇到异常：\n\n- A caller may provide bad arguments or configuration information.\n- An invoked method may not be able to complete a requested operation. For example, an I/O operation may fail, or a required resource may not be available.\n- In a distributed system, network packets may be lost or delayed, servers may not respond in a timely fashion, or peers may communicate in unexpected ways.\n- The code may detect bugs, internal inconsistencies, or situations it is not prepared to handle.\n\n---\n\n> - 调用方可能会提供错误的参数或配置信息。\n> - 调用的方法可能无法完成请求的操作。例如，I/O 操作可能失败，或者所需的资源可能不可用。\n> - 在分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或者对等方可能会以意想不到的方式进行通信。\n> - 该代码可能会检测到错误，内部不一致或未准备处理的情况。\n\nLarge systems have to deal with many exceptional conditions, particularly if they are distributed or need to be fault-tolerant. Exception handling can account for a significant fraction of all the code in a system.\n\n> 大型系统必须应对许多特殊情况，特别是在它们是分布式的或需要容错的情况下。异常处理可以占系统中所有代码的很大一部分。\n\nException handling code is inherently more difficult to write than normal-case code. An exception disrupts the normal flow of the code; it usually means that something didn’t work as expected. When an exception occurs, the programmer can deal with it in two ways, each of which can be complicated. The first approach is to move forward and complete the work in progress in spite of the exception. For example, if a network packet is lost, it can be resent; if data is corrupted, perhaps it can be recovered from a redundant copy. The second approach is to abort the operation in progress and report the exception upwards. However, aborting can be complicated because the exception may have occurred at a point where system state is inconsistent (a data structure might have been partially initialized); the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.\n\n> 异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流;它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复数据。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化);异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。\n\nFurthermore, exception handling code creates opportunities for more exceptions. Consider the case of resending a lost network packet. Perhaps the packet wasn’t actually lost, but was simply delayed. In this case, resending the packet will result in duplicate packets arriving at the peer; this introduces a new exceptional condition that the peer must handle. Or, consider the case of recovering lost data from a redundant copy: what if the redundant copy has also been lost? Secondary exceptions occurring during recovery are often more subtle and complex than the primary exceptions. If an exception is handled by aborting the operation in progress, then this must be reported to the caller as another exception. To prevent an unending cascade of exceptions, the developer must eventually find a way to handle exceptions without introducing more exceptions.\n\n> 此外，异常处理代码为更多异常创造了机会。考虑重新发送丢失的网络数据包的情况。也许该数据包实际上并没有丢失，但是只是被延迟了。在这种情况下，重新发送数据包将导致重复的数据包到达对等方；这引入了对等方必须处理的新的例外条件。或者，考虑从冗余副本恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更加微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用方。为了防止无休止的异常级联，开发人员最终必须找到一种在不引入更多异常的情况下处理异常的方法。\n\nLanguage support for exceptions tends to be verbose and clunky, which makes exception handling code hard to read. For example, consider the following code, which reads a collection of tweets from a file using Java’s support for object serialization and deserialization:\n\n> 语言对异常的支持往往是冗长而笨拙的，这使得异常处理代码难以阅读。例如，考虑以下代码，该代码使用 Java 对对象序列化和反序列化的支持从文件中读取 tweet 的集合：\n\n```java\ntry (\n    FileInputStream fileStream = new FileInputStream(fileName);\n    BufferedInputStream bufferedStream = new BufferedInputStream(fileStream);\n    ObjectInputStream objectStream = new ObjectInputStream(bufferedStream);\n) {\n    for (int i = 0; i < tweetsPerFile; i++) {\n        tweets.add((Tweet) objectStream.readObject());\n    }\n}\ncatch (FileNotFoundException e) {\n    ...\n}\ncatch (ClassNotFoundException e) {\n    ...\n}\ncatch (EOFException e) {\n    // Not a problem: not all tweet files have full\n    // set of tweets.\n}\ncatch (IOException e) {\n    ...\n}\ncatch (ClassCastException e) {\n    ...\n}\n```\n\nJust the basic try-catch boilerplate accounts for more lines of code than the code for normal-case operation, without even considering the code that actually handles the exceptions. It is hard to relate the exception handling code to the normal-case code: for example, it’s not obvious where each exception is generated. An alternative approach is to break up the code into many distinct try blocks; in the extreme case there could be a try for each line of code that can generate an exception. This would make it clear where exceptions occur, but the try blocks themselves break up the flow of the code and make it harder to read; in addition, some exception handling code might end up duplicated in multiple try blocks.\n\n> 只是基本的 try-catch 样板代码比正常情况下的操作代码所占的代码行更多，甚至没有考虑实际处理异常的代码。很难将异常处理代码与普通情况代码相关联：例如，每个异常的生成位置都不明显。另一种方法是将代码分解为许多不同的 try 块。在极端情况下，可能会尝试尝试每行可能产生异常的代码。这样可以清楚地说明异常发生的位置，但是 try 块本身会破坏代码流，并使代码难以阅读。此外，某些异常处理代码可能最终会在多个 try 块中重复。\n\nIt’s difficult to ensure that exception handling code really works. Some exceptions, such as I/O errors, can’t easily be generated in a test environment, so it’s hard to test the code that handles them. Exceptions don’t occur very often in running systems, so exception handling code rarely executes. Bugs can go undetected for a long time, and when the exception handling code is finally needed, there’s a good chance that it won’t work (one of my favorite sayings: “code that hasn’t been executed doesn’t work”). A recent study found that more than 90% of catastrophic failures in distributed data-intensive systems were caused by incorrect error handling1. When exception handling code fails, it’s difficult to debug the problem, since it occurs so infrequently.\n\n> 确保异常处理代码真正起作用是困难的。某些异常（例如 I/O 错误）在测试环境中不易生成，因此很难测试处理它们的代码。异常在运行的系统中很少发生，因此异常处理代码很少执行。错误可能会长时间未被发现，并且当最终需要异常处理代码时，它很有可能无法正常工作（我最喜欢的一句话是：“未执行的代码无效”） 。最近的一项研究发现，分布式数据密集型系统中超过 90％的灾难性故障是由错误的错误处理引起的 1。当异常处理代码失败时，很难调试该问题，因为它很少发生。\n\n## 10.2 Too many exceptions 异常过多\n\nProgrammers exacerbate the problems related to exception handling by defining unnecessary exceptions. Most programmers are taught that it’s important to detect and report errors; they often interpret this to mean “the more errors detected, the better.” This leads to an over-defensive style where anything that looks even a bit suspicious is rejected with an exception, which results in a proliferation of unnecessary exceptions that increase the complexity of the system.\n\n> 程序员通过定义不必要的异常加剧了与异常处理有关的问题。告诉大多数程序员，检测和报告错误很重要。他们通常将其解释为“检测到的错误越多越好”。这导致了一种过分防御的风格，其中任何看起来甚至有点可疑的东西都被拒绝，并带有异常，这导致了不必要的异常的泛滥，从而增加了系统的复杂性。\n\nI made this mistake myself in the design of the Tcl scripting language. Tcl contains an unset command that can be used to remove a variable. I defined unset so that it throws an error if the variable doesn’t exist. At the time I thought that it must be a bug if someone tries to delete a variable that doesn’t exist, so Tcl should report it. However, one of the most common uses of unset is to clean up temporary state created by some previous operation. It’s often hard to predict exactly what state was created, particularly if the operation aborted partway through. Thus, the simplest thing is to delete all of the variables that might possibly have been created. The definition of unset makes this awkward: developers end up enclosing calls to unset in catch statements to catch and ignore errors thrown by unset. In retrospect, the definition of the unset command is one of the biggest mistakes I made in the design of Tcl.\n\n> 在设计 Tcl 脚本语言时，我自己就犯了这个错误。Tcl 包含一个未设置的命令，可用于删除变量。我定义了 unset 以便在变量不存在时抛出错误。当时我认为，如果有人试图删除一个不存在的变量，那么它一定是一个 bug，所以 Tcl 应该报告它。然而，unset 最常见的用途之一是清理以前操作创建的临时状态。通常很难准确地预测创建了什么状态，特别是在操作中途中止的情况下。因此，最简单的方法是删除可能已经创建的所有变量。unset 的定义使得这种情况很尴尬:开发人员最终会在 catch 语句中封装对 unset 的调用，以捕获并忽略 unset 抛出的错误。回顾过去，unset 命令的定义是我在 Tcl 设计中犯下的最大错误之一。\n\nIt’s tempting to use exceptions to avoid dealing with difficult situations: rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller. Some might argue that this approach empowers callers, since it allows each caller to handle the exception in a different way. However, if you are having trouble figuring out what to do for the particular situation, there’s a good chance that the caller won’t know what to do either. Generating an exception in a situation like this just passes the problem to someone else and adds to the system’s complexity.\n\n> 试图使用异常来避免处理困难的情况很诱人：与其想出一种干净的方法来处理它，不如抛出一个异常并将问题平移给调用者。有人可能会争辩说，这种方法可以赋予调用者权力，因为它允许每个调用者以不同的方式处理异常。但是，如果您在确定特定情况下该怎么做时遇到困难，则呼叫者很可能都不知道该怎么办。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。\n\nThe exceptions thrown by a class are part of its interface; classes with lots of exceptions have complex interfaces, and they are shallower than classes with fewer exceptions. An exception is a particularly complex element of an interface. It can propagate up through several stack levels before being caught, so it affects not just the method’s caller, but potentially also higher-level callers (and their interfaces).\n\n> 类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且比具有较少异常的类浅。异常是接口中特别复杂的元素。它可以在被捕获之前通过多个堆栈级别向上传播，因此它不仅影响方法的调用者，而且还可能影响更高级别的调用者（及其接口）。\n\nThrowing exceptions is easy; handling them is hard. Thus, the complexity of exceptions comes from the exception handling code. The best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled. The rest of this chapter will discuss four techniques for reducing the number of exception handlers.\n\n> 抛出异常很容易；处理它们很困难。因此，异常的复杂性来自异常处理代码。减少由异常处理引起的复杂性破坏的最佳方法是减少必须处理异常的位置的数量。本章的其余部分将讨论减少异常处理程序数量的四种技术。\n\n## 10.3 Define errors out of existence 定义错误不存在\n\nThe best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. This may seem sacrilegious, but it is very effective in practice. Consider the Tcl unset command discussed above. Rather than throwing an error when unset is asked to delete an unknown variable, it should have simply returned without doing anything. I should have changed the definition of unset slightly: rather than deleting a variable, unset should ensure that a variable no longer exists. With the first definition, unset can’t do its job if the variable doesn’t exist, so generating an exception makes sense. With the second definition, it is perfectly natural for unset to be invoked with the name of a variable that doesn’t exist. In this case, its work is already done, so it can simply return. There is no longer an error case to report.\n\n> 消除异常处理复杂性的最好方法是定义您的 API，以便没有异常要处理：定义错误而已。这似乎是牺牲品，但在实践中非常有效。考虑上面讨论的 Tcl unset 命令。而不是在要求 unset 删除未知变量时引发错误，它应该只是返回而无需执行任何操作。我应该稍微修改一下 unset 的定义：与其删除一个变量，不应该删除 unset 来确保一个变量不再存在。根据第一个定义，如果变量不存在，则 unset 不能执行其工作，因此生成异常是有意义的。使用第二个定义，使用不存在的变量名调用 unset 是很自然的。在这种情况下，它的工作已经完成，因此可以简单地返回。\n\n## 10.4 Example: file deletion in Windows 示例：Windows 中的文件删除\n\nFile deletion provides another example of how errors can be defined away. The Windows operating system does not permit a file to be deleted if it is open in a process. This is a continual source of frustration for developers and users. In order to delete a file that is in use, the user must search through the system to find the process that has the file open, and then kill that process. Sometimes users give up and reboot their system, just so they can delete a file.\n\n> 文件删除提供了如何定义错误的另一个示例。Windows 操作系统不允许删除文件（如果已在进程中打开文件）。对于开发人员和用户来说，这是不断沮丧的根源。为了删除正在使用的文件，用户必须在系统中搜索以找到已打开文件的进程，然后终止该进程。有时用户放弃并重新启动系统，只是为了删除文件。\n\nThe Unix operating system defines file deletion more elegantly. In Unix, if a file is open when it is deleted, Unix does not delete the file immediately. Instead, it marks the file for deletion, then the delete operation returns successfully. The file name has been removed from its directory, so no other processes can open the old file and a new file with the same name can be created, but the existing file data persists. Processes that already have the file open can continue to read it and write it normally. Once the file has been closed by all of the accessing processes, its data is freed.\n\n> Unix 操作系统更优雅地定义了文件删除。在 Unix 中，如果在删除文件时打开了文件，则 Unix 不会立即删除该文件。而是将文件标记为删除，然后删除操作成功返回。该文件名已从其目录中删除，因此其他进程无法打开该旧文件，并且可以创建具有相同名称的新文件，但现有文件数据将保留。已经打开文件的进程可以继续读取和正常写入文件。一旦所有访问进程都关闭了文件，便释放其数据。\n\nThe Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the delete succeeds, and the file will eventually be deleted. Second, deleting a file that’s in use does not create exceptions for the processes using the file. One possible approach to this problem would have been to delete the file immediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach would create new errors for those processes to handle. Instead, Unix allows them to keep accessing the file normally; delaying the file deletion defines errors out of existence.\n\n> Unix 方法定义了两种不同的错误。首先，如果文件当前正在使用中，则删除操作不再返回错误；删除成功，该文件最终将被删除。其次，删除正在使用的文件不会为使用该文件的进程创建例外。解决此问题的一种可能方法是立即删除文件并标记文件的所有打开以禁用它们。其他进程读取或写入已删除文件的任何尝试均将失败。但是，此方法将为那些要处理的过程创建新的错误。相反，Unix 允许他们继续正常访问文件。延迟文件删除将定义错误不存在。\n\nIt may seem strange that Unix allows a process to continue to read and write a doomed file, but I have never encountered a situation where this caused significant problems. The Unix definition of file deletion is much simpler to work with, both for developers and users, than the Windows definition.\n\n> Unix 允许进程继续读取和写入已损坏的文件可能看起来很奇怪，但是我从未遇到过引起严重问题的情况。对于开发人员和用户，Unix 删除文件的定义比 Windows 定义要容易得多。\n\n## 10.5 Example: Java substring method 示例：Java 子字符串方法\n\nAs a final example, consider the Java String class and its substring method. Given two indexes into a string, substring returns the substring starting at the character given by the first index and ending with the character just before the second index. However, if either index is outside the range of the string, then substring throws IndexOutOfBoundsException. This exception is unnecessary and complicates the use of this method. I often find myself in a situation where one or both of the indices may be outside the range of the string, and I would like to extract all of the characters in the string that overlap the specified range. Unfortunately, this requires me to check each of the indices and round them up to zero or down to the end of the string; a one-line method call now becomes 5–10 lines of code.\n\n> 作为最后一个示例，请考虑 Java String 类及其子字符串方法。给定一个字符串中的两个索引，substring 返回该子字符串，该字符串从第一个索引给定的字符开始，以第二个索引之前的字符结束。但是，如果两个索引中的任何一个都超出字符串的范围，则子字符串将引发 IndexOutOfBoundsException。此异常是不必要的，并且会使此方法的使用复杂化。我经常发现自己处于一个或两个索引可能不在字符串范围内的情况，并且我想提取字符串中与指定范围重叠的所有字符。不幸的是，这要求我检查每个索引并将它们向上舍入为零或向下舍入到字符串的末尾。现在，单行方法调用变成 5-10 行代码。\n\nThe Java substring method would be easier to use if it performed this adjustment automatically, so that it implemented the following API: “returns the characters of the string (if any) with index greater than or equal to beginIndex and less than endIndex.” This is a simple and natural API, and it defines the IndexOutOfBoundsException exception out of existence. The method’s behavior is now well-defined even if one or both of the indexes are negative, or if beginIndex is greater than endIndex. This approach simplifies the API for the method while increasing its functionality, so it makes the method deeper. Many other languages have taken the error-free approach; for example, Python returns an empty result for out-of-range list slices.\n\n> 如果 Java 子字符串方法自动执行此调整，则将更易于使用，因此它实现了以下 API：“返回索引大于或等于 beginIndex 且小于 endIndex 的字符串的字符（如果有）。” 这是一个简单自然的 API，它定义了 IndexOutOfBoundsException 异常。现在，即使一个或两个索引均为负，或者 beginIndex 大于 endIndex，该方法的行为也已明确定义。这种方法简化了方法的 API，同时增加了其功能，因此使方法更深。许多其他语言都采用了无错误的方法。例如，Python 对于超出范围的列表切片返回空结果。\n\nWhen I argue for defining errors out of existence, people sometimes counter that throwing errors will catch bugs; if errors are defined out of existence, won’t that result in buggier software? Perhaps this is why the Java developers decided that substring should throw exceptions. The error-ful approach may catch some bugs, but it also increases complexity, which results in other bugs. In the error-ful approach, developers must write additional code to avoid or ignore the errors, and this increases the likelihood of bugs; or, they may forget to write the additional code, in which case unexpected errors may be thrown at runtime. In contrast, defining errors out of existence simplifies APIs and it reduces the amount of code that must be written.\n\n> 当我主张定义错误而不再存在时，人们有时会反驳说抛出错误会捕获错误。如果错误定义不存在，那会不会导致 Buggier 软件出现？也许这就是 Java 开发人员决定子字符串应引发异常的原因。错误的方法可能会捕获一些错误，但也会增加复杂性，从而导致其他错误。在错误有效的方法中，开发人员必须编写额外的代码来避免或忽略错误，这增加了发生错误的可能性。或者，他们可能会忘记编写其他代码，在这种情况下，运行时可能会引发意外错误。相反，定义错误而不存在将简化 API，并减少必须编写的代码量。\n\nOverall, the best way to reduce bugs is to make software simpler.\n\n> 总体而言，减少错误的最好方法是简化软件。\n\n## 10.6 Mask exceptions 掩码异常\n\nThe second technique for reducing the number of places where exceptions must be handled is exception masking. With this approach, an exceptional condition is detected and handled at a low level in the system, so that higher levels of software need not be aware of the condition. Exception masking is particularly common in distributed systems. For instance, in a network transport protocol such as TCP, packets can be dropped for various reasons such as corruption and congestion. TCP masks packet loss by resending lost packets within its implementation, so all data eventually gets through and clients are unaware of the dropped packets.\n\n> 减少必须处理异常的地方数量的第二种技术是异常屏蔽。使用这种方法，可以在系统的较低级别上检测和处理异常情况，因此，更高级别的软件无需知道该情况。异常屏蔽在分布式系统中尤其常见。例如，在诸如 TCP 的网络传输协议中，由于各种原因（例如损坏和拥塞），可能会丢弃数据包。TCP 通过在其实现中重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将通过，并且客户端不知道丢失的数据包。\n\nA more controversial example of masking occurs in the NFS network file system. If an NFS file server crashes or fails to respond for any reason, clients reissue their requests to the server over and over again until the problem is eventually resolved. The low-level file system code on the client does not report any exceptions to the invoking application. The operation in progress (and hence the application) just hangs until the operation can complete successfully. If the hang lasts more than a short time, the NFS client prints messages on the user’s console of the form “NFS server xyzzy not responding still trying.”\n\n> NFS 网络文件系统中出现了一个更具争议性的屏蔽示例。如果 NFS 文件服务器由于任何原因崩溃或无法响应，客户端将一遍又一遍地向服务器发出请求，直到问题最终得到解决。客户端上的低级文件系统代码不会向调用应用程序报告任何异常。正在进行的操作（以及因此的应用程序）只是挂起，直到操作可以成功完成。如果挂起持续的时间不超过一小段时间，则 NFS 客户端将在用户控制台上以“ NFS 服务器 xyzzy 无法响应仍在尝试响应”的形式打印消息。\n\nNFS users often complain about the fact that their applications hang while waiting for an NFS server to resume normal operation. Many people have suggested that NFS should abort operations with an exception rather than hanging. However, reporting exceptions would make things worse, not better. There’s not much an application can do if it loses access to its files. One possibility would be for the application to retry the file operation, but this would still hang the application, and it’s easier to perform the retry in one place in the NFS layer, rather than at every file system call in every application (a compiler shouldn’t have to worry about this!). The other alternative is for applications to abort and return errors to their callers. It’s unlikely that the callers would know what to do either, so they would abort as well, resulting in a collapse of the user’s working environment. Users still wouldn’t be able to get any work done while the file server was down, and they would have to restart all of their applications once the file server came back to life.\n\n> NFS 用户经常抱怨这样的事实，即他们的应用程序在等待 NFS 服务器恢复正常运行时挂起。许多人建议 NFS 应该异常终止操作而不是挂起。但是，报告异常会使情况更糟，而不是更好。如果应用程序无法访问其文件，则无能为力。一种可能性是应用程序重试文件操作，但这仍然会使应用程序挂起，并且在 NFS 层中的一个位置执行重试会比在每个应用程序中的每个文件系统调用处执行重试更容易（编译器应不必为此担心！）。另一种选择是让应用程序中止并将错误返回给调用者。呼叫者不太可能知道该怎么做，因此他们也将中止，导致用户工作环境崩溃。用户在文件服务器关闭时仍然无法完成任何工作，并且一旦文件服务器恢复工作，他们将不得不重新启动所有应用程序。\n\nThus, the best alternative is for NFS to mask the errors and hang applications. With this approach, applications don’t need any code to deal with server problems, and they can resume seamlessly once the server comes back to life. If users get tired of waiting, they can always abort applications manually.\n\n> 因此，最好的替代方法是让 NFS 掩盖错误并挂起应用程序。通过这种方法，应用程序不需要任何代码来处理服务器问题，并且一旦服务器恢复运行，它们就可以无缝恢复。如果用户厌倦了等待，他们总是可以手动中止应用程序。\n\nException masking doesn’t work in all situations, but it is a powerful tool in the situations where it works. It results in deeper classes, since it reduces the class’s interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception. Exception masking is an example of pulling complexity downward.\n\n> 异常屏蔽并非在所有情况下都有效，但是在它起作用的情况下它是一个强大的工具。它导致了更深的类，因为它减少了类的界面（用户需要注意的异常更少）并以掩盖异常的代码形式添加了功能。异常屏蔽是降低复杂性的一个例子。\n\n## 10.7 Exception aggregation 异常聚集\n\nThe third technique for reducing complexity related to exceptions is exception aggregation. The idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.\n\n> 减少与异常相关的复杂性的第三种技术是异常聚合。异常聚合的思想是用一个代码段处理许多异常。与其为多个单独的异常编写不同的处理程序，不如用一个处理程序将它们全部处理在一个地方。\n\nConsider how to handle missing parameters in a Web server. A Web server implements a collection of URLs. When the server receives an incoming URL, it dispatches to a URL-specific service method to process that URL and generate a response. The URL contains various parameters that are used to generate the response. Each service method will call a lower-level method (let’s call it getParameter) to extract the parameters that it needs from the URL. If the URL does not contain the desired parameter, getParameter throws an exception.\n\n> 考虑如何处理 Web 服务器中缺少的参数。Web 服务器实现 URL 的集合。服务器收到传入的 URL 时，将分派到特定于 URL 的服务方法来处理该 URL 并生成响应。该 URL 包含用于生成响应的各种参数。每个服务方法都将调用一个较低层的方法（将其称为 getParameter）以从 URL 中提取所需的参数。如果 URL 不包含所需的参数，则 getParameter 会引发异常。\n\nWhen students in a software design class implemented such a server, many of them wrapped each distinct call to getParameter in a separate exception handler to catch NoSuchParameter exceptions, as in Figure 10.1. This resulted in a large number of handlers, all of which did essentially the same thing (generate an error response).\n\n> 当参加软件设计课程的学生实现这样的服务器时，他们中的许多人将对 getParameter 的每个不同调用包装在单独的异常处理程序中以捕获 NoSuchParameter 异常，如图 10.1 所示。这导致大量的处理程序，所有这些处理程序基本上都执行相同的操作（生成错误响应）。\n\n![](../../img/figures/00020.jpeg)\n\nFigure 10.1: The code at the top dispatches to one of several methods in a Web server, each of which handles a particular URL. Each of those methods (bottom) uses parameters from the incoming HTTP request. In this figure, there is a separate exception handler for each call to getParameter; this results in duplicated code.\n\n> 图 10.1：顶部的代码将分派给 Web 服务器中的几种方法之一，每种方法都处理一个特定的 URL。每个方法（底部）都使用传入 HTTP 请求中的参数。在此图中，每个对 getParameter 的调用都有一个单独的异常处理程序。这导致重复的代码。\n\nA better approach is to aggregate the exceptions. Instead of catching the exceptions in the individual service methods, let them propagate up to the top-level dispatch method for the Web server, as in Figure 10.2. A single handler in this method can catch all of the exceptions and generate an appropriate error response for missing parameters.\n\n> 更好的方法是汇总异常。让它们传播到 Web 服务器的顶级调度方法，而不是在单个服务方法中捕获异常，如图 10.2 所示。此方法中的单个处理程序可以捕获所有异常，并为丢失的参数生成适当的错误响应。\n\nThe aggregation approach can be taken even further in the Web example. There are many other errors besides missing parameters that can occur while processing a Web page; for example, a parameter might not have the right syntax (the service method expected an integer, but the value was “xyz”), or the user might not have permission for the requested operation. In each case, the error should result in an error response; the errors differ only in the error message to include in the response (“parameter 'quantity' not present in URL” or “bad value 'xyz' for 'quantity' parameter; must be positive integer”). Thus, all conditions resulting in an error response can be handled with a single top-level exception handler. The error message can be generated at the time the exception is thrown and included as a variable in the exception record; for example, getParameter will generate the “parameter 'quantity' not present in URL” message. The top-level handler extracts the message from the exception and incorporates it into the error response.\n\n> 在 Web 示例中甚至可以采用聚合方法。处理网页时，除了缺少参数外，还有许多其他错误；例如，参数可能没有正确的语法（服务方法应为整数，但值为“ xyz”），或者用户可能无权执行所请求的操作。在每种情况下，错误都应导致错误响应。错误仅在响应中包含的错误消息中有所不同（“ URL 中不存在参数'数量'”或“'数量'参数的错误值'xyz'；必须为正整数”）。因此，所有导致错误响应的条件都可以使用单个顶级异常处理程序进行处理。错误消息可以在引发异常时生成，并作为变量包含在异常记录中。例如，getParameter 将生成“ URL 中不存在的参数'数量'”消息。顶级处理程序从异常中提取消息，并将其合并到错误响应中。\n\n![](../../img/figures/00021.jpeg)\n\nFigure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter exceptions from all of the URL-specific methods.\n\n> 图 10.2：此代码在功能上等效于图 10.1，但是异常处理已聚合：分派器中的单个异常处理程序从所有特定于 URL 的方法中捕获所有 NoSuchParameter 异常。\n\nThe aggregation described in the preceding paragraph has good properties from the standpoint of encapsulation and information hiding. The top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception. The getParameter method encapsulates knowledge about how to extract a parameter from a URL, and it also knows how to describe extraction errors in a human-readable form. These two pieces of information are closely related, so it makes sense for them to be in the same place. However, getParameter knows nothing about the syntax of an HTTP error response. As new functionality is added to the Web server, new methods like getParameter may be created with their own errors. If the new methods throw exceptions in the same way as getParameter (by generating exceptions that inherit from the same superclass and including an error message in each exception), they can plug into the existing system with no other changes: the top-level handler will automatically generate error responses for them.\n\n> 从封装和信息隐藏的角度来看，上一段中描述的聚合具有良好的属性。顶级异常处理程序封装了有关如何生成错误响应的知识，但对特定错误一无所知。它仅使用异常中提供的错误消息。getParameter 方法封装了有关如何从 URL 提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两个信息密切相关，因此将它们放在同一位置是很有意义的。但是，getParameter 对 HTTP 错误响应的语法一无所知。随着向 Web 服务器中添加了新功能，可能会创建具有类似自身错误的新方法，如 getParameter。\n\nThis example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, it’s useful to define an exception that aborts the current request, cleans up the system’s state, and continues with the next request. The exception is caught in a single place near the top of the system’s request-handling loop. This exception can be thrown at any point in the processing of a request to abort the request; different subclasses of the exception can be defined for different conditions. Exceptions of this type should be clearly distinguished from exceptions that are fatal to the entire system.\n\n> 此示例说明了用于异常处理的通用设计模式。如果系统处理一系列请求，则定义一个异常以中止当前请求，清除系统状态并继续下一个请求非常有用。异常被捕获在系统请求处理循环顶部附近的单个位置。在处理中止请求的任何时候都可以抛出该异常。可以为不同的条件定义异常的不同子类。应该将这种类型的异常与对整个系统致命的异常区分开来。\n\nException aggregation works best if an exception propagates several levels up the stack before it is handled; this allows more exceptions from more methods to be handled in the same place. This is the opposite of exception masking: masking usually works best if an exception is handled in a low-level method. For masking, the low-level method is typically a library method used by many other methods, so allowing the exception to propagate would increase the number of places where it is handled. Masking and aggregation are similar in that both approaches position an exception handler where it can catch the most exceptions, eliminating many handlers that would otherwise need to be created.\n\n> 如果异常在处理之前在堆栈中传播了多个级别，则异常聚集最有效。这样可以在同一位置处理更多方法的更多异常。这与异常屏蔽相反：如果使用低级方法处理异常，则屏蔽通常效果最好。对于屏蔽，低级方法通常是许多其他方法使用的库方法，因此，允许传播异常会增加处理该异常的位置数。掩码和聚合的相似之处在于，这两种方法都将异常处理程序置于可以捕获最多异常的位置，从而消除了许多本来需要创建的处理程序。\n\nAnother example of exception aggregation occurs in the RAMCloud storage system for crash recovery. A RAMCloud system consists of a collection of storage servers that keep multiple copies of each object, so the system can recover from a variety of failures. For example, if a server crashes and loses all of its data, RAMCloud reconstructs the lost data using copies stored on other servers. Errors can also happen on a smaller scale; for example, a server may discover that an individual object is corrupted.\n\n> RAMCloud 存储系统中发生异常聚集的另一个示例是崩溃恢复。RAMCloud 系统由一组存储服务器组成，这些存储服务器保留每个对象的多个副本，因此系统可以从各种故障中恢复。例如，如果服务器崩溃并丢失其所有数据，RAMCloud 会使用存储在其他服务器上的副本来重建丢失的数据。错误也可能在较小的范围内发生。例如，服务器可能发现单个对象已损坏。\n\nRAMCloud does not have separate recovery mechanisms for each different kind of error. Instead, RAMCloud “promotes” many smaller errors into larger ones. RAMCloud could, in principle, handle a corrupted object by restoring that one object from a backup copy. However, it doesn’t do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloud uses this approach because crash recovery is quite complex and this approach minimized the number of different recovery mechanisms that had to be created. Creating a recovery mechanism for crashed servers was unavoidable, so RAMCloud uses the same mechanism for other kinds of recovery as well. This reduced the amount of code that had to be written, and it also meant that server crash recovery gets invoked more often. As a result, bugs in recovery are more likely to be discovered and fixed.\n\n> 对于每种不同类型的错误，RAMCloud 没有单独的恢复机制。相反，RAMCloud 将许多较小的错误“提升”为较大的错误。原则上，RAMCloud 可以通过从备份副本中恢复一个损坏的对象来处理这个损坏的对象。然而，它并不这样做。相反，如果它发现一个损坏的对象，它会使包含该对象的服务器崩溃。RAMCloud 使用这种方法是因为崩溃恢复非常复杂，而且这种方法最小化了必须创建的不同恢复机制的数量。为崩溃的服务器创建恢复机制是不可避免的，因此 RAMCloud 对其他类型的恢复也使用相同的机制。这减少了必须编写的代码量，而且这还意味着服务器崩溃恢复将更频繁地被调用。因此，恢复中的 bug 更有可能被发现和修复。\n\nOne disadvantage of promoting a corrupted object into a server crash is that it increases the cost of recovery considerably. This is not a problem in RAMCloud, since object corruption is quite rare. However, error promotion may not make sense for errors that happen frequently. As one example, it would not be practical to crash a server anytime one of its network packets is lost.\n\n> 将损坏的对象升级为服务器崩溃的一个缺点是，它大大增加了恢复成本。这在 RAMCloud 中不是问题，因为对象损坏非常罕见。但是，错误升级对于经常发生的错误可能没有意义。举一个例子，在服务器的任何网络数据包丢失时使服务器崩溃是不切实际的。\n\nOne way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations. This provides another illustration of the benefits of general-purpose mechanisms.\n\n> 考虑异常聚合的一种方法是，它用可以处理多种情况的单个通用机制替换了几种针对特定情况而量身定制的特殊用途的机制。这再次说明了通用机制的好处。\n\n## 10.8 Just crash? 崩溃了吗？\n\nThe fourth technique for reducing complexity related to exception handling is to crash the application. In most applications there will be certain errors that it’s not worth trying to handle. Typically, these errors are difficult or impossible to handle and don’t occur very often. The simplest thing to do in response to these errors is to print diagnostic information and then abort the application.\n\n> 减少与异常处理相关的复杂性的第四种技术是使应用程序崩溃。在大多数应用程序中，有些错误是不值得尝试的。通常，这些错误很难或不可能处理，而且很少发生。针对这些错误的最简单的操作是打印诊断信息，然后中止应用程序。\n\nOne example is “out of memory” errors that occur during storage allocation. Consider the malloc function in C, which returns NULL if it cannot allocate the desired block of memory. This is an unfortunate behavior, because it assumes that every single caller of malloc will check the return value and take appropriate action if there is no memory. Applications contain numerous calls to malloc, so checking the result after each call would add significant complexity. If a programmer forgets the check (which is fairly likely), then the application will dereference a null pointer if memory runs out, resulting in a crash that camouflages the real problem.\n\n> 一个示例是在存储分配期间发生的“内存不足”错误。考虑一下 C 语言中的 malloc 函数，如果它无法分配所需的内存块，则该函数将返回 NULL。这是一个不幸的行为，因为它假定 malloc 的每个调用者都将检查返回值并在没有内存的情况下采取适当的措施。应用程序包含许多对 malloc 的调用，因此在每次调用后检查结果将增加相当大的复杂性。如果程序员忘记了检查（这很有可能），那么如果内存用完，应用程序将取消引用空指针，从而导致崩溃，从而掩盖了实际问题。\n\nFurthermore, there isn’t much an application can do when it discovers that memory is exhausted. In principle the application could look for unneeded memory to free, but if the application had unneeded memory it could already have freed it, which would have prevented the out-of-memory error in the first place. Today’s systems have so much memory that memory almost never runs out; if it does, it usually indicates a bug in the application. Thus, it rarely make sense to try to handle out-of-memory errors; this creates too much complexity for too little benefit.\n\n> 此外，当应用程序发现内存已用完时，它无能为力。原则上，应用程序可以寻找不需要的内存以释放它，但是如果应用程序有不需要的内存，它可以已经释放它，这首先可以防止内存不足错误。当今的系统具有如此大的内存，以至于内存几乎永远不会耗尽。如果是这样，通常表明应用程序中存在错误。因此，尝试处理内存不足错误几乎没有道理。这会带来太多的复杂性，而带来的收益却太少。\n\nA better approach is to define a new method ckalloc, which calls malloc, checks the result, and aborts the application with an error message if memory is exhausted. The application never invokes malloc directly; it always invokes ckalloc.\n\n> 更好的方法是定义一个新的 ckalloc 方法，该方法调用 malloc，检查结果，并在内存耗尽时通过错误消息中止应用程序。该应用程序从不直接调用 malloc。它总是调用 ckalloc。\n\nIn newer languages such as C++ and Java, the new operator throws an exception if memory is exhausted. There’s not much point in catching this exception, since there’s a good chance that the exception handler will also try to allocate memory, which will also fail. Dynamically allocated memory is such a fundamental element of any modern application that it doesn’t make sense for the application to continue if memory is exhausted; it’s better to crash as soon as the error is detected.\n\n> 在较新的语言（例如 C ++和 Java）中，如果内存耗尽，则 new 运算符将引发异常。捕获此异常没有什么意义，因为异常处理程序很有可能还会尝试分配内存，这也会失败。动态分配的内存是任何现代应用程序中的基本元素，如果内存耗尽，则继续应用程序是没有意义的。最好在检测到错误后立即崩溃。\n\nThere are many other examples of errors where crashing the application makes sense. For most programs, if an I/O error occurs while reading or writing an open file (such as a disk hard error), or if a network socket cannot be opened, there’s not much the application can do to recover, so aborting with a clear error message is a sensible approach. These errors are infrequent, so they are unlikely to affect the overall usability of the application. Aborting with an error message is also appropriate if an application encounters an internal error such as an inconsistent data structure. Conditions like this probably indicate bugs in the program.\n\n> 还有许多其他错误示例，这些错误会使应用程序崩溃很有意义。对于大多数程序，如果在读取或写入打开的文件时发生 I/O 错误（例如磁盘硬错误），或者无法打开网络套接字，则应用程序无济于事，因此中止了操作。清除错误消息是一种明智的方法。这些错误很少发生，因此它们不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误（如数据结构不一致），则错误消息中止也是合适的。这样的条件可能表明程序中存在错误。\n\nWhether or not it is acceptable to crash on a particular error depends on the application. For a replicated storage system, it isn’t appropriate to abort on an I/O error. Instead, the system must use replicated data to recover any information that was lost. The recovery mechanisms will add considerable complexity to the program, but recovering lost data is an essential part of the value the system provides to its users.\n\n> 在特定错误上崩溃是否可以接受取决于应用程序。对于复制的存储系统，不适合因 I/O 错误而中止。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将给程序增加相当大的复杂性，但是恢复丢失的数据是系统为用户提供的价值的重要组成部分。\n\n## 10.9 Design special cases out of existence 设计特殊情况不存在\n\nFor the same reason that it makes sense to define errors out of existence, it also makes sense to define other special cases out of existence. Special cases can result in code that is riddled with if statements, which make the code hard to understand and lead to bugs. Thus, special cases should be eliminated wherever possible. The best way to do this is by designing the normal case in a way that automatically handles the special cases without any extra code.\n\n> 出于同样的原因，定义不存在的错误是有意义的，而定义其他不存在的特殊情况也是有意义的。特殊情况可能导致代码中混入 if 语句，这使代码难以理解并导致错误。因此，应尽可能消除特殊情况。做到这一点的最佳方法是设计一种普通情况，这种方式可以自动处理特殊情况而无需任何额外的代码。\n\nIn the text editor project described in Chapter 6, students had to implement a mechanism for selecting text and copying or deleting the selection. Most students introduced a state variable in their selection implementation to indicate whether or not the selection exists. They probably chose this approach because there are times when no selection is visible on the screen, so it seemed natural to represent this notion in the implementation. However, this approach resulted in numerous checks to detect the “no selection” condition and handle it specially.\n\n> 在第 6 章中描述的文本编辑器项目中，学生必须实现一种选择文本以及复制或删除所选内容的机制。大多数学生在他们的选择实现中引入了状态变量，以表明选择是否存在。他们之所以选择这种方法，是因为有时屏幕上看不到任何选择，因此在实现中似乎很自然地代表了这一概念。但是，这种方法导致大量检查以检测“无选择”条件并进行特殊处理。\n\nThe selection handling code can be simplified by eliminating the “no selection” special case, so that the selection always exists. When there is no selection visible on the screen, it can be represented internally with an empty selection, whose starting and ending positions are the same. With this approach, the selection management code can be written without any checks for “no selection”. When copying the selection, if the selection is empty then 0 bytes will be inserted at the new location (if implemented correctly, there will be no need to check for 0 bytes as a special case). Similarly, it should be possible to design the code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection, extract the portion of the line preceding the selection and concatenate it with the portion of the line following the selection to form the new line. If the selection is empty, this approach will regenerate the original line.\n\n> 通过消除“不选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，可以编写选择管理代码，而无需对“不选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节（如果正确实现，则在特殊情况下无需检查 0 字节）。同样，应该有可能设计用于删除选择的代码，以便无需任何特殊情况检查就可以处理空情况。在一行上考虑所有选择。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。\n\nThis example also illustrates the “different layer, different abstraction” idea from Chapter 7. The notion of “no selection” makes sense in terms of how the user thinks about the application’s interface, but that doesn’t mean it has to be represented explicitly inside the application. Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation.\n\n> 此示例还说明了第 7 章中的“不同的层，不同的抽象”概念。“无选择”的概念在用户对应用程序界面的看法方面很有意义，但这并不意味着必须明确表示它在应用程序内部。选择总是存在的，但有时是空的，因此是不可见的，这样可以简化实现。\n\n## 10.10 Taking it too far 走得太远\n\nDefining away exceptions, or masking them inside a module, only makes sense if the exception information isn’t needed outside the module. This was true for the examples in this chapter, such the Tcl unset command and the Java substring method; in the rare situations where a caller cares about the special cases detected by the exceptions, there are other ways for it to get this information.\n\n> 定义异常或将其屏蔽在模块内部，仅在模块外部不需要异常信息时才有意义。对于本章中的示例，例如 Tcl unset 命令和 Java 子字符串方法，都是如此。在极少数情况下，呼叫者关心异常检测到的特殊情况，还有其他方法可以获取此信息。\n\nHowever, it is possible to take this idea too far. In a module for network communication, a student team masked all network exceptions: if a network error occurred, the module caught it, discarded it, and continued as if there were no problem. This meant that applications using the module had no way to find out if messages were lost or a peer server failed; without this information, it was impossible to build robust applications. In this case, it is essential for the module to expose the exceptions, even though they add complexity to the module’s interface.\n\n> 但是，有可能使这个想法太过分。在用于网络通信的模块中，一个学生团队掩盖了所有网络异常：如果发生网络错误，则模块将其捕获，丢弃并继续进行，就好像没有问题一样。这意味着使用该模块的应用程序无法确定消息是否丢失或对等服务器是否发生故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，模块必须公开异常，即使它们增加了模块接口的复杂性。\n\nWith exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when something is important, it must be exposed.\n\n> 与软件设计中的许多其他领域一样，您必须确定哪些是重要的，哪些是不重要的。不重要的事物应该被隐藏起来，它们越多越好。但是，当某件事很重要时，必须将其暴露出来。\n\n## 10.11 Conclusion 结论\n\nSpecial cases of any form make code harder to understand and increase the likelihood of bugs. This chapter focused on exceptions, which are one of the most significant sources of special-case code, and discussed how to reduce the number of places where exceptions must be handled. The best way to do this is by redefining semantics to eliminate error conditions. For exceptions that can’t be defined away, you should look for opportunities to mask them at a low level, so their impact is limited, or aggregate several special-case handlers into a single more generic handler. Together, these techniques can have a significant impact on overall system complexity.\n\n> 任何形式的特殊情况都使代码更难以理解，并增加了发生错误的可能性。本章重点讨论异常，异常是特殊情况代码的最重要来源之一，并讨论了如何减少必须处理异常的地方的数量。做到这一点的最佳方法是重新定义语义以消除错误条件。对于无法定义的异常，您应该寻找机会将它们掩盖到较低的水平，以免影响有限，或者将多个特殊情况的处理程序聚合到一个更通用的处理程序中。总之，这些技术可能会对整体系统复杂性产生重大影响。\n\n1Ding Yuan et. al., “Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems,” 2014 USENIX Conference on Operating System Design and Implementation.\n\n> 1 丁元等 等人，“简单的测试可以防止最关键的故障：对分布式数据密集型系统中的生产故障的分析”，2014 USENIX 操作系统设计和实施大会。\n","slug":"软件设计的哲学-ch10","published":1,"updated":"2021-02-16T04:53:48.198Z","_id":"ckl7iw2w4000qkiiyfbor44s8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>定义不存在的错误</p>\n<a id=\"more\"></a>\n<h1 id=\"第-10-章-定义不存在的错误\"><a href=\"#第-10-章-定义不存在的错误\" class=\"headerlink\" title=\"第 10 章 定义不存在的错误\"></a>第 10 章 定义不存在的错误</h1><blockquote>\n<p>Chapter 10 Define Errors Out Of Existence</p>\n</blockquote>\n<p>Exception handling is one of the worst sources of complexity in software systems. Code that deals with special conditions is inherently harder to write than code that deals with normal cases, and developers often define exceptions without considering how they will be handled. This chapter discusses why exceptions contribute disproportionately to complexity, then it shows how to simplify exception handling. The key overall lesson from this chapter is to reduce the number of places where exceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and there is no exceptional condition to report (hence the title of this chapter).</p>\n<blockquote>\n<p>异常处理是软件系统中最糟糕的复杂性来源之一。处理特殊情况的代码在本质上比处理正常情况的代码更难编写，并且开发人员经常在定义异常时不考虑异常的处理方式。本章讨论了为什么异常对复杂性的贡献不成比例，然后说明了如何简化异常处理。本章总的主要教训是减少必须处理异常的地方的数量。在许多情况下，可以修改操作的语义，以便正常行为可以处理所有情况，并且没有要报告的特殊条件（因此，本章标题）。</p>\n</blockquote>\n<h2 id=\"10-1-Why-exceptions-add-complexity-为什么异常会增加复杂性\"><a href=\"#10-1-Why-exceptions-add-complexity-为什么异常会增加复杂性\" class=\"headerlink\" title=\"10.1 Why exceptions add complexity 为什么异常会增加复杂性\"></a>10.1 Why exceptions add complexity 为什么异常会增加复杂性</h2><p>I use the term exception to refer to any uncommon condition that alters the normal flow of control in a program. Many programming languages include a formal exception mechanism that allows exceptions to be thrown by lower-level code and caught by enclosing code. However, exceptions can occur even without using a formal exception reporting mechanism, such as when a method returns a special value indicating that it didn’t complete its normal behavior. All of these forms of exceptions contribute to complexity.</p>\n<blockquote>\n<p>我使用“异常”一词来指代任何会改变程序中正常控制流程的不常见条件。许多编程语言都包含一种正式的异常机制，该机制允许异常由低级代码引发并由封闭代码捕获。但是，即使不使用正式的异常报告机制，异常也可能发生，例如，当某个方法返回一个特殊值指示其未完成其正常行为时。所有这些形式的异常都会增加复杂性。</p>\n</blockquote>\n<p>A particular piece of code may encounter exceptions in several different ways:</p>\n<blockquote>\n<p>一段特定的代码可能会以几种不同的方式遇到异常：</p>\n</blockquote>\n<ul>\n<li>A caller may provide bad arguments or configuration information.</li>\n<li>An invoked method may not be able to complete a requested operation. For example, an I/O operation may fail, or a required resource may not be available.</li>\n<li>In a distributed system, network packets may be lost or delayed, servers may not respond in a timely fashion, or peers may communicate in unexpected ways.</li>\n<li>The code may detect bugs, internal inconsistencies, or situations it is not prepared to handle.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>调用方可能会提供错误的参数或配置信息。</li>\n<li>调用的方法可能无法完成请求的操作。例如，I/O 操作可能失败，或者所需的资源可能不可用。</li>\n<li>在分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或者对等方可能会以意想不到的方式进行通信。</li>\n<li>该代码可能会检测到错误，内部不一致或未准备处理的情况。</li>\n</ul>\n</blockquote>\n<p>Large systems have to deal with many exceptional conditions, particularly if they are distributed or need to be fault-tolerant. Exception handling can account for a significant fraction of all the code in a system.</p>\n<blockquote>\n<p>大型系统必须应对许多特殊情况，特别是在它们是分布式的或需要容错的情况下。异常处理可以占系统中所有代码的很大一部分。</p>\n</blockquote>\n<p>Exception handling code is inherently more difficult to write than normal-case code. An exception disrupts the normal flow of the code; it usually means that something didn’t work as expected. When an exception occurs, the programmer can deal with it in two ways, each of which can be complicated. The first approach is to move forward and complete the work in progress in spite of the exception. For example, if a network packet is lost, it can be resent; if data is corrupted, perhaps it can be recovered from a redundant copy. The second approach is to abort the operation in progress and report the exception upwards. However, aborting can be complicated because the exception may have occurred at a point where system state is inconsistent (a data structure might have been partially initialized); the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.</p>\n<blockquote>\n<p>异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流;它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复数据。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化);异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。</p>\n</blockquote>\n<p>Furthermore, exception handling code creates opportunities for more exceptions. Consider the case of resending a lost network packet. Perhaps the packet wasn’t actually lost, but was simply delayed. In this case, resending the packet will result in duplicate packets arriving at the peer; this introduces a new exceptional condition that the peer must handle. Or, consider the case of recovering lost data from a redundant copy: what if the redundant copy has also been lost? Secondary exceptions occurring during recovery are often more subtle and complex than the primary exceptions. If an exception is handled by aborting the operation in progress, then this must be reported to the caller as another exception. To prevent an unending cascade of exceptions, the developer must eventually find a way to handle exceptions without introducing more exceptions.</p>\n<blockquote>\n<p>此外，异常处理代码为更多异常创造了机会。考虑重新发送丢失的网络数据包的情况。也许该数据包实际上并没有丢失，但是只是被延迟了。在这种情况下，重新发送数据包将导致重复的数据包到达对等方；这引入了对等方必须处理的新的例外条件。或者，考虑从冗余副本恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更加微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用方。为了防止无休止的异常级联，开发人员最终必须找到一种在不引入更多异常的情况下处理异常的方法。</p>\n</blockquote>\n<p>Language support for exceptions tends to be verbose and clunky, which makes exception handling code hard to read. For example, consider the following code, which reads a collection of tweets from a file using Java’s support for object serialization and deserialization:</p>\n<blockquote>\n<p>语言对异常的支持往往是冗长而笨拙的，这使得异常处理代码难以阅读。例如，考虑以下代码，该代码使用 Java 对对象序列化和反序列化的支持从文件中读取 tweet 的集合：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (</span><br><span class=\"line\">    FileInputStream fileStream = <span class=\"keyword\">new</span> FileInputStream(fileName);</span><br><span class=\"line\">    BufferedInputStream bufferedStream = <span class=\"keyword\">new</span> BufferedInputStream(fileStream);</span><br><span class=\"line\">    ObjectInputStream objectStream = <span class=\"keyword\">new</span> ObjectInputStream(bufferedStream);</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tweetsPerFile; i++) &#123;</span><br><span class=\"line\">        tweets.add((Tweet) objectStream.readObject());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (EOFException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Not a problem: not all tweet files have full</span></span><br><span class=\"line\">    <span class=\"comment\">// set of tweets.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (ClassCastException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Just the basic try-catch boilerplate accounts for more lines of code than the code for normal-case operation, without even considering the code that actually handles the exceptions. It is hard to relate the exception handling code to the normal-case code: for example, it’s not obvious where each exception is generated. An alternative approach is to break up the code into many distinct try blocks; in the extreme case there could be a try for each line of code that can generate an exception. This would make it clear where exceptions occur, but the try blocks themselves break up the flow of the code and make it harder to read; in addition, some exception handling code might end up duplicated in multiple try blocks.</p>\n<blockquote>\n<p>只是基本的 try-catch 样板代码比正常情况下的操作代码所占的代码行更多，甚至没有考虑实际处理异常的代码。很难将异常处理代码与普通情况代码相关联：例如，每个异常的生成位置都不明显。另一种方法是将代码分解为许多不同的 try 块。在极端情况下，可能会尝试尝试每行可能产生异常的代码。这样可以清楚地说明异常发生的位置，但是 try 块本身会破坏代码流，并使代码难以阅读。此外，某些异常处理代码可能最终会在多个 try 块中重复。</p>\n</blockquote>\n<p>It’s difficult to ensure that exception handling code really works. Some exceptions, such as I/O errors, can’t easily be generated in a test environment, so it’s hard to test the code that handles them. Exceptions don’t occur very often in running systems, so exception handling code rarely executes. Bugs can go undetected for a long time, and when the exception handling code is finally needed, there’s a good chance that it won’t work (one of my favorite sayings: “code that hasn’t been executed doesn’t work”). A recent study found that more than 90% of catastrophic failures in distributed data-intensive systems were caused by incorrect error handling1. When exception handling code fails, it’s difficult to debug the problem, since it occurs so infrequently.</p>\n<blockquote>\n<p>确保异常处理代码真正起作用是困难的。某些异常（例如 I/O 错误）在测试环境中不易生成，因此很难测试处理它们的代码。异常在运行的系统中很少发生，因此异常处理代码很少执行。错误可能会长时间未被发现，并且当最终需要异常处理代码时，它很有可能无法正常工作（我最喜欢的一句话是：“未执行的代码无效”） 。最近的一项研究发现，分布式数据密集型系统中超过 90％的灾难性故障是由错误的错误处理引起的 1。当异常处理代码失败时，很难调试该问题，因为它很少发生。</p>\n</blockquote>\n<h2 id=\"10-2-Too-many-exceptions-异常过多\"><a href=\"#10-2-Too-many-exceptions-异常过多\" class=\"headerlink\" title=\"10.2 Too many exceptions 异常过多\"></a>10.2 Too many exceptions 异常过多</h2><p>Programmers exacerbate the problems related to exception handling by defining unnecessary exceptions. Most programmers are taught that it’s important to detect and report errors; they often interpret this to mean “the more errors detected, the better.” This leads to an over-defensive style where anything that looks even a bit suspicious is rejected with an exception, which results in a proliferation of unnecessary exceptions that increase the complexity of the system.</p>\n<blockquote>\n<p>程序员通过定义不必要的异常加剧了与异常处理有关的问题。告诉大多数程序员，检测和报告错误很重要。他们通常将其解释为“检测到的错误越多越好”。这导致了一种过分防御的风格，其中任何看起来甚至有点可疑的东西都被拒绝，并带有异常，这导致了不必要的异常的泛滥，从而增加了系统的复杂性。</p>\n</blockquote>\n<p>I made this mistake myself in the design of the Tcl scripting language. Tcl contains an unset command that can be used to remove a variable. I defined unset so that it throws an error if the variable doesn’t exist. At the time I thought that it must be a bug if someone tries to delete a variable that doesn’t exist, so Tcl should report it. However, one of the most common uses of unset is to clean up temporary state created by some previous operation. It’s often hard to predict exactly what state was created, particularly if the operation aborted partway through. Thus, the simplest thing is to delete all of the variables that might possibly have been created. The definition of unset makes this awkward: developers end up enclosing calls to unset in catch statements to catch and ignore errors thrown by unset. In retrospect, the definition of the unset command is one of the biggest mistakes I made in the design of Tcl.</p>\n<blockquote>\n<p>在设计 Tcl 脚本语言时，我自己就犯了这个错误。Tcl 包含一个未设置的命令，可用于删除变量。我定义了 unset 以便在变量不存在时抛出错误。当时我认为，如果有人试图删除一个不存在的变量，那么它一定是一个 bug，所以 Tcl 应该报告它。然而，unset 最常见的用途之一是清理以前操作创建的临时状态。通常很难准确地预测创建了什么状态，特别是在操作中途中止的情况下。因此，最简单的方法是删除可能已经创建的所有变量。unset 的定义使得这种情况很尴尬:开发人员最终会在 catch 语句中封装对 unset 的调用，以捕获并忽略 unset 抛出的错误。回顾过去，unset 命令的定义是我在 Tcl 设计中犯下的最大错误之一。</p>\n</blockquote>\n<p>It’s tempting to use exceptions to avoid dealing with difficult situations: rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller. Some might argue that this approach empowers callers, since it allows each caller to handle the exception in a different way. However, if you are having trouble figuring out what to do for the particular situation, there’s a good chance that the caller won’t know what to do either. Generating an exception in a situation like this just passes the problem to someone else and adds to the system’s complexity.</p>\n<blockquote>\n<p>试图使用异常来避免处理困难的情况很诱人：与其想出一种干净的方法来处理它，不如抛出一个异常并将问题平移给调用者。有人可能会争辩说，这种方法可以赋予调用者权力，因为它允许每个调用者以不同的方式处理异常。但是，如果您在确定特定情况下该怎么做时遇到困难，则呼叫者很可能都不知道该怎么办。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。</p>\n</blockquote>\n<p>The exceptions thrown by a class are part of its interface; classes with lots of exceptions have complex interfaces, and they are shallower than classes with fewer exceptions. An exception is a particularly complex element of an interface. It can propagate up through several stack levels before being caught, so it affects not just the method’s caller, but potentially also higher-level callers (and their interfaces).</p>\n<blockquote>\n<p>类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且比具有较少异常的类浅。异常是接口中特别复杂的元素。它可以在被捕获之前通过多个堆栈级别向上传播，因此它不仅影响方法的调用者，而且还可能影响更高级别的调用者（及其接口）。</p>\n</blockquote>\n<p>Throwing exceptions is easy; handling them is hard. Thus, the complexity of exceptions comes from the exception handling code. The best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled. The rest of this chapter will discuss four techniques for reducing the number of exception handlers.</p>\n<blockquote>\n<p>抛出异常很容易；处理它们很困难。因此，异常的复杂性来自异常处理代码。减少由异常处理引起的复杂性破坏的最佳方法是减少必须处理异常的位置的数量。本章的其余部分将讨论减少异常处理程序数量的四种技术。</p>\n</blockquote>\n<h2 id=\"10-3-Define-errors-out-of-existence-定义错误不存在\"><a href=\"#10-3-Define-errors-out-of-existence-定义错误不存在\" class=\"headerlink\" title=\"10.3 Define errors out of existence 定义错误不存在\"></a>10.3 Define errors out of existence 定义错误不存在</h2><p>The best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. This may seem sacrilegious, but it is very effective in practice. Consider the Tcl unset command discussed above. Rather than throwing an error when unset is asked to delete an unknown variable, it should have simply returned without doing anything. I should have changed the definition of unset slightly: rather than deleting a variable, unset should ensure that a variable no longer exists. With the first definition, unset can’t do its job if the variable doesn’t exist, so generating an exception makes sense. With the second definition, it is perfectly natural for unset to be invoked with the name of a variable that doesn’t exist. In this case, its work is already done, so it can simply return. There is no longer an error case to report.</p>\n<blockquote>\n<p>消除异常处理复杂性的最好方法是定义您的 API，以便没有异常要处理：定义错误而已。这似乎是牺牲品，但在实践中非常有效。考虑上面讨论的 Tcl unset 命令。而不是在要求 unset 删除未知变量时引发错误，它应该只是返回而无需执行任何操作。我应该稍微修改一下 unset 的定义：与其删除一个变量，不应该删除 unset 来确保一个变量不再存在。根据第一个定义，如果变量不存在，则 unset 不能执行其工作，因此生成异常是有意义的。使用第二个定义，使用不存在的变量名调用 unset 是很自然的。在这种情况下，它的工作已经完成，因此可以简单地返回。</p>\n</blockquote>\n<h2 id=\"10-4-Example-file-deletion-in-Windows-示例：Windows-中的文件删除\"><a href=\"#10-4-Example-file-deletion-in-Windows-示例：Windows-中的文件删除\" class=\"headerlink\" title=\"10.4 Example: file deletion in Windows 示例：Windows 中的文件删除\"></a>10.4 Example: file deletion in Windows 示例：Windows 中的文件删除</h2><p>File deletion provides another example of how errors can be defined away. The Windows operating system does not permit a file to be deleted if it is open in a process. This is a continual source of frustration for developers and users. In order to delete a file that is in use, the user must search through the system to find the process that has the file open, and then kill that process. Sometimes users give up and reboot their system, just so they can delete a file.</p>\n<blockquote>\n<p>文件删除提供了如何定义错误的另一个示例。Windows 操作系统不允许删除文件（如果已在进程中打开文件）。对于开发人员和用户来说，这是不断沮丧的根源。为了删除正在使用的文件，用户必须在系统中搜索以找到已打开文件的进程，然后终止该进程。有时用户放弃并重新启动系统，只是为了删除文件。</p>\n</blockquote>\n<p>The Unix operating system defines file deletion more elegantly. In Unix, if a file is open when it is deleted, Unix does not delete the file immediately. Instead, it marks the file for deletion, then the delete operation returns successfully. The file name has been removed from its directory, so no other processes can open the old file and a new file with the same name can be created, but the existing file data persists. Processes that already have the file open can continue to read it and write it normally. Once the file has been closed by all of the accessing processes, its data is freed.</p>\n<blockquote>\n<p>Unix 操作系统更优雅地定义了文件删除。在 Unix 中，如果在删除文件时打开了文件，则 Unix 不会立即删除该文件。而是将文件标记为删除，然后删除操作成功返回。该文件名已从其目录中删除，因此其他进程无法打开该旧文件，并且可以创建具有相同名称的新文件，但现有文件数据将保留。已经打开文件的进程可以继续读取和正常写入文件。一旦所有访问进程都关闭了文件，便释放其数据。</p>\n</blockquote>\n<p>The Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the delete succeeds, and the file will eventually be deleted. Second, deleting a file that’s in use does not create exceptions for the processes using the file. One possible approach to this problem would have been to delete the file immediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach would create new errors for those processes to handle. Instead, Unix allows them to keep accessing the file normally; delaying the file deletion defines errors out of existence.</p>\n<blockquote>\n<p>Unix 方法定义了两种不同的错误。首先，如果文件当前正在使用中，则删除操作不再返回错误；删除成功，该文件最终将被删除。其次，删除正在使用的文件不会为使用该文件的进程创建例外。解决此问题的一种可能方法是立即删除文件并标记文件的所有打开以禁用它们。其他进程读取或写入已删除文件的任何尝试均将失败。但是，此方法将为那些要处理的过程创建新的错误。相反，Unix 允许他们继续正常访问文件。延迟文件删除将定义错误不存在。</p>\n</blockquote>\n<p>It may seem strange that Unix allows a process to continue to read and write a doomed file, but I have never encountered a situation where this caused significant problems. The Unix definition of file deletion is much simpler to work with, both for developers and users, than the Windows definition.</p>\n<blockquote>\n<p>Unix 允许进程继续读取和写入已损坏的文件可能看起来很奇怪，但是我从未遇到过引起严重问题的情况。对于开发人员和用户，Unix 删除文件的定义比 Windows 定义要容易得多。</p>\n</blockquote>\n<h2 id=\"10-5-Example-Java-substring-method-示例：Java-子字符串方法\"><a href=\"#10-5-Example-Java-substring-method-示例：Java-子字符串方法\" class=\"headerlink\" title=\"10.5 Example: Java substring method 示例：Java 子字符串方法\"></a>10.5 Example: Java substring method 示例：Java 子字符串方法</h2><p>As a final example, consider the Java String class and its substring method. Given two indexes into a string, substring returns the substring starting at the character given by the first index and ending with the character just before the second index. However, if either index is outside the range of the string, then substring throws IndexOutOfBoundsException. This exception is unnecessary and complicates the use of this method. I often find myself in a situation where one or both of the indices may be outside the range of the string, and I would like to extract all of the characters in the string that overlap the specified range. Unfortunately, this requires me to check each of the indices and round them up to zero or down to the end of the string; a one-line method call now becomes 5–10 lines of code.</p>\n<blockquote>\n<p>作为最后一个示例，请考虑 Java String 类及其子字符串方法。给定一个字符串中的两个索引，substring 返回该子字符串，该字符串从第一个索引给定的字符开始，以第二个索引之前的字符结束。但是，如果两个索引中的任何一个都超出字符串的范围，则子字符串将引发 IndexOutOfBoundsException。此异常是不必要的，并且会使此方法的使用复杂化。我经常发现自己处于一个或两个索引可能不在字符串范围内的情况，并且我想提取字符串中与指定范围重叠的所有字符。不幸的是，这要求我检查每个索引并将它们向上舍入为零或向下舍入到字符串的末尾。现在，单行方法调用变成 5-10 行代码。</p>\n</blockquote>\n<p>The Java substring method would be easier to use if it performed this adjustment automatically, so that it implemented the following API: “returns the characters of the string (if any) with index greater than or equal to beginIndex and less than endIndex.” This is a simple and natural API, and it defines the IndexOutOfBoundsException exception out of existence. The method’s behavior is now well-defined even if one or both of the indexes are negative, or if beginIndex is greater than endIndex. This approach simplifies the API for the method while increasing its functionality, so it makes the method deeper. Many other languages have taken the error-free approach; for example, Python returns an empty result for out-of-range list slices.</p>\n<blockquote>\n<p>如果 Java 子字符串方法自动执行此调整，则将更易于使用，因此它实现了以下 API：“返回索引大于或等于 beginIndex 且小于 endIndex 的字符串的字符（如果有）。” 这是一个简单自然的 API，它定义了 IndexOutOfBoundsException 异常。现在，即使一个或两个索引均为负，或者 beginIndex 大于 endIndex，该方法的行为也已明确定义。这种方法简化了方法的 API，同时增加了其功能，因此使方法更深。许多其他语言都采用了无错误的方法。例如，Python 对于超出范围的列表切片返回空结果。</p>\n</blockquote>\n<p>When I argue for defining errors out of existence, people sometimes counter that throwing errors will catch bugs; if errors are defined out of existence, won’t that result in buggier software? Perhaps this is why the Java developers decided that substring should throw exceptions. The error-ful approach may catch some bugs, but it also increases complexity, which results in other bugs. In the error-ful approach, developers must write additional code to avoid or ignore the errors, and this increases the likelihood of bugs; or, they may forget to write the additional code, in which case unexpected errors may be thrown at runtime. In contrast, defining errors out of existence simplifies APIs and it reduces the amount of code that must be written.</p>\n<blockquote>\n<p>当我主张定义错误而不再存在时，人们有时会反驳说抛出错误会捕获错误。如果错误定义不存在，那会不会导致 Buggier 软件出现？也许这就是 Java 开发人员决定子字符串应引发异常的原因。错误的方法可能会捕获一些错误，但也会增加复杂性，从而导致其他错误。在错误有效的方法中，开发人员必须编写额外的代码来避免或忽略错误，这增加了发生错误的可能性。或者，他们可能会忘记编写其他代码，在这种情况下，运行时可能会引发意外错误。相反，定义错误而不存在将简化 API，并减少必须编写的代码量。</p>\n</blockquote>\n<p>Overall, the best way to reduce bugs is to make software simpler.</p>\n<blockquote>\n<p>总体而言，减少错误的最好方法是简化软件。</p>\n</blockquote>\n<h2 id=\"10-6-Mask-exceptions-掩码异常\"><a href=\"#10-6-Mask-exceptions-掩码异常\" class=\"headerlink\" title=\"10.6 Mask exceptions 掩码异常\"></a>10.6 Mask exceptions 掩码异常</h2><p>The second technique for reducing the number of places where exceptions must be handled is exception masking. With this approach, an exceptional condition is detected and handled at a low level in the system, so that higher levels of software need not be aware of the condition. Exception masking is particularly common in distributed systems. For instance, in a network transport protocol such as TCP, packets can be dropped for various reasons such as corruption and congestion. TCP masks packet loss by resending lost packets within its implementation, so all data eventually gets through and clients are unaware of the dropped packets.</p>\n<blockquote>\n<p>减少必须处理异常的地方数量的第二种技术是异常屏蔽。使用这种方法，可以在系统的较低级别上检测和处理异常情况，因此，更高级别的软件无需知道该情况。异常屏蔽在分布式系统中尤其常见。例如，在诸如 TCP 的网络传输协议中，由于各种原因（例如损坏和拥塞），可能会丢弃数据包。TCP 通过在其实现中重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将通过，并且客户端不知道丢失的数据包。</p>\n</blockquote>\n<p>A more controversial example of masking occurs in the NFS network file system. If an NFS file server crashes or fails to respond for any reason, clients reissue their requests to the server over and over again until the problem is eventually resolved. The low-level file system code on the client does not report any exceptions to the invoking application. The operation in progress (and hence the application) just hangs until the operation can complete successfully. If the hang lasts more than a short time, the NFS client prints messages on the user’s console of the form “NFS server xyzzy not responding still trying.”</p>\n<blockquote>\n<p>NFS 网络文件系统中出现了一个更具争议性的屏蔽示例。如果 NFS 文件服务器由于任何原因崩溃或无法响应，客户端将一遍又一遍地向服务器发出请求，直到问题最终得到解决。客户端上的低级文件系统代码不会向调用应用程序报告任何异常。正在进行的操作（以及因此的应用程序）只是挂起，直到操作可以成功完成。如果挂起持续的时间不超过一小段时间，则 NFS 客户端将在用户控制台上以“ NFS 服务器 xyzzy 无法响应仍在尝试响应”的形式打印消息。</p>\n</blockquote>\n<p>NFS users often complain about the fact that their applications hang while waiting for an NFS server to resume normal operation. Many people have suggested that NFS should abort operations with an exception rather than hanging. However, reporting exceptions would make things worse, not better. There’s not much an application can do if it loses access to its files. One possibility would be for the application to retry the file operation, but this would still hang the application, and it’s easier to perform the retry in one place in the NFS layer, rather than at every file system call in every application (a compiler shouldn’t have to worry about this!). The other alternative is for applications to abort and return errors to their callers. It’s unlikely that the callers would know what to do either, so they would abort as well, resulting in a collapse of the user’s working environment. Users still wouldn’t be able to get any work done while the file server was down, and they would have to restart all of their applications once the file server came back to life.</p>\n<blockquote>\n<p>NFS 用户经常抱怨这样的事实，即他们的应用程序在等待 NFS 服务器恢复正常运行时挂起。许多人建议 NFS 应该异常终止操作而不是挂起。但是，报告异常会使情况更糟，而不是更好。如果应用程序无法访问其文件，则无能为力。一种可能性是应用程序重试文件操作，但这仍然会使应用程序挂起，并且在 NFS 层中的一个位置执行重试会比在每个应用程序中的每个文件系统调用处执行重试更容易（编译器应不必为此担心！）。另一种选择是让应用程序中止并将错误返回给调用者。呼叫者不太可能知道该怎么做，因此他们也将中止，导致用户工作环境崩溃。用户在文件服务器关闭时仍然无法完成任何工作，并且一旦文件服务器恢复工作，他们将不得不重新启动所有应用程序。</p>\n</blockquote>\n<p>Thus, the best alternative is for NFS to mask the errors and hang applications. With this approach, applications don’t need any code to deal with server problems, and they can resume seamlessly once the server comes back to life. If users get tired of waiting, they can always abort applications manually.</p>\n<blockquote>\n<p>因此，最好的替代方法是让 NFS 掩盖错误并挂起应用程序。通过这种方法，应用程序不需要任何代码来处理服务器问题，并且一旦服务器恢复运行，它们就可以无缝恢复。如果用户厌倦了等待，他们总是可以手动中止应用程序。</p>\n</blockquote>\n<p>Exception masking doesn’t work in all situations, but it is a powerful tool in the situations where it works. It results in deeper classes, since it reduces the class’s interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception. Exception masking is an example of pulling complexity downward.</p>\n<blockquote>\n<p>异常屏蔽并非在所有情况下都有效，但是在它起作用的情况下它是一个强大的工具。它导致了更深的类，因为它减少了类的界面（用户需要注意的异常更少）并以掩盖异常的代码形式添加了功能。异常屏蔽是降低复杂性的一个例子。</p>\n</blockquote>\n<h2 id=\"10-7-Exception-aggregation-异常聚集\"><a href=\"#10-7-Exception-aggregation-异常聚集\" class=\"headerlink\" title=\"10.7 Exception aggregation 异常聚集\"></a>10.7 Exception aggregation 异常聚集</h2><p>The third technique for reducing complexity related to exceptions is exception aggregation. The idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.</p>\n<blockquote>\n<p>减少与异常相关的复杂性的第三种技术是异常聚合。异常聚合的思想是用一个代码段处理许多异常。与其为多个单独的异常编写不同的处理程序，不如用一个处理程序将它们全部处理在一个地方。</p>\n</blockquote>\n<p>Consider how to handle missing parameters in a Web server. A Web server implements a collection of URLs. When the server receives an incoming URL, it dispatches to a URL-specific service method to process that URL and generate a response. The URL contains various parameters that are used to generate the response. Each service method will call a lower-level method (let’s call it getParameter) to extract the parameters that it needs from the URL. If the URL does not contain the desired parameter, getParameter throws an exception.</p>\n<blockquote>\n<p>考虑如何处理 Web 服务器中缺少的参数。Web 服务器实现 URL 的集合。服务器收到传入的 URL 时，将分派到特定于 URL 的服务方法来处理该 URL 并生成响应。该 URL 包含用于生成响应的各种参数。每个服务方法都将调用一个较低层的方法（将其称为 getParameter）以从 URL 中提取所需的参数。如果 URL 不包含所需的参数，则 getParameter 会引发异常。</p>\n</blockquote>\n<p>When students in a software design class implemented such a server, many of them wrapped each distinct call to getParameter in a separate exception handler to catch NoSuchParameter exceptions, as in Figure 10.1. This resulted in a large number of handlers, all of which did essentially the same thing (generate an error response).</p>\n<blockquote>\n<p>当参加软件设计课程的学生实现这样的服务器时，他们中的许多人将对 getParameter 的每个不同调用包装在单独的异常处理程序中以捕获 NoSuchParameter 异常，如图 10.1 所示。这导致大量的处理程序，所有这些处理程序基本上都执行相同的操作（生成错误响应）。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00020.jpeg\" alt=\"\"></p>\n<p>Figure 10.1: The code at the top dispatches to one of several methods in a Web server, each of which handles a particular URL. Each of those methods (bottom) uses parameters from the incoming HTTP request. In this figure, there is a separate exception handler for each call to getParameter; this results in duplicated code.</p>\n<blockquote>\n<p>图 10.1：顶部的代码将分派给 Web 服务器中的几种方法之一，每种方法都处理一个特定的 URL。每个方法（底部）都使用传入 HTTP 请求中的参数。在此图中，每个对 getParameter 的调用都有一个单独的异常处理程序。这导致重复的代码。</p>\n</blockquote>\n<p>A better approach is to aggregate the exceptions. Instead of catching the exceptions in the individual service methods, let them propagate up to the top-level dispatch method for the Web server, as in Figure 10.2. A single handler in this method can catch all of the exceptions and generate an appropriate error response for missing parameters.</p>\n<blockquote>\n<p>更好的方法是汇总异常。让它们传播到 Web 服务器的顶级调度方法，而不是在单个服务方法中捕获异常，如图 10.2 所示。此方法中的单个处理程序可以捕获所有异常，并为丢失的参数生成适当的错误响应。</p>\n</blockquote>\n<p>The aggregation approach can be taken even further in the Web example. There are many other errors besides missing parameters that can occur while processing a Web page; for example, a parameter might not have the right syntax (the service method expected an integer, but the value was “xyz”), or the user might not have permission for the requested operation. In each case, the error should result in an error response; the errors differ only in the error message to include in the response (“parameter ‘quantity’ not present in URL” or “bad value ‘xyz’ for ‘quantity’ parameter; must be positive integer”). Thus, all conditions resulting in an error response can be handled with a single top-level exception handler. The error message can be generated at the time the exception is thrown and included as a variable in the exception record; for example, getParameter will generate the “parameter ‘quantity’ not present in URL” message. The top-level handler extracts the message from the exception and incorporates it into the error response.</p>\n<blockquote>\n<p>在 Web 示例中甚至可以采用聚合方法。处理网页时，除了缺少参数外，还有许多其他错误；例如，参数可能没有正确的语法（服务方法应为整数，但值为“ xyz”），或者用户可能无权执行所请求的操作。在每种情况下，错误都应导致错误响应。错误仅在响应中包含的错误消息中有所不同（“ URL 中不存在参数’数量’”或“’数量’参数的错误值’xyz’；必须为正整数”）。因此，所有导致错误响应的条件都可以使用单个顶级异常处理程序进行处理。错误消息可以在引发异常时生成，并作为变量包含在异常记录中。例如，getParameter 将生成“ URL 中不存在的参数’数量’”消息。顶级处理程序从异常中提取消息，并将其合并到错误响应中。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00021.jpeg\" alt=\"\"></p>\n<p>Figure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter exceptions from all of the URL-specific methods.</p>\n<blockquote>\n<p>图 10.2：此代码在功能上等效于图 10.1，但是异常处理已聚合：分派器中的单个异常处理程序从所有特定于 URL 的方法中捕获所有 NoSuchParameter 异常。</p>\n</blockquote>\n<p>The aggregation described in the preceding paragraph has good properties from the standpoint of encapsulation and information hiding. The top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception. The getParameter method encapsulates knowledge about how to extract a parameter from a URL, and it also knows how to describe extraction errors in a human-readable form. These two pieces of information are closely related, so it makes sense for them to be in the same place. However, getParameter knows nothing about the syntax of an HTTP error response. As new functionality is added to the Web server, new methods like getParameter may be created with their own errors. If the new methods throw exceptions in the same way as getParameter (by generating exceptions that inherit from the same superclass and including an error message in each exception), they can plug into the existing system with no other changes: the top-level handler will automatically generate error responses for them.</p>\n<blockquote>\n<p>从封装和信息隐藏的角度来看，上一段中描述的聚合具有良好的属性。顶级异常处理程序封装了有关如何生成错误响应的知识，但对特定错误一无所知。它仅使用异常中提供的错误消息。getParameter 方法封装了有关如何从 URL 提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两个信息密切相关，因此将它们放在同一位置是很有意义的。但是，getParameter 对 HTTP 错误响应的语法一无所知。随着向 Web 服务器中添加了新功能，可能会创建具有类似自身错误的新方法，如 getParameter。</p>\n</blockquote>\n<p>This example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, it’s useful to define an exception that aborts the current request, cleans up the system’s state, and continues with the next request. The exception is caught in a single place near the top of the system’s request-handling loop. This exception can be thrown at any point in the processing of a request to abort the request; different subclasses of the exception can be defined for different conditions. Exceptions of this type should be clearly distinguished from exceptions that are fatal to the entire system.</p>\n<blockquote>\n<p>此示例说明了用于异常处理的通用设计模式。如果系统处理一系列请求，则定义一个异常以中止当前请求，清除系统状态并继续下一个请求非常有用。异常被捕获在系统请求处理循环顶部附近的单个位置。在处理中止请求的任何时候都可以抛出该异常。可以为不同的条件定义异常的不同子类。应该将这种类型的异常与对整个系统致命的异常区分开来。</p>\n</blockquote>\n<p>Exception aggregation works best if an exception propagates several levels up the stack before it is handled; this allows more exceptions from more methods to be handled in the same place. This is the opposite of exception masking: masking usually works best if an exception is handled in a low-level method. For masking, the low-level method is typically a library method used by many other methods, so allowing the exception to propagate would increase the number of places where it is handled. Masking and aggregation are similar in that both approaches position an exception handler where it can catch the most exceptions, eliminating many handlers that would otherwise need to be created.</p>\n<blockquote>\n<p>如果异常在处理之前在堆栈中传播了多个级别，则异常聚集最有效。这样可以在同一位置处理更多方法的更多异常。这与异常屏蔽相反：如果使用低级方法处理异常，则屏蔽通常效果最好。对于屏蔽，低级方法通常是许多其他方法使用的库方法，因此，允许传播异常会增加处理该异常的位置数。掩码和聚合的相似之处在于，这两种方法都将异常处理程序置于可以捕获最多异常的位置，从而消除了许多本来需要创建的处理程序。</p>\n</blockquote>\n<p>Another example of exception aggregation occurs in the RAMCloud storage system for crash recovery. A RAMCloud system consists of a collection of storage servers that keep multiple copies of each object, so the system can recover from a variety of failures. For example, if a server crashes and loses all of its data, RAMCloud reconstructs the lost data using copies stored on other servers. Errors can also happen on a smaller scale; for example, a server may discover that an individual object is corrupted.</p>\n<blockquote>\n<p>RAMCloud 存储系统中发生异常聚集的另一个示例是崩溃恢复。RAMCloud 系统由一组存储服务器组成，这些存储服务器保留每个对象的多个副本，因此系统可以从各种故障中恢复。例如，如果服务器崩溃并丢失其所有数据，RAMCloud 会使用存储在其他服务器上的副本来重建丢失的数据。错误也可能在较小的范围内发生。例如，服务器可能发现单个对象已损坏。</p>\n</blockquote>\n<p>RAMCloud does not have separate recovery mechanisms for each different kind of error. Instead, RAMCloud “promotes” many smaller errors into larger ones. RAMCloud could, in principle, handle a corrupted object by restoring that one object from a backup copy. However, it doesn’t do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloud uses this approach because crash recovery is quite complex and this approach minimized the number of different recovery mechanisms that had to be created. Creating a recovery mechanism for crashed servers was unavoidable, so RAMCloud uses the same mechanism for other kinds of recovery as well. This reduced the amount of code that had to be written, and it also meant that server crash recovery gets invoked more often. As a result, bugs in recovery are more likely to be discovered and fixed.</p>\n<blockquote>\n<p>对于每种不同类型的错误，RAMCloud 没有单独的恢复机制。相反，RAMCloud 将许多较小的错误“提升”为较大的错误。原则上，RAMCloud 可以通过从备份副本中恢复一个损坏的对象来处理这个损坏的对象。然而，它并不这样做。相反，如果它发现一个损坏的对象，它会使包含该对象的服务器崩溃。RAMCloud 使用这种方法是因为崩溃恢复非常复杂，而且这种方法最小化了必须创建的不同恢复机制的数量。为崩溃的服务器创建恢复机制是不可避免的，因此 RAMCloud 对其他类型的恢复也使用相同的机制。这减少了必须编写的代码量，而且这还意味着服务器崩溃恢复将更频繁地被调用。因此，恢复中的 bug 更有可能被发现和修复。</p>\n</blockquote>\n<p>One disadvantage of promoting a corrupted object into a server crash is that it increases the cost of recovery considerably. This is not a problem in RAMCloud, since object corruption is quite rare. However, error promotion may not make sense for errors that happen frequently. As one example, it would not be practical to crash a server anytime one of its network packets is lost.</p>\n<blockquote>\n<p>将损坏的对象升级为服务器崩溃的一个缺点是，它大大增加了恢复成本。这在 RAMCloud 中不是问题，因为对象损坏非常罕见。但是，错误升级对于经常发生的错误可能没有意义。举一个例子，在服务器的任何网络数据包丢失时使服务器崩溃是不切实际的。</p>\n</blockquote>\n<p>One way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations. This provides another illustration of the benefits of general-purpose mechanisms.</p>\n<blockquote>\n<p>考虑异常聚合的一种方法是，它用可以处理多种情况的单个通用机制替换了几种针对特定情况而量身定制的特殊用途的机制。这再次说明了通用机制的好处。</p>\n</blockquote>\n<h2 id=\"10-8-Just-crash-崩溃了吗？\"><a href=\"#10-8-Just-crash-崩溃了吗？\" class=\"headerlink\" title=\"10.8 Just crash? 崩溃了吗？\"></a>10.8 Just crash? 崩溃了吗？</h2><p>The fourth technique for reducing complexity related to exception handling is to crash the application. In most applications there will be certain errors that it’s not worth trying to handle. Typically, these errors are difficult or impossible to handle and don’t occur very often. The simplest thing to do in response to these errors is to print diagnostic information and then abort the application.</p>\n<blockquote>\n<p>减少与异常处理相关的复杂性的第四种技术是使应用程序崩溃。在大多数应用程序中，有些错误是不值得尝试的。通常，这些错误很难或不可能处理，而且很少发生。针对这些错误的最简单的操作是打印诊断信息，然后中止应用程序。</p>\n</blockquote>\n<p>One example is “out of memory” errors that occur during storage allocation. Consider the malloc function in C, which returns NULL if it cannot allocate the desired block of memory. This is an unfortunate behavior, because it assumes that every single caller of malloc will check the return value and take appropriate action if there is no memory. Applications contain numerous calls to malloc, so checking the result after each call would add significant complexity. If a programmer forgets the check (which is fairly likely), then the application will dereference a null pointer if memory runs out, resulting in a crash that camouflages the real problem.</p>\n<blockquote>\n<p>一个示例是在存储分配期间发生的“内存不足”错误。考虑一下 C 语言中的 malloc 函数，如果它无法分配所需的内存块，则该函数将返回 NULL。这是一个不幸的行为，因为它假定 malloc 的每个调用者都将检查返回值并在没有内存的情况下采取适当的措施。应用程序包含许多对 malloc 的调用，因此在每次调用后检查结果将增加相当大的复杂性。如果程序员忘记了检查（这很有可能），那么如果内存用完，应用程序将取消引用空指针，从而导致崩溃，从而掩盖了实际问题。</p>\n</blockquote>\n<p>Furthermore, there isn’t much an application can do when it discovers that memory is exhausted. In principle the application could look for unneeded memory to free, but if the application had unneeded memory it could already have freed it, which would have prevented the out-of-memory error in the first place. Today’s systems have so much memory that memory almost never runs out; if it does, it usually indicates a bug in the application. Thus, it rarely make sense to try to handle out-of-memory errors; this creates too much complexity for too little benefit.</p>\n<blockquote>\n<p>此外，当应用程序发现内存已用完时，它无能为力。原则上，应用程序可以寻找不需要的内存以释放它，但是如果应用程序有不需要的内存，它可以已经释放它，这首先可以防止内存不足错误。当今的系统具有如此大的内存，以至于内存几乎永远不会耗尽。如果是这样，通常表明应用程序中存在错误。因此，尝试处理内存不足错误几乎没有道理。这会带来太多的复杂性，而带来的收益却太少。</p>\n</blockquote>\n<p>A better approach is to define a new method ckalloc, which calls malloc, checks the result, and aborts the application with an error message if memory is exhausted. The application never invokes malloc directly; it always invokes ckalloc.</p>\n<blockquote>\n<p>更好的方法是定义一个新的 ckalloc 方法，该方法调用 malloc，检查结果，并在内存耗尽时通过错误消息中止应用程序。该应用程序从不直接调用 malloc。它总是调用 ckalloc。</p>\n</blockquote>\n<p>In newer languages such as C++ and Java, the new operator throws an exception if memory is exhausted. There’s not much point in catching this exception, since there’s a good chance that the exception handler will also try to allocate memory, which will also fail. Dynamically allocated memory is such a fundamental element of any modern application that it doesn’t make sense for the application to continue if memory is exhausted; it’s better to crash as soon as the error is detected.</p>\n<blockquote>\n<p>在较新的语言（例如 C ++和 Java）中，如果内存耗尽，则 new 运算符将引发异常。捕获此异常没有什么意义，因为异常处理程序很有可能还会尝试分配内存，这也会失败。动态分配的内存是任何现代应用程序中的基本元素，如果内存耗尽，则继续应用程序是没有意义的。最好在检测到错误后立即崩溃。</p>\n</blockquote>\n<p>There are many other examples of errors where crashing the application makes sense. For most programs, if an I/O error occurs while reading or writing an open file (such as a disk hard error), or if a network socket cannot be opened, there’s not much the application can do to recover, so aborting with a clear error message is a sensible approach. These errors are infrequent, so they are unlikely to affect the overall usability of the application. Aborting with an error message is also appropriate if an application encounters an internal error such as an inconsistent data structure. Conditions like this probably indicate bugs in the program.</p>\n<blockquote>\n<p>还有许多其他错误示例，这些错误会使应用程序崩溃很有意义。对于大多数程序，如果在读取或写入打开的文件时发生 I/O 错误（例如磁盘硬错误），或者无法打开网络套接字，则应用程序无济于事，因此中止了操作。清除错误消息是一种明智的方法。这些错误很少发生，因此它们不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误（如数据结构不一致），则错误消息中止也是合适的。这样的条件可能表明程序中存在错误。</p>\n</blockquote>\n<p>Whether or not it is acceptable to crash on a particular error depends on the application. For a replicated storage system, it isn’t appropriate to abort on an I/O error. Instead, the system must use replicated data to recover any information that was lost. The recovery mechanisms will add considerable complexity to the program, but recovering lost data is an essential part of the value the system provides to its users.</p>\n<blockquote>\n<p>在特定错误上崩溃是否可以接受取决于应用程序。对于复制的存储系统，不适合因 I/O 错误而中止。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将给程序增加相当大的复杂性，但是恢复丢失的数据是系统为用户提供的价值的重要组成部分。</p>\n</blockquote>\n<h2 id=\"10-9-Design-special-cases-out-of-existence-设计特殊情况不存在\"><a href=\"#10-9-Design-special-cases-out-of-existence-设计特殊情况不存在\" class=\"headerlink\" title=\"10.9 Design special cases out of existence 设计特殊情况不存在\"></a>10.9 Design special cases out of existence 设计特殊情况不存在</h2><p>For the same reason that it makes sense to define errors out of existence, it also makes sense to define other special cases out of existence. Special cases can result in code that is riddled with if statements, which make the code hard to understand and lead to bugs. Thus, special cases should be eliminated wherever possible. The best way to do this is by designing the normal case in a way that automatically handles the special cases without any extra code.</p>\n<blockquote>\n<p>出于同样的原因，定义不存在的错误是有意义的，而定义其他不存在的特殊情况也是有意义的。特殊情况可能导致代码中混入 if 语句，这使代码难以理解并导致错误。因此，应尽可能消除特殊情况。做到这一点的最佳方法是设计一种普通情况，这种方式可以自动处理特殊情况而无需任何额外的代码。</p>\n</blockquote>\n<p>In the text editor project described in Chapter 6, students had to implement a mechanism for selecting text and copying or deleting the selection. Most students introduced a state variable in their selection implementation to indicate whether or not the selection exists. They probably chose this approach because there are times when no selection is visible on the screen, so it seemed natural to represent this notion in the implementation. However, this approach resulted in numerous checks to detect the “no selection” condition and handle it specially.</p>\n<blockquote>\n<p>在第 6 章中描述的文本编辑器项目中，学生必须实现一种选择文本以及复制或删除所选内容的机制。大多数学生在他们的选择实现中引入了状态变量，以表明选择是否存在。他们之所以选择这种方法，是因为有时屏幕上看不到任何选择，因此在实现中似乎很自然地代表了这一概念。但是，这种方法导致大量检查以检测“无选择”条件并进行特殊处理。</p>\n</blockquote>\n<p>The selection handling code can be simplified by eliminating the “no selection” special case, so that the selection always exists. When there is no selection visible on the screen, it can be represented internally with an empty selection, whose starting and ending positions are the same. With this approach, the selection management code can be written without any checks for “no selection”. When copying the selection, if the selection is empty then 0 bytes will be inserted at the new location (if implemented correctly, there will be no need to check for 0 bytes as a special case). Similarly, it should be possible to design the code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection, extract the portion of the line preceding the selection and concatenate it with the portion of the line following the selection to form the new line. If the selection is empty, this approach will regenerate the original line.</p>\n<blockquote>\n<p>通过消除“不选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，可以编写选择管理代码，而无需对“不选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节（如果正确实现，则在特殊情况下无需检查 0 字节）。同样，应该有可能设计用于删除选择的代码，以便无需任何特殊情况检查就可以处理空情况。在一行上考虑所有选择。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。</p>\n</blockquote>\n<p>This example also illustrates the “different layer, different abstraction” idea from Chapter 7. The notion of “no selection” makes sense in terms of how the user thinks about the application’s interface, but that doesn’t mean it has to be represented explicitly inside the application. Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation.</p>\n<blockquote>\n<p>此示例还说明了第 7 章中的“不同的层，不同的抽象”概念。“无选择”的概念在用户对应用程序界面的看法方面很有意义，但这并不意味着必须明确表示它在应用程序内部。选择总是存在的，但有时是空的，因此是不可见的，这样可以简化实现。</p>\n</blockquote>\n<h2 id=\"10-10-Taking-it-too-far-走得太远\"><a href=\"#10-10-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"10.10 Taking it too far 走得太远\"></a>10.10 Taking it too far 走得太远</h2><p>Defining away exceptions, or masking them inside a module, only makes sense if the exception information isn’t needed outside the module. This was true for the examples in this chapter, such the Tcl unset command and the Java substring method; in the rare situations where a caller cares about the special cases detected by the exceptions, there are other ways for it to get this information.</p>\n<blockquote>\n<p>定义异常或将其屏蔽在模块内部，仅在模块外部不需要异常信息时才有意义。对于本章中的示例，例如 Tcl unset 命令和 Java 子字符串方法，都是如此。在极少数情况下，呼叫者关心异常检测到的特殊情况，还有其他方法可以获取此信息。</p>\n</blockquote>\n<p>However, it is possible to take this idea too far. In a module for network communication, a student team masked all network exceptions: if a network error occurred, the module caught it, discarded it, and continued as if there were no problem. This meant that applications using the module had no way to find out if messages were lost or a peer server failed; without this information, it was impossible to build robust applications. In this case, it is essential for the module to expose the exceptions, even though they add complexity to the module’s interface.</p>\n<blockquote>\n<p>但是，有可能使这个想法太过分。在用于网络通信的模块中，一个学生团队掩盖了所有网络异常：如果发生网络错误，则模块将其捕获，丢弃并继续进行，就好像没有问题一样。这意味着使用该模块的应用程序无法确定消息是否丢失或对等服务器是否发生故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，模块必须公开异常，即使它们增加了模块接口的复杂性。</p>\n</blockquote>\n<p>With exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when something is important, it must be exposed.</p>\n<blockquote>\n<p>与软件设计中的许多其他领域一样，您必须确定哪些是重要的，哪些是不重要的。不重要的事物应该被隐藏起来，它们越多越好。但是，当某件事很重要时，必须将其暴露出来。</p>\n</blockquote>\n<h2 id=\"10-11-Conclusion-结论\"><a href=\"#10-11-Conclusion-结论\" class=\"headerlink\" title=\"10.11 Conclusion 结论\"></a>10.11 Conclusion 结论</h2><p>Special cases of any form make code harder to understand and increase the likelihood of bugs. This chapter focused on exceptions, which are one of the most significant sources of special-case code, and discussed how to reduce the number of places where exceptions must be handled. The best way to do this is by redefining semantics to eliminate error conditions. For exceptions that can’t be defined away, you should look for opportunities to mask them at a low level, so their impact is limited, or aggregate several special-case handlers into a single more generic handler. Together, these techniques can have a significant impact on overall system complexity.</p>\n<blockquote>\n<p>任何形式的特殊情况都使代码更难以理解，并增加了发生错误的可能性。本章重点讨论异常，异常是特殊情况代码的最重要来源之一，并讨论了如何减少必须处理异常的地方的数量。做到这一点的最佳方法是重新定义语义以消除错误条件。对于无法定义的异常，您应该寻找机会将它们掩盖到较低的水平，以免影响有限，或者将多个特殊情况的处理程序聚合到一个更通用的处理程序中。总之，这些技术可能会对整体系统复杂性产生重大影响。</p>\n</blockquote>\n<p>1Ding Yuan et. al., “Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems,” 2014 USENIX Conference on Operating System Design and Implementation.</p>\n<blockquote>\n<p>1 丁元等 等人，“简单的测试可以防止最关键的故障：对分布式数据密集型系统中的生产故障的分析”，2014 USENIX 操作系统设计和实施大会。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>定义不存在的错误</p>","more":"<h1 id=\"第-10-章-定义不存在的错误\"><a href=\"#第-10-章-定义不存在的错误\" class=\"headerlink\" title=\"第 10 章 定义不存在的错误\"></a>第 10 章 定义不存在的错误</h1><blockquote>\n<p>Chapter 10 Define Errors Out Of Existence</p>\n</blockquote>\n<p>Exception handling is one of the worst sources of complexity in software systems. Code that deals with special conditions is inherently harder to write than code that deals with normal cases, and developers often define exceptions without considering how they will be handled. This chapter discusses why exceptions contribute disproportionately to complexity, then it shows how to simplify exception handling. The key overall lesson from this chapter is to reduce the number of places where exceptions must be handled; in many cases the semantics of operations can be modified so that the normal behavior handles all situations and there is no exceptional condition to report (hence the title of this chapter).</p>\n<blockquote>\n<p>异常处理是软件系统中最糟糕的复杂性来源之一。处理特殊情况的代码在本质上比处理正常情况的代码更难编写，并且开发人员经常在定义异常时不考虑异常的处理方式。本章讨论了为什么异常对复杂性的贡献不成比例，然后说明了如何简化异常处理。本章总的主要教训是减少必须处理异常的地方的数量。在许多情况下，可以修改操作的语义，以便正常行为可以处理所有情况，并且没有要报告的特殊条件（因此，本章标题）。</p>\n</blockquote>\n<h2 id=\"10-1-Why-exceptions-add-complexity-为什么异常会增加复杂性\"><a href=\"#10-1-Why-exceptions-add-complexity-为什么异常会增加复杂性\" class=\"headerlink\" title=\"10.1 Why exceptions add complexity 为什么异常会增加复杂性\"></a>10.1 Why exceptions add complexity 为什么异常会增加复杂性</h2><p>I use the term exception to refer to any uncommon condition that alters the normal flow of control in a program. Many programming languages include a formal exception mechanism that allows exceptions to be thrown by lower-level code and caught by enclosing code. However, exceptions can occur even without using a formal exception reporting mechanism, such as when a method returns a special value indicating that it didn’t complete its normal behavior. All of these forms of exceptions contribute to complexity.</p>\n<blockquote>\n<p>我使用“异常”一词来指代任何会改变程序中正常控制流程的不常见条件。许多编程语言都包含一种正式的异常机制，该机制允许异常由低级代码引发并由封闭代码捕获。但是，即使不使用正式的异常报告机制，异常也可能发生，例如，当某个方法返回一个特殊值指示其未完成其正常行为时。所有这些形式的异常都会增加复杂性。</p>\n</blockquote>\n<p>A particular piece of code may encounter exceptions in several different ways:</p>\n<blockquote>\n<p>一段特定的代码可能会以几种不同的方式遇到异常：</p>\n</blockquote>\n<ul>\n<li>A caller may provide bad arguments or configuration information.</li>\n<li>An invoked method may not be able to complete a requested operation. For example, an I/O operation may fail, or a required resource may not be available.</li>\n<li>In a distributed system, network packets may be lost or delayed, servers may not respond in a timely fashion, or peers may communicate in unexpected ways.</li>\n<li>The code may detect bugs, internal inconsistencies, or situations it is not prepared to handle.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>调用方可能会提供错误的参数或配置信息。</li>\n<li>调用的方法可能无法完成请求的操作。例如，I/O 操作可能失败，或者所需的资源可能不可用。</li>\n<li>在分布式系统中，网络数据包可能会丢失或延迟，服务器可能无法及时响应，或者对等方可能会以意想不到的方式进行通信。</li>\n<li>该代码可能会检测到错误，内部不一致或未准备处理的情况。</li>\n</ul>\n</blockquote>\n<p>Large systems have to deal with many exceptional conditions, particularly if they are distributed or need to be fault-tolerant. Exception handling can account for a significant fraction of all the code in a system.</p>\n<blockquote>\n<p>大型系统必须应对许多特殊情况，特别是在它们是分布式的或需要容错的情况下。异常处理可以占系统中所有代码的很大一部分。</p>\n</blockquote>\n<p>Exception handling code is inherently more difficult to write than normal-case code. An exception disrupts the normal flow of the code; it usually means that something didn’t work as expected. When an exception occurs, the programmer can deal with it in two ways, each of which can be complicated. The first approach is to move forward and complete the work in progress in spite of the exception. For example, if a network packet is lost, it can be resent; if data is corrupted, perhaps it can be recovered from a redundant copy. The second approach is to abort the operation in progress and report the exception upwards. However, aborting can be complicated because the exception may have occurred at a point where system state is inconsistent (a data structure might have been partially initialized); the exception handling code must restore consistency, such as by unwinding any changes made before the exception occurred.</p>\n<blockquote>\n<p>异常处理代码天生就比正常情况下的代码更难写。异常中断了正常的代码流;它通常意味着某事没有像预期的那样工作。当异常发生时，程序员可以用两种方法处理它，每种方法都很复杂。第一种方法是向前推进并完成正在进行的工作，尽管存在例外。例如，如果一个网络数据包丢失，它可以被重发;如果数据损坏了，也许可以从冗余副本中恢复数据。第二种方法是中止正在进行的操作，向上报告异常。但是，中止可能很复杂，因为异常可能发生在系统状态不一致的地方(数据结构可能已经部分初始化);异常处理代码必须恢复一致性，例如通过撤销发生异常之前所做的任何更改。</p>\n</blockquote>\n<p>Furthermore, exception handling code creates opportunities for more exceptions. Consider the case of resending a lost network packet. Perhaps the packet wasn’t actually lost, but was simply delayed. In this case, resending the packet will result in duplicate packets arriving at the peer; this introduces a new exceptional condition that the peer must handle. Or, consider the case of recovering lost data from a redundant copy: what if the redundant copy has also been lost? Secondary exceptions occurring during recovery are often more subtle and complex than the primary exceptions. If an exception is handled by aborting the operation in progress, then this must be reported to the caller as another exception. To prevent an unending cascade of exceptions, the developer must eventually find a way to handle exceptions without introducing more exceptions.</p>\n<blockquote>\n<p>此外，异常处理代码为更多异常创造了机会。考虑重新发送丢失的网络数据包的情况。也许该数据包实际上并没有丢失，但是只是被延迟了。在这种情况下，重新发送数据包将导致重复的数据包到达对等方；这引入了对等方必须处理的新的例外条件。或者，考虑从冗余副本恢复丢失的数据的情况：如果冗余副本也丢失了怎么办？在恢复期间发生的次要异常通常比主要异常更加微妙和复杂。如果通过中止正在进行的操作来处理异常，则必须将此异常作为另一个异常报告给调用方。为了防止无休止的异常级联，开发人员最终必须找到一种在不引入更多异常的情况下处理异常的方法。</p>\n</blockquote>\n<p>Language support for exceptions tends to be verbose and clunky, which makes exception handling code hard to read. For example, consider the following code, which reads a collection of tweets from a file using Java’s support for object serialization and deserialization:</p>\n<blockquote>\n<p>语言对异常的支持往往是冗长而笨拙的，这使得异常处理代码难以阅读。例如，考虑以下代码，该代码使用 Java 对对象序列化和反序列化的支持从文件中读取 tweet 的集合：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span> (</span><br><span class=\"line\">    FileInputStream fileStream = <span class=\"keyword\">new</span> FileInputStream(fileName);</span><br><span class=\"line\">    BufferedInputStream bufferedStream = <span class=\"keyword\">new</span> BufferedInputStream(fileStream);</span><br><span class=\"line\">    ObjectInputStream objectStream = <span class=\"keyword\">new</span> ObjectInputStream(bufferedStream);</span><br><span class=\"line\">) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; tweetsPerFile; i++) &#123;</span><br><span class=\"line\">        tweets.add((Tweet) objectStream.readObject());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (FileNotFoundException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (ClassNotFoundException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (EOFException e) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Not a problem: not all tweet files have full</span></span><br><span class=\"line\">    <span class=\"comment\">// set of tweets.</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (IOException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">catch</span> (ClassCastException e) &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>Just the basic try-catch boilerplate accounts for more lines of code than the code for normal-case operation, without even considering the code that actually handles the exceptions. It is hard to relate the exception handling code to the normal-case code: for example, it’s not obvious where each exception is generated. An alternative approach is to break up the code into many distinct try blocks; in the extreme case there could be a try for each line of code that can generate an exception. This would make it clear where exceptions occur, but the try blocks themselves break up the flow of the code and make it harder to read; in addition, some exception handling code might end up duplicated in multiple try blocks.</p>\n<blockquote>\n<p>只是基本的 try-catch 样板代码比正常情况下的操作代码所占的代码行更多，甚至没有考虑实际处理异常的代码。很难将异常处理代码与普通情况代码相关联：例如，每个异常的生成位置都不明显。另一种方法是将代码分解为许多不同的 try 块。在极端情况下，可能会尝试尝试每行可能产生异常的代码。这样可以清楚地说明异常发生的位置，但是 try 块本身会破坏代码流，并使代码难以阅读。此外，某些异常处理代码可能最终会在多个 try 块中重复。</p>\n</blockquote>\n<p>It’s difficult to ensure that exception handling code really works. Some exceptions, such as I/O errors, can’t easily be generated in a test environment, so it’s hard to test the code that handles them. Exceptions don’t occur very often in running systems, so exception handling code rarely executes. Bugs can go undetected for a long time, and when the exception handling code is finally needed, there’s a good chance that it won’t work (one of my favorite sayings: “code that hasn’t been executed doesn’t work”). A recent study found that more than 90% of catastrophic failures in distributed data-intensive systems were caused by incorrect error handling1. When exception handling code fails, it’s difficult to debug the problem, since it occurs so infrequently.</p>\n<blockquote>\n<p>确保异常处理代码真正起作用是困难的。某些异常（例如 I/O 错误）在测试环境中不易生成，因此很难测试处理它们的代码。异常在运行的系统中很少发生，因此异常处理代码很少执行。错误可能会长时间未被发现，并且当最终需要异常处理代码时，它很有可能无法正常工作（我最喜欢的一句话是：“未执行的代码无效”） 。最近的一项研究发现，分布式数据密集型系统中超过 90％的灾难性故障是由错误的错误处理引起的 1。当异常处理代码失败时，很难调试该问题，因为它很少发生。</p>\n</blockquote>\n<h2 id=\"10-2-Too-many-exceptions-异常过多\"><a href=\"#10-2-Too-many-exceptions-异常过多\" class=\"headerlink\" title=\"10.2 Too many exceptions 异常过多\"></a>10.2 Too many exceptions 异常过多</h2><p>Programmers exacerbate the problems related to exception handling by defining unnecessary exceptions. Most programmers are taught that it’s important to detect and report errors; they often interpret this to mean “the more errors detected, the better.” This leads to an over-defensive style where anything that looks even a bit suspicious is rejected with an exception, which results in a proliferation of unnecessary exceptions that increase the complexity of the system.</p>\n<blockquote>\n<p>程序员通过定义不必要的异常加剧了与异常处理有关的问题。告诉大多数程序员，检测和报告错误很重要。他们通常将其解释为“检测到的错误越多越好”。这导致了一种过分防御的风格，其中任何看起来甚至有点可疑的东西都被拒绝，并带有异常，这导致了不必要的异常的泛滥，从而增加了系统的复杂性。</p>\n</blockquote>\n<p>I made this mistake myself in the design of the Tcl scripting language. Tcl contains an unset command that can be used to remove a variable. I defined unset so that it throws an error if the variable doesn’t exist. At the time I thought that it must be a bug if someone tries to delete a variable that doesn’t exist, so Tcl should report it. However, one of the most common uses of unset is to clean up temporary state created by some previous operation. It’s often hard to predict exactly what state was created, particularly if the operation aborted partway through. Thus, the simplest thing is to delete all of the variables that might possibly have been created. The definition of unset makes this awkward: developers end up enclosing calls to unset in catch statements to catch and ignore errors thrown by unset. In retrospect, the definition of the unset command is one of the biggest mistakes I made in the design of Tcl.</p>\n<blockquote>\n<p>在设计 Tcl 脚本语言时，我自己就犯了这个错误。Tcl 包含一个未设置的命令，可用于删除变量。我定义了 unset 以便在变量不存在时抛出错误。当时我认为，如果有人试图删除一个不存在的变量，那么它一定是一个 bug，所以 Tcl 应该报告它。然而，unset 最常见的用途之一是清理以前操作创建的临时状态。通常很难准确地预测创建了什么状态，特别是在操作中途中止的情况下。因此，最简单的方法是删除可能已经创建的所有变量。unset 的定义使得这种情况很尴尬:开发人员最终会在 catch 语句中封装对 unset 的调用，以捕获并忽略 unset 抛出的错误。回顾过去，unset 命令的定义是我在 Tcl 设计中犯下的最大错误之一。</p>\n</blockquote>\n<p>It’s tempting to use exceptions to avoid dealing with difficult situations: rather than figuring out a clean way to handle it, just throw an exception and punt the problem to the caller. Some might argue that this approach empowers callers, since it allows each caller to handle the exception in a different way. However, if you are having trouble figuring out what to do for the particular situation, there’s a good chance that the caller won’t know what to do either. Generating an exception in a situation like this just passes the problem to someone else and adds to the system’s complexity.</p>\n<blockquote>\n<p>试图使用异常来避免处理困难的情况很诱人：与其想出一种干净的方法来处理它，不如抛出一个异常并将问题平移给调用者。有人可能会争辩说，这种方法可以赋予调用者权力，因为它允许每个调用者以不同的方式处理异常。但是，如果您在确定特定情况下该怎么做时遇到困难，则呼叫者很可能都不知道该怎么办。在这种情况下生成异常只会将问题传递给其他人，并增加系统的复杂性。</p>\n</blockquote>\n<p>The exceptions thrown by a class are part of its interface; classes with lots of exceptions have complex interfaces, and they are shallower than classes with fewer exceptions. An exception is a particularly complex element of an interface. It can propagate up through several stack levels before being caught, so it affects not just the method’s caller, but potentially also higher-level callers (and their interfaces).</p>\n<blockquote>\n<p>类抛出的异常是其接口的一部分；具有大量异常的类具有复杂的接口，并且比具有较少异常的类浅。异常是接口中特别复杂的元素。它可以在被捕获之前通过多个堆栈级别向上传播，因此它不仅影响方法的调用者，而且还可能影响更高级别的调用者（及其接口）。</p>\n</blockquote>\n<p>Throwing exceptions is easy; handling them is hard. Thus, the complexity of exceptions comes from the exception handling code. The best way to reduce the complexity damage caused by exception handling is to reduce the number of places where exceptions have to be handled. The rest of this chapter will discuss four techniques for reducing the number of exception handlers.</p>\n<blockquote>\n<p>抛出异常很容易；处理它们很困难。因此，异常的复杂性来自异常处理代码。减少由异常处理引起的复杂性破坏的最佳方法是减少必须处理异常的位置的数量。本章的其余部分将讨论减少异常处理程序数量的四种技术。</p>\n</blockquote>\n<h2 id=\"10-3-Define-errors-out-of-existence-定义错误不存在\"><a href=\"#10-3-Define-errors-out-of-existence-定义错误不存在\" class=\"headerlink\" title=\"10.3 Define errors out of existence 定义错误不存在\"></a>10.3 Define errors out of existence 定义错误不存在</h2><p>The best way to eliminate exception handling complexity is to define your APIs so that there are no exceptions to handle: define errors out of existence. This may seem sacrilegious, but it is very effective in practice. Consider the Tcl unset command discussed above. Rather than throwing an error when unset is asked to delete an unknown variable, it should have simply returned without doing anything. I should have changed the definition of unset slightly: rather than deleting a variable, unset should ensure that a variable no longer exists. With the first definition, unset can’t do its job if the variable doesn’t exist, so generating an exception makes sense. With the second definition, it is perfectly natural for unset to be invoked with the name of a variable that doesn’t exist. In this case, its work is already done, so it can simply return. There is no longer an error case to report.</p>\n<blockquote>\n<p>消除异常处理复杂性的最好方法是定义您的 API，以便没有异常要处理：定义错误而已。这似乎是牺牲品，但在实践中非常有效。考虑上面讨论的 Tcl unset 命令。而不是在要求 unset 删除未知变量时引发错误，它应该只是返回而无需执行任何操作。我应该稍微修改一下 unset 的定义：与其删除一个变量，不应该删除 unset 来确保一个变量不再存在。根据第一个定义，如果变量不存在，则 unset 不能执行其工作，因此生成异常是有意义的。使用第二个定义，使用不存在的变量名调用 unset 是很自然的。在这种情况下，它的工作已经完成，因此可以简单地返回。</p>\n</blockquote>\n<h2 id=\"10-4-Example-file-deletion-in-Windows-示例：Windows-中的文件删除\"><a href=\"#10-4-Example-file-deletion-in-Windows-示例：Windows-中的文件删除\" class=\"headerlink\" title=\"10.4 Example: file deletion in Windows 示例：Windows 中的文件删除\"></a>10.4 Example: file deletion in Windows 示例：Windows 中的文件删除</h2><p>File deletion provides another example of how errors can be defined away. The Windows operating system does not permit a file to be deleted if it is open in a process. This is a continual source of frustration for developers and users. In order to delete a file that is in use, the user must search through the system to find the process that has the file open, and then kill that process. Sometimes users give up and reboot their system, just so they can delete a file.</p>\n<blockquote>\n<p>文件删除提供了如何定义错误的另一个示例。Windows 操作系统不允许删除文件（如果已在进程中打开文件）。对于开发人员和用户来说，这是不断沮丧的根源。为了删除正在使用的文件，用户必须在系统中搜索以找到已打开文件的进程，然后终止该进程。有时用户放弃并重新启动系统，只是为了删除文件。</p>\n</blockquote>\n<p>The Unix operating system defines file deletion more elegantly. In Unix, if a file is open when it is deleted, Unix does not delete the file immediately. Instead, it marks the file for deletion, then the delete operation returns successfully. The file name has been removed from its directory, so no other processes can open the old file and a new file with the same name can be created, but the existing file data persists. Processes that already have the file open can continue to read it and write it normally. Once the file has been closed by all of the accessing processes, its data is freed.</p>\n<blockquote>\n<p>Unix 操作系统更优雅地定义了文件删除。在 Unix 中，如果在删除文件时打开了文件，则 Unix 不会立即删除该文件。而是将文件标记为删除，然后删除操作成功返回。该文件名已从其目录中删除，因此其他进程无法打开该旧文件，并且可以创建具有相同名称的新文件，但现有文件数据将保留。已经打开文件的进程可以继续读取和正常写入文件。一旦所有访问进程都关闭了文件，便释放其数据。</p>\n</blockquote>\n<p>The Unix approach defines away two different kinds of errors. First, the delete operation no longer returns an error if the file is currently in use; the delete succeeds, and the file will eventually be deleted. Second, deleting a file that’s in use does not create exceptions for the processes using the file. One possible approach to this problem would have been to delete the file immediately and mark all of the opens of the file to disable them; any attempts by other processes to read or write the deleted file would fail. However, this approach would create new errors for those processes to handle. Instead, Unix allows them to keep accessing the file normally; delaying the file deletion defines errors out of existence.</p>\n<blockquote>\n<p>Unix 方法定义了两种不同的错误。首先，如果文件当前正在使用中，则删除操作不再返回错误；删除成功，该文件最终将被删除。其次，删除正在使用的文件不会为使用该文件的进程创建例外。解决此问题的一种可能方法是立即删除文件并标记文件的所有打开以禁用它们。其他进程读取或写入已删除文件的任何尝试均将失败。但是，此方法将为那些要处理的过程创建新的错误。相反，Unix 允许他们继续正常访问文件。延迟文件删除将定义错误不存在。</p>\n</blockquote>\n<p>It may seem strange that Unix allows a process to continue to read and write a doomed file, but I have never encountered a situation where this caused significant problems. The Unix definition of file deletion is much simpler to work with, both for developers and users, than the Windows definition.</p>\n<blockquote>\n<p>Unix 允许进程继续读取和写入已损坏的文件可能看起来很奇怪，但是我从未遇到过引起严重问题的情况。对于开发人员和用户，Unix 删除文件的定义比 Windows 定义要容易得多。</p>\n</blockquote>\n<h2 id=\"10-5-Example-Java-substring-method-示例：Java-子字符串方法\"><a href=\"#10-5-Example-Java-substring-method-示例：Java-子字符串方法\" class=\"headerlink\" title=\"10.5 Example: Java substring method 示例：Java 子字符串方法\"></a>10.5 Example: Java substring method 示例：Java 子字符串方法</h2><p>As a final example, consider the Java String class and its substring method. Given two indexes into a string, substring returns the substring starting at the character given by the first index and ending with the character just before the second index. However, if either index is outside the range of the string, then substring throws IndexOutOfBoundsException. This exception is unnecessary and complicates the use of this method. I often find myself in a situation where one or both of the indices may be outside the range of the string, and I would like to extract all of the characters in the string that overlap the specified range. Unfortunately, this requires me to check each of the indices and round them up to zero or down to the end of the string; a one-line method call now becomes 5–10 lines of code.</p>\n<blockquote>\n<p>作为最后一个示例，请考虑 Java String 类及其子字符串方法。给定一个字符串中的两个索引，substring 返回该子字符串，该字符串从第一个索引给定的字符开始，以第二个索引之前的字符结束。但是，如果两个索引中的任何一个都超出字符串的范围，则子字符串将引发 IndexOutOfBoundsException。此异常是不必要的，并且会使此方法的使用复杂化。我经常发现自己处于一个或两个索引可能不在字符串范围内的情况，并且我想提取字符串中与指定范围重叠的所有字符。不幸的是，这要求我检查每个索引并将它们向上舍入为零或向下舍入到字符串的末尾。现在，单行方法调用变成 5-10 行代码。</p>\n</blockquote>\n<p>The Java substring method would be easier to use if it performed this adjustment automatically, so that it implemented the following API: “returns the characters of the string (if any) with index greater than or equal to beginIndex and less than endIndex.” This is a simple and natural API, and it defines the IndexOutOfBoundsException exception out of existence. The method’s behavior is now well-defined even if one or both of the indexes are negative, or if beginIndex is greater than endIndex. This approach simplifies the API for the method while increasing its functionality, so it makes the method deeper. Many other languages have taken the error-free approach; for example, Python returns an empty result for out-of-range list slices.</p>\n<blockquote>\n<p>如果 Java 子字符串方法自动执行此调整，则将更易于使用，因此它实现了以下 API：“返回索引大于或等于 beginIndex 且小于 endIndex 的字符串的字符（如果有）。” 这是一个简单自然的 API，它定义了 IndexOutOfBoundsException 异常。现在，即使一个或两个索引均为负，或者 beginIndex 大于 endIndex，该方法的行为也已明确定义。这种方法简化了方法的 API，同时增加了其功能，因此使方法更深。许多其他语言都采用了无错误的方法。例如，Python 对于超出范围的列表切片返回空结果。</p>\n</blockquote>\n<p>When I argue for defining errors out of existence, people sometimes counter that throwing errors will catch bugs; if errors are defined out of existence, won’t that result in buggier software? Perhaps this is why the Java developers decided that substring should throw exceptions. The error-ful approach may catch some bugs, but it also increases complexity, which results in other bugs. In the error-ful approach, developers must write additional code to avoid or ignore the errors, and this increases the likelihood of bugs; or, they may forget to write the additional code, in which case unexpected errors may be thrown at runtime. In contrast, defining errors out of existence simplifies APIs and it reduces the amount of code that must be written.</p>\n<blockquote>\n<p>当我主张定义错误而不再存在时，人们有时会反驳说抛出错误会捕获错误。如果错误定义不存在，那会不会导致 Buggier 软件出现？也许这就是 Java 开发人员决定子字符串应引发异常的原因。错误的方法可能会捕获一些错误，但也会增加复杂性，从而导致其他错误。在错误有效的方法中，开发人员必须编写额外的代码来避免或忽略错误，这增加了发生错误的可能性。或者，他们可能会忘记编写其他代码，在这种情况下，运行时可能会引发意外错误。相反，定义错误而不存在将简化 API，并减少必须编写的代码量。</p>\n</blockquote>\n<p>Overall, the best way to reduce bugs is to make software simpler.</p>\n<blockquote>\n<p>总体而言，减少错误的最好方法是简化软件。</p>\n</blockquote>\n<h2 id=\"10-6-Mask-exceptions-掩码异常\"><a href=\"#10-6-Mask-exceptions-掩码异常\" class=\"headerlink\" title=\"10.6 Mask exceptions 掩码异常\"></a>10.6 Mask exceptions 掩码异常</h2><p>The second technique for reducing the number of places where exceptions must be handled is exception masking. With this approach, an exceptional condition is detected and handled at a low level in the system, so that higher levels of software need not be aware of the condition. Exception masking is particularly common in distributed systems. For instance, in a network transport protocol such as TCP, packets can be dropped for various reasons such as corruption and congestion. TCP masks packet loss by resending lost packets within its implementation, so all data eventually gets through and clients are unaware of the dropped packets.</p>\n<blockquote>\n<p>减少必须处理异常的地方数量的第二种技术是异常屏蔽。使用这种方法，可以在系统的较低级别上检测和处理异常情况，因此，更高级别的软件无需知道该情况。异常屏蔽在分布式系统中尤其常见。例如，在诸如 TCP 的网络传输协议中，由于各种原因（例如损坏和拥塞），可能会丢弃数据包。TCP 通过在其实现中重新发送丢失的数据包来掩盖数据包的丢失，因此所有数据最终都将通过，并且客户端不知道丢失的数据包。</p>\n</blockquote>\n<p>A more controversial example of masking occurs in the NFS network file system. If an NFS file server crashes or fails to respond for any reason, clients reissue their requests to the server over and over again until the problem is eventually resolved. The low-level file system code on the client does not report any exceptions to the invoking application. The operation in progress (and hence the application) just hangs until the operation can complete successfully. If the hang lasts more than a short time, the NFS client prints messages on the user’s console of the form “NFS server xyzzy not responding still trying.”</p>\n<blockquote>\n<p>NFS 网络文件系统中出现了一个更具争议性的屏蔽示例。如果 NFS 文件服务器由于任何原因崩溃或无法响应，客户端将一遍又一遍地向服务器发出请求，直到问题最终得到解决。客户端上的低级文件系统代码不会向调用应用程序报告任何异常。正在进行的操作（以及因此的应用程序）只是挂起，直到操作可以成功完成。如果挂起持续的时间不超过一小段时间，则 NFS 客户端将在用户控制台上以“ NFS 服务器 xyzzy 无法响应仍在尝试响应”的形式打印消息。</p>\n</blockquote>\n<p>NFS users often complain about the fact that their applications hang while waiting for an NFS server to resume normal operation. Many people have suggested that NFS should abort operations with an exception rather than hanging. However, reporting exceptions would make things worse, not better. There’s not much an application can do if it loses access to its files. One possibility would be for the application to retry the file operation, but this would still hang the application, and it’s easier to perform the retry in one place in the NFS layer, rather than at every file system call in every application (a compiler shouldn’t have to worry about this!). The other alternative is for applications to abort and return errors to their callers. It’s unlikely that the callers would know what to do either, so they would abort as well, resulting in a collapse of the user’s working environment. Users still wouldn’t be able to get any work done while the file server was down, and they would have to restart all of their applications once the file server came back to life.</p>\n<blockquote>\n<p>NFS 用户经常抱怨这样的事实，即他们的应用程序在等待 NFS 服务器恢复正常运行时挂起。许多人建议 NFS 应该异常终止操作而不是挂起。但是，报告异常会使情况更糟，而不是更好。如果应用程序无法访问其文件，则无能为力。一种可能性是应用程序重试文件操作，但这仍然会使应用程序挂起，并且在 NFS 层中的一个位置执行重试会比在每个应用程序中的每个文件系统调用处执行重试更容易（编译器应不必为此担心！）。另一种选择是让应用程序中止并将错误返回给调用者。呼叫者不太可能知道该怎么做，因此他们也将中止，导致用户工作环境崩溃。用户在文件服务器关闭时仍然无法完成任何工作，并且一旦文件服务器恢复工作，他们将不得不重新启动所有应用程序。</p>\n</blockquote>\n<p>Thus, the best alternative is for NFS to mask the errors and hang applications. With this approach, applications don’t need any code to deal with server problems, and they can resume seamlessly once the server comes back to life. If users get tired of waiting, they can always abort applications manually.</p>\n<blockquote>\n<p>因此，最好的替代方法是让 NFS 掩盖错误并挂起应用程序。通过这种方法，应用程序不需要任何代码来处理服务器问题，并且一旦服务器恢复运行，它们就可以无缝恢复。如果用户厌倦了等待，他们总是可以手动中止应用程序。</p>\n</blockquote>\n<p>Exception masking doesn’t work in all situations, but it is a powerful tool in the situations where it works. It results in deeper classes, since it reduces the class’s interface (fewer exceptions for users to be aware of) and adds functionality in the form of the code that masks the exception. Exception masking is an example of pulling complexity downward.</p>\n<blockquote>\n<p>异常屏蔽并非在所有情况下都有效，但是在它起作用的情况下它是一个强大的工具。它导致了更深的类，因为它减少了类的界面（用户需要注意的异常更少）并以掩盖异常的代码形式添加了功能。异常屏蔽是降低复杂性的一个例子。</p>\n</blockquote>\n<h2 id=\"10-7-Exception-aggregation-异常聚集\"><a href=\"#10-7-Exception-aggregation-异常聚集\" class=\"headerlink\" title=\"10.7 Exception aggregation 异常聚集\"></a>10.7 Exception aggregation 异常聚集</h2><p>The third technique for reducing complexity related to exceptions is exception aggregation. The idea behind exception aggregation is to handle many exceptions with a single piece of code; rather than writing distinct handlers for many individual exceptions, handle them all in one place with a single handler.</p>\n<blockquote>\n<p>减少与异常相关的复杂性的第三种技术是异常聚合。异常聚合的思想是用一个代码段处理许多异常。与其为多个单独的异常编写不同的处理程序，不如用一个处理程序将它们全部处理在一个地方。</p>\n</blockquote>\n<p>Consider how to handle missing parameters in a Web server. A Web server implements a collection of URLs. When the server receives an incoming URL, it dispatches to a URL-specific service method to process that URL and generate a response. The URL contains various parameters that are used to generate the response. Each service method will call a lower-level method (let’s call it getParameter) to extract the parameters that it needs from the URL. If the URL does not contain the desired parameter, getParameter throws an exception.</p>\n<blockquote>\n<p>考虑如何处理 Web 服务器中缺少的参数。Web 服务器实现 URL 的集合。服务器收到传入的 URL 时，将分派到特定于 URL 的服务方法来处理该 URL 并生成响应。该 URL 包含用于生成响应的各种参数。每个服务方法都将调用一个较低层的方法（将其称为 getParameter）以从 URL 中提取所需的参数。如果 URL 不包含所需的参数，则 getParameter 会引发异常。</p>\n</blockquote>\n<p>When students in a software design class implemented such a server, many of them wrapped each distinct call to getParameter in a separate exception handler to catch NoSuchParameter exceptions, as in Figure 10.1. This resulted in a large number of handlers, all of which did essentially the same thing (generate an error response).</p>\n<blockquote>\n<p>当参加软件设计课程的学生实现这样的服务器时，他们中的许多人将对 getParameter 的每个不同调用包装在单独的异常处理程序中以捕获 NoSuchParameter 异常，如图 10.1 所示。这导致大量的处理程序，所有这些处理程序基本上都执行相同的操作（生成错误响应）。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00020.jpeg\" alt=\"\"></p>\n<p>Figure 10.1: The code at the top dispatches to one of several methods in a Web server, each of which handles a particular URL. Each of those methods (bottom) uses parameters from the incoming HTTP request. In this figure, there is a separate exception handler for each call to getParameter; this results in duplicated code.</p>\n<blockquote>\n<p>图 10.1：顶部的代码将分派给 Web 服务器中的几种方法之一，每种方法都处理一个特定的 URL。每个方法（底部）都使用传入 HTTP 请求中的参数。在此图中，每个对 getParameter 的调用都有一个单独的异常处理程序。这导致重复的代码。</p>\n</blockquote>\n<p>A better approach is to aggregate the exceptions. Instead of catching the exceptions in the individual service methods, let them propagate up to the top-level dispatch method for the Web server, as in Figure 10.2. A single handler in this method can catch all of the exceptions and generate an appropriate error response for missing parameters.</p>\n<blockquote>\n<p>更好的方法是汇总异常。让它们传播到 Web 服务器的顶级调度方法，而不是在单个服务方法中捕获异常，如图 10.2 所示。此方法中的单个处理程序可以捕获所有异常，并为丢失的参数生成适当的错误响应。</p>\n</blockquote>\n<p>The aggregation approach can be taken even further in the Web example. There are many other errors besides missing parameters that can occur while processing a Web page; for example, a parameter might not have the right syntax (the service method expected an integer, but the value was “xyz”), or the user might not have permission for the requested operation. In each case, the error should result in an error response; the errors differ only in the error message to include in the response (“parameter ‘quantity’ not present in URL” or “bad value ‘xyz’ for ‘quantity’ parameter; must be positive integer”). Thus, all conditions resulting in an error response can be handled with a single top-level exception handler. The error message can be generated at the time the exception is thrown and included as a variable in the exception record; for example, getParameter will generate the “parameter ‘quantity’ not present in URL” message. The top-level handler extracts the message from the exception and incorporates it into the error response.</p>\n<blockquote>\n<p>在 Web 示例中甚至可以采用聚合方法。处理网页时，除了缺少参数外，还有许多其他错误；例如，参数可能没有正确的语法（服务方法应为整数，但值为“ xyz”），或者用户可能无权执行所请求的操作。在每种情况下，错误都应导致错误响应。错误仅在响应中包含的错误消息中有所不同（“ URL 中不存在参数’数量’”或“’数量’参数的错误值’xyz’；必须为正整数”）。因此，所有导致错误响应的条件都可以使用单个顶级异常处理程序进行处理。错误消息可以在引发异常时生成，并作为变量包含在异常记录中。例如，getParameter 将生成“ URL 中不存在的参数’数量’”消息。顶级处理程序从异常中提取消息，并将其合并到错误响应中。</p>\n</blockquote>\n<p><img src=\"../../img/figures/00021.jpeg\" alt=\"\"></p>\n<p>Figure 10.2: This code is functionally equivalent to Figure 10.1, but exception handling has been aggregated: a single exception handler in the dispatcher catches all of the NoSuchParameter exceptions from all of the URL-specific methods.</p>\n<blockquote>\n<p>图 10.2：此代码在功能上等效于图 10.1，但是异常处理已聚合：分派器中的单个异常处理程序从所有特定于 URL 的方法中捕获所有 NoSuchParameter 异常。</p>\n</blockquote>\n<p>The aggregation described in the preceding paragraph has good properties from the standpoint of encapsulation and information hiding. The top-level exception handler encapsulates knowledge about how to generate error responses, but it knows nothing about specific errors; it just uses the error message provided in the exception. The getParameter method encapsulates knowledge about how to extract a parameter from a URL, and it also knows how to describe extraction errors in a human-readable form. These two pieces of information are closely related, so it makes sense for them to be in the same place. However, getParameter knows nothing about the syntax of an HTTP error response. As new functionality is added to the Web server, new methods like getParameter may be created with their own errors. If the new methods throw exceptions in the same way as getParameter (by generating exceptions that inherit from the same superclass and including an error message in each exception), they can plug into the existing system with no other changes: the top-level handler will automatically generate error responses for them.</p>\n<blockquote>\n<p>从封装和信息隐藏的角度来看，上一段中描述的聚合具有良好的属性。顶级异常处理程序封装了有关如何生成错误响应的知识，但对特定错误一无所知。它仅使用异常中提供的错误消息。getParameter 方法封装了有关如何从 URL 提取参数的知识，并且还知道如何以人类可读的形式描述提取错误。这两个信息密切相关，因此将它们放在同一位置是很有意义的。但是，getParameter 对 HTTP 错误响应的语法一无所知。随着向 Web 服务器中添加了新功能，可能会创建具有类似自身错误的新方法，如 getParameter。</p>\n</blockquote>\n<p>This example illustrates a generally-useful design pattern for exception handling. If a system processes a series of requests, it’s useful to define an exception that aborts the current request, cleans up the system’s state, and continues with the next request. The exception is caught in a single place near the top of the system’s request-handling loop. This exception can be thrown at any point in the processing of a request to abort the request; different subclasses of the exception can be defined for different conditions. Exceptions of this type should be clearly distinguished from exceptions that are fatal to the entire system.</p>\n<blockquote>\n<p>此示例说明了用于异常处理的通用设计模式。如果系统处理一系列请求，则定义一个异常以中止当前请求，清除系统状态并继续下一个请求非常有用。异常被捕获在系统请求处理循环顶部附近的单个位置。在处理中止请求的任何时候都可以抛出该异常。可以为不同的条件定义异常的不同子类。应该将这种类型的异常与对整个系统致命的异常区分开来。</p>\n</blockquote>\n<p>Exception aggregation works best if an exception propagates several levels up the stack before it is handled; this allows more exceptions from more methods to be handled in the same place. This is the opposite of exception masking: masking usually works best if an exception is handled in a low-level method. For masking, the low-level method is typically a library method used by many other methods, so allowing the exception to propagate would increase the number of places where it is handled. Masking and aggregation are similar in that both approaches position an exception handler where it can catch the most exceptions, eliminating many handlers that would otherwise need to be created.</p>\n<blockquote>\n<p>如果异常在处理之前在堆栈中传播了多个级别，则异常聚集最有效。这样可以在同一位置处理更多方法的更多异常。这与异常屏蔽相反：如果使用低级方法处理异常，则屏蔽通常效果最好。对于屏蔽，低级方法通常是许多其他方法使用的库方法，因此，允许传播异常会增加处理该异常的位置数。掩码和聚合的相似之处在于，这两种方法都将异常处理程序置于可以捕获最多异常的位置，从而消除了许多本来需要创建的处理程序。</p>\n</blockquote>\n<p>Another example of exception aggregation occurs in the RAMCloud storage system for crash recovery. A RAMCloud system consists of a collection of storage servers that keep multiple copies of each object, so the system can recover from a variety of failures. For example, if a server crashes and loses all of its data, RAMCloud reconstructs the lost data using copies stored on other servers. Errors can also happen on a smaller scale; for example, a server may discover that an individual object is corrupted.</p>\n<blockquote>\n<p>RAMCloud 存储系统中发生异常聚集的另一个示例是崩溃恢复。RAMCloud 系统由一组存储服务器组成，这些存储服务器保留每个对象的多个副本，因此系统可以从各种故障中恢复。例如，如果服务器崩溃并丢失其所有数据，RAMCloud 会使用存储在其他服务器上的副本来重建丢失的数据。错误也可能在较小的范围内发生。例如，服务器可能发现单个对象已损坏。</p>\n</blockquote>\n<p>RAMCloud does not have separate recovery mechanisms for each different kind of error. Instead, RAMCloud “promotes” many smaller errors into larger ones. RAMCloud could, in principle, handle a corrupted object by restoring that one object from a backup copy. However, it doesn’t do this. Instead, if it discovers a corrupted object it crashes the server containing the object. RAMCloud uses this approach because crash recovery is quite complex and this approach minimized the number of different recovery mechanisms that had to be created. Creating a recovery mechanism for crashed servers was unavoidable, so RAMCloud uses the same mechanism for other kinds of recovery as well. This reduced the amount of code that had to be written, and it also meant that server crash recovery gets invoked more often. As a result, bugs in recovery are more likely to be discovered and fixed.</p>\n<blockquote>\n<p>对于每种不同类型的错误，RAMCloud 没有单独的恢复机制。相反，RAMCloud 将许多较小的错误“提升”为较大的错误。原则上，RAMCloud 可以通过从备份副本中恢复一个损坏的对象来处理这个损坏的对象。然而，它并不这样做。相反，如果它发现一个损坏的对象，它会使包含该对象的服务器崩溃。RAMCloud 使用这种方法是因为崩溃恢复非常复杂，而且这种方法最小化了必须创建的不同恢复机制的数量。为崩溃的服务器创建恢复机制是不可避免的，因此 RAMCloud 对其他类型的恢复也使用相同的机制。这减少了必须编写的代码量，而且这还意味着服务器崩溃恢复将更频繁地被调用。因此，恢复中的 bug 更有可能被发现和修复。</p>\n</blockquote>\n<p>One disadvantage of promoting a corrupted object into a server crash is that it increases the cost of recovery considerably. This is not a problem in RAMCloud, since object corruption is quite rare. However, error promotion may not make sense for errors that happen frequently. As one example, it would not be practical to crash a server anytime one of its network packets is lost.</p>\n<blockquote>\n<p>将损坏的对象升级为服务器崩溃的一个缺点是，它大大增加了恢复成本。这在 RAMCloud 中不是问题，因为对象损坏非常罕见。但是，错误升级对于经常发生的错误可能没有意义。举一个例子，在服务器的任何网络数据包丢失时使服务器崩溃是不切实际的。</p>\n</blockquote>\n<p>One way of thinking about exception aggregation is that it replaces several special-purpose mechanisms, each tailored for a particular situation, with a single general-purpose mechanism that can handle multiple situations. This provides another illustration of the benefits of general-purpose mechanisms.</p>\n<blockquote>\n<p>考虑异常聚合的一种方法是，它用可以处理多种情况的单个通用机制替换了几种针对特定情况而量身定制的特殊用途的机制。这再次说明了通用机制的好处。</p>\n</blockquote>\n<h2 id=\"10-8-Just-crash-崩溃了吗？\"><a href=\"#10-8-Just-crash-崩溃了吗？\" class=\"headerlink\" title=\"10.8 Just crash? 崩溃了吗？\"></a>10.8 Just crash? 崩溃了吗？</h2><p>The fourth technique for reducing complexity related to exception handling is to crash the application. In most applications there will be certain errors that it’s not worth trying to handle. Typically, these errors are difficult or impossible to handle and don’t occur very often. The simplest thing to do in response to these errors is to print diagnostic information and then abort the application.</p>\n<blockquote>\n<p>减少与异常处理相关的复杂性的第四种技术是使应用程序崩溃。在大多数应用程序中，有些错误是不值得尝试的。通常，这些错误很难或不可能处理，而且很少发生。针对这些错误的最简单的操作是打印诊断信息，然后中止应用程序。</p>\n</blockquote>\n<p>One example is “out of memory” errors that occur during storage allocation. Consider the malloc function in C, which returns NULL if it cannot allocate the desired block of memory. This is an unfortunate behavior, because it assumes that every single caller of malloc will check the return value and take appropriate action if there is no memory. Applications contain numerous calls to malloc, so checking the result after each call would add significant complexity. If a programmer forgets the check (which is fairly likely), then the application will dereference a null pointer if memory runs out, resulting in a crash that camouflages the real problem.</p>\n<blockquote>\n<p>一个示例是在存储分配期间发生的“内存不足”错误。考虑一下 C 语言中的 malloc 函数，如果它无法分配所需的内存块，则该函数将返回 NULL。这是一个不幸的行为，因为它假定 malloc 的每个调用者都将检查返回值并在没有内存的情况下采取适当的措施。应用程序包含许多对 malloc 的调用，因此在每次调用后检查结果将增加相当大的复杂性。如果程序员忘记了检查（这很有可能），那么如果内存用完，应用程序将取消引用空指针，从而导致崩溃，从而掩盖了实际问题。</p>\n</blockquote>\n<p>Furthermore, there isn’t much an application can do when it discovers that memory is exhausted. In principle the application could look for unneeded memory to free, but if the application had unneeded memory it could already have freed it, which would have prevented the out-of-memory error in the first place. Today’s systems have so much memory that memory almost never runs out; if it does, it usually indicates a bug in the application. Thus, it rarely make sense to try to handle out-of-memory errors; this creates too much complexity for too little benefit.</p>\n<blockquote>\n<p>此外，当应用程序发现内存已用完时，它无能为力。原则上，应用程序可以寻找不需要的内存以释放它，但是如果应用程序有不需要的内存，它可以已经释放它，这首先可以防止内存不足错误。当今的系统具有如此大的内存，以至于内存几乎永远不会耗尽。如果是这样，通常表明应用程序中存在错误。因此，尝试处理内存不足错误几乎没有道理。这会带来太多的复杂性，而带来的收益却太少。</p>\n</blockquote>\n<p>A better approach is to define a new method ckalloc, which calls malloc, checks the result, and aborts the application with an error message if memory is exhausted. The application never invokes malloc directly; it always invokes ckalloc.</p>\n<blockquote>\n<p>更好的方法是定义一个新的 ckalloc 方法，该方法调用 malloc，检查结果，并在内存耗尽时通过错误消息中止应用程序。该应用程序从不直接调用 malloc。它总是调用 ckalloc。</p>\n</blockquote>\n<p>In newer languages such as C++ and Java, the new operator throws an exception if memory is exhausted. There’s not much point in catching this exception, since there’s a good chance that the exception handler will also try to allocate memory, which will also fail. Dynamically allocated memory is such a fundamental element of any modern application that it doesn’t make sense for the application to continue if memory is exhausted; it’s better to crash as soon as the error is detected.</p>\n<blockquote>\n<p>在较新的语言（例如 C ++和 Java）中，如果内存耗尽，则 new 运算符将引发异常。捕获此异常没有什么意义，因为异常处理程序很有可能还会尝试分配内存，这也会失败。动态分配的内存是任何现代应用程序中的基本元素，如果内存耗尽，则继续应用程序是没有意义的。最好在检测到错误后立即崩溃。</p>\n</blockquote>\n<p>There are many other examples of errors where crashing the application makes sense. For most programs, if an I/O error occurs while reading or writing an open file (such as a disk hard error), or if a network socket cannot be opened, there’s not much the application can do to recover, so aborting with a clear error message is a sensible approach. These errors are infrequent, so they are unlikely to affect the overall usability of the application. Aborting with an error message is also appropriate if an application encounters an internal error such as an inconsistent data structure. Conditions like this probably indicate bugs in the program.</p>\n<blockquote>\n<p>还有许多其他错误示例，这些错误会使应用程序崩溃很有意义。对于大多数程序，如果在读取或写入打开的文件时发生 I/O 错误（例如磁盘硬错误），或者无法打开网络套接字，则应用程序无济于事，因此中止了操作。清除错误消息是一种明智的方法。这些错误很少发生，因此它们不太可能影响应用程序的整体可用性。如果应用程序遇到内部错误（如数据结构不一致），则错误消息中止也是合适的。这样的条件可能表明程序中存在错误。</p>\n</blockquote>\n<p>Whether or not it is acceptable to crash on a particular error depends on the application. For a replicated storage system, it isn’t appropriate to abort on an I/O error. Instead, the system must use replicated data to recover any information that was lost. The recovery mechanisms will add considerable complexity to the program, but recovering lost data is an essential part of the value the system provides to its users.</p>\n<blockquote>\n<p>在特定错误上崩溃是否可以接受取决于应用程序。对于复制的存储系统，不适合因 I/O 错误而中止。相反，系统必须使用复制的数据来恢复丢失的任何信息。恢复机制将给程序增加相当大的复杂性，但是恢复丢失的数据是系统为用户提供的价值的重要组成部分。</p>\n</blockquote>\n<h2 id=\"10-9-Design-special-cases-out-of-existence-设计特殊情况不存在\"><a href=\"#10-9-Design-special-cases-out-of-existence-设计特殊情况不存在\" class=\"headerlink\" title=\"10.9 Design special cases out of existence 设计特殊情况不存在\"></a>10.9 Design special cases out of existence 设计特殊情况不存在</h2><p>For the same reason that it makes sense to define errors out of existence, it also makes sense to define other special cases out of existence. Special cases can result in code that is riddled with if statements, which make the code hard to understand and lead to bugs. Thus, special cases should be eliminated wherever possible. The best way to do this is by designing the normal case in a way that automatically handles the special cases without any extra code.</p>\n<blockquote>\n<p>出于同样的原因，定义不存在的错误是有意义的，而定义其他不存在的特殊情况也是有意义的。特殊情况可能导致代码中混入 if 语句，这使代码难以理解并导致错误。因此，应尽可能消除特殊情况。做到这一点的最佳方法是设计一种普通情况，这种方式可以自动处理特殊情况而无需任何额外的代码。</p>\n</blockquote>\n<p>In the text editor project described in Chapter 6, students had to implement a mechanism for selecting text and copying or deleting the selection. Most students introduced a state variable in their selection implementation to indicate whether or not the selection exists. They probably chose this approach because there are times when no selection is visible on the screen, so it seemed natural to represent this notion in the implementation. However, this approach resulted in numerous checks to detect the “no selection” condition and handle it specially.</p>\n<blockquote>\n<p>在第 6 章中描述的文本编辑器项目中，学生必须实现一种选择文本以及复制或删除所选内容的机制。大多数学生在他们的选择实现中引入了状态变量，以表明选择是否存在。他们之所以选择这种方法，是因为有时屏幕上看不到任何选择，因此在实现中似乎很自然地代表了这一概念。但是，这种方法导致大量检查以检测“无选择”条件并进行特殊处理。</p>\n</blockquote>\n<p>The selection handling code can be simplified by eliminating the “no selection” special case, so that the selection always exists. When there is no selection visible on the screen, it can be represented internally with an empty selection, whose starting and ending positions are the same. With this approach, the selection management code can be written without any checks for “no selection”. When copying the selection, if the selection is empty then 0 bytes will be inserted at the new location (if implemented correctly, there will be no need to check for 0 bytes as a special case). Similarly, it should be possible to design the code for deleting the selection so that the empty case is handled without any special-case checks. Consider a selection all on a single line. To delete the selection, extract the portion of the line preceding the selection and concatenate it with the portion of the line following the selection to form the new line. If the selection is empty, this approach will regenerate the original line.</p>\n<blockquote>\n<p>通过消除“不选择”的特殊情况，可以简化选择处理代码，从而使选择始终存在。当屏幕上没有可见的选择时，可以在内部用空的选择表示，其开始和结束位置相同。使用这种方法，可以编写选择管理代码，而无需对“不选择”进行任何检查。复制所选内容时，如果所选内容为空，则将在新位置插入 0 字节（如果正确实现，则在特殊情况下无需检查 0 字节）。同样，应该有可能设计用于删除选择的代码，以便无需任何特殊情况检查就可以处理空情况。在一行上考虑所有选择。要删除选择，提取选择之前的行的一部分，并将其与选择之后的行的部分连接起来以形成新行。如果选择为空，则此方法将重新生成原始行。</p>\n</blockquote>\n<p>This example also illustrates the “different layer, different abstraction” idea from Chapter 7. The notion of “no selection” makes sense in terms of how the user thinks about the application’s interface, but that doesn’t mean it has to be represented explicitly inside the application. Having a selection that always exists, but is sometimes empty and thus invisible, results in a simpler implementation.</p>\n<blockquote>\n<p>此示例还说明了第 7 章中的“不同的层，不同的抽象”概念。“无选择”的概念在用户对应用程序界面的看法方面很有意义，但这并不意味着必须明确表示它在应用程序内部。选择总是存在的，但有时是空的，因此是不可见的，这样可以简化实现。</p>\n</blockquote>\n<h2 id=\"10-10-Taking-it-too-far-走得太远\"><a href=\"#10-10-Taking-it-too-far-走得太远\" class=\"headerlink\" title=\"10.10 Taking it too far 走得太远\"></a>10.10 Taking it too far 走得太远</h2><p>Defining away exceptions, or masking them inside a module, only makes sense if the exception information isn’t needed outside the module. This was true for the examples in this chapter, such the Tcl unset command and the Java substring method; in the rare situations where a caller cares about the special cases detected by the exceptions, there are other ways for it to get this information.</p>\n<blockquote>\n<p>定义异常或将其屏蔽在模块内部，仅在模块外部不需要异常信息时才有意义。对于本章中的示例，例如 Tcl unset 命令和 Java 子字符串方法，都是如此。在极少数情况下，呼叫者关心异常检测到的特殊情况，还有其他方法可以获取此信息。</p>\n</blockquote>\n<p>However, it is possible to take this idea too far. In a module for network communication, a student team masked all network exceptions: if a network error occurred, the module caught it, discarded it, and continued as if there were no problem. This meant that applications using the module had no way to find out if messages were lost or a peer server failed; without this information, it was impossible to build robust applications. In this case, it is essential for the module to expose the exceptions, even though they add complexity to the module’s interface.</p>\n<blockquote>\n<p>但是，有可能使这个想法太过分。在用于网络通信的模块中，一个学生团队掩盖了所有网络异常：如果发生网络错误，则模块将其捕获，丢弃并继续进行，就好像没有问题一样。这意味着使用该模块的应用程序无法确定消息是否丢失或对等服务器是否发生故障；没有这些信息，就不可能构建健壮的应用程序。在这种情况下，模块必须公开异常，即使它们增加了模块接口的复杂性。</p>\n</blockquote>\n<p>With exceptions, as with many other areas in software design, you must determine what is important and what is not important. Things that are not important should be hidden, and the more of them the better. But when something is important, it must be exposed.</p>\n<blockquote>\n<p>与软件设计中的许多其他领域一样，您必须确定哪些是重要的，哪些是不重要的。不重要的事物应该被隐藏起来，它们越多越好。但是，当某件事很重要时，必须将其暴露出来。</p>\n</blockquote>\n<h2 id=\"10-11-Conclusion-结论\"><a href=\"#10-11-Conclusion-结论\" class=\"headerlink\" title=\"10.11 Conclusion 结论\"></a>10.11 Conclusion 结论</h2><p>Special cases of any form make code harder to understand and increase the likelihood of bugs. This chapter focused on exceptions, which are one of the most significant sources of special-case code, and discussed how to reduce the number of places where exceptions must be handled. The best way to do this is by redefining semantics to eliminate error conditions. For exceptions that can’t be defined away, you should look for opportunities to mask them at a low level, so their impact is limited, or aggregate several special-case handlers into a single more generic handler. Together, these techniques can have a significant impact on overall system complexity.</p>\n<blockquote>\n<p>任何形式的特殊情况都使代码更难以理解，并增加了发生错误的可能性。本章重点讨论异常，异常是特殊情况代码的最重要来源之一，并讨论了如何减少必须处理异常的地方的数量。做到这一点的最佳方法是重新定义语义以消除错误条件。对于无法定义的异常，您应该寻找机会将它们掩盖到较低的水平，以免影响有限，或者将多个特殊情况的处理程序聚合到一个更通用的处理程序中。总之，这些技术可能会对整体系统复杂性产生重大影响。</p>\n</blockquote>\n<p>1Ding Yuan et. al., “Simple Testing Can Prevent Most Critical Failures: An Analysis of Production Failures in Distributed Data-Intensive Systems,” 2014 USENIX Conference on Operating System Design and Implementation.</p>\n<blockquote>\n<p>1 丁元等 等人，“简单的测试可以防止最关键的故障：对分布式数据密集型系统中的生产故障的分析”，2014 USENIX 操作系统设计和实施大会。</p>\n</blockquote>"},{"title":"软件设计的哲学 - ch13","date":"2021-02-12T16:00:00.000Z","_content":"注释应该描述代码中不明显的内容\n<!-- more -->\n# 第 13 章 注释应该描述代码中不明显的内容\n\n> Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code\n\nThe reason for writing comments is that statements in a programming language can’t capture all of the important information that was in the mind of the developer when the code was written. Comments record this information so that developers who come along later can easily understand and modify the code. The guiding principle for comments is that comments should describe things that aren’t obvious from the code.\n\n> 编写注释的原因是，使用编程语言编写的语句无法捕获编写代码时开发人员想到的所有重要信息。注释记录了这些信息，以便后来的开发人员可以轻松地理解和修改代码。注释的指导原则是，注释应描述代码中不明显的内容。\n\nThere are many things that aren’t obvious from the code. Sometimes it’s low-level details that aren’t obvious. For example, when a pair of indices describe a range, it isn’t obvious whether the elements given by the indices are inside the range or out. Sometimes it’s not clear why code is needed, or why it was implemented in a particular way. Sometimes there are rules the developer followed, such as “always invoke a before b.” You might be able to guess at a rule by looking at all of the code, but this is painful and error-prone; a comment can make the rule explicit and clear.\n\n> 从代码中看不到很多事情。有时，底层细节并不明显。例如，当一对索引描述一个范围时，由索引给出的元素是在范围之内还是之外并不明显。有时不清楚为什么需要代码，或者为什么要以特定方式实现代码。有时，开发人员遵循一些规则，例如“总是在 b 之前调用 a”。您可能可以通过查看所有代码来猜测规则，但这很痛苦且容易出错。注释可以使规则清晰明了。\n\nOne of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code. The idea of an abstraction is to provide a simple way of thinking about something, but code is so detailed that it can be hard to see the abstraction just from reading the code. Comments can provide a simpler, higher-level view (“after this method is invoked, network traffic will be limited to maxBandwidth bytes per second”). Even if this information can be deduced by reading the code, we don’t want to force users of a module to do that: reading the code is time-consuming and forces them to consider a lot of information that isn’t needed to use the module. Developers should be able to understand the abstraction provided by a module without reading any code other than its externally visible declarations. The only way to do this is by supplementing the declarations with comments.\n\n> 注释的最重要原因之一是抽象，其中包括许多从代码中看不到的信息。抽象的思想是提供一种思考问题的简单方法，但是代码是如此详细，以至于仅通过阅读代码就很难看到抽象。注释可以提供一个更简单，更高级的视图（“调用此方法后，网络流量将被限制为每秒 maxBandwidth 字节”）。即使可以通过阅读代码推断出此信息，我们也不想强迫模块用户这样做：阅读代码很耗时，并且迫使他们考虑很多不需要使用的信息模块。开发人员应该能够理解模块提供的抽象，而无需阅读其外部可见声明以外的任何代码。\n\nThis chapter discusses what information needs to be described in comments and how to write good comments. As you will see, good comments typically explain things at a different level of detail than the code, which is more detailed in some situations and less detailed (more abstract) in others.\n\n> 本章讨论需要在注释中描述哪些信息以及如何编写良好的注释。就像您将看到的那样，好的注释通常以与代码不同的详细程度来解释事物，在某些情况下，注释会更详细，而在某些情况下，代码则较不抽象（更抽象）。\n\n## 13.1 Pick conventions\n\nThe first step in writing comments is to decide on conventions for commenting, such as what you will comment and the format you will use for comments. If you are programming in a language for which there exists a document compilation tool, such as Javadoc for Java, Doxygen for C++, or godoc for Go!, follow the conventions of the tools. None of these conventions is perfect, but the tools provide enough benefits to make up for that. If you are programming in an environment where there are no existing conventions to follow, try to adopt the conventions from some other language or project that is similar; this will make it easier for other developers to understand and adhere to your conventions.\n\n> 编写注释的第一步是确定注释的约定，例如您要注释的内容和注释的格式。如果您正在使用存在文档编译工具的语言进行编程，例如 Java 的 Javadoc，C ++的 Doxygen 或 Go！的 godoc，请遵循工具的约定。这些约定都不是完美的，但是这些工具可提供足够的好处来弥补这一缺点。如果在没有现有约定可遵循的环境中进行编程，请尝试从其他类似的语言或项目中采用这些约定；这将使其他开发人员更容易理解和遵守您的约定。\n\nConventions serve two purposes. First, they ensure consistency, which makes comments easier to read and understand. Second, they help to ensure that you actually write comments. If you don’t have a clear idea what you are going to comment and how, it’s easy to end up writing no comments at all.\n\n> 约定有两个目的。首先，它们确保一致性，这使得注释更易于阅读和理解。其次，它们有助于确保您实际编写评论。如果您不清楚要发表的评论以及发表评论的方式，那么很容易最终根本不发表评论。\n\nMost comments fall into one of the following categories:\n\n> 大多数评论属于以下类别之一：\n\nInterface: a comment block that immediately precedes the declaration of a module such as a class, data structure, function, or method. The comment describe’s the module’s interface. For a class, the comment describes the overall abstraction provided by the class. For a method or function, the comment describes its overall behavior, its arguments and return value, if any, any side effects or exceptions that it generates, and any other requirements the caller must satisfy before invoking the method.\n\n> 接口：在模块声明（例如类，数据结构，函数或方法）之前的注释块。注释描述模块的接口。对于一个类，注释描述了该类提供的整体抽象。对于方法或函数，注释描述其整体行为，其参数和返回值（如果有），其生成的任何副作用或异常，以及调用者在调用该方法之前必须满足的任何其他要求。\n\nData structure member: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.\n\n> 数据结构成员：数据结构中字段声明旁边的注释，例如类的实例变量或静态变量。\n\nImplementation comment: a comment inside the code of a method or function, which describes how the code works internally.\n\n> 实现注释：方法或函数代码内部的注释，它描述代码在内部的工作方式。\n\nCross-module comment: a comment describing dependencies that cross module boundaries.\n\n> 跨模块注释：描述跨模块边界的依赖项的注释。\n\nThe most important comments are those in the first two categories. Every class should have an interface comment, every class variable should have a comment, and every method should have an interface comment. Occasionally, the declaration for a variable or method is so obvious that there is nothing useful to add in a comment (getters and setters sometimes fall in this category), but this is rare; it is easier to comment everything rather than spend energy worrying about whether a comment is needed. Implementation comments are often unnecessary (see Section 13.6 below). Cross-module comments are the most rare of all and they are problematic to write, but when they are needed they are quite important; Section 13.7 discusses them in more detail.\n\n> 最重要的评论是前两个类别中的评论。每个类都应有一个接口注释，每个类变量应有一个注释，每个方法都应有一个接口注释。有时，变量或方法的声明是如此明显，以至于在注释中没有添加任何有用的东西（getter 和 setter 有时都属于此类），但这很少见。评论所有内容要比花精力担心是否需要评论要容易得多。实施注释通常是不必要的（请参阅下面的 13.6 节）。跨模块注释是最罕见的，而且编写起来很成问题，但是当需要它们时，它们就很重要。第 13.7 节将更详细地讨论它们。\n\n## 13.2 Don’t repeat the code 不要重复代码\n\nUnfortunately, many comments are not particularly helpful. The most common reason is that the comments repeat the code: all of the information in the comment can easily be deduced from the code next to the comment. Here is a code sample that appeared in a recent research paper:\n\n> 不幸的是，许多评论并不是特别有用。最常见的原因是注释重复了代码：可以轻松地从注释旁边的代码中推断出注释中的所有信息。这是最近研究论文中出现的代码示例：\n\n```sh\nptr_copy = get_copy(obj)            # Get pointer copy\nif is_unlocked(ptr_copy):           # Is obj free?\n    return obj                      # return current obj\nif is_copy(ptr_copy):               # Already a copy?\n    return obj                      # return obj\nthread_id = get_thread_id(ptr_copy)\nif thread_id == ctx.thread_id:      # Locked by current ctx\n    return ptr_copy                 # Return copy\n```\n\nThere is no useful information in any of these comments except for the “Locked by” comment, which suggests something about the thread that might not be obvious from the code. Notice that these comments are at roughly the same level of detail as the code: there is one comment per line of code, which describes that line. Comments like this are rarely useful.\n\n> 这些注释中没有任何有用的信息，但“ Locked by”注释除外，该注释暗示了有关线程的某些信息可能在代码中并不明显。请注意，这些注释的详细程度与代码大致相同：每行代码有一个注释，用于描述该行。这样的注释很少有用。\n\nHere are more examples of comments that repeat the code:\n\n> 以下是重复代码的注释的更多示例：\n\n```java\n// Add a horizontal scroll bar\nhScrollBar = new JScrollBar(JScrollBar.HORIZONTAL);\nadd(hScrollBar, BorderLayout.SOUTH);\n\n// Add a vertical scroll bar\nvScrollBar = new JScrollBar(JScrollBar.VERTICAL);\nadd(vScrollBar, BorderLayout.EAST);\n\n// Initialize the caret-position related values\ncaretX     = 0;\ncaretY     = 0;\ncaretMemX  = null;\n```\n\nNone of these comments provide any value. For the first two comments, the code is already clear enough that it doesn’t really need comments; in the third case, a comment might be useful, but the current comment doesn’t provide enough detail to be helpful.\n\n> 这些评论均未提供任何价值。对于前两个注释，代码已经很清楚了，它实际上不需要注释。在第三种情况下，注释可能有用，但是当前注释没有提供足够的细节来提供帮助。\n\nAfter you have written a comment, ask yourself the following question: could someone who has never seen the code write the comment just by looking at the code next to the comment? If the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand. Comments like these are why some people think that comments are worthless.\n\n> 编写评论后，请问自己以下问题：从未看过代码的人能否仅通过查看评论旁边的代码来编写评论？如果答案是肯定的（如上述示例所示），则注释不会使代码更易于理解。像这样的评论是为什么有些人认为评论毫无价值的原因。\n\nAnother common mistake is to use the same words in the comment that appear in the name of the entity being documented:\n\n> 另一个常见的错误是在注释中使用与要记录的实体名称相同的词：\n\n```java\n/*\n * Obtain a normalized resource name from REQ.\n */\nprivate static String[] getNormalizedResourceNames(\n            HTTPRequest req) ...\n/*\n * Downcast PARAMETER to TYPE.\n */\nprivate static Object downCastParameter(String parameter, String type) ...\n/*\n * The horizontal padding of each line in the text.\n */\nprivate static final int textHorizontalPadding = 4;\n```\n\nThese comments just take the words from the method or variable name, perhaps add a few words from argument names and types, and form them into a sentence. For example, the only thing in the second comment that isn’t in the code is the word “to”! Once again, these comments could be written just by looking at the declarations, without any understanding the methods of variables; as a result, they have no value.\n\n> 这些注释只是从方法或变量名中提取单词，或者从参数名称和类型中添加几个单词，然后将它们组成一个句子。例如，第二个注释中唯一不在代码中的是单词“ to”！再说一次，这些注释可以仅通过查看声明来编写，而无需任何了解变量的方法。结果，它们没有价值。\n\nimg Red Flag: Comment Repeats Code img\n\nIf the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful. One example of this is when the comment uses the same words that make up the name of the thing it is describing.\n\n> 如果注释旁边的代码中的注释信息已经很明显，则注释无济于事。这样的一个例子是，当注释使用与所描述事物名称相同的单词时。\n\nAt the same time, there is important information that is missing from the comments: for example, what is a “normalized resource name”, and what are the elements of the array returned by getNormalizedResourceNames? What does “downcast” mean? What are the units of padding, and is the padding on one side of each line or both? Describing these things in comments would be helpful.\n\n> 同时，注释中缺少一些重要信息：例如，什么是“标准化资源名称”，以及 getNormalizedResourceNames 返回的数组的元素是什么？“贬低”是什么意思？填充的单位是什么，填充是在每行的一侧还是在两者的两侧？在注释中描述这些内容将很有帮助。\n\nA first step towards writing good comments is to use different words in the comment from those in the name of the entity being described. Pick words for the comment that provide additional information about the meaning of the entity, rather than just repeating its name. For example, here is a better comment for textHorizontalPadding:\n\n> 编写良好评论的第一步是在评论中使用与所描述实体名称不同的词。为注释选择单词，以提供有关实体含义的更多信息，而不仅仅是重复其名称。例如，以下是针对 textHorizo​​ntalPadding 的更好注释：\n\n```java\n/*\n * The amount of blank space to leave on the left and\n * right sides of each line of text, in pixels.\n */\nprivate static final int textHorizontalPadding = 4;\n```\n\nThis comment provides additional information that is not obvious from the declaration itself, such as the units (pixels) and the fact that padding applies to both sides of each line. Instead of using the term “padding”, the comment explains what padding is, in case the reader isn’t already familiar with the term.\n\n> 该注释提供了从声明本身不明显的其他信息，例如单位（像素）以及填充适用于每行两边的事实。如果读者不熟悉该术语，则注释将解释什么是填充，而不是使用术语“填充”。\n\n## 13.3 Lower-level comments add precision 低级注释可提高精度\n\nNow that you know what not to do, let’s discuss what information you should put in comments. Comments augment the code by providing information at a different level of detail. Some comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code. Other comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code. Comments at the same level as the code are likely to repeat the code. This section discusses the lower-level approach in more detail, and the next section discusses the higher-level approach.\n\n> 现在您知道了不应该做的事情，让我们讨论应该在注释中添加哪些信息。注释通过提供不同详细程度的信息来增强代码。一些注释提供了比代码更低，更详细的信息。这些注释通过阐明代码的确切含 ​​ 义来增加精度。其他注释提供了比代码更高，更抽象的信息。这些注释提供了直觉，例如代码背后的推理，或者更简单，更抽象的代码思考方式。与代码处于同一级别的注释可能会重复该代码。本节将更详细地讨论下层方法，而下一节将讨论上层方法。\n\nPrecision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and type in a variable declaration are typically not very precise. Comments can fill in missing details such as:\n\n> 在注释变量声明（例如类实例变量，方法参数和返回值）时，精度最有用。变量声明中的名称和类型通常不是很精确。注释可以填写缺少的详细信息，例如：\n\n- What are the units for this variable?\n- Are the boundary conditions inclusive or exclusive?\n- If a null value is permitted, what does it imply?\n- If a variable refers to a resource that must eventually be freed or closed, who is responsible for freeing or closing it?\n- Are there certain properties that are always true for the variable (invariants), such as “this list always contains at least one entry”?\n\n---\n\n> - 此变量的单位是什么？\n> - 边界条件是包容性还是排他性？\n> - 如果允许使用空值，则意味着什么？\n> - 如果变量引用了最终必须释放或关闭的资源，那么谁负责释放或关闭该资源？\n> - 是否存在某些对于变量始终不变的属性（不变量），例如“此列表始终包含至少一个条目”？\n\nSome of this information could potentially be figured out by examining all of the code where the variable is used. However, this is time-consuming and error-prone; the declaration’s comment should be clear and complete enough to make this unnecessary. When I say that the comment for a declaration should describe things that aren’t obvious from the code, “the code” refers to the code next to the comment (the declaration), not “all of the code in the application.”\n\n> 通过检查使用该变量的所有代码，可以潜在地了解某些信息。但是，这很耗时且容易出错。宣言的评论应清晰，完整，以免不必要。当我说声明的注释应描述代码中不明显的内容时，“代码”是指注释（声明）旁边的代码，而不是“应用程序中的所有代码”。\n\nThe most common problem with comments for variables is that the comments are too vague. Here are two examples of comments that aren’t precise enough:\n\n> 变量注释最常见的问题是注释太模糊。这是两个不够精确的注释示例：\n\n```java\n// Current offset in resp Buffer\nuint32_t offset;\n\n// Contains all line-widths inside the document and\n// number of appearances.\nprivate TreeMap<Integer, Integer> lineWidths;\n```\n\nIn the first example, it’s not clear what “current” means. In the second example, it’s not clear that the keys in the TreeMap are line widths and values are occurrence counts. Also, are widths measured in pixels or characters? The revised comments below provide additional details:\n\n> 在第一个示例中，尚不清楚“当前”的含义。在第二个示例中，尚不清楚 TreeMap 中的键是线宽，值是出现次数。另外，宽度是以像素或字符为单位测量的吗？以下修订后的注释提供了更多详细信息：\n\n```java\n//  Position in this buffer of the first object that hasn't\n//  been returned to the client.\nuint32_t offset;\n\n//  Holds statistics about line lengths of the form <length, count>\n//  where length is the number of characters in a line (including\n//  the newline), and count is the number of lines with\n//  exactly that many characters. If there are no lines with\n//  a particular length, then there is no entry for that length.\nprivate TreeMap<Integer, Integer> numLinesWithLength;\n```\n\nThe second declaration uses a longer name that conveys more information. It also changes “width” to “length”, because this term is more likely to make people think that the units are characters rather than pixels. Notice that the second comment documents not only the details of each entry, but also what it means if an entry is missing.\n\n> 第二个声明使用一个较长的名称来传达更多信息。它还将“宽度”更改为“长度”，因为该术语更可能使人们认为单位是字符而不是像素。请注意，第二条注释不仅记录了每个条目的详细信息，还记录了缺少条目的含义。\n\nWhen documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated. Consider the following comment:\n\n> 在记录变量时，请考虑名词而不是动词。换句话说，关注变量代表什么，而不是如何操纵变量。考虑以下评论：\n\n```java\n/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and the\n * PeriodicTasks thread to communicate about whether a heartbeat has been\n * received within the follower's election timeout window.\n * Toggled to TRUE when a valid heartbeat is received.\n * Toggled to FALSE when the election timeout window is reset.  */\nprivate boolean receivedValidHeartbeat;\n```\n\nThis documentation describes how the variable is modified by several pieces of code in the class. The comment will be both shorter and more useful if it describes what the variable represents rather than mirroring the code structure:\n\n> 本文档描述了如何通过类中的几段代码来修改变量。如果注释描述变量代表什么而不是镜像代码结构，则注释将更短且更有用：\n\n```java\n/* True means that a heartbeat has been received since the last time\n * the election timer was reset. Used for communication between the\n * Receiver and PeriodicTasks threads.  */\nprivate boolean receivedValidHeartbeat;\n```\n\nGiven this documentation, it’s easy to infer that the variable must be set to true when a heartbeat is received and false when the election timer is reset.\n\n> 根据本文档，很容易推断出，当接收到心跳信号时，变量必须设置为 true；而当重置选举计时器时，则必须将变量设置为 false。\n\n## 13.4 Higher-level comments enhance intuition 高级注释可增强直觉\n\nThe second way in which comments can augment code is by providing intuition. These comments are written at a higher level than the code. They omit details and help the reader to understand the overall intent and structure of the code. This approach is commonly used for comments inside methods, and for interface comments. For example, consider the following code:\n\n> 注释可以增加代码的第二种方法是提供直觉。这些注释是在比代码更高的级别上编写的。它们忽略了细节，并帮助读者理解了代码的整体意图和结构。此方法通常用于方法内部的注释以及接口注释。例如，考虑以下代码：\n\n```java\n// If there is a LOADING readRpc using the same session\n// as PKHash pointed to by assignPos, and the last PKHash\n// in that readRPC is smaller than current assigning\n// PKHash, then we put assigning PKHash into that readRPC.\nint readActiveRpcId = RPC_ID_NOT_ASSIGNED;\nfor (int i = 0; i < NUM_READ_RPC; i++) {\n    if (session == readRpc[i].session\n            && readRpc[i].status == LOADING\n            && readRpc[i].maxPos < assignPos\n            && readRpc[i].numHashes < MAX_PKHASHES_PERRPC) {\n        readActiveRpcId = i;\n        break;\n    }\n}\n```\n\nThe comment is too low-level and detailed. On the one hand, it partially repeats the code: “if there is a LOADING readRPC” just duplicates the test `readRpc[i].status == LOADING`. On the other hand, the comment doesn’t explain the overall purpose of this code, or how it fits into the method that contains it. As a result, the comment doesn’t help the reader to understand the code.\n\n> 该评论太底层和太详细。一方面，它部分重复了代码：“如果有 LOADING readRPC”仅重复测试 `readRpc[i].status == LOADING`。另一方面，注释不能解释此代码的总体目的，也不能解释其如何适合包含此代码的方法。如此一来注释不能帮助读者理解代码。\n\nHere is a better comment:\n\n> 这是一个更好的评论：\n\n```java\n// Try to append the current key hash onto an existing\n// RPC to the desired server that hasn't been sent yet.\n```\n\nThis comment doesn’t contain any details; instead, it describes the code’s overall function at a higher level. With this high-level information, a reader can explain almost everything that happens in the code: the loop must be iterating over all the existing remote procedure calls (RPCs); the session test is probably used to see if a particular RPC is destined for the right server; the LOADING test suggests that RPCs can have multiple states, and in some states it isn’t safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how many hashes can be sent in a single RPC. The only thing not explained by the comment is the maxPos test. Furthermore, the new comment provides a basis for readers to judge the code: does it do everything that is needed to add the key hash to an existing RPC? The original comment didn’t describe the overall intent of the code, so it’s hard for a reader to decide whether the code is behaving correctly.\n\n> 此评论不包含任何详细信息。相反，它在更高级别上描述了代码的整体功能。有了这些高级信息，读者就可以解释代码中几乎发生的所有事情：循环必须遍历所有现有的远程过程调用（RPC）；会话测试可能用于查看特定的 RPC 是否发往正确的服务器；LOADING 测试表明 RPC 可以具有多个状态，在某些状态下添加更多的哈希值是不安全的；MAX-PKHASHES_PERRPC 测试表明在单个 RPC 中可以发送多少个哈希值是有限制的。注释中唯一没有解释的是 maxPos 测试。此外，新注释为读者判断代码提供了基础：它可以完成将密钥哈希添加到现有 RPC 所需的一切吗？原始注释并未描述代码的整体意图，因此，读者很难确定代码是否行为正确。\n\nHigher-level comments are more difficult to write than lower-level comments because you must think about the code in a different way. Ask yourself: What is this code trying to do? What is the simplest thing you can say that explains everything in the code? What is the most important thing about this code?\n\n> 高级别的注释比低级别的注释更难编写，因为您必须以不同的方式考虑代码。问问自己：这段代码要做什么？您能说什么最简单的东西来解释代码中的所有内容？这段代码最重要的是什么？\n\nEngineers tend to be very detail-oriented. We love details and are good at managing lots of them; this is essential for being a good engineer. But, great software designers can also step back from the details and think about a system at a higher level. This means deciding which aspects of the system are most important, and being able to ignore the low-level details and think about the system only in terms of its most fundamental characteristics. This is the essence of abstraction (finding a simple way to think about a complex entity), and it’s also what you must do when writing higher-level comments. A good higher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as “append to an existing RPC.” Given the framework, it becomes easy to see how specific code statements relate to the overall goal.\n\n> 工程师往往非常注重细节。我们喜欢细节，善于管理其中的许多细节；这对于成为一名优秀的工程师至关重要。但是，优秀的软件设计师也可以从细节退后一步，从更高层次考虑系统。这意味着要确定系统的哪些方面最重要，并且能够忽略底层细节，仅根据系统的最基本特征来考虑系统。这是抽象的本质（找到一种思考复杂实体的简单方法），这也是编写高级注释时必须执行的操作。一个好的高层注释表达了一个或几个简单的想法，这些想法提供了一个概念框架，例如“附加到现有的 RPC”。使用该框架，可以很容易地看到特定的代码语句与总体目标之间的关系。\n\nHere is another code sample, which has a good higher-level comment:\n\n> 这是另一个代码示例，具有较高层次的注释：\n\n```java\nif (numProcessedPKHashes < readRpc[i].numHashes) {\n    // Some of the key hashes couldn't be looked up in\n    // this request (either because they aren't stored\n    // on the server, the server crashed, or there\n    // wasn't enough space in the response message).\n    // Mark the unprocessed hashes so they will get\n    // reassigned to new RPCs.\n    for (size_t p = removePos; p < insertPos; p++) {\n        if (activeRpcId[p] == i) {\n            if (numProcessedPKHashes > 0) {\n                numProcessedPKHashes--;\n            } else {\n                if (p < assignPos)\n                    assignPos = p;\n                activeRpcId[p] = RPC_ID_NOT_ASSIGNED;\n            }\n        }\n    }\n}\n```\n\nThis comment does two things. The second sentence provides an abstract description of what the code does. The first sentence is different: it explains (in high level terms) why the code is executed. Comments of the form “how we get here” are very useful for helping people to understand code. For example, when documenting a method, it can be very helpful to describe the conditions under which the method is most likely to be invoked (especially if the method is only invoked in unusual situations).\n\n> 此评论有两件事。第二句话提供了代码功能的抽象描述。第一句话是不同的：它以高级的方式解释了为什么执行代码。“如何到达这里”形式的注释对于帮助人们理解代码非常有用。例如，在记录方法时，描述最有可能在什么情况下调用该方法的条件（特别是仅在异常情况下调用该方法的情况）会非常有帮助。\n\n## 13.5 Interface documentation 接口文档\n\nOne of the most important roles for comments is to define abstractions. Recall from Chapter 4 that an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. Code isn’t suitable for describing abstractions; it’s too low level and it includes implementation details that shouldn’t be visible in the abstraction. The only way to describe an abstraction is with comments. If you want code that presents good abstractions, you must document those abstractions with comments.\n\n> 注释最重要的作用之一就是定义抽象。回想一下第 4 章，抽象是实体的简化视图，它保留了基本信息，但省略了可以安全忽略的细节。代码不适合描述抽象；它的级别太低，它包含实现细节，这些细节在抽象中不应该看到。描述抽象的唯一方法是使用注释。如果您想要呈现良好抽象的代码，则必须用注释记录这些抽象。\n\nThe first step in documenting abstractions is to separate interface comments from implementation comments. Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction. Implementation comments describe how a class or method works internally in order to implement the abstraction. It’s important to separate these two kinds of comments, so that users of an interface are not exposed to implementation details. Furthermore, these two forms had better be different. If interface comments must also describe the implementation, then the class or method is shallow. This means that the act of writing comments can provide clues about the quality of a design; Chapter 15 will return to this idea.\n\n> 记录抽象的第一步是将接口注释与实现注释分开。接口注释提供了使用类或方法时需要知道的信息。他们定义了抽象。实现注释描述了类或方法如何在内部工作以实现抽象。区分这两种注释很重要，这样界面的用户就不会暴露于实现细节。此外，这两种形式最好有所不同。如果接口注释也必须描述实现，则该类或方法很浅。这意味着撰写评论的行为可以提供有关设计质量的线索；第 15 章将回到这个想法。\n\nThe interface comment for a class provides a high-level description of the abstraction provided by the class, such as the following:\n\n> 类的接口注释提供了该类提供的抽象的高级描述，例如：\n\n```java\n/**\n * This class implements a simple server-side interface to the HTTP\n * protocol: by using this class, an application can receive HTTP\n * requests, process them, and return responses. Each instance of\n * this class corresponds to a particular socket used to receive\n * requests. The current implementation is single-threaded and\n * processes one request at a time.\n */\npublic class Http {...}\n```\n\nThis comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods. It also describes what each instance of the class represents. Finally, the comments describe the limitations of the class (it does not support concurrent access from multiple threads), which may be important to developers contemplating whether to use it.\n\n> 该注释描述了类的整体功能，没有任何实现细节，甚至没有特定方法的细节。它还描述了该类的每个实例代表什么。最后，注释描述了该类的限制（它不支持从多个线程的并发访问），这对于考虑是否使用它的开发人员可能很重要。\n\nThe interface comment for a method includes both higher-level information for abstraction and lower-level details for precision:\n\n> 方法的接口注释既包括用于抽象的高层信息，又包括用于精度的低层细节：\n\n- The comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.\n- The comment must describe each argument and the return value (if any). These comments must be very precise, and must describe any constraints on argument values as well as dependencies between arguments.\n- If the method has any side effects, these must be documented in the interface comment. A side effect is any consequence of the method that affects the future behavior of the system but is not part of the result. For example, if the method adds a value to an internal data structure, which can be retrieved by future method calls, this is a side effect; writing to the file system is also a side effect.\n- A method’s interface comment must describe any exceptions that can emanate from the method.\n- If there are any preconditions that must be satisfied before a method is invoked, these must be described (perhaps some other method must be invoked first; for a binary search method, the list being searched must be sorted). It is a good idea to minimize preconditions, but any that remain must be documented.\n\n---\n\n> - 注释通常以一两个句子开头，描述调用者感知到的方法的行为。这是更高层次的抽象。\n> - 注释必须描述每个参数和返回值（如果有）。这些注释必须非常精确，并且必须描述对参数值的任何约束以及参数之间的依赖关系。\n> - 如果该方法有任何副作用，则必须在界面注释中记录这些副作用。副作用是该方法的任何结果都会影响系统的未来行为，但不属于结果的一部分。例如，如果该方法将一个值添加到内部数据结构中，可以通过将来的方法调用来检索该值，则这是副作用。写入文件系统也是一个副作用。\n> - 方法的界面注释必须描述该方法可能产生的任何异常。\n> - 如果在调用某个方法之前必须满足任何前提条件，则必须对其进行描述（也许必须先调用其他方法；对于二进制搜索方法，必须对要搜索的列表进行排序）。尽量减少前提条件是一个好主意，但是任何保留的条件都必须记录在案。\n\nHere is the interface comment for a method that copies data out of a Buffer object:\n\n> 这是从 Buffer 对象复制数据的方法的接口注释：\n\n```java\n/**\n * Copy a range of bytes from a buffer to an external location.\n *\n * \\param offset\n *        Index within the buffer of the first byte to copy.\n * \\param length\n *        Number of bytes to copy.\n * \\param dest\n *        Where to copy the bytes: must have room for at least\n *        length bytes.\n *\n * \\return\n *        The return value is the actual number of bytes copied,\n *        which may be less than length if the requested range of\n *        bytes extends past the end of the buffer. 0 is returned\n *        if there is no overlap between the requested range and\n *        the actual buffer.\n */\n\nuint32_t\nBuffer::copy(uint32_t offset, uint32_t length, void* dest)\n...\n```\n\nThe syntax of this comment (e.g., \\return) follows the conventions of Doxygen, a program that extracts comments from C/C++ code and compiles them into Web pages. The goal of the comment is to provide all the information a developer needs in order to invoke the method, including how special cases are handled (note how this method follows the advice of Chapter 10 and defines out of existence any errors associated with the range specification). The developer should not need to read the body of the method in order to invoke it, and the interface comment provides no information about how the method is implemented, such as how it scans its internal data structures to find the desired data.\n\n> 此注释的语法（例如\\ return）遵循 Doxygen 的约定，该程序从 C / C ++代码中提取注释并将其编译为 Web 页。注释的目的是提供开发人员调用该方法所需的所有信息，包括特殊情况的处理方式（请注意，此方法如何遵循第 10 章的建议并定义与范围规范相关的任何错误。 ）。开发人员不必为了调用它而阅读方法的主体，并且接口注释不提供有关如何实现该方法的信息，例如它如何扫描其内部数据结构以查找所需的数据。\n\nFor a more extended example, let’s consider a class called IndexLookup, which is part of a distributed storage system. The storage system holds a collection of tables, each of which contains many objects. In addition, each table can have one or more indexes; each index provides efficient access to objects in the table based on a particular field of the object. For example, one index might be used to look up objects based on their name field, and another index might be used to look up objects based on their age field. With these indexes, applications can quickly extract all of the objects with a particular name, or all of those with an age in a given range.\n\n> 对于更扩展的示例，让我们考虑一个称为 IndexLookup 的类，该类是分布式存储系统的一部分。存储系统拥有一个表集合，每个表包含许多对象。另外，每个表可以具有一个或多个索引；每个索引都基于对象的特定字段提供对表中对象的有效访问。例如，一个索引可以用于根据对象的名称字段查找对象，而另一个索引可以用于根据对象的年龄字段查找对象。使用这些索引，应用程序可以快速提取具有特定名称的所有对象，或具有给定范围内的年龄的所有对象。\n\nThe IndexLookup class provides a convenient interface for performing indexed lookups. Here is an example of how it might be used in an application:\n\n> IndexLookup 类为执行索引查找提供了一个方便的接口。这是一个如何在应用程序中使用的示例：\n\n```java\nquery = new IndexLookup(table, index, key1, key2);\nwhile  (true) {\n    object = query.getNext();\n    if  (object == NULL) {\n        break;\n    }\n    ... process object ...\n}\n```\n\nThe application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example, if the index is based on an age field, key1 and key2 might be specified as 21 and 65 to select all objects with ages between those values). Then the application calls the getNext method repeatedly. Each invocation returns one object that falls within the desired range; once all of the matching objects have been returned, getNext returns NULL. Because the storage system is distributed, the implementation of this class is somewhat complex. The objects in a table may be spread across multiple servers, and each index may also be distributed across a different set of servers; the code in the IndexLookup class must first communicate with all of the relevant index servers to collect information about the objects in the range, then it must communicate with the servers that actually store the objects in order to retrieve their values.\n\n> 应用程序首先构造一个类型为 IndexLookup 的对象，并提供用于选择表，索引和索引内范围的参数（例如，如果索引基于年龄字段，则 key1 和 key2 可以指定为 21 和 65 选择年龄介于这些值之间的所有对象）。然后，应用程序重复调用 getNext 方法。每次调用都返回一个位于所需范围内的对象。一旦返回所有匹配的对象，getNext 将返回 NULL。因为存储系统是分布式的，所以此类的实现有些复杂。表中的对象可以分布在多个服务器上，每个索引也可以分布在一组不同的服务器上。\n\nNow let’s consider what information needs to be included in the interface comment for this class. For each piece of information given below, ask yourself whether a developer needs to know that information in order to use the class (my answers to the questions are at the end of the chapter):\n\n> 现在，让我们考虑该类的接口注释中需要包含哪些信息。对于下面给出的每条信息，问自己一个开发人员是否需要知道该信息才能使用该类（我对问题的回答在本章的结尾）：\n\n1. The format of messages that the IndexLookup class sends to the servers holding indexes and objects.\n2. The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?).\n3. The data structure used to store indexes on servers.\n4. Whether or not IndexLookup issues multiple requests to different servers concurrently.\n5. The mechanism for handling server crashes.\n\n> 1. IndexLookup 类发送给包含索引和对象的服务器的消息格式。\n> 2. 用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。\n> 3. 用于在服务器上存储索引的数据结构。\n> 4. IndexLookup 是否同时向多个服务器发出多个请求。\n> 5. 处理服务器崩溃的机制。\n\n---\n\nHere is the original version of the interface comment for the IndexLookup class; the excerpt also includes a few lines from the class’s definition, which are referred to in the comment:\n\n> 这是 IndexLookup 类的接口注释的原始版本；摘录还包括类定义的几行内容，在注释中进行了引用：\n\n```cpp\n/*\n * This class implements the client side framework for index range\n * lookups. It manages a single LookupIndexKeys RPC and multiple\n * IndexedRead RPCs. Client side just includes \"IndexLookup.h\" in\n * its header to use IndexLookup class. Several parameters can be set\n * in the config below:\n * - The number of concurrent indexedRead RPCs\n * - The max number of PKHashes a indexedRead RPC can hold at a time\n * - The size of the active PKHashes\n *\n * To use IndexLookup, the client creates an object of this class by\n * providing all necessary information. After construction of\n * IndexLookup, client can call getNext() function to move to next\n * available object. If getNext() returns NULL, it means we reached\n * the last object. Client can use getKey, getKeyLength, getValue,\n * and getValueLength to get object data of current object.\n */\n class IndexLookup {\n       ...\n   private:\n       /// Max number of concurrent indexedRead RPCs\n       static const uint8_t NUM_READ_RPC = 10;\n       /// Max number of PKHashes that can be sent in one\n       /// indexedRead RPC\n       static const uint32_t MAX_PKHASHES_PERRPC = 256;\n       /// Max number of PKHashes that activeHashes can\n       /// hold at once.\n       static const size_t MAX_NUM_PK = (1 << LG_BUFFER_SIZE);\n }\n```\n\nBefore reading further, see if you can identify the problems with this comment. Here are the problems that I found:\n\n> 在进一步阅读之前，请先查看您是否可以使用此注释确定问题所在。这是我发现的问题：\n\n- Most of the first paragraph concerns the implementation, not the interface. As one example, users don’t need to know the names of the particular remote procedure calls used to communicate with the servers. The configuration parameters referred to in the second half of the first paragraph are all private variables that are relevant only to the maintainer of the class, not to its users. All of this implementation information should be omitted from the comment.\n- The comment also includes several things that are obvious. For example, there’s no need to tell users to include IndexLookup.h: anyone who writes C++ code will be able to guess that this is necessary. In addition, the text “by providing all necessary information” says nothing, so it can be omitted.\n\n---\n\n> - 第一段的大部分与实现有关，而不是接口。举一个例子，用户不需要知道用于与服务器通信的特定远程过程调用的名称。在第一段的后半部分中提到的配置参数都是所有私有变量，它们仅与类的维护者相关，而与类的用户无关。所有这些实现信息都应从注释中省略。\n> - 该评论还包括一些显而易见的事情。例如，不需要告诉用户包括 IndexLookup.h：任何编写 C ++代码的人都可以猜测这是必要的。另外，“通过提供所有必要的信息”一词无语，因此可以省略。\n\nA shorter comment for this class is sufficient (and preferable):\n\n> 对此类的简短评论就足够了（并且更可取）：\n\n```java\n/*\n * This class is used by client applications to make range queries\n * using indexes. Each instance represents a single range query.\n *\n * To start a range query, a client creates an instance of this\n * class. The client can then call getNext() to retrieve the objects\n * in the desired range. For each object returned by getNext(), the\n * caller can invoke getKey(), getKeyLength(), getValue(), and\n * getValueLength() to get information about that object.\n */\n```\n\nThe last paragraph of this comment is not strictly necessary, since it mostly duplicates information in the comments for individual methods. However, it can be helpful to have examples in the class documentation that illustrate how its methods work together, particularly for deep classes with usage patterns that are nonobvious. Note that the new comment does not mention NULL return values from getNext. This comment is not intended to document every detail of each method; it just provides high level information to help readers understand how the methods work together and when each method might be invoked. For details, readers can refer to the interface comments for individual methods. This comment also does not mention server crashes; that is because server crashes are invisible to users of this class (the system automatically recovers from them).\n\n> 此注释的最后一段不是严格必需的，因为它主要针对单个方法复制了注释中的信息。但是，在类文档中提供示例来说明其方法如何协同工作可能会有所帮助，特别是对于使用模式不明显的深层类尤其如此。注意，新注释未提及 getNext 的 NULL 返回值。此注释无意记录每种方法的每个细节；它只是提供高级信息，以帮助读者了解这些方法如何协同工作以及何时可以调用每种方法。有关详细信息，读者可以参考接口注释中的各个方法。此评论也没有提到服务器崩溃；这是因为此类服务器的用户看不到服务器崩溃（系统会自动从中恢复）。\n\nimg Red Flag: Implementation Documentation Contaminates Interface img\n\nThis red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.\n\n> 当接口文档（例如方法的文档）描述了不需要使用要记录的事物的实现详细信息时，就会出现此红色标记。\n\nNow consider the following code, which shows the first version of the documentation for the isReady method in IndexLookup:\n\n> 现在考虑以下代码，该代码显示 IndexLookup 中 isReady 方法的文档的第一版：\n\n```cpp\n/**\n * Check if the next object is RESULT_READY. This function is\n * implemented in a DCFT module, each execution of isReady() tries\n * to make small progress, and getNext() invokes isReady() in a\n * while loop, until isReady() returns true.\n *\n * isReady() is implemented in a rule-based approach. We check\n * different rules by following a particular order, and perform\n * certain actions if some rule is satisfied.\n *\n * \\return\n *         True means the next Object is available. Otherwise, return\n *         false.\n */\nbool IndexLookup::isReady() { ... }\n```\n\nOnce again, most of this documentation, such as the reference to DCFT and the entire second paragraph, concerns the implementation, so it doesn’t belong here; this is one of the most common errors in interface comments. Some of the implementation documentation is useful, but it should go inside the method, where it will be clearly separated from interface documentation. In addition, the first sentence of the documentation is cryptic (what does RESULT_READY mean?) and some important information is missing. Finally, it isn’t necessary to describe the implementation of getNext here. Here is a better version of the comment:\n\n> 再一次，本文档中的大多数内容，例如对 DCFT 的引用以及整个第二段，都与实现有关，因此不属于此处。这是界面注释中最常见的错误之一。某些实现文档很有用，但应放在方法内部，在该方法中应将其与接口文档明确分开。此外，文档的第一句话是含糊的（RESULT_READY 是什么意思？），并且缺少一些重要信息。最后，无需在此处描述 getNext 的实现。这是评论的更好版本：\n\n```java\n/*\n * Indicates whether an indexed read has made enough progress for\n * getNext to return immediately without blocking. In addition, this\n * method does most of the real work for indexed reads, so it must\n * be invoked (either directly, or indirectly by calling getNext) in\n * order for the indexed read to make progress.\n *\n * \\return\n *         True means that the next invocation of getNext will not block\n *         (at least one object is available to return, or the end of the\n *         lookup has been reached); false means getNext may block.\n */\n```\n\nThis version of the comment provides more precise information about what “ready” means, and it provides the important information that this method must eventually be invoked if the indexed retrieval is to move forward.\n\n> 此注释版本提供了有关“就绪”含义的更精确信息，并且提供了重要信息，如果要继续进行索引检索，则必须最终调用此方法。\n\n## 13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何\n\nImplementation comments are the comments that appear inside methods to help readers understand how they work internally. Most methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.\n\n> 实现注释是出现在方法内部的注释，以帮助读者了解它们在内部的工作方式。大多数方法是如此简短，简单，以至于它们不需要任何实现注释：有了代码和接口注释，就很容易弄清楚方法的工作原理。\n\nThe main goal of implementation comments is to help readers understand what the code is doing (not how it does it). Once readers know what the code is trying to do, it’s usually easy to understand how the code works. For short methods, the code only does one thing, which is already described in its interface comment, so no implementation comments are needed. Longer methods have several blocks of code that do different things as part of the method’s overall task. Add a comment before each of the major blocks to provide a high-level (more abstract) description of what that block does. Here is an example:\n\n> 实现注释的主要目的是帮助读者理解代码在做什么（而不是代码如何工作）。一旦读者知道了代码要做什么，通常就很容易理解代码的工作原理。对于简短的方法，代码只做一件事，该问题已在其接口注释中进行了描述，因此不需要实现注释。较长的方法具有多个代码块，这些代码块作为方法的整体任务的一部分执行不同的操作。在每个主要块之前添加注释，以提供对该块的作用的高级（更抽象）描述。这是一个例子：\n\n```java\n// Phase 1: Scan active RPCs to see if any have completed.\n```\n\nFor loops, it’s helpful to have a comment before the loop that describes what happens in each iteration:\n\n> 对于循环，在循环前加一个注释来描述每次迭代中发生的事情是有帮助的：\n\n```java\n// Each iteration of the following loop extracts one request from\n// the request message, increments the corresponding object, and\n// appends a response to the response message.\n```\n\nNotice how this comment describes the loop at a more abstract and intuitive level; it doesn’t go into any details about how a request is extracted from the request message or how the object is incremented. Loop comments are only needed for longer or more complex loops, where it may not be obvious what the loop is doing; many loops are short and simple enough that their behavior is already obvious.\n\n> 请注意，此注释如何更抽象和直观地描述循环。它没有详细介绍如何从请求消息中提取请求或对象如何递增。仅对于更长或更复杂的循环才需要循环注释，在这种情况下，循环的作用可能并不明显。许多循环足够短且简单，以至于其行为已经很明显。\n\nIn addition to describing what the code is doing, implementation comments are also useful to explain why. If there are tricky aspects to the code that won’t be obvious from reading it, you should document them. For example, if a bug fix requires the addition of code whose purpose isn’t totally obvious, add a comment describing why the code is needed. For bug fixes where there is a well-written bug report describing the problem, the comment can refer to the issue in the bug tracking database rather than repeating all its details (“Fixes RAM-436, related to device driver crashes in Linux 2.4.x”). Developers can look in the bug database for more details (this is an example of avoiding duplication in comments, which will be discussed in Chapter 16).\n\n> 除了描述代码在做什么之外，实现注释还有助于解释原因。如果代码中有些棘手的方面从阅读中看不出来，则应将它们记录下来。例如，如果一个错误修复程序需要添加目的不是很明显的代码，请添加注释以说明为什么需要该代码。对于错误修复，其中有写得很好的错误报告来描述问题，该注释可以引用错误跟踪数据库中的问题，而不是重复其所有详细信息（“修复 RAM-436，与 Linux 2.4 中的设备驱动程序崩溃有关。” X”）。开发人员可以在 bug 数据库中查找更多详细信息（这是一个避免注释重复的示例，这将在第 16 章中进行讨论）。\n\nFor longer methods, it can be helpful to write comments for a few of the most important local variables. However, most local variables don’t need documentation if they have good names. If all of the uses of a variable are visible within a few lines of each other, it’s usually easy to understand the variable’s purpose without a comment. In this case it’s OK to let readers read the code to figure out the meaning of the variable. However, if the variable is used over a large span of code, then you should consider adding a comment to describe the variable. When documenting variables, focus on what the variable represents, not how it is manipulated in the code.\n\n> 对于更长的方法，为一些最重要的局部变量写注释会很有帮助。但是，如果大多数局部变量具有好名字，则不需要文档。如果变量的所有用法在几行之内都是可见的，则通常无需注释即可轻松理解变量的用途。在这种情况下，可以让读者阅读代码来弄清楚变量的含义。但是，如果在大量代码中使用了该变量，则应考虑添加注释以描述该变量。在记录变量时，应关注变量表示的内容，而不是代码中如何对其进行操作。\n\n## 13.7 Cross-module design decisions 跨模块设计决策\n\nIn a perfect world, every important design decision would be encapsulated within a single class. Unfortunately, real systems inevitably end up with design decisions that affect multiple classes. For example, the design of a network protocol will affect both the sender and the receiver, and these may be implemented in different places. Cross-module decisions are often complex and subtle, and they account for many bugs, so good documentation for them is crucial.\n\n> 在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。\n\nThe biggest challenge with cross-module documentation is finding a place to put it where it will naturally be discovered by developers. Sometimes there is an obvious central place to put such documentation. For example, the RAMCloud storage system defines a Status value, which is returned by each request to indicate success or failure. Adding a Status for a new error condition requires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on). Fortunately, there is one obvious place where developers will have to go when adding a new status value, which is the declaration of the Status enum. We took advantage of this by adding comments in that enum to identify all of the other places that must also be modified:\n\n> 跨模块文档的最大挑战是找到一个放置它的位置，以便开发人员自然地发现它。有时，放置此类文档的中心位置很明显。例如，RAMCloud 存储系统定义一个状态值，每个请求均返回该状态值以指示成功或失败。为新的错误状况添加状态需要修改许多不同的文件（一个文件将状态值映射到异常，另一个文件为每个状态提供人类可读的消息，依此类推）。幸运的是，添加新的状态值（即 Status 枚举的声明）时，开发人员必须去一个明显的地方。我们通过在该枚举中添加注释来标识所有其他必须修改的地方，从而利用了这一点：在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。\n\n```cpp\ntypedef enum Status {\n    STATUS_OK = 0,\n    STATUS_UNKNOWN_TABLET                = 1,\n    STATUS_WRONG_VERSION                 = 2,\n    ...\n    STATUS_INDEX_DOESNT_EXIST            = 29,\n    STATUS_INVALID_PARAMETER             = 30,\n    STATUS_MAX_VALUE                     = 30,\n    // Note: if you add a new status value you must make the following\n    // additional updates:\n    // (1)  Modify STATUS_MAX_VALUE to have a value equal to the\n    //      largest defined status value, and make sure its definition\n    //      is the last one in the list. STATUS_MAX_VALUE is used\n    //      primarily for testing.\n    // (2)  Add new entries in the tables \"messages\" and \"symbols\" in\n    //      Status.cc.\n    // (3)  Add a new exception class to ClientException.h\n    // (4)  Add a new \"case\" to ClientException::throwException to map\n    //      from the status value to a status-specific ClientException\n    //      subclass.\n    // (5)  In the Java bindings, add a static class for the exception\n    //      to ClientException.java\n    // (6)  Add a case for the status of the exception to throw the\n    //      exception in ClientException.java\n    // (7)  Add the exception to the Status enum in Status.java, making\n    //      sure the status is in the correct position corresponding to\n    //      its status code.\n}\n```\n\nNew status values will be added at the end of the existing list, so the comments are also placed at the end, where they are most likely to be seen.\n\n> 新状态值将添加到现有列表的末尾，因此注释也将放置在最有可能出现的末尾。\n\nUnfortunately, in many cases there is not an obvious central place to put cross-module documentation. One example from the RAMCloud storage system was the code for dealing with zombie servers, which are servers that the system believes have crashed, but in fact are still running. Neutralizing zombie servers required code in several different modules, and these pieces of code all depend on each other. None of the pieces of code is an obvious central place to put documentation. One possibility is to duplicate parts of the documentation in each location that depends on it. However, this is awkward, and it is difficult to keep such documentation up to date as the system evolves. Alternatively, the documentation can be located in one of the places where it is needed, but in this case it’s unlikely that developers will see the documentation or know where to look for it.\n\n> 不幸的是，在许多情况下，并没有一个明显的中心位置来放置跨模块文档。RAMCloud 存储系统中的一个例子是处理僵尸服务器的代码，僵尸服务器是系统认为已经崩溃但实际上仍在运行的服务器。中和 zombie server 需要几个不同模块中的代码，这些代码都相互依赖。没有一段代码明显是放置文档的中心位置。一种可能性是在每个依赖文档的位置复制文档的部分。然而，这是令人尴尬的，并且随着系统的发展，很难使这样的文档保持最新。或者，文档可以位于需要它的位置之一，但是在这种情况下，开发人员不太可能看到文档或者知道在哪里查找它。\n\nI have recently been experimenting with an approach where cross-module issues are documented in a central file called designNotes. The file is divided up into clearly labeled sections, one for each major topic. For example, here is an excerpt from the file:\n\n> 我最近一直在尝试一种方法，该方法将跨模块问题记录在一个名为 designNotes 的中央文件中。该文件分为清楚标记的部分，每个主要主题一个。例如，以下是该文件的摘录：\n\n```\n...\nZombies\n-------\nA zombie is a server that is considered dead by the rest of the\ncluster; any data stored on the server has been recovered and will\nbe managed by other servers. However, if a zombie is not actually\ndead (e.g., it was just disconnected from the other servers for a\nwhile) two forms of inconsistency can arise:\n* A zombie server must not serve read requests once replacement servers have taken over; otherwise it may return stale data that does not reflect writes accepted by the replacement servers.\n* The zombie server must not accept write requests once replacement servers have begun replaying its log during recovery; if it does, these writes may be lost (the new values may not be stored on the replacement servers and thus will not be returned by reads).\n\nRAMCloud uses two techniques to neutralize zombies. First,\n...\n```\n\nThen, in any piece of code that relates to one of these issues there is a short comment referring to the designNotes file:\n\n> 然后，在与这些问题之一相关的任何代码段中，都有一条简短的注释引用了 designNotes 文件：\n\n```c\n// See \"Zombies\" in designNotes.\n```\n\nWith this approach, there is only a single copy of the documentation and it is relatively easy for developers to find it when they need it. However, this has the disadvantage that the documentation is not near any of the pieces of code that depend on it, so it may be difficult to keep up-to-date as the system evolves.\n\n> 使用这种方法，文档只有一个副本，因此开发人员在需要时可以相对容易地找到它。但是，这样做的缺点是，文档离它依赖的任何代码段都不近，因此随着系统的发展，可能难以保持最新。\n\n## 13.8 Conclusion 结论\n\nThe goal of comments is to ensure that the structure and behavior of the system is obvious to readers, so they can quickly find the information they need and make modifications to the system with confidence that they will work. Some of this information can be represented in the code in a way that will already be obvious to readers, but there is a significant amount of information that can’t easily be deduced from the code. Comments fill in this information.\n\n> 评论的目的是确保系统的结构和行为对读者来说是显而易见的，因此他们可以快速找到所需的信息，并有信心对其进行修改，以对系统进行修改。这些信息中的某些信息可以以对读者来说显而易见的方式表示在代码中，但是有大量信息无法从代码中轻易推导出。注释将填写此信息。\n\nWhen following the rule that comments should describe things that aren’t obvious from the code, “obvious” is from the perspective of someone reading your code for the first time (not you). When writing comments, try to put yourself in the mindset of the reader and ask yourself what are the key things he or she will need to know. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious. Instead of arguing, try to understand what they found confusing and see if you can clarify that, either with better comments or better code.\n\n> 当遵循注释应描述代码中不明显的内容的规则时，“明显”是从第一次读取您的代码的人（不是您）的角度出发。在撰写评论时，请尝试使自己进入读者的心态，并问自己他或她需要知道哪些关键事项。如果您的代码正在接受审核，并且审核者告诉您某些不明显的内容，请不要与他们争论。如果读者认为它不明显，那么它就不明显。不用争论，而是尝试了解他们发现的令人困惑的地方，并查看是否可以通过更好的注释或更好的代码来澄清它们。\n\n## 13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题\n\nDoes a developer need to know each of the following pieces of information in order to use the IndexLookup class?\n\n> 开发人员是否需要了解以下每条信息才能使用 IndexLookup 类？\n\n1. The format of messages that the IndexLookup class sends to the servers holding indexes and objects. No: this is an implementation detail that should be hidden within the class.\n2. The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?). Yes: users of the class need to know this information.\n3. The data structure used to store indexes on servers. No: this information should be encapsulated on the servers; not even the implementation of IndexLookup should need to know this.\n4. Whether or not IndexLookup issues multiple requests to different servers concurrently. Possibly: if IndexLookup uses special techniques to improve performance, then the documentation should provide some high-level information about this, since users may care about performance.\n5. The mechanism for handling server crashes. No: RAMCloud recovers automatically from server crashes, so crashes are not visible to application-level software; thus, there is no need to mention crashes in the interface documentation for IndexLookup. If crashes were reflected up to applications, then the interface documentation would need to describe how they manifest themselves (but not the details of how crash recovery works).\n\n---\n\n> 1. IndexLookup 类发送给包含索引和对象的服务器的消息格式。否：这是应隐藏在类中的实现细节。\n> 2. 用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。是：该课程的用户需要了解此信息。\n> 3. 用于在服务器上存储索引的数据结构。否：此信息应封装在服务器上；甚至 IndexLookup 的实现都不需要知道这一点。\n> 4. IndexLookup 是否同时向多个服务器发出多个请求。可能：如果 IndexLookup 使用特殊技术来提高性能，则文档应提供有关此问题的一些高级信息，因为用户可能会在意性能。\n> 5. 处理服务器崩溃的机制。否：RAMCloud 可从服务器崩溃中自动恢复，因此崩溃对于应用程序级软件不可见；因此，在 IndexLookup 的接口文档中无需提及崩溃。如果崩溃反映到应用程序中，则接口文档将需要描述它们如何表现出来（而不是崩溃恢复如何工作的详细信息）。\n","source":"_posts/软件设计的哲学-ch13.md","raw":"---\ntitle: 软件设计的哲学 - ch13\ndate: 2021-02-13\ntags: 软件设计的哲学 软件开发 方法论\n---\n注释应该描述代码中不明显的内容\n<!-- more -->\n# 第 13 章 注释应该描述代码中不明显的内容\n\n> Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code\n\nThe reason for writing comments is that statements in a programming language can’t capture all of the important information that was in the mind of the developer when the code was written. Comments record this information so that developers who come along later can easily understand and modify the code. The guiding principle for comments is that comments should describe things that aren’t obvious from the code.\n\n> 编写注释的原因是，使用编程语言编写的语句无法捕获编写代码时开发人员想到的所有重要信息。注释记录了这些信息，以便后来的开发人员可以轻松地理解和修改代码。注释的指导原则是，注释应描述代码中不明显的内容。\n\nThere are many things that aren’t obvious from the code. Sometimes it’s low-level details that aren’t obvious. For example, when a pair of indices describe a range, it isn’t obvious whether the elements given by the indices are inside the range or out. Sometimes it’s not clear why code is needed, or why it was implemented in a particular way. Sometimes there are rules the developer followed, such as “always invoke a before b.” You might be able to guess at a rule by looking at all of the code, but this is painful and error-prone; a comment can make the rule explicit and clear.\n\n> 从代码中看不到很多事情。有时，底层细节并不明显。例如，当一对索引描述一个范围时，由索引给出的元素是在范围之内还是之外并不明显。有时不清楚为什么需要代码，或者为什么要以特定方式实现代码。有时，开发人员遵循一些规则，例如“总是在 b 之前调用 a”。您可能可以通过查看所有代码来猜测规则，但这很痛苦且容易出错。注释可以使规则清晰明了。\n\nOne of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code. The idea of an abstraction is to provide a simple way of thinking about something, but code is so detailed that it can be hard to see the abstraction just from reading the code. Comments can provide a simpler, higher-level view (“after this method is invoked, network traffic will be limited to maxBandwidth bytes per second”). Even if this information can be deduced by reading the code, we don’t want to force users of a module to do that: reading the code is time-consuming and forces them to consider a lot of information that isn’t needed to use the module. Developers should be able to understand the abstraction provided by a module without reading any code other than its externally visible declarations. The only way to do this is by supplementing the declarations with comments.\n\n> 注释的最重要原因之一是抽象，其中包括许多从代码中看不到的信息。抽象的思想是提供一种思考问题的简单方法，但是代码是如此详细，以至于仅通过阅读代码就很难看到抽象。注释可以提供一个更简单，更高级的视图（“调用此方法后，网络流量将被限制为每秒 maxBandwidth 字节”）。即使可以通过阅读代码推断出此信息，我们也不想强迫模块用户这样做：阅读代码很耗时，并且迫使他们考虑很多不需要使用的信息模块。开发人员应该能够理解模块提供的抽象，而无需阅读其外部可见声明以外的任何代码。\n\nThis chapter discusses what information needs to be described in comments and how to write good comments. As you will see, good comments typically explain things at a different level of detail than the code, which is more detailed in some situations and less detailed (more abstract) in others.\n\n> 本章讨论需要在注释中描述哪些信息以及如何编写良好的注释。就像您将看到的那样，好的注释通常以与代码不同的详细程度来解释事物，在某些情况下，注释会更详细，而在某些情况下，代码则较不抽象（更抽象）。\n\n## 13.1 Pick conventions\n\nThe first step in writing comments is to decide on conventions for commenting, such as what you will comment and the format you will use for comments. If you are programming in a language for which there exists a document compilation tool, such as Javadoc for Java, Doxygen for C++, or godoc for Go!, follow the conventions of the tools. None of these conventions is perfect, but the tools provide enough benefits to make up for that. If you are programming in an environment where there are no existing conventions to follow, try to adopt the conventions from some other language or project that is similar; this will make it easier for other developers to understand and adhere to your conventions.\n\n> 编写注释的第一步是确定注释的约定，例如您要注释的内容和注释的格式。如果您正在使用存在文档编译工具的语言进行编程，例如 Java 的 Javadoc，C ++的 Doxygen 或 Go！的 godoc，请遵循工具的约定。这些约定都不是完美的，但是这些工具可提供足够的好处来弥补这一缺点。如果在没有现有约定可遵循的环境中进行编程，请尝试从其他类似的语言或项目中采用这些约定；这将使其他开发人员更容易理解和遵守您的约定。\n\nConventions serve two purposes. First, they ensure consistency, which makes comments easier to read and understand. Second, they help to ensure that you actually write comments. If you don’t have a clear idea what you are going to comment and how, it’s easy to end up writing no comments at all.\n\n> 约定有两个目的。首先，它们确保一致性，这使得注释更易于阅读和理解。其次，它们有助于确保您实际编写评论。如果您不清楚要发表的评论以及发表评论的方式，那么很容易最终根本不发表评论。\n\nMost comments fall into one of the following categories:\n\n> 大多数评论属于以下类别之一：\n\nInterface: a comment block that immediately precedes the declaration of a module such as a class, data structure, function, or method. The comment describe’s the module’s interface. For a class, the comment describes the overall abstraction provided by the class. For a method or function, the comment describes its overall behavior, its arguments and return value, if any, any side effects or exceptions that it generates, and any other requirements the caller must satisfy before invoking the method.\n\n> 接口：在模块声明（例如类，数据结构，函数或方法）之前的注释块。注释描述模块的接口。对于一个类，注释描述了该类提供的整体抽象。对于方法或函数，注释描述其整体行为，其参数和返回值（如果有），其生成的任何副作用或异常，以及调用者在调用该方法之前必须满足的任何其他要求。\n\nData structure member: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.\n\n> 数据结构成员：数据结构中字段声明旁边的注释，例如类的实例变量或静态变量。\n\nImplementation comment: a comment inside the code of a method or function, which describes how the code works internally.\n\n> 实现注释：方法或函数代码内部的注释，它描述代码在内部的工作方式。\n\nCross-module comment: a comment describing dependencies that cross module boundaries.\n\n> 跨模块注释：描述跨模块边界的依赖项的注释。\n\nThe most important comments are those in the first two categories. Every class should have an interface comment, every class variable should have a comment, and every method should have an interface comment. Occasionally, the declaration for a variable or method is so obvious that there is nothing useful to add in a comment (getters and setters sometimes fall in this category), but this is rare; it is easier to comment everything rather than spend energy worrying about whether a comment is needed. Implementation comments are often unnecessary (see Section 13.6 below). Cross-module comments are the most rare of all and they are problematic to write, but when they are needed they are quite important; Section 13.7 discusses them in more detail.\n\n> 最重要的评论是前两个类别中的评论。每个类都应有一个接口注释，每个类变量应有一个注释，每个方法都应有一个接口注释。有时，变量或方法的声明是如此明显，以至于在注释中没有添加任何有用的东西（getter 和 setter 有时都属于此类），但这很少见。评论所有内容要比花精力担心是否需要评论要容易得多。实施注释通常是不必要的（请参阅下面的 13.6 节）。跨模块注释是最罕见的，而且编写起来很成问题，但是当需要它们时，它们就很重要。第 13.7 节将更详细地讨论它们。\n\n## 13.2 Don’t repeat the code 不要重复代码\n\nUnfortunately, many comments are not particularly helpful. The most common reason is that the comments repeat the code: all of the information in the comment can easily be deduced from the code next to the comment. Here is a code sample that appeared in a recent research paper:\n\n> 不幸的是，许多评论并不是特别有用。最常见的原因是注释重复了代码：可以轻松地从注释旁边的代码中推断出注释中的所有信息。这是最近研究论文中出现的代码示例：\n\n```sh\nptr_copy = get_copy(obj)            # Get pointer copy\nif is_unlocked(ptr_copy):           # Is obj free?\n    return obj                      # return current obj\nif is_copy(ptr_copy):               # Already a copy?\n    return obj                      # return obj\nthread_id = get_thread_id(ptr_copy)\nif thread_id == ctx.thread_id:      # Locked by current ctx\n    return ptr_copy                 # Return copy\n```\n\nThere is no useful information in any of these comments except for the “Locked by” comment, which suggests something about the thread that might not be obvious from the code. Notice that these comments are at roughly the same level of detail as the code: there is one comment per line of code, which describes that line. Comments like this are rarely useful.\n\n> 这些注释中没有任何有用的信息，但“ Locked by”注释除外，该注释暗示了有关线程的某些信息可能在代码中并不明显。请注意，这些注释的详细程度与代码大致相同：每行代码有一个注释，用于描述该行。这样的注释很少有用。\n\nHere are more examples of comments that repeat the code:\n\n> 以下是重复代码的注释的更多示例：\n\n```java\n// Add a horizontal scroll bar\nhScrollBar = new JScrollBar(JScrollBar.HORIZONTAL);\nadd(hScrollBar, BorderLayout.SOUTH);\n\n// Add a vertical scroll bar\nvScrollBar = new JScrollBar(JScrollBar.VERTICAL);\nadd(vScrollBar, BorderLayout.EAST);\n\n// Initialize the caret-position related values\ncaretX     = 0;\ncaretY     = 0;\ncaretMemX  = null;\n```\n\nNone of these comments provide any value. For the first two comments, the code is already clear enough that it doesn’t really need comments; in the third case, a comment might be useful, but the current comment doesn’t provide enough detail to be helpful.\n\n> 这些评论均未提供任何价值。对于前两个注释，代码已经很清楚了，它实际上不需要注释。在第三种情况下，注释可能有用，但是当前注释没有提供足够的细节来提供帮助。\n\nAfter you have written a comment, ask yourself the following question: could someone who has never seen the code write the comment just by looking at the code next to the comment? If the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand. Comments like these are why some people think that comments are worthless.\n\n> 编写评论后，请问自己以下问题：从未看过代码的人能否仅通过查看评论旁边的代码来编写评论？如果答案是肯定的（如上述示例所示），则注释不会使代码更易于理解。像这样的评论是为什么有些人认为评论毫无价值的原因。\n\nAnother common mistake is to use the same words in the comment that appear in the name of the entity being documented:\n\n> 另一个常见的错误是在注释中使用与要记录的实体名称相同的词：\n\n```java\n/*\n * Obtain a normalized resource name from REQ.\n */\nprivate static String[] getNormalizedResourceNames(\n            HTTPRequest req) ...\n/*\n * Downcast PARAMETER to TYPE.\n */\nprivate static Object downCastParameter(String parameter, String type) ...\n/*\n * The horizontal padding of each line in the text.\n */\nprivate static final int textHorizontalPadding = 4;\n```\n\nThese comments just take the words from the method or variable name, perhaps add a few words from argument names and types, and form them into a sentence. For example, the only thing in the second comment that isn’t in the code is the word “to”! Once again, these comments could be written just by looking at the declarations, without any understanding the methods of variables; as a result, they have no value.\n\n> 这些注释只是从方法或变量名中提取单词，或者从参数名称和类型中添加几个单词，然后将它们组成一个句子。例如，第二个注释中唯一不在代码中的是单词“ to”！再说一次，这些注释可以仅通过查看声明来编写，而无需任何了解变量的方法。结果，它们没有价值。\n\nimg Red Flag: Comment Repeats Code img\n\nIf the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful. One example of this is when the comment uses the same words that make up the name of the thing it is describing.\n\n> 如果注释旁边的代码中的注释信息已经很明显，则注释无济于事。这样的一个例子是，当注释使用与所描述事物名称相同的单词时。\n\nAt the same time, there is important information that is missing from the comments: for example, what is a “normalized resource name”, and what are the elements of the array returned by getNormalizedResourceNames? What does “downcast” mean? What are the units of padding, and is the padding on one side of each line or both? Describing these things in comments would be helpful.\n\n> 同时，注释中缺少一些重要信息：例如，什么是“标准化资源名称”，以及 getNormalizedResourceNames 返回的数组的元素是什么？“贬低”是什么意思？填充的单位是什么，填充是在每行的一侧还是在两者的两侧？在注释中描述这些内容将很有帮助。\n\nA first step towards writing good comments is to use different words in the comment from those in the name of the entity being described. Pick words for the comment that provide additional information about the meaning of the entity, rather than just repeating its name. For example, here is a better comment for textHorizontalPadding:\n\n> 编写良好评论的第一步是在评论中使用与所描述实体名称不同的词。为注释选择单词，以提供有关实体含义的更多信息，而不仅仅是重复其名称。例如，以下是针对 textHorizo​​ntalPadding 的更好注释：\n\n```java\n/*\n * The amount of blank space to leave on the left and\n * right sides of each line of text, in pixels.\n */\nprivate static final int textHorizontalPadding = 4;\n```\n\nThis comment provides additional information that is not obvious from the declaration itself, such as the units (pixels) and the fact that padding applies to both sides of each line. Instead of using the term “padding”, the comment explains what padding is, in case the reader isn’t already familiar with the term.\n\n> 该注释提供了从声明本身不明显的其他信息，例如单位（像素）以及填充适用于每行两边的事实。如果读者不熟悉该术语，则注释将解释什么是填充，而不是使用术语“填充”。\n\n## 13.3 Lower-level comments add precision 低级注释可提高精度\n\nNow that you know what not to do, let’s discuss what information you should put in comments. Comments augment the code by providing information at a different level of detail. Some comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code. Other comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code. Comments at the same level as the code are likely to repeat the code. This section discusses the lower-level approach in more detail, and the next section discusses the higher-level approach.\n\n> 现在您知道了不应该做的事情，让我们讨论应该在注释中添加哪些信息。注释通过提供不同详细程度的信息来增强代码。一些注释提供了比代码更低，更详细的信息。这些注释通过阐明代码的确切含 ​​ 义来增加精度。其他注释提供了比代码更高，更抽象的信息。这些注释提供了直觉，例如代码背后的推理，或者更简单，更抽象的代码思考方式。与代码处于同一级别的注释可能会重复该代码。本节将更详细地讨论下层方法，而下一节将讨论上层方法。\n\nPrecision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and type in a variable declaration are typically not very precise. Comments can fill in missing details such as:\n\n> 在注释变量声明（例如类实例变量，方法参数和返回值）时，精度最有用。变量声明中的名称和类型通常不是很精确。注释可以填写缺少的详细信息，例如：\n\n- What are the units for this variable?\n- Are the boundary conditions inclusive or exclusive?\n- If a null value is permitted, what does it imply?\n- If a variable refers to a resource that must eventually be freed or closed, who is responsible for freeing or closing it?\n- Are there certain properties that are always true for the variable (invariants), such as “this list always contains at least one entry”?\n\n---\n\n> - 此变量的单位是什么？\n> - 边界条件是包容性还是排他性？\n> - 如果允许使用空值，则意味着什么？\n> - 如果变量引用了最终必须释放或关闭的资源，那么谁负责释放或关闭该资源？\n> - 是否存在某些对于变量始终不变的属性（不变量），例如“此列表始终包含至少一个条目”？\n\nSome of this information could potentially be figured out by examining all of the code where the variable is used. However, this is time-consuming and error-prone; the declaration’s comment should be clear and complete enough to make this unnecessary. When I say that the comment for a declaration should describe things that aren’t obvious from the code, “the code” refers to the code next to the comment (the declaration), not “all of the code in the application.”\n\n> 通过检查使用该变量的所有代码，可以潜在地了解某些信息。但是，这很耗时且容易出错。宣言的评论应清晰，完整，以免不必要。当我说声明的注释应描述代码中不明显的内容时，“代码”是指注释（声明）旁边的代码，而不是“应用程序中的所有代码”。\n\nThe most common problem with comments for variables is that the comments are too vague. Here are two examples of comments that aren’t precise enough:\n\n> 变量注释最常见的问题是注释太模糊。这是两个不够精确的注释示例：\n\n```java\n// Current offset in resp Buffer\nuint32_t offset;\n\n// Contains all line-widths inside the document and\n// number of appearances.\nprivate TreeMap<Integer, Integer> lineWidths;\n```\n\nIn the first example, it’s not clear what “current” means. In the second example, it’s not clear that the keys in the TreeMap are line widths and values are occurrence counts. Also, are widths measured in pixels or characters? The revised comments below provide additional details:\n\n> 在第一个示例中，尚不清楚“当前”的含义。在第二个示例中，尚不清楚 TreeMap 中的键是线宽，值是出现次数。另外，宽度是以像素或字符为单位测量的吗？以下修订后的注释提供了更多详细信息：\n\n```java\n//  Position in this buffer of the first object that hasn't\n//  been returned to the client.\nuint32_t offset;\n\n//  Holds statistics about line lengths of the form <length, count>\n//  where length is the number of characters in a line (including\n//  the newline), and count is the number of lines with\n//  exactly that many characters. If there are no lines with\n//  a particular length, then there is no entry for that length.\nprivate TreeMap<Integer, Integer> numLinesWithLength;\n```\n\nThe second declaration uses a longer name that conveys more information. It also changes “width” to “length”, because this term is more likely to make people think that the units are characters rather than pixels. Notice that the second comment documents not only the details of each entry, but also what it means if an entry is missing.\n\n> 第二个声明使用一个较长的名称来传达更多信息。它还将“宽度”更改为“长度”，因为该术语更可能使人们认为单位是字符而不是像素。请注意，第二条注释不仅记录了每个条目的详细信息，还记录了缺少条目的含义。\n\nWhen documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated. Consider the following comment:\n\n> 在记录变量时，请考虑名词而不是动词。换句话说，关注变量代表什么，而不是如何操纵变量。考虑以下评论：\n\n```java\n/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and the\n * PeriodicTasks thread to communicate about whether a heartbeat has been\n * received within the follower's election timeout window.\n * Toggled to TRUE when a valid heartbeat is received.\n * Toggled to FALSE when the election timeout window is reset.  */\nprivate boolean receivedValidHeartbeat;\n```\n\nThis documentation describes how the variable is modified by several pieces of code in the class. The comment will be both shorter and more useful if it describes what the variable represents rather than mirroring the code structure:\n\n> 本文档描述了如何通过类中的几段代码来修改变量。如果注释描述变量代表什么而不是镜像代码结构，则注释将更短且更有用：\n\n```java\n/* True means that a heartbeat has been received since the last time\n * the election timer was reset. Used for communication between the\n * Receiver and PeriodicTasks threads.  */\nprivate boolean receivedValidHeartbeat;\n```\n\nGiven this documentation, it’s easy to infer that the variable must be set to true when a heartbeat is received and false when the election timer is reset.\n\n> 根据本文档，很容易推断出，当接收到心跳信号时，变量必须设置为 true；而当重置选举计时器时，则必须将变量设置为 false。\n\n## 13.4 Higher-level comments enhance intuition 高级注释可增强直觉\n\nThe second way in which comments can augment code is by providing intuition. These comments are written at a higher level than the code. They omit details and help the reader to understand the overall intent and structure of the code. This approach is commonly used for comments inside methods, and for interface comments. For example, consider the following code:\n\n> 注释可以增加代码的第二种方法是提供直觉。这些注释是在比代码更高的级别上编写的。它们忽略了细节，并帮助读者理解了代码的整体意图和结构。此方法通常用于方法内部的注释以及接口注释。例如，考虑以下代码：\n\n```java\n// If there is a LOADING readRpc using the same session\n// as PKHash pointed to by assignPos, and the last PKHash\n// in that readRPC is smaller than current assigning\n// PKHash, then we put assigning PKHash into that readRPC.\nint readActiveRpcId = RPC_ID_NOT_ASSIGNED;\nfor (int i = 0; i < NUM_READ_RPC; i++) {\n    if (session == readRpc[i].session\n            && readRpc[i].status == LOADING\n            && readRpc[i].maxPos < assignPos\n            && readRpc[i].numHashes < MAX_PKHASHES_PERRPC) {\n        readActiveRpcId = i;\n        break;\n    }\n}\n```\n\nThe comment is too low-level and detailed. On the one hand, it partially repeats the code: “if there is a LOADING readRPC” just duplicates the test `readRpc[i].status == LOADING`. On the other hand, the comment doesn’t explain the overall purpose of this code, or how it fits into the method that contains it. As a result, the comment doesn’t help the reader to understand the code.\n\n> 该评论太底层和太详细。一方面，它部分重复了代码：“如果有 LOADING readRPC”仅重复测试 `readRpc[i].status == LOADING`。另一方面，注释不能解释此代码的总体目的，也不能解释其如何适合包含此代码的方法。如此一来注释不能帮助读者理解代码。\n\nHere is a better comment:\n\n> 这是一个更好的评论：\n\n```java\n// Try to append the current key hash onto an existing\n// RPC to the desired server that hasn't been sent yet.\n```\n\nThis comment doesn’t contain any details; instead, it describes the code’s overall function at a higher level. With this high-level information, a reader can explain almost everything that happens in the code: the loop must be iterating over all the existing remote procedure calls (RPCs); the session test is probably used to see if a particular RPC is destined for the right server; the LOADING test suggests that RPCs can have multiple states, and in some states it isn’t safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how many hashes can be sent in a single RPC. The only thing not explained by the comment is the maxPos test. Furthermore, the new comment provides a basis for readers to judge the code: does it do everything that is needed to add the key hash to an existing RPC? The original comment didn’t describe the overall intent of the code, so it’s hard for a reader to decide whether the code is behaving correctly.\n\n> 此评论不包含任何详细信息。相反，它在更高级别上描述了代码的整体功能。有了这些高级信息，读者就可以解释代码中几乎发生的所有事情：循环必须遍历所有现有的远程过程调用（RPC）；会话测试可能用于查看特定的 RPC 是否发往正确的服务器；LOADING 测试表明 RPC 可以具有多个状态，在某些状态下添加更多的哈希值是不安全的；MAX-PKHASHES_PERRPC 测试表明在单个 RPC 中可以发送多少个哈希值是有限制的。注释中唯一没有解释的是 maxPos 测试。此外，新注释为读者判断代码提供了基础：它可以完成将密钥哈希添加到现有 RPC 所需的一切吗？原始注释并未描述代码的整体意图，因此，读者很难确定代码是否行为正确。\n\nHigher-level comments are more difficult to write than lower-level comments because you must think about the code in a different way. Ask yourself: What is this code trying to do? What is the simplest thing you can say that explains everything in the code? What is the most important thing about this code?\n\n> 高级别的注释比低级别的注释更难编写，因为您必须以不同的方式考虑代码。问问自己：这段代码要做什么？您能说什么最简单的东西来解释代码中的所有内容？这段代码最重要的是什么？\n\nEngineers tend to be very detail-oriented. We love details and are good at managing lots of them; this is essential for being a good engineer. But, great software designers can also step back from the details and think about a system at a higher level. This means deciding which aspects of the system are most important, and being able to ignore the low-level details and think about the system only in terms of its most fundamental characteristics. This is the essence of abstraction (finding a simple way to think about a complex entity), and it’s also what you must do when writing higher-level comments. A good higher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as “append to an existing RPC.” Given the framework, it becomes easy to see how specific code statements relate to the overall goal.\n\n> 工程师往往非常注重细节。我们喜欢细节，善于管理其中的许多细节；这对于成为一名优秀的工程师至关重要。但是，优秀的软件设计师也可以从细节退后一步，从更高层次考虑系统。这意味着要确定系统的哪些方面最重要，并且能够忽略底层细节，仅根据系统的最基本特征来考虑系统。这是抽象的本质（找到一种思考复杂实体的简单方法），这也是编写高级注释时必须执行的操作。一个好的高层注释表达了一个或几个简单的想法，这些想法提供了一个概念框架，例如“附加到现有的 RPC”。使用该框架，可以很容易地看到特定的代码语句与总体目标之间的关系。\n\nHere is another code sample, which has a good higher-level comment:\n\n> 这是另一个代码示例，具有较高层次的注释：\n\n```java\nif (numProcessedPKHashes < readRpc[i].numHashes) {\n    // Some of the key hashes couldn't be looked up in\n    // this request (either because they aren't stored\n    // on the server, the server crashed, or there\n    // wasn't enough space in the response message).\n    // Mark the unprocessed hashes so they will get\n    // reassigned to new RPCs.\n    for (size_t p = removePos; p < insertPos; p++) {\n        if (activeRpcId[p] == i) {\n            if (numProcessedPKHashes > 0) {\n                numProcessedPKHashes--;\n            } else {\n                if (p < assignPos)\n                    assignPos = p;\n                activeRpcId[p] = RPC_ID_NOT_ASSIGNED;\n            }\n        }\n    }\n}\n```\n\nThis comment does two things. The second sentence provides an abstract description of what the code does. The first sentence is different: it explains (in high level terms) why the code is executed. Comments of the form “how we get here” are very useful for helping people to understand code. For example, when documenting a method, it can be very helpful to describe the conditions under which the method is most likely to be invoked (especially if the method is only invoked in unusual situations).\n\n> 此评论有两件事。第二句话提供了代码功能的抽象描述。第一句话是不同的：它以高级的方式解释了为什么执行代码。“如何到达这里”形式的注释对于帮助人们理解代码非常有用。例如，在记录方法时，描述最有可能在什么情况下调用该方法的条件（特别是仅在异常情况下调用该方法的情况）会非常有帮助。\n\n## 13.5 Interface documentation 接口文档\n\nOne of the most important roles for comments is to define abstractions. Recall from Chapter 4 that an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. Code isn’t suitable for describing abstractions; it’s too low level and it includes implementation details that shouldn’t be visible in the abstraction. The only way to describe an abstraction is with comments. If you want code that presents good abstractions, you must document those abstractions with comments.\n\n> 注释最重要的作用之一就是定义抽象。回想一下第 4 章，抽象是实体的简化视图，它保留了基本信息，但省略了可以安全忽略的细节。代码不适合描述抽象；它的级别太低，它包含实现细节，这些细节在抽象中不应该看到。描述抽象的唯一方法是使用注释。如果您想要呈现良好抽象的代码，则必须用注释记录这些抽象。\n\nThe first step in documenting abstractions is to separate interface comments from implementation comments. Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction. Implementation comments describe how a class or method works internally in order to implement the abstraction. It’s important to separate these two kinds of comments, so that users of an interface are not exposed to implementation details. Furthermore, these two forms had better be different. If interface comments must also describe the implementation, then the class or method is shallow. This means that the act of writing comments can provide clues about the quality of a design; Chapter 15 will return to this idea.\n\n> 记录抽象的第一步是将接口注释与实现注释分开。接口注释提供了使用类或方法时需要知道的信息。他们定义了抽象。实现注释描述了类或方法如何在内部工作以实现抽象。区分这两种注释很重要，这样界面的用户就不会暴露于实现细节。此外，这两种形式最好有所不同。如果接口注释也必须描述实现，则该类或方法很浅。这意味着撰写评论的行为可以提供有关设计质量的线索；第 15 章将回到这个想法。\n\nThe interface comment for a class provides a high-level description of the abstraction provided by the class, such as the following:\n\n> 类的接口注释提供了该类提供的抽象的高级描述，例如：\n\n```java\n/**\n * This class implements a simple server-side interface to the HTTP\n * protocol: by using this class, an application can receive HTTP\n * requests, process them, and return responses. Each instance of\n * this class corresponds to a particular socket used to receive\n * requests. The current implementation is single-threaded and\n * processes one request at a time.\n */\npublic class Http {...}\n```\n\nThis comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods. It also describes what each instance of the class represents. Finally, the comments describe the limitations of the class (it does not support concurrent access from multiple threads), which may be important to developers contemplating whether to use it.\n\n> 该注释描述了类的整体功能，没有任何实现细节，甚至没有特定方法的细节。它还描述了该类的每个实例代表什么。最后，注释描述了该类的限制（它不支持从多个线程的并发访问），这对于考虑是否使用它的开发人员可能很重要。\n\nThe interface comment for a method includes both higher-level information for abstraction and lower-level details for precision:\n\n> 方法的接口注释既包括用于抽象的高层信息，又包括用于精度的低层细节：\n\n- The comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.\n- The comment must describe each argument and the return value (if any). These comments must be very precise, and must describe any constraints on argument values as well as dependencies between arguments.\n- If the method has any side effects, these must be documented in the interface comment. A side effect is any consequence of the method that affects the future behavior of the system but is not part of the result. For example, if the method adds a value to an internal data structure, which can be retrieved by future method calls, this is a side effect; writing to the file system is also a side effect.\n- A method’s interface comment must describe any exceptions that can emanate from the method.\n- If there are any preconditions that must be satisfied before a method is invoked, these must be described (perhaps some other method must be invoked first; for a binary search method, the list being searched must be sorted). It is a good idea to minimize preconditions, but any that remain must be documented.\n\n---\n\n> - 注释通常以一两个句子开头，描述调用者感知到的方法的行为。这是更高层次的抽象。\n> - 注释必须描述每个参数和返回值（如果有）。这些注释必须非常精确，并且必须描述对参数值的任何约束以及参数之间的依赖关系。\n> - 如果该方法有任何副作用，则必须在界面注释中记录这些副作用。副作用是该方法的任何结果都会影响系统的未来行为，但不属于结果的一部分。例如，如果该方法将一个值添加到内部数据结构中，可以通过将来的方法调用来检索该值，则这是副作用。写入文件系统也是一个副作用。\n> - 方法的界面注释必须描述该方法可能产生的任何异常。\n> - 如果在调用某个方法之前必须满足任何前提条件，则必须对其进行描述（也许必须先调用其他方法；对于二进制搜索方法，必须对要搜索的列表进行排序）。尽量减少前提条件是一个好主意，但是任何保留的条件都必须记录在案。\n\nHere is the interface comment for a method that copies data out of a Buffer object:\n\n> 这是从 Buffer 对象复制数据的方法的接口注释：\n\n```java\n/**\n * Copy a range of bytes from a buffer to an external location.\n *\n * \\param offset\n *        Index within the buffer of the first byte to copy.\n * \\param length\n *        Number of bytes to copy.\n * \\param dest\n *        Where to copy the bytes: must have room for at least\n *        length bytes.\n *\n * \\return\n *        The return value is the actual number of bytes copied,\n *        which may be less than length if the requested range of\n *        bytes extends past the end of the buffer. 0 is returned\n *        if there is no overlap between the requested range and\n *        the actual buffer.\n */\n\nuint32_t\nBuffer::copy(uint32_t offset, uint32_t length, void* dest)\n...\n```\n\nThe syntax of this comment (e.g., \\return) follows the conventions of Doxygen, a program that extracts comments from C/C++ code and compiles them into Web pages. The goal of the comment is to provide all the information a developer needs in order to invoke the method, including how special cases are handled (note how this method follows the advice of Chapter 10 and defines out of existence any errors associated with the range specification). The developer should not need to read the body of the method in order to invoke it, and the interface comment provides no information about how the method is implemented, such as how it scans its internal data structures to find the desired data.\n\n> 此注释的语法（例如\\ return）遵循 Doxygen 的约定，该程序从 C / C ++代码中提取注释并将其编译为 Web 页。注释的目的是提供开发人员调用该方法所需的所有信息，包括特殊情况的处理方式（请注意，此方法如何遵循第 10 章的建议并定义与范围规范相关的任何错误。 ）。开发人员不必为了调用它而阅读方法的主体，并且接口注释不提供有关如何实现该方法的信息，例如它如何扫描其内部数据结构以查找所需的数据。\n\nFor a more extended example, let’s consider a class called IndexLookup, which is part of a distributed storage system. The storage system holds a collection of tables, each of which contains many objects. In addition, each table can have one or more indexes; each index provides efficient access to objects in the table based on a particular field of the object. For example, one index might be used to look up objects based on their name field, and another index might be used to look up objects based on their age field. With these indexes, applications can quickly extract all of the objects with a particular name, or all of those with an age in a given range.\n\n> 对于更扩展的示例，让我们考虑一个称为 IndexLookup 的类，该类是分布式存储系统的一部分。存储系统拥有一个表集合，每个表包含许多对象。另外，每个表可以具有一个或多个索引；每个索引都基于对象的特定字段提供对表中对象的有效访问。例如，一个索引可以用于根据对象的名称字段查找对象，而另一个索引可以用于根据对象的年龄字段查找对象。使用这些索引，应用程序可以快速提取具有特定名称的所有对象，或具有给定范围内的年龄的所有对象。\n\nThe IndexLookup class provides a convenient interface for performing indexed lookups. Here is an example of how it might be used in an application:\n\n> IndexLookup 类为执行索引查找提供了一个方便的接口。这是一个如何在应用程序中使用的示例：\n\n```java\nquery = new IndexLookup(table, index, key1, key2);\nwhile  (true) {\n    object = query.getNext();\n    if  (object == NULL) {\n        break;\n    }\n    ... process object ...\n}\n```\n\nThe application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example, if the index is based on an age field, key1 and key2 might be specified as 21 and 65 to select all objects with ages between those values). Then the application calls the getNext method repeatedly. Each invocation returns one object that falls within the desired range; once all of the matching objects have been returned, getNext returns NULL. Because the storage system is distributed, the implementation of this class is somewhat complex. The objects in a table may be spread across multiple servers, and each index may also be distributed across a different set of servers; the code in the IndexLookup class must first communicate with all of the relevant index servers to collect information about the objects in the range, then it must communicate with the servers that actually store the objects in order to retrieve their values.\n\n> 应用程序首先构造一个类型为 IndexLookup 的对象，并提供用于选择表，索引和索引内范围的参数（例如，如果索引基于年龄字段，则 key1 和 key2 可以指定为 21 和 65 选择年龄介于这些值之间的所有对象）。然后，应用程序重复调用 getNext 方法。每次调用都返回一个位于所需范围内的对象。一旦返回所有匹配的对象，getNext 将返回 NULL。因为存储系统是分布式的，所以此类的实现有些复杂。表中的对象可以分布在多个服务器上，每个索引也可以分布在一组不同的服务器上。\n\nNow let’s consider what information needs to be included in the interface comment for this class. For each piece of information given below, ask yourself whether a developer needs to know that information in order to use the class (my answers to the questions are at the end of the chapter):\n\n> 现在，让我们考虑该类的接口注释中需要包含哪些信息。对于下面给出的每条信息，问自己一个开发人员是否需要知道该信息才能使用该类（我对问题的回答在本章的结尾）：\n\n1. The format of messages that the IndexLookup class sends to the servers holding indexes and objects.\n2. The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?).\n3. The data structure used to store indexes on servers.\n4. Whether or not IndexLookup issues multiple requests to different servers concurrently.\n5. The mechanism for handling server crashes.\n\n> 1. IndexLookup 类发送给包含索引和对象的服务器的消息格式。\n> 2. 用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。\n> 3. 用于在服务器上存储索引的数据结构。\n> 4. IndexLookup 是否同时向多个服务器发出多个请求。\n> 5. 处理服务器崩溃的机制。\n\n---\n\nHere is the original version of the interface comment for the IndexLookup class; the excerpt also includes a few lines from the class’s definition, which are referred to in the comment:\n\n> 这是 IndexLookup 类的接口注释的原始版本；摘录还包括类定义的几行内容，在注释中进行了引用：\n\n```cpp\n/*\n * This class implements the client side framework for index range\n * lookups. It manages a single LookupIndexKeys RPC and multiple\n * IndexedRead RPCs. Client side just includes \"IndexLookup.h\" in\n * its header to use IndexLookup class. Several parameters can be set\n * in the config below:\n * - The number of concurrent indexedRead RPCs\n * - The max number of PKHashes a indexedRead RPC can hold at a time\n * - The size of the active PKHashes\n *\n * To use IndexLookup, the client creates an object of this class by\n * providing all necessary information. After construction of\n * IndexLookup, client can call getNext() function to move to next\n * available object. If getNext() returns NULL, it means we reached\n * the last object. Client can use getKey, getKeyLength, getValue,\n * and getValueLength to get object data of current object.\n */\n class IndexLookup {\n       ...\n   private:\n       /// Max number of concurrent indexedRead RPCs\n       static const uint8_t NUM_READ_RPC = 10;\n       /// Max number of PKHashes that can be sent in one\n       /// indexedRead RPC\n       static const uint32_t MAX_PKHASHES_PERRPC = 256;\n       /// Max number of PKHashes that activeHashes can\n       /// hold at once.\n       static const size_t MAX_NUM_PK = (1 << LG_BUFFER_SIZE);\n }\n```\n\nBefore reading further, see if you can identify the problems with this comment. Here are the problems that I found:\n\n> 在进一步阅读之前，请先查看您是否可以使用此注释确定问题所在。这是我发现的问题：\n\n- Most of the first paragraph concerns the implementation, not the interface. As one example, users don’t need to know the names of the particular remote procedure calls used to communicate with the servers. The configuration parameters referred to in the second half of the first paragraph are all private variables that are relevant only to the maintainer of the class, not to its users. All of this implementation information should be omitted from the comment.\n- The comment also includes several things that are obvious. For example, there’s no need to tell users to include IndexLookup.h: anyone who writes C++ code will be able to guess that this is necessary. In addition, the text “by providing all necessary information” says nothing, so it can be omitted.\n\n---\n\n> - 第一段的大部分与实现有关，而不是接口。举一个例子，用户不需要知道用于与服务器通信的特定远程过程调用的名称。在第一段的后半部分中提到的配置参数都是所有私有变量，它们仅与类的维护者相关，而与类的用户无关。所有这些实现信息都应从注释中省略。\n> - 该评论还包括一些显而易见的事情。例如，不需要告诉用户包括 IndexLookup.h：任何编写 C ++代码的人都可以猜测这是必要的。另外，“通过提供所有必要的信息”一词无语，因此可以省略。\n\nA shorter comment for this class is sufficient (and preferable):\n\n> 对此类的简短评论就足够了（并且更可取）：\n\n```java\n/*\n * This class is used by client applications to make range queries\n * using indexes. Each instance represents a single range query.\n *\n * To start a range query, a client creates an instance of this\n * class. The client can then call getNext() to retrieve the objects\n * in the desired range. For each object returned by getNext(), the\n * caller can invoke getKey(), getKeyLength(), getValue(), and\n * getValueLength() to get information about that object.\n */\n```\n\nThe last paragraph of this comment is not strictly necessary, since it mostly duplicates information in the comments for individual methods. However, it can be helpful to have examples in the class documentation that illustrate how its methods work together, particularly for deep classes with usage patterns that are nonobvious. Note that the new comment does not mention NULL return values from getNext. This comment is not intended to document every detail of each method; it just provides high level information to help readers understand how the methods work together and when each method might be invoked. For details, readers can refer to the interface comments for individual methods. This comment also does not mention server crashes; that is because server crashes are invisible to users of this class (the system automatically recovers from them).\n\n> 此注释的最后一段不是严格必需的，因为它主要针对单个方法复制了注释中的信息。但是，在类文档中提供示例来说明其方法如何协同工作可能会有所帮助，特别是对于使用模式不明显的深层类尤其如此。注意，新注释未提及 getNext 的 NULL 返回值。此注释无意记录每种方法的每个细节；它只是提供高级信息，以帮助读者了解这些方法如何协同工作以及何时可以调用每种方法。有关详细信息，读者可以参考接口注释中的各个方法。此评论也没有提到服务器崩溃；这是因为此类服务器的用户看不到服务器崩溃（系统会自动从中恢复）。\n\nimg Red Flag: Implementation Documentation Contaminates Interface img\n\nThis red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.\n\n> 当接口文档（例如方法的文档）描述了不需要使用要记录的事物的实现详细信息时，就会出现此红色标记。\n\nNow consider the following code, which shows the first version of the documentation for the isReady method in IndexLookup:\n\n> 现在考虑以下代码，该代码显示 IndexLookup 中 isReady 方法的文档的第一版：\n\n```cpp\n/**\n * Check if the next object is RESULT_READY. This function is\n * implemented in a DCFT module, each execution of isReady() tries\n * to make small progress, and getNext() invokes isReady() in a\n * while loop, until isReady() returns true.\n *\n * isReady() is implemented in a rule-based approach. We check\n * different rules by following a particular order, and perform\n * certain actions if some rule is satisfied.\n *\n * \\return\n *         True means the next Object is available. Otherwise, return\n *         false.\n */\nbool IndexLookup::isReady() { ... }\n```\n\nOnce again, most of this documentation, such as the reference to DCFT and the entire second paragraph, concerns the implementation, so it doesn’t belong here; this is one of the most common errors in interface comments. Some of the implementation documentation is useful, but it should go inside the method, where it will be clearly separated from interface documentation. In addition, the first sentence of the documentation is cryptic (what does RESULT_READY mean?) and some important information is missing. Finally, it isn’t necessary to describe the implementation of getNext here. Here is a better version of the comment:\n\n> 再一次，本文档中的大多数内容，例如对 DCFT 的引用以及整个第二段，都与实现有关，因此不属于此处。这是界面注释中最常见的错误之一。某些实现文档很有用，但应放在方法内部，在该方法中应将其与接口文档明确分开。此外，文档的第一句话是含糊的（RESULT_READY 是什么意思？），并且缺少一些重要信息。最后，无需在此处描述 getNext 的实现。这是评论的更好版本：\n\n```java\n/*\n * Indicates whether an indexed read has made enough progress for\n * getNext to return immediately without blocking. In addition, this\n * method does most of the real work for indexed reads, so it must\n * be invoked (either directly, or indirectly by calling getNext) in\n * order for the indexed read to make progress.\n *\n * \\return\n *         True means that the next invocation of getNext will not block\n *         (at least one object is available to return, or the end of the\n *         lookup has been reached); false means getNext may block.\n */\n```\n\nThis version of the comment provides more precise information about what “ready” means, and it provides the important information that this method must eventually be invoked if the indexed retrieval is to move forward.\n\n> 此注释版本提供了有关“就绪”含义的更精确信息，并且提供了重要信息，如果要继续进行索引检索，则必须最终调用此方法。\n\n## 13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何\n\nImplementation comments are the comments that appear inside methods to help readers understand how they work internally. Most methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.\n\n> 实现注释是出现在方法内部的注释，以帮助读者了解它们在内部的工作方式。大多数方法是如此简短，简单，以至于它们不需要任何实现注释：有了代码和接口注释，就很容易弄清楚方法的工作原理。\n\nThe main goal of implementation comments is to help readers understand what the code is doing (not how it does it). Once readers know what the code is trying to do, it’s usually easy to understand how the code works. For short methods, the code only does one thing, which is already described in its interface comment, so no implementation comments are needed. Longer methods have several blocks of code that do different things as part of the method’s overall task. Add a comment before each of the major blocks to provide a high-level (more abstract) description of what that block does. Here is an example:\n\n> 实现注释的主要目的是帮助读者理解代码在做什么（而不是代码如何工作）。一旦读者知道了代码要做什么，通常就很容易理解代码的工作原理。对于简短的方法，代码只做一件事，该问题已在其接口注释中进行了描述，因此不需要实现注释。较长的方法具有多个代码块，这些代码块作为方法的整体任务的一部分执行不同的操作。在每个主要块之前添加注释，以提供对该块的作用的高级（更抽象）描述。这是一个例子：\n\n```java\n// Phase 1: Scan active RPCs to see if any have completed.\n```\n\nFor loops, it’s helpful to have a comment before the loop that describes what happens in each iteration:\n\n> 对于循环，在循环前加一个注释来描述每次迭代中发生的事情是有帮助的：\n\n```java\n// Each iteration of the following loop extracts one request from\n// the request message, increments the corresponding object, and\n// appends a response to the response message.\n```\n\nNotice how this comment describes the loop at a more abstract and intuitive level; it doesn’t go into any details about how a request is extracted from the request message or how the object is incremented. Loop comments are only needed for longer or more complex loops, where it may not be obvious what the loop is doing; many loops are short and simple enough that their behavior is already obvious.\n\n> 请注意，此注释如何更抽象和直观地描述循环。它没有详细介绍如何从请求消息中提取请求或对象如何递增。仅对于更长或更复杂的循环才需要循环注释，在这种情况下，循环的作用可能并不明显。许多循环足够短且简单，以至于其行为已经很明显。\n\nIn addition to describing what the code is doing, implementation comments are also useful to explain why. If there are tricky aspects to the code that won’t be obvious from reading it, you should document them. For example, if a bug fix requires the addition of code whose purpose isn’t totally obvious, add a comment describing why the code is needed. For bug fixes where there is a well-written bug report describing the problem, the comment can refer to the issue in the bug tracking database rather than repeating all its details (“Fixes RAM-436, related to device driver crashes in Linux 2.4.x”). Developers can look in the bug database for more details (this is an example of avoiding duplication in comments, which will be discussed in Chapter 16).\n\n> 除了描述代码在做什么之外，实现注释还有助于解释原因。如果代码中有些棘手的方面从阅读中看不出来，则应将它们记录下来。例如，如果一个错误修复程序需要添加目的不是很明显的代码，请添加注释以说明为什么需要该代码。对于错误修复，其中有写得很好的错误报告来描述问题，该注释可以引用错误跟踪数据库中的问题，而不是重复其所有详细信息（“修复 RAM-436，与 Linux 2.4 中的设备驱动程序崩溃有关。” X”）。开发人员可以在 bug 数据库中查找更多详细信息（这是一个避免注释重复的示例，这将在第 16 章中进行讨论）。\n\nFor longer methods, it can be helpful to write comments for a few of the most important local variables. However, most local variables don’t need documentation if they have good names. If all of the uses of a variable are visible within a few lines of each other, it’s usually easy to understand the variable’s purpose without a comment. In this case it’s OK to let readers read the code to figure out the meaning of the variable. However, if the variable is used over a large span of code, then you should consider adding a comment to describe the variable. When documenting variables, focus on what the variable represents, not how it is manipulated in the code.\n\n> 对于更长的方法，为一些最重要的局部变量写注释会很有帮助。但是，如果大多数局部变量具有好名字，则不需要文档。如果变量的所有用法在几行之内都是可见的，则通常无需注释即可轻松理解变量的用途。在这种情况下，可以让读者阅读代码来弄清楚变量的含义。但是，如果在大量代码中使用了该变量，则应考虑添加注释以描述该变量。在记录变量时，应关注变量表示的内容，而不是代码中如何对其进行操作。\n\n## 13.7 Cross-module design decisions 跨模块设计决策\n\nIn a perfect world, every important design decision would be encapsulated within a single class. Unfortunately, real systems inevitably end up with design decisions that affect multiple classes. For example, the design of a network protocol will affect both the sender and the receiver, and these may be implemented in different places. Cross-module decisions are often complex and subtle, and they account for many bugs, so good documentation for them is crucial.\n\n> 在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。\n\nThe biggest challenge with cross-module documentation is finding a place to put it where it will naturally be discovered by developers. Sometimes there is an obvious central place to put such documentation. For example, the RAMCloud storage system defines a Status value, which is returned by each request to indicate success or failure. Adding a Status for a new error condition requires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on). Fortunately, there is one obvious place where developers will have to go when adding a new status value, which is the declaration of the Status enum. We took advantage of this by adding comments in that enum to identify all of the other places that must also be modified:\n\n> 跨模块文档的最大挑战是找到一个放置它的位置，以便开发人员自然地发现它。有时，放置此类文档的中心位置很明显。例如，RAMCloud 存储系统定义一个状态值，每个请求均返回该状态值以指示成功或失败。为新的错误状况添加状态需要修改许多不同的文件（一个文件将状态值映射到异常，另一个文件为每个状态提供人类可读的消息，依此类推）。幸运的是，添加新的状态值（即 Status 枚举的声明）时，开发人员必须去一个明显的地方。我们通过在该枚举中添加注释来标识所有其他必须修改的地方，从而利用了这一点：在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。\n\n```cpp\ntypedef enum Status {\n    STATUS_OK = 0,\n    STATUS_UNKNOWN_TABLET                = 1,\n    STATUS_WRONG_VERSION                 = 2,\n    ...\n    STATUS_INDEX_DOESNT_EXIST            = 29,\n    STATUS_INVALID_PARAMETER             = 30,\n    STATUS_MAX_VALUE                     = 30,\n    // Note: if you add a new status value you must make the following\n    // additional updates:\n    // (1)  Modify STATUS_MAX_VALUE to have a value equal to the\n    //      largest defined status value, and make sure its definition\n    //      is the last one in the list. STATUS_MAX_VALUE is used\n    //      primarily for testing.\n    // (2)  Add new entries in the tables \"messages\" and \"symbols\" in\n    //      Status.cc.\n    // (3)  Add a new exception class to ClientException.h\n    // (4)  Add a new \"case\" to ClientException::throwException to map\n    //      from the status value to a status-specific ClientException\n    //      subclass.\n    // (5)  In the Java bindings, add a static class for the exception\n    //      to ClientException.java\n    // (6)  Add a case for the status of the exception to throw the\n    //      exception in ClientException.java\n    // (7)  Add the exception to the Status enum in Status.java, making\n    //      sure the status is in the correct position corresponding to\n    //      its status code.\n}\n```\n\nNew status values will be added at the end of the existing list, so the comments are also placed at the end, where they are most likely to be seen.\n\n> 新状态值将添加到现有列表的末尾，因此注释也将放置在最有可能出现的末尾。\n\nUnfortunately, in many cases there is not an obvious central place to put cross-module documentation. One example from the RAMCloud storage system was the code for dealing with zombie servers, which are servers that the system believes have crashed, but in fact are still running. Neutralizing zombie servers required code in several different modules, and these pieces of code all depend on each other. None of the pieces of code is an obvious central place to put documentation. One possibility is to duplicate parts of the documentation in each location that depends on it. However, this is awkward, and it is difficult to keep such documentation up to date as the system evolves. Alternatively, the documentation can be located in one of the places where it is needed, but in this case it’s unlikely that developers will see the documentation or know where to look for it.\n\n> 不幸的是，在许多情况下，并没有一个明显的中心位置来放置跨模块文档。RAMCloud 存储系统中的一个例子是处理僵尸服务器的代码，僵尸服务器是系统认为已经崩溃但实际上仍在运行的服务器。中和 zombie server 需要几个不同模块中的代码，这些代码都相互依赖。没有一段代码明显是放置文档的中心位置。一种可能性是在每个依赖文档的位置复制文档的部分。然而，这是令人尴尬的，并且随着系统的发展，很难使这样的文档保持最新。或者，文档可以位于需要它的位置之一，但是在这种情况下，开发人员不太可能看到文档或者知道在哪里查找它。\n\nI have recently been experimenting with an approach where cross-module issues are documented in a central file called designNotes. The file is divided up into clearly labeled sections, one for each major topic. For example, here is an excerpt from the file:\n\n> 我最近一直在尝试一种方法，该方法将跨模块问题记录在一个名为 designNotes 的中央文件中。该文件分为清楚标记的部分，每个主要主题一个。例如，以下是该文件的摘录：\n\n```\n...\nZombies\n-------\nA zombie is a server that is considered dead by the rest of the\ncluster; any data stored on the server has been recovered and will\nbe managed by other servers. However, if a zombie is not actually\ndead (e.g., it was just disconnected from the other servers for a\nwhile) two forms of inconsistency can arise:\n* A zombie server must not serve read requests once replacement servers have taken over; otherwise it may return stale data that does not reflect writes accepted by the replacement servers.\n* The zombie server must not accept write requests once replacement servers have begun replaying its log during recovery; if it does, these writes may be lost (the new values may not be stored on the replacement servers and thus will not be returned by reads).\n\nRAMCloud uses two techniques to neutralize zombies. First,\n...\n```\n\nThen, in any piece of code that relates to one of these issues there is a short comment referring to the designNotes file:\n\n> 然后，在与这些问题之一相关的任何代码段中，都有一条简短的注释引用了 designNotes 文件：\n\n```c\n// See \"Zombies\" in designNotes.\n```\n\nWith this approach, there is only a single copy of the documentation and it is relatively easy for developers to find it when they need it. However, this has the disadvantage that the documentation is not near any of the pieces of code that depend on it, so it may be difficult to keep up-to-date as the system evolves.\n\n> 使用这种方法，文档只有一个副本，因此开发人员在需要时可以相对容易地找到它。但是，这样做的缺点是，文档离它依赖的任何代码段都不近，因此随着系统的发展，可能难以保持最新。\n\n## 13.8 Conclusion 结论\n\nThe goal of comments is to ensure that the structure and behavior of the system is obvious to readers, so they can quickly find the information they need and make modifications to the system with confidence that they will work. Some of this information can be represented in the code in a way that will already be obvious to readers, but there is a significant amount of information that can’t easily be deduced from the code. Comments fill in this information.\n\n> 评论的目的是确保系统的结构和行为对读者来说是显而易见的，因此他们可以快速找到所需的信息，并有信心对其进行修改，以对系统进行修改。这些信息中的某些信息可以以对读者来说显而易见的方式表示在代码中，但是有大量信息无法从代码中轻易推导出。注释将填写此信息。\n\nWhen following the rule that comments should describe things that aren’t obvious from the code, “obvious” is from the perspective of someone reading your code for the first time (not you). When writing comments, try to put yourself in the mindset of the reader and ask yourself what are the key things he or she will need to know. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious. Instead of arguing, try to understand what they found confusing and see if you can clarify that, either with better comments or better code.\n\n> 当遵循注释应描述代码中不明显的内容的规则时，“明显”是从第一次读取您的代码的人（不是您）的角度出发。在撰写评论时，请尝试使自己进入读者的心态，并问自己他或她需要知道哪些关键事项。如果您的代码正在接受审核，并且审核者告诉您某些不明显的内容，请不要与他们争论。如果读者认为它不明显，那么它就不明显。不用争论，而是尝试了解他们发现的令人困惑的地方，并查看是否可以通过更好的注释或更好的代码来澄清它们。\n\n## 13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题\n\nDoes a developer need to know each of the following pieces of information in order to use the IndexLookup class?\n\n> 开发人员是否需要了解以下每条信息才能使用 IndexLookup 类？\n\n1. The format of messages that the IndexLookup class sends to the servers holding indexes and objects. No: this is an implementation detail that should be hidden within the class.\n2. The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?). Yes: users of the class need to know this information.\n3. The data structure used to store indexes on servers. No: this information should be encapsulated on the servers; not even the implementation of IndexLookup should need to know this.\n4. Whether or not IndexLookup issues multiple requests to different servers concurrently. Possibly: if IndexLookup uses special techniques to improve performance, then the documentation should provide some high-level information about this, since users may care about performance.\n5. The mechanism for handling server crashes. No: RAMCloud recovers automatically from server crashes, so crashes are not visible to application-level software; thus, there is no need to mention crashes in the interface documentation for IndexLookup. If crashes were reflected up to applications, then the interface documentation would need to describe how they manifest themselves (but not the details of how crash recovery works).\n\n---\n\n> 1. IndexLookup 类发送给包含索引和对象的服务器的消息格式。否：这是应隐藏在类中的实现细节。\n> 2. 用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。是：该课程的用户需要了解此信息。\n> 3. 用于在服务器上存储索引的数据结构。否：此信息应封装在服务器上；甚至 IndexLookup 的实现都不需要知道这一点。\n> 4. IndexLookup 是否同时向多个服务器发出多个请求。可能：如果 IndexLookup 使用特殊技术来提高性能，则文档应提供有关此问题的一些高级信息，因为用户可能会在意性能。\n> 5. 处理服务器崩溃的机制。否：RAMCloud 可从服务器崩溃中自动恢复，因此崩溃对于应用程序级软件不可见；因此，在 IndexLookup 的接口文档中无需提及崩溃。如果崩溃反映到应用程序中，则接口文档将需要描述它们如何表现出来（而不是崩溃恢复如何工作的详细信息）。\n","slug":"软件设计的哲学-ch13","published":1,"updated":"2021-02-16T04:53:33.095Z","_id":"ckl7iw2w6000skiiy4m1d1lty","comments":1,"layout":"post","photos":[],"link":"","content":"<p>注释应该描述代码中不明显的内容</p>\n<a id=\"more\"></a>\n<h1 id=\"第-13-章-注释应该描述代码中不明显的内容\"><a href=\"#第-13-章-注释应该描述代码中不明显的内容\" class=\"headerlink\" title=\"第 13 章 注释应该描述代码中不明显的内容\"></a>第 13 章 注释应该描述代码中不明显的内容</h1><blockquote>\n<p>Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code</p>\n</blockquote>\n<p>The reason for writing comments is that statements in a programming language can’t capture all of the important information that was in the mind of the developer when the code was written. Comments record this information so that developers who come along later can easily understand and modify the code. The guiding principle for comments is that comments should describe things that aren’t obvious from the code.</p>\n<blockquote>\n<p>编写注释的原因是，使用编程语言编写的语句无法捕获编写代码时开发人员想到的所有重要信息。注释记录了这些信息，以便后来的开发人员可以轻松地理解和修改代码。注释的指导原则是，注释应描述代码中不明显的内容。</p>\n</blockquote>\n<p>There are many things that aren’t obvious from the code. Sometimes it’s low-level details that aren’t obvious. For example, when a pair of indices describe a range, it isn’t obvious whether the elements given by the indices are inside the range or out. Sometimes it’s not clear why code is needed, or why it was implemented in a particular way. Sometimes there are rules the developer followed, such as “always invoke a before b.” You might be able to guess at a rule by looking at all of the code, but this is painful and error-prone; a comment can make the rule explicit and clear.</p>\n<blockquote>\n<p>从代码中看不到很多事情。有时，底层细节并不明显。例如，当一对索引描述一个范围时，由索引给出的元素是在范围之内还是之外并不明显。有时不清楚为什么需要代码，或者为什么要以特定方式实现代码。有时，开发人员遵循一些规则，例如“总是在 b 之前调用 a”。您可能可以通过查看所有代码来猜测规则，但这很痛苦且容易出错。注释可以使规则清晰明了。</p>\n</blockquote>\n<p>One of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code. The idea of an abstraction is to provide a simple way of thinking about something, but code is so detailed that it can be hard to see the abstraction just from reading the code. Comments can provide a simpler, higher-level view (“after this method is invoked, network traffic will be limited to maxBandwidth bytes per second”). Even if this information can be deduced by reading the code, we don’t want to force users of a module to do that: reading the code is time-consuming and forces them to consider a lot of information that isn’t needed to use the module. Developers should be able to understand the abstraction provided by a module without reading any code other than its externally visible declarations. The only way to do this is by supplementing the declarations with comments.</p>\n<blockquote>\n<p>注释的最重要原因之一是抽象，其中包括许多从代码中看不到的信息。抽象的思想是提供一种思考问题的简单方法，但是代码是如此详细，以至于仅通过阅读代码就很难看到抽象。注释可以提供一个更简单，更高级的视图（“调用此方法后，网络流量将被限制为每秒 maxBandwidth 字节”）。即使可以通过阅读代码推断出此信息，我们也不想强迫模块用户这样做：阅读代码很耗时，并且迫使他们考虑很多不需要使用的信息模块。开发人员应该能够理解模块提供的抽象，而无需阅读其外部可见声明以外的任何代码。</p>\n</blockquote>\n<p>This chapter discusses what information needs to be described in comments and how to write good comments. As you will see, good comments typically explain things at a different level of detail than the code, which is more detailed in some situations and less detailed (more abstract) in others.</p>\n<blockquote>\n<p>本章讨论需要在注释中描述哪些信息以及如何编写良好的注释。就像您将看到的那样，好的注释通常以与代码不同的详细程度来解释事物，在某些情况下，注释会更详细，而在某些情况下，代码则较不抽象（更抽象）。</p>\n</blockquote>\n<h2 id=\"13-1-Pick-conventions\"><a href=\"#13-1-Pick-conventions\" class=\"headerlink\" title=\"13.1 Pick conventions\"></a>13.1 Pick conventions</h2><p>The first step in writing comments is to decide on conventions for commenting, such as what you will comment and the format you will use for comments. If you are programming in a language for which there exists a document compilation tool, such as Javadoc for Java, Doxygen for C++, or godoc for Go!, follow the conventions of the tools. None of these conventions is perfect, but the tools provide enough benefits to make up for that. If you are programming in an environment where there are no existing conventions to follow, try to adopt the conventions from some other language or project that is similar; this will make it easier for other developers to understand and adhere to your conventions.</p>\n<blockquote>\n<p>编写注释的第一步是确定注释的约定，例如您要注释的内容和注释的格式。如果您正在使用存在文档编译工具的语言进行编程，例如 Java 的 Javadoc，C ++的 Doxygen 或 Go！的 godoc，请遵循工具的约定。这些约定都不是完美的，但是这些工具可提供足够的好处来弥补这一缺点。如果在没有现有约定可遵循的环境中进行编程，请尝试从其他类似的语言或项目中采用这些约定；这将使其他开发人员更容易理解和遵守您的约定。</p>\n</blockquote>\n<p>Conventions serve two purposes. First, they ensure consistency, which makes comments easier to read and understand. Second, they help to ensure that you actually write comments. If you don’t have a clear idea what you are going to comment and how, it’s easy to end up writing no comments at all.</p>\n<blockquote>\n<p>约定有两个目的。首先，它们确保一致性，这使得注释更易于阅读和理解。其次，它们有助于确保您实际编写评论。如果您不清楚要发表的评论以及发表评论的方式，那么很容易最终根本不发表评论。</p>\n</blockquote>\n<p>Most comments fall into one of the following categories:</p>\n<blockquote>\n<p>大多数评论属于以下类别之一：</p>\n</blockquote>\n<p>Interface: a comment block that immediately precedes the declaration of a module such as a class, data structure, function, or method. The comment describe’s the module’s interface. For a class, the comment describes the overall abstraction provided by the class. For a method or function, the comment describes its overall behavior, its arguments and return value, if any, any side effects or exceptions that it generates, and any other requirements the caller must satisfy before invoking the method.</p>\n<blockquote>\n<p>接口：在模块声明（例如类，数据结构，函数或方法）之前的注释块。注释描述模块的接口。对于一个类，注释描述了该类提供的整体抽象。对于方法或函数，注释描述其整体行为，其参数和返回值（如果有），其生成的任何副作用或异常，以及调用者在调用该方法之前必须满足的任何其他要求。</p>\n</blockquote>\n<p>Data structure member: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.</p>\n<blockquote>\n<p>数据结构成员：数据结构中字段声明旁边的注释，例如类的实例变量或静态变量。</p>\n</blockquote>\n<p>Implementation comment: a comment inside the code of a method or function, which describes how the code works internally.</p>\n<blockquote>\n<p>实现注释：方法或函数代码内部的注释，它描述代码在内部的工作方式。</p>\n</blockquote>\n<p>Cross-module comment: a comment describing dependencies that cross module boundaries.</p>\n<blockquote>\n<p>跨模块注释：描述跨模块边界的依赖项的注释。</p>\n</blockquote>\n<p>The most important comments are those in the first two categories. Every class should have an interface comment, every class variable should have a comment, and every method should have an interface comment. Occasionally, the declaration for a variable or method is so obvious that there is nothing useful to add in a comment (getters and setters sometimes fall in this category), but this is rare; it is easier to comment everything rather than spend energy worrying about whether a comment is needed. Implementation comments are often unnecessary (see Section 13.6 below). Cross-module comments are the most rare of all and they are problematic to write, but when they are needed they are quite important; Section 13.7 discusses them in more detail.</p>\n<blockquote>\n<p>最重要的评论是前两个类别中的评论。每个类都应有一个接口注释，每个类变量应有一个注释，每个方法都应有一个接口注释。有时，变量或方法的声明是如此明显，以至于在注释中没有添加任何有用的东西（getter 和 setter 有时都属于此类），但这很少见。评论所有内容要比花精力担心是否需要评论要容易得多。实施注释通常是不必要的（请参阅下面的 13.6 节）。跨模块注释是最罕见的，而且编写起来很成问题，但是当需要它们时，它们就很重要。第 13.7 节将更详细地讨论它们。</p>\n</blockquote>\n<h2 id=\"13-2-Don’t-repeat-the-code-不要重复代码\"><a href=\"#13-2-Don’t-repeat-the-code-不要重复代码\" class=\"headerlink\" title=\"13.2 Don’t repeat the code 不要重复代码\"></a>13.2 Don’t repeat the code 不要重复代码</h2><p>Unfortunately, many comments are not particularly helpful. The most common reason is that the comments repeat the code: all of the information in the comment can easily be deduced from the code next to the comment. Here is a code sample that appeared in a recent research paper:</p>\n<blockquote>\n<p>不幸的是，许多评论并不是特别有用。最常见的原因是注释重复了代码：可以轻松地从注释旁边的代码中推断出注释中的所有信息。这是最近研究论文中出现的代码示例：</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ptr_copy = get_copy(obj)            <span class=\"comment\"># Get pointer copy</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> is_unlocked(ptr_copy):           <span class=\"comment\"># Is obj free?</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj                      <span class=\"comment\"># return current obj</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> is_copy(ptr_copy):               <span class=\"comment\"># Already a copy?</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj                      <span class=\"comment\"># return obj</span></span><br><span class=\"line\">thread_id = get_thread_id(ptr_copy)</span><br><span class=\"line\"><span class=\"keyword\">if</span> thread_id == ctx.thread_id:      <span class=\"comment\"># Locked by current ctx</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> ptr_copy                 <span class=\"comment\"># Return copy</span></span><br></pre></td></tr></table></figure>\n\n<p>There is no useful information in any of these comments except for the “Locked by” comment, which suggests something about the thread that might not be obvious from the code. Notice that these comments are at roughly the same level of detail as the code: there is one comment per line of code, which describes that line. Comments like this are rarely useful.</p>\n<blockquote>\n<p>这些注释中没有任何有用的信息，但“ Locked by”注释除外，该注释暗示了有关线程的某些信息可能在代码中并不明显。请注意，这些注释的详细程度与代码大致相同：每行代码有一个注释，用于描述该行。这样的注释很少有用。</p>\n</blockquote>\n<p>Here are more examples of comments that repeat the code:</p>\n<blockquote>\n<p>以下是重复代码的注释的更多示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add a horizontal scroll bar</span></span><br><span class=\"line\">hScrollBar = <span class=\"keyword\">new</span> JScrollBar(JScrollBar.HORIZONTAL);</span><br><span class=\"line\">add(hScrollBar, BorderLayout.SOUTH);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add a vertical scroll bar</span></span><br><span class=\"line\">vScrollBar = <span class=\"keyword\">new</span> JScrollBar(JScrollBar.VERTICAL);</span><br><span class=\"line\">add(vScrollBar, BorderLayout.EAST);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize the caret-position related values</span></span><br><span class=\"line\">caretX     = <span class=\"number\">0</span>;</span><br><span class=\"line\">caretY     = <span class=\"number\">0</span>;</span><br><span class=\"line\">caretMemX  = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>None of these comments provide any value. For the first two comments, the code is already clear enough that it doesn’t really need comments; in the third case, a comment might be useful, but the current comment doesn’t provide enough detail to be helpful.</p>\n<blockquote>\n<p>这些评论均未提供任何价值。对于前两个注释，代码已经很清楚了，它实际上不需要注释。在第三种情况下，注释可能有用，但是当前注释没有提供足够的细节来提供帮助。</p>\n</blockquote>\n<p>After you have written a comment, ask yourself the following question: could someone who has never seen the code write the comment just by looking at the code next to the comment? If the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand. Comments like these are why some people think that comments are worthless.</p>\n<blockquote>\n<p>编写评论后，请问自己以下问题：从未看过代码的人能否仅通过查看评论旁边的代码来编写评论？如果答案是肯定的（如上述示例所示），则注释不会使代码更易于理解。像这样的评论是为什么有些人认为评论毫无价值的原因。</p>\n</blockquote>\n<p>Another common mistake is to use the same words in the comment that appear in the name of the entity being documented:</p>\n<blockquote>\n<p>另一个常见的错误是在注释中使用与要记录的实体名称相同的词：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain a normalized resource name from REQ.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String[] getNormalizedResourceNames(</span><br><span class=\"line\">            HTTPRequest req) ...</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Downcast PARAMETER to TYPE.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">downCastParameter</span><span class=\"params\">(String parameter, String type)</span> ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/*</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> * The horizontal padding of each line in the text.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textHorizontalPadding </span>= <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>These comments just take the words from the method or variable name, perhaps add a few words from argument names and types, and form them into a sentence. For example, the only thing in the second comment that isn’t in the code is the word “to”! Once again, these comments could be written just by looking at the declarations, without any understanding the methods of variables; as a result, they have no value.</p>\n<blockquote>\n<p>这些注释只是从方法或变量名中提取单词，或者从参数名称和类型中添加几个单词，然后将它们组成一个句子。例如，第二个注释中唯一不在代码中的是单词“ to”！再说一次，这些注释可以仅通过查看声明来编写，而无需任何了解变量的方法。结果，它们没有价值。</p>\n</blockquote>\n<p>img Red Flag: Comment Repeats Code img</p>\n<p>If the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful. One example of this is when the comment uses the same words that make up the name of the thing it is describing.</p>\n<blockquote>\n<p>如果注释旁边的代码中的注释信息已经很明显，则注释无济于事。这样的一个例子是，当注释使用与所描述事物名称相同的单词时。</p>\n</blockquote>\n<p>At the same time, there is important information that is missing from the comments: for example, what is a “normalized resource name”, and what are the elements of the array returned by getNormalizedResourceNames? What does “downcast” mean? What are the units of padding, and is the padding on one side of each line or both? Describing these things in comments would be helpful.</p>\n<blockquote>\n<p>同时，注释中缺少一些重要信息：例如，什么是“标准化资源名称”，以及 getNormalizedResourceNames 返回的数组的元素是什么？“贬低”是什么意思？填充的单位是什么，填充是在每行的一侧还是在两者的两侧？在注释中描述这些内容将很有帮助。</p>\n</blockquote>\n<p>A first step towards writing good comments is to use different words in the comment from those in the name of the entity being described. Pick words for the comment that provide additional information about the meaning of the entity, rather than just repeating its name. For example, here is a better comment for textHorizontalPadding:</p>\n<blockquote>\n<p>编写良好评论的第一步是在评论中使用与所描述实体名称不同的词。为注释选择单词，以提供有关实体含义的更多信息，而不仅仅是重复其名称。例如，以下是针对 textHorizo​​ntalPadding 的更好注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The amount of blank space to leave on the left and</span></span><br><span class=\"line\"><span class=\"comment\"> * right sides of each line of text, in pixels.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textHorizontalPadding = <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>This comment provides additional information that is not obvious from the declaration itself, such as the units (pixels) and the fact that padding applies to both sides of each line. Instead of using the term “padding”, the comment explains what padding is, in case the reader isn’t already familiar with the term.</p>\n<blockquote>\n<p>该注释提供了从声明本身不明显的其他信息，例如单位（像素）以及填充适用于每行两边的事实。如果读者不熟悉该术语，则注释将解释什么是填充，而不是使用术语“填充”。</p>\n</blockquote>\n<h2 id=\"13-3-Lower-level-comments-add-precision-低级注释可提高精度\"><a href=\"#13-3-Lower-level-comments-add-precision-低级注释可提高精度\" class=\"headerlink\" title=\"13.3 Lower-level comments add precision 低级注释可提高精度\"></a>13.3 Lower-level comments add precision 低级注释可提高精度</h2><p>Now that you know what not to do, let’s discuss what information you should put in comments. Comments augment the code by providing information at a different level of detail. Some comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code. Other comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code. Comments at the same level as the code are likely to repeat the code. This section discusses the lower-level approach in more detail, and the next section discusses the higher-level approach.</p>\n<blockquote>\n<p>现在您知道了不应该做的事情，让我们讨论应该在注释中添加哪些信息。注释通过提供不同详细程度的信息来增强代码。一些注释提供了比代码更低，更详细的信息。这些注释通过阐明代码的确切含 ​​ 义来增加精度。其他注释提供了比代码更高，更抽象的信息。这些注释提供了直觉，例如代码背后的推理，或者更简单，更抽象的代码思考方式。与代码处于同一级别的注释可能会重复该代码。本节将更详细地讨论下层方法，而下一节将讨论上层方法。</p>\n</blockquote>\n<p>Precision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and type in a variable declaration are typically not very precise. Comments can fill in missing details such as:</p>\n<blockquote>\n<p>在注释变量声明（例如类实例变量，方法参数和返回值）时，精度最有用。变量声明中的名称和类型通常不是很精确。注释可以填写缺少的详细信息，例如：</p>\n</blockquote>\n<ul>\n<li>What are the units for this variable?</li>\n<li>Are the boundary conditions inclusive or exclusive?</li>\n<li>If a null value is permitted, what does it imply?</li>\n<li>If a variable refers to a resource that must eventually be freed or closed, who is responsible for freeing or closing it?</li>\n<li>Are there certain properties that are always true for the variable (invariants), such as “this list always contains at least one entry”?</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>此变量的单位是什么？</li>\n<li>边界条件是包容性还是排他性？</li>\n<li>如果允许使用空值，则意味着什么？</li>\n<li>如果变量引用了最终必须释放或关闭的资源，那么谁负责释放或关闭该资源？</li>\n<li>是否存在某些对于变量始终不变的属性（不变量），例如“此列表始终包含至少一个条目”？</li>\n</ul>\n</blockquote>\n<p>Some of this information could potentially be figured out by examining all of the code where the variable is used. However, this is time-consuming and error-prone; the declaration’s comment should be clear and complete enough to make this unnecessary. When I say that the comment for a declaration should describe things that aren’t obvious from the code, “the code” refers to the code next to the comment (the declaration), not “all of the code in the application.”</p>\n<blockquote>\n<p>通过检查使用该变量的所有代码，可以潜在地了解某些信息。但是，这很耗时且容易出错。宣言的评论应清晰，完整，以免不必要。当我说声明的注释应描述代码中不明显的内容时，“代码”是指注释（声明）旁边的代码，而不是“应用程序中的所有代码”。</p>\n</blockquote>\n<p>The most common problem with comments for variables is that the comments are too vague. Here are two examples of comments that aren’t precise enough:</p>\n<blockquote>\n<p>变量注释最常见的问题是注释太模糊。这是两个不够精确的注释示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Current offset in resp Buffer</span></span><br><span class=\"line\">uint32_t offset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Contains all line-widths inside the document and</span></span><br><span class=\"line\"><span class=\"comment\">// number of appearances.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; lineWidths;</span><br></pre></td></tr></table></figure>\n\n<p>In the first example, it’s not clear what “current” means. In the second example, it’s not clear that the keys in the TreeMap are line widths and values are occurrence counts. Also, are widths measured in pixels or characters? The revised comments below provide additional details:</p>\n<blockquote>\n<p>在第一个示例中，尚不清楚“当前”的含义。在第二个示例中，尚不清楚 TreeMap 中的键是线宽，值是出现次数。另外，宽度是以像素或字符为单位测量的吗？以下修订后的注释提供了更多详细信息：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Position in this buffer of the first object that hasn't</span></span><br><span class=\"line\"><span class=\"comment\">//  been returned to the client.</span></span><br><span class=\"line\">uint32_t offset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Holds statistics about line lengths of the form &lt;length, count&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  where length is the number of characters in a line (including</span></span><br><span class=\"line\"><span class=\"comment\">//  the newline), and count is the number of lines with</span></span><br><span class=\"line\"><span class=\"comment\">//  exactly that many characters. If there are no lines with</span></span><br><span class=\"line\"><span class=\"comment\">//  a particular length, then there is no entry for that length.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; numLinesWithLength;</span><br></pre></td></tr></table></figure>\n\n<p>The second declaration uses a longer name that conveys more information. It also changes “width” to “length”, because this term is more likely to make people think that the units are characters rather than pixels. Notice that the second comment documents not only the details of each entry, but also what it means if an entry is missing.</p>\n<blockquote>\n<p>第二个声明使用一个较长的名称来传达更多信息。它还将“宽度”更改为“长度”，因为该术语更可能使人们认为单位是字符而不是像素。请注意，第二条注释不仅记录了每个条目的详细信息，还记录了缺少条目的含义。</p>\n</blockquote>\n<p>When documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated. Consider the following comment:</p>\n<blockquote>\n<p>在记录变量时，请考虑名词而不是动词。换句话说，关注变量代表什么，而不是如何操纵变量。考虑以下评论：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and the</span></span><br><span class=\"line\"><span class=\"comment\"> * PeriodicTasks thread to communicate about whether a heartbeat has been</span></span><br><span class=\"line\"><span class=\"comment\"> * received within the follower's election timeout window.</span></span><br><span class=\"line\"><span class=\"comment\"> * Toggled to TRUE when a valid heartbeat is received.</span></span><br><span class=\"line\"><span class=\"comment\"> * Toggled to FALSE when the election timeout window is reset.  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure>\n\n<p>This documentation describes how the variable is modified by several pieces of code in the class. The comment will be both shorter and more useful if it describes what the variable represents rather than mirroring the code structure:</p>\n<blockquote>\n<p>本文档描述了如何通过类中的几段代码来修改变量。如果注释描述变量代表什么而不是镜像代码结构，则注释将更短且更有用：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* True means that a heartbeat has been received since the last time</span></span><br><span class=\"line\"><span class=\"comment\"> * the election timer was reset. Used for communication between the</span></span><br><span class=\"line\"><span class=\"comment\"> * Receiver and PeriodicTasks threads.  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure>\n\n<p>Given this documentation, it’s easy to infer that the variable must be set to true when a heartbeat is received and false when the election timer is reset.</p>\n<blockquote>\n<p>根据本文档，很容易推断出，当接收到心跳信号时，变量必须设置为 true；而当重置选举计时器时，则必须将变量设置为 false。</p>\n</blockquote>\n<h2 id=\"13-4-Higher-level-comments-enhance-intuition-高级注释可增强直觉\"><a href=\"#13-4-Higher-level-comments-enhance-intuition-高级注释可增强直觉\" class=\"headerlink\" title=\"13.4 Higher-level comments enhance intuition 高级注释可增强直觉\"></a>13.4 Higher-level comments enhance intuition 高级注释可增强直觉</h2><p>The second way in which comments can augment code is by providing intuition. These comments are written at a higher level than the code. They omit details and help the reader to understand the overall intent and structure of the code. This approach is commonly used for comments inside methods, and for interface comments. For example, consider the following code:</p>\n<blockquote>\n<p>注释可以增加代码的第二种方法是提供直觉。这些注释是在比代码更高的级别上编写的。它们忽略了细节，并帮助读者理解了代码的整体意图和结构。此方法通常用于方法内部的注释以及接口注释。例如，考虑以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If there is a LOADING readRpc using the same session</span></span><br><span class=\"line\"><span class=\"comment\">// as PKHash pointed to by assignPos, and the last PKHash</span></span><br><span class=\"line\"><span class=\"comment\">// in that readRPC is smaller than current assigning</span></span><br><span class=\"line\"><span class=\"comment\">// PKHash, then we put assigning PKHash into that readRPC.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readActiveRpcId = RPC_ID_NOT_ASSIGNED;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NUM_READ_RPC; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (session == readRpc[i].session</span><br><span class=\"line\">            &amp;&amp; readRpc[i].status == LOADING</span><br><span class=\"line\">            &amp;&amp; readRpc[i].maxPos &lt; assignPos</span><br><span class=\"line\">            &amp;&amp; readRpc[i].numHashes &lt; MAX_PKHASHES_PERRPC) &#123;</span><br><span class=\"line\">        readActiveRpcId = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The comment is too low-level and detailed. On the one hand, it partially repeats the code: “if there is a LOADING readRPC” just duplicates the test <code>readRpc[i].status == LOADING</code>. On the other hand, the comment doesn’t explain the overall purpose of this code, or how it fits into the method that contains it. As a result, the comment doesn’t help the reader to understand the code.</p>\n<blockquote>\n<p>该评论太底层和太详细。一方面，它部分重复了代码：“如果有 LOADING readRPC”仅重复测试 <code>readRpc[i].status == LOADING</code>。另一方面，注释不能解释此代码的总体目的，也不能解释其如何适合包含此代码的方法。如此一来注释不能帮助读者理解代码。</p>\n</blockquote>\n<p>Here is a better comment:</p>\n<blockquote>\n<p>这是一个更好的评论：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try to append the current key hash onto an existing</span></span><br><span class=\"line\"><span class=\"comment\">// RPC to the desired server that hasn't been sent yet.</span></span><br></pre></td></tr></table></figure>\n\n<p>This comment doesn’t contain any details; instead, it describes the code’s overall function at a higher level. With this high-level information, a reader can explain almost everything that happens in the code: the loop must be iterating over all the existing remote procedure calls (RPCs); the session test is probably used to see if a particular RPC is destined for the right server; the LOADING test suggests that RPCs can have multiple states, and in some states it isn’t safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how many hashes can be sent in a single RPC. The only thing not explained by the comment is the maxPos test. Furthermore, the new comment provides a basis for readers to judge the code: does it do everything that is needed to add the key hash to an existing RPC? The original comment didn’t describe the overall intent of the code, so it’s hard for a reader to decide whether the code is behaving correctly.</p>\n<blockquote>\n<p>此评论不包含任何详细信息。相反，它在更高级别上描述了代码的整体功能。有了这些高级信息，读者就可以解释代码中几乎发生的所有事情：循环必须遍历所有现有的远程过程调用（RPC）；会话测试可能用于查看特定的 RPC 是否发往正确的服务器；LOADING 测试表明 RPC 可以具有多个状态，在某些状态下添加更多的哈希值是不安全的；MAX-PKHASHES_PERRPC 测试表明在单个 RPC 中可以发送多少个哈希值是有限制的。注释中唯一没有解释的是 maxPos 测试。此外，新注释为读者判断代码提供了基础：它可以完成将密钥哈希添加到现有 RPC 所需的一切吗？原始注释并未描述代码的整体意图，因此，读者很难确定代码是否行为正确。</p>\n</blockquote>\n<p>Higher-level comments are more difficult to write than lower-level comments because you must think about the code in a different way. Ask yourself: What is this code trying to do? What is the simplest thing you can say that explains everything in the code? What is the most important thing about this code?</p>\n<blockquote>\n<p>高级别的注释比低级别的注释更难编写，因为您必须以不同的方式考虑代码。问问自己：这段代码要做什么？您能说什么最简单的东西来解释代码中的所有内容？这段代码最重要的是什么？</p>\n</blockquote>\n<p>Engineers tend to be very detail-oriented. We love details and are good at managing lots of them; this is essential for being a good engineer. But, great software designers can also step back from the details and think about a system at a higher level. This means deciding which aspects of the system are most important, and being able to ignore the low-level details and think about the system only in terms of its most fundamental characteristics. This is the essence of abstraction (finding a simple way to think about a complex entity), and it’s also what you must do when writing higher-level comments. A good higher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as “append to an existing RPC.” Given the framework, it becomes easy to see how specific code statements relate to the overall goal.</p>\n<blockquote>\n<p>工程师往往非常注重细节。我们喜欢细节，善于管理其中的许多细节；这对于成为一名优秀的工程师至关重要。但是，优秀的软件设计师也可以从细节退后一步，从更高层次考虑系统。这意味着要确定系统的哪些方面最重要，并且能够忽略底层细节，仅根据系统的最基本特征来考虑系统。这是抽象的本质（找到一种思考复杂实体的简单方法），这也是编写高级注释时必须执行的操作。一个好的高层注释表达了一个或几个简单的想法，这些想法提供了一个概念框架，例如“附加到现有的 RPC”。使用该框架，可以很容易地看到特定的代码语句与总体目标之间的关系。</p>\n</blockquote>\n<p>Here is another code sample, which has a good higher-level comment:</p>\n<blockquote>\n<p>这是另一个代码示例，具有较高层次的注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (numProcessedPKHashes &lt; readRpc[i].numHashes) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Some of the key hashes couldn't be looked up in</span></span><br><span class=\"line\">    <span class=\"comment\">// this request (either because they aren't stored</span></span><br><span class=\"line\">    <span class=\"comment\">// on the server, the server crashed, or there</span></span><br><span class=\"line\">    <span class=\"comment\">// wasn't enough space in the response message).</span></span><br><span class=\"line\">    <span class=\"comment\">// Mark the unprocessed hashes so they will get</span></span><br><span class=\"line\">    <span class=\"comment\">// reassigned to new RPCs.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t p = removePos; p &lt; insertPos; p++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activeRpcId[p] == i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numProcessedPKHashes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                numProcessedPKHashes--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p &lt; assignPos)</span><br><span class=\"line\">                    assignPos = p;</span><br><span class=\"line\">                activeRpcId[p] = RPC_ID_NOT_ASSIGNED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This comment does two things. The second sentence provides an abstract description of what the code does. The first sentence is different: it explains (in high level terms) why the code is executed. Comments of the form “how we get here” are very useful for helping people to understand code. For example, when documenting a method, it can be very helpful to describe the conditions under which the method is most likely to be invoked (especially if the method is only invoked in unusual situations).</p>\n<blockquote>\n<p>此评论有两件事。第二句话提供了代码功能的抽象描述。第一句话是不同的：它以高级的方式解释了为什么执行代码。“如何到达这里”形式的注释对于帮助人们理解代码非常有用。例如，在记录方法时，描述最有可能在什么情况下调用该方法的条件（特别是仅在异常情况下调用该方法的情况）会非常有帮助。</p>\n</blockquote>\n<h2 id=\"13-5-Interface-documentation-接口文档\"><a href=\"#13-5-Interface-documentation-接口文档\" class=\"headerlink\" title=\"13.5 Interface documentation 接口文档\"></a>13.5 Interface documentation 接口文档</h2><p>One of the most important roles for comments is to define abstractions. Recall from Chapter 4 that an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. Code isn’t suitable for describing abstractions; it’s too low level and it includes implementation details that shouldn’t be visible in the abstraction. The only way to describe an abstraction is with comments. If you want code that presents good abstractions, you must document those abstractions with comments.</p>\n<blockquote>\n<p>注释最重要的作用之一就是定义抽象。回想一下第 4 章，抽象是实体的简化视图，它保留了基本信息，但省略了可以安全忽略的细节。代码不适合描述抽象；它的级别太低，它包含实现细节，这些细节在抽象中不应该看到。描述抽象的唯一方法是使用注释。如果您想要呈现良好抽象的代码，则必须用注释记录这些抽象。</p>\n</blockquote>\n<p>The first step in documenting abstractions is to separate interface comments from implementation comments. Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction. Implementation comments describe how a class or method works internally in order to implement the abstraction. It’s important to separate these two kinds of comments, so that users of an interface are not exposed to implementation details. Furthermore, these two forms had better be different. If interface comments must also describe the implementation, then the class or method is shallow. This means that the act of writing comments can provide clues about the quality of a design; Chapter 15 will return to this idea.</p>\n<blockquote>\n<p>记录抽象的第一步是将接口注释与实现注释分开。接口注释提供了使用类或方法时需要知道的信息。他们定义了抽象。实现注释描述了类或方法如何在内部工作以实现抽象。区分这两种注释很重要，这样界面的用户就不会暴露于实现细节。此外，这两种形式最好有所不同。如果接口注释也必须描述实现，则该类或方法很浅。这意味着撰写评论的行为可以提供有关设计质量的线索；第 15 章将回到这个想法。</p>\n</blockquote>\n<p>The interface comment for a class provides a high-level description of the abstraction provided by the class, such as the following:</p>\n<blockquote>\n<p>类的接口注释提供了该类提供的抽象的高级描述，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class implements a simple server-side interface to the HTTP</span></span><br><span class=\"line\"><span class=\"comment\"> * protocol: by using this class, an application can receive HTTP</span></span><br><span class=\"line\"><span class=\"comment\"> * requests, process them, and return responses. Each instance of</span></span><br><span class=\"line\"><span class=\"comment\"> * this class corresponds to a particular socket used to receive</span></span><br><span class=\"line\"><span class=\"comment\"> * requests. The current implementation is single-threaded and</span></span><br><span class=\"line\"><span class=\"comment\"> * processes one request at a time.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Http</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods. It also describes what each instance of the class represents. Finally, the comments describe the limitations of the class (it does not support concurrent access from multiple threads), which may be important to developers contemplating whether to use it.</p>\n<blockquote>\n<p>该注释描述了类的整体功能，没有任何实现细节，甚至没有特定方法的细节。它还描述了该类的每个实例代表什么。最后，注释描述了该类的限制（它不支持从多个线程的并发访问），这对于考虑是否使用它的开发人员可能很重要。</p>\n</blockquote>\n<p>The interface comment for a method includes both higher-level information for abstraction and lower-level details for precision:</p>\n<blockquote>\n<p>方法的接口注释既包括用于抽象的高层信息，又包括用于精度的低层细节：</p>\n</blockquote>\n<ul>\n<li>The comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.</li>\n<li>The comment must describe each argument and the return value (if any). These comments must be very precise, and must describe any constraints on argument values as well as dependencies between arguments.</li>\n<li>If the method has any side effects, these must be documented in the interface comment. A side effect is any consequence of the method that affects the future behavior of the system but is not part of the result. For example, if the method adds a value to an internal data structure, which can be retrieved by future method calls, this is a side effect; writing to the file system is also a side effect.</li>\n<li>A method’s interface comment must describe any exceptions that can emanate from the method.</li>\n<li>If there are any preconditions that must be satisfied before a method is invoked, these must be described (perhaps some other method must be invoked first; for a binary search method, the list being searched must be sorted). It is a good idea to minimize preconditions, but any that remain must be documented.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>注释通常以一两个句子开头，描述调用者感知到的方法的行为。这是更高层次的抽象。</li>\n<li>注释必须描述每个参数和返回值（如果有）。这些注释必须非常精确，并且必须描述对参数值的任何约束以及参数之间的依赖关系。</li>\n<li>如果该方法有任何副作用，则必须在界面注释中记录这些副作用。副作用是该方法的任何结果都会影响系统的未来行为，但不属于结果的一部分。例如，如果该方法将一个值添加到内部数据结构中，可以通过将来的方法调用来检索该值，则这是副作用。写入文件系统也是一个副作用。</li>\n<li>方法的界面注释必须描述该方法可能产生的任何异常。</li>\n<li>如果在调用某个方法之前必须满足任何前提条件，则必须对其进行描述（也许必须先调用其他方法；对于二进制搜索方法，必须对要搜索的列表进行排序）。尽量减少前提条件是一个好主意，但是任何保留的条件都必须记录在案。</li>\n</ul>\n</blockquote>\n<p>Here is the interface comment for a method that copies data out of a Buffer object:</p>\n<blockquote>\n<p>这是从 Buffer 对象复制数据的方法的接口注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Copy a range of bytes from a buffer to an external location.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param offset</span></span><br><span class=\"line\"><span class=\"comment\"> *        Index within the buffer of the first byte to copy.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param length</span></span><br><span class=\"line\"><span class=\"comment\"> *        Number of bytes to copy.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param dest</span></span><br><span class=\"line\"><span class=\"comment\"> *        Where to copy the bytes: must have room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> *        length bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *        The return value is the actual number of bytes copied,</span></span><br><span class=\"line\"><span class=\"comment\"> *        which may be less than length if the requested range of</span></span><br><span class=\"line\"><span class=\"comment\"> *        bytes extends past the end of the buffer. 0 is returned</span></span><br><span class=\"line\"><span class=\"comment\"> *        if there is no overlap between the requested range and</span></span><br><span class=\"line\"><span class=\"comment\"> *        the actual buffer.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">uint32_t</span><br><span class=\"line\">Buffer::copy(uint32_t offset, uint32_t length, <span class=\"keyword\">void</span>* dest)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>The syntax of this comment (e.g., \\return) follows the conventions of Doxygen, a program that extracts comments from C/C++ code and compiles them into Web pages. The goal of the comment is to provide all the information a developer needs in order to invoke the method, including how special cases are handled (note how this method follows the advice of Chapter 10 and defines out of existence any errors associated with the range specification). The developer should not need to read the body of the method in order to invoke it, and the interface comment provides no information about how the method is implemented, such as how it scans its internal data structures to find the desired data.</p>\n<blockquote>\n<p>此注释的语法（例如\\ return）遵循 Doxygen 的约定，该程序从 C / C ++代码中提取注释并将其编译为 Web 页。注释的目的是提供开发人员调用该方法所需的所有信息，包括特殊情况的处理方式（请注意，此方法如何遵循第 10 章的建议并定义与范围规范相关的任何错误。 ）。开发人员不必为了调用它而阅读方法的主体，并且接口注释不提供有关如何实现该方法的信息，例如它如何扫描其内部数据结构以查找所需的数据。</p>\n</blockquote>\n<p>For a more extended example, let’s consider a class called IndexLookup, which is part of a distributed storage system. The storage system holds a collection of tables, each of which contains many objects. In addition, each table can have one or more indexes; each index provides efficient access to objects in the table based on a particular field of the object. For example, one index might be used to look up objects based on their name field, and another index might be used to look up objects based on their age field. With these indexes, applications can quickly extract all of the objects with a particular name, or all of those with an age in a given range.</p>\n<blockquote>\n<p>对于更扩展的示例，让我们考虑一个称为 IndexLookup 的类，该类是分布式存储系统的一部分。存储系统拥有一个表集合，每个表包含许多对象。另外，每个表可以具有一个或多个索引；每个索引都基于对象的特定字段提供对表中对象的有效访问。例如，一个索引可以用于根据对象的名称字段查找对象，而另一个索引可以用于根据对象的年龄字段查找对象。使用这些索引，应用程序可以快速提取具有特定名称的所有对象，或具有给定范围内的年龄的所有对象。</p>\n</blockquote>\n<p>The IndexLookup class provides a convenient interface for performing indexed lookups. Here is an example of how it might be used in an application:</p>\n<blockquote>\n<p>IndexLookup 类为执行索引查找提供了一个方便的接口。这是一个如何在应用程序中使用的示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">query = <span class=\"keyword\">new</span> IndexLookup(table, index, key1, key2);</span><br><span class=\"line\"><span class=\"keyword\">while</span>  (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    object = query.getNext();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (object == NULL) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... process object ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example, if the index is based on an age field, key1 and key2 might be specified as 21 and 65 to select all objects with ages between those values). Then the application calls the getNext method repeatedly. Each invocation returns one object that falls within the desired range; once all of the matching objects have been returned, getNext returns NULL. Because the storage system is distributed, the implementation of this class is somewhat complex. The objects in a table may be spread across multiple servers, and each index may also be distributed across a different set of servers; the code in the IndexLookup class must first communicate with all of the relevant index servers to collect information about the objects in the range, then it must communicate with the servers that actually store the objects in order to retrieve their values.</p>\n<blockquote>\n<p>应用程序首先构造一个类型为 IndexLookup 的对象，并提供用于选择表，索引和索引内范围的参数（例如，如果索引基于年龄字段，则 key1 和 key2 可以指定为 21 和 65 选择年龄介于这些值之间的所有对象）。然后，应用程序重复调用 getNext 方法。每次调用都返回一个位于所需范围内的对象。一旦返回所有匹配的对象，getNext 将返回 NULL。因为存储系统是分布式的，所以此类的实现有些复杂。表中的对象可以分布在多个服务器上，每个索引也可以分布在一组不同的服务器上。</p>\n</blockquote>\n<p>Now let’s consider what information needs to be included in the interface comment for this class. For each piece of information given below, ask yourself whether a developer needs to know that information in order to use the class (my answers to the questions are at the end of the chapter):</p>\n<blockquote>\n<p>现在，让我们考虑该类的接口注释中需要包含哪些信息。对于下面给出的每条信息，问自己一个开发人员是否需要知道该信息才能使用该类（我对问题的回答在本章的结尾）：</p>\n</blockquote>\n<ol>\n<li>The format of messages that the IndexLookup class sends to the servers holding indexes and objects.</li>\n<li>The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?).</li>\n<li>The data structure used to store indexes on servers.</li>\n<li>Whether or not IndexLookup issues multiple requests to different servers concurrently.</li>\n<li>The mechanism for handling server crashes.</li>\n</ol>\n<blockquote>\n<ol>\n<li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。</li>\n<li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。</li>\n<li>用于在服务器上存储索引的数据结构。</li>\n<li>IndexLookup 是否同时向多个服务器发出多个请求。</li>\n<li>处理服务器崩溃的机制。</li>\n</ol>\n</blockquote>\n<hr>\n<p>Here is the original version of the interface comment for the IndexLookup class; the excerpt also includes a few lines from the class’s definition, which are referred to in the comment:</p>\n<blockquote>\n<p>这是 IndexLookup 类的接口注释的原始版本；摘录还包括类定义的几行内容，在注释中进行了引用：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * This class implements the client side framework for index range</span></span><br><span class=\"line\"><span class=\"comment\"> * lookups. It manages a single LookupIndexKeys RPC and multiple</span></span><br><span class=\"line\"><span class=\"comment\"> * IndexedRead RPCs. Client side just includes \"IndexLookup.h\" in</span></span><br><span class=\"line\"><span class=\"comment\"> * its header to use IndexLookup class. Several parameters can be set</span></span><br><span class=\"line\"><span class=\"comment\"> * in the config below:</span></span><br><span class=\"line\"><span class=\"comment\"> * - The number of concurrent indexedRead RPCs</span></span><br><span class=\"line\"><span class=\"comment\"> * - The max number of PKHashes a indexedRead RPC can hold at a time</span></span><br><span class=\"line\"><span class=\"comment\"> * - The size of the active PKHashes</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To use IndexLookup, the client creates an object of this class by</span></span><br><span class=\"line\"><span class=\"comment\"> * providing all necessary information. After construction of</span></span><br><span class=\"line\"><span class=\"comment\"> * IndexLookup, client can call getNext() function to move to next</span></span><br><span class=\"line\"><span class=\"comment\"> * available object. If getNext() returns NULL, it means we reached</span></span><br><span class=\"line\"><span class=\"comment\"> * the last object. Client can use getKey, getKeyLength, getValue,</span></span><br><span class=\"line\"><span class=\"comment\"> * and getValueLength to get object data of current object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexLookup</span> &#123;</span></span><br><span class=\"line\">       ...</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of concurrent indexedRead RPCs</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> NUM_READ_RPC = <span class=\"number\">10</span>;</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of PKHashes that can be sent in one</span></span><br><span class=\"line\">       <span class=\"comment\">/// indexedRead RPC</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">uint32_t</span> MAX_PKHASHES_PERRPC = <span class=\"number\">256</span>;</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of PKHashes that activeHashes can</span></span><br><span class=\"line\">       <span class=\"comment\">/// hold at once.</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> MAX_NUM_PK = (<span class=\"number\">1</span> &lt;&lt; LG_BUFFER_SIZE);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Before reading further, see if you can identify the problems with this comment. Here are the problems that I found:</p>\n<blockquote>\n<p>在进一步阅读之前，请先查看您是否可以使用此注释确定问题所在。这是我发现的问题：</p>\n</blockquote>\n<ul>\n<li>Most of the first paragraph concerns the implementation, not the interface. As one example, users don’t need to know the names of the particular remote procedure calls used to communicate with the servers. The configuration parameters referred to in the second half of the first paragraph are all private variables that are relevant only to the maintainer of the class, not to its users. All of this implementation information should be omitted from the comment.</li>\n<li>The comment also includes several things that are obvious. For example, there’s no need to tell users to include IndexLookup.h: anyone who writes C++ code will be able to guess that this is necessary. In addition, the text “by providing all necessary information” says nothing, so it can be omitted.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>第一段的大部分与实现有关，而不是接口。举一个例子，用户不需要知道用于与服务器通信的特定远程过程调用的名称。在第一段的后半部分中提到的配置参数都是所有私有变量，它们仅与类的维护者相关，而与类的用户无关。所有这些实现信息都应从注释中省略。</li>\n<li>该评论还包括一些显而易见的事情。例如，不需要告诉用户包括 IndexLookup.h：任何编写 C ++代码的人都可以猜测这是必要的。另外，“通过提供所有必要的信息”一词无语，因此可以省略。</li>\n</ul>\n</blockquote>\n<p>A shorter comment for this class is sufficient (and preferable):</p>\n<blockquote>\n<p>对此类的简短评论就足够了（并且更可取）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * This class is used by client applications to make range queries</span></span><br><span class=\"line\"><span class=\"comment\"> * using indexes. Each instance represents a single range query.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To start a range query, a client creates an instance of this</span></span><br><span class=\"line\"><span class=\"comment\"> * class. The client can then call getNext() to retrieve the objects</span></span><br><span class=\"line\"><span class=\"comment\"> * in the desired range. For each object returned by getNext(), the</span></span><br><span class=\"line\"><span class=\"comment\"> * caller can invoke getKey(), getKeyLength(), getValue(), and</span></span><br><span class=\"line\"><span class=\"comment\"> * getValueLength() to get information about that object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>The last paragraph of this comment is not strictly necessary, since it mostly duplicates information in the comments for individual methods. However, it can be helpful to have examples in the class documentation that illustrate how its methods work together, particularly for deep classes with usage patterns that are nonobvious. Note that the new comment does not mention NULL return values from getNext. This comment is not intended to document every detail of each method; it just provides high level information to help readers understand how the methods work together and when each method might be invoked. For details, readers can refer to the interface comments for individual methods. This comment also does not mention server crashes; that is because server crashes are invisible to users of this class (the system automatically recovers from them).</p>\n<blockquote>\n<p>此注释的最后一段不是严格必需的，因为它主要针对单个方法复制了注释中的信息。但是，在类文档中提供示例来说明其方法如何协同工作可能会有所帮助，特别是对于使用模式不明显的深层类尤其如此。注意，新注释未提及 getNext 的 NULL 返回值。此注释无意记录每种方法的每个细节；它只是提供高级信息，以帮助读者了解这些方法如何协同工作以及何时可以调用每种方法。有关详细信息，读者可以参考接口注释中的各个方法。此评论也没有提到服务器崩溃；这是因为此类服务器的用户看不到服务器崩溃（系统会自动从中恢复）。</p>\n</blockquote>\n<p>img Red Flag: Implementation Documentation Contaminates Interface img</p>\n<p>This red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.</p>\n<blockquote>\n<p>当接口文档（例如方法的文档）描述了不需要使用要记录的事物的实现详细信息时，就会出现此红色标记。</p>\n</blockquote>\n<p>Now consider the following code, which shows the first version of the documentation for the isReady method in IndexLookup:</p>\n<blockquote>\n<p>现在考虑以下代码，该代码显示 IndexLookup 中 isReady 方法的文档的第一版：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check if the next object is RESULT_READY. This function is</span></span><br><span class=\"line\"><span class=\"comment\"> * implemented in a DCFT module, each execution of isReady() tries</span></span><br><span class=\"line\"><span class=\"comment\"> * to make small progress, and getNext() invokes isReady() in a</span></span><br><span class=\"line\"><span class=\"comment\"> * while loop, until isReady() returns true.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * isReady() is implemented in a rule-based approach. We check</span></span><br><span class=\"line\"><span class=\"comment\"> * different rules by following a particular order, and perform</span></span><br><span class=\"line\"><span class=\"comment\"> * certain actions if some rule is satisfied.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *         True means the next Object is available. Otherwise, return</span></span><br><span class=\"line\"><span class=\"comment\"> *         false.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IndexLookup::isReady</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Once again, most of this documentation, such as the reference to DCFT and the entire second paragraph, concerns the implementation, so it doesn’t belong here; this is one of the most common errors in interface comments. Some of the implementation documentation is useful, but it should go inside the method, where it will be clearly separated from interface documentation. In addition, the first sentence of the documentation is cryptic (what does RESULT_READY mean?) and some important information is missing. Finally, it isn’t necessary to describe the implementation of getNext here. Here is a better version of the comment:</p>\n<blockquote>\n<p>再一次，本文档中的大多数内容，例如对 DCFT 的引用以及整个第二段，都与实现有关，因此不属于此处。这是界面注释中最常见的错误之一。某些实现文档很有用，但应放在方法内部，在该方法中应将其与接口文档明确分开。此外，文档的第一句话是含糊的（RESULT_READY 是什么意思？），并且缺少一些重要信息。最后，无需在此处描述 getNext 的实现。这是评论的更好版本：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Indicates whether an indexed read has made enough progress for</span></span><br><span class=\"line\"><span class=\"comment\"> * getNext to return immediately without blocking. In addition, this</span></span><br><span class=\"line\"><span class=\"comment\"> * method does most of the real work for indexed reads, so it must</span></span><br><span class=\"line\"><span class=\"comment\"> * be invoked (either directly, or indirectly by calling getNext) in</span></span><br><span class=\"line\"><span class=\"comment\"> * order for the indexed read to make progress.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *         True means that the next invocation of getNext will not block</span></span><br><span class=\"line\"><span class=\"comment\"> *         (at least one object is available to return, or the end of the</span></span><br><span class=\"line\"><span class=\"comment\"> *         lookup has been reached); false means getNext may block.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>This version of the comment provides more precise information about what “ready” means, and it provides the important information that this method must eventually be invoked if the indexed retrieval is to move forward.</p>\n<blockquote>\n<p>此注释版本提供了有关“就绪”含义的更精确信息，并且提供了重要信息，如果要继续进行索引检索，则必须最终调用此方法。</p>\n</blockquote>\n<h2 id=\"13-6-Implementation-comments-what-and-why-not-how-实施注释：什么以及为什么，而不是如何\"><a href=\"#13-6-Implementation-comments-what-and-why-not-how-实施注释：什么以及为什么，而不是如何\" class=\"headerlink\" title=\"13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何\"></a>13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何</h2><p>Implementation comments are the comments that appear inside methods to help readers understand how they work internally. Most methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.</p>\n<blockquote>\n<p>实现注释是出现在方法内部的注释，以帮助读者了解它们在内部的工作方式。大多数方法是如此简短，简单，以至于它们不需要任何实现注释：有了代码和接口注释，就很容易弄清楚方法的工作原理。</p>\n</blockquote>\n<p>The main goal of implementation comments is to help readers understand what the code is doing (not how it does it). Once readers know what the code is trying to do, it’s usually easy to understand how the code works. For short methods, the code only does one thing, which is already described in its interface comment, so no implementation comments are needed. Longer methods have several blocks of code that do different things as part of the method’s overall task. Add a comment before each of the major blocks to provide a high-level (more abstract) description of what that block does. Here is an example:</p>\n<blockquote>\n<p>实现注释的主要目的是帮助读者理解代码在做什么（而不是代码如何工作）。一旦读者知道了代码要做什么，通常就很容易理解代码的工作原理。对于简短的方法，代码只做一件事，该问题已在其接口注释中进行了描述，因此不需要实现注释。较长的方法具有多个代码块，这些代码块作为方法的整体任务的一部分执行不同的操作。在每个主要块之前添加注释，以提供对该块的作用的高级（更抽象）描述。这是一个例子：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Phase 1: Scan active RPCs to see if any have completed.</span></span><br></pre></td></tr></table></figure>\n\n<p>For loops, it’s helpful to have a comment before the loop that describes what happens in each iteration:</p>\n<blockquote>\n<p>对于循环，在循环前加一个注释来描述每次迭代中发生的事情是有帮助的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Each iteration of the following loop extracts one request from</span></span><br><span class=\"line\"><span class=\"comment\">// the request message, increments the corresponding object, and</span></span><br><span class=\"line\"><span class=\"comment\">// appends a response to the response message.</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice how this comment describes the loop at a more abstract and intuitive level; it doesn’t go into any details about how a request is extracted from the request message or how the object is incremented. Loop comments are only needed for longer or more complex loops, where it may not be obvious what the loop is doing; many loops are short and simple enough that their behavior is already obvious.</p>\n<blockquote>\n<p>请注意，此注释如何更抽象和直观地描述循环。它没有详细介绍如何从请求消息中提取请求或对象如何递增。仅对于更长或更复杂的循环才需要循环注释，在这种情况下，循环的作用可能并不明显。许多循环足够短且简单，以至于其行为已经很明显。</p>\n</blockquote>\n<p>In addition to describing what the code is doing, implementation comments are also useful to explain why. If there are tricky aspects to the code that won’t be obvious from reading it, you should document them. For example, if a bug fix requires the addition of code whose purpose isn’t totally obvious, add a comment describing why the code is needed. For bug fixes where there is a well-written bug report describing the problem, the comment can refer to the issue in the bug tracking database rather than repeating all its details (“Fixes RAM-436, related to device driver crashes in Linux 2.4.x”). Developers can look in the bug database for more details (this is an example of avoiding duplication in comments, which will be discussed in Chapter 16).</p>\n<blockquote>\n<p>除了描述代码在做什么之外，实现注释还有助于解释原因。如果代码中有些棘手的方面从阅读中看不出来，则应将它们记录下来。例如，如果一个错误修复程序需要添加目的不是很明显的代码，请添加注释以说明为什么需要该代码。对于错误修复，其中有写得很好的错误报告来描述问题，该注释可以引用错误跟踪数据库中的问题，而不是重复其所有详细信息（“修复 RAM-436，与 Linux 2.4 中的设备驱动程序崩溃有关。” X”）。开发人员可以在 bug 数据库中查找更多详细信息（这是一个避免注释重复的示例，这将在第 16 章中进行讨论）。</p>\n</blockquote>\n<p>For longer methods, it can be helpful to write comments for a few of the most important local variables. However, most local variables don’t need documentation if they have good names. If all of the uses of a variable are visible within a few lines of each other, it’s usually easy to understand the variable’s purpose without a comment. In this case it’s OK to let readers read the code to figure out the meaning of the variable. However, if the variable is used over a large span of code, then you should consider adding a comment to describe the variable. When documenting variables, focus on what the variable represents, not how it is manipulated in the code.</p>\n<blockquote>\n<p>对于更长的方法，为一些最重要的局部变量写注释会很有帮助。但是，如果大多数局部变量具有好名字，则不需要文档。如果变量的所有用法在几行之内都是可见的，则通常无需注释即可轻松理解变量的用途。在这种情况下，可以让读者阅读代码来弄清楚变量的含义。但是，如果在大量代码中使用了该变量，则应考虑添加注释以描述该变量。在记录变量时，应关注变量表示的内容，而不是代码中如何对其进行操作。</p>\n</blockquote>\n<h2 id=\"13-7-Cross-module-design-decisions-跨模块设计决策\"><a href=\"#13-7-Cross-module-design-decisions-跨模块设计决策\" class=\"headerlink\" title=\"13.7 Cross-module design decisions 跨模块设计决策\"></a>13.7 Cross-module design decisions 跨模块设计决策</h2><p>In a perfect world, every important design decision would be encapsulated within a single class. Unfortunately, real systems inevitably end up with design decisions that affect multiple classes. For example, the design of a network protocol will affect both the sender and the receiver, and these may be implemented in different places. Cross-module decisions are often complex and subtle, and they account for many bugs, so good documentation for them is crucial.</p>\n<blockquote>\n<p>在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p>\n</blockquote>\n<p>The biggest challenge with cross-module documentation is finding a place to put it where it will naturally be discovered by developers. Sometimes there is an obvious central place to put such documentation. For example, the RAMCloud storage system defines a Status value, which is returned by each request to indicate success or failure. Adding a Status for a new error condition requires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on). Fortunately, there is one obvious place where developers will have to go when adding a new status value, which is the declaration of the Status enum. We took advantage of this by adding comments in that enum to identify all of the other places that must also be modified:</p>\n<blockquote>\n<p>跨模块文档的最大挑战是找到一个放置它的位置，以便开发人员自然地发现它。有时，放置此类文档的中心位置很明显。例如，RAMCloud 存储系统定义一个状态值，每个请求均返回该状态值以指示成功或失败。为新的错误状况添加状态需要修改许多不同的文件（一个文件将状态值映射到异常，另一个文件为每个状态提供人类可读的消息，依此类推）。幸运的是，添加新的状态值（即 Status 枚举的声明）时，开发人员必须去一个明显的地方。我们通过在该枚举中添加注释来标识所有其他必须修改的地方，从而利用了这一点：在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> Status &#123;</span><br><span class=\"line\">    STATUS_OK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    STATUS_UNKNOWN_TABLET                = <span class=\"number\">1</span>,</span><br><span class=\"line\">    STATUS_WRONG_VERSION                 = <span class=\"number\">2</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    STATUS_INDEX_DOESNT_EXIST            = <span class=\"number\">29</span>,</span><br><span class=\"line\">    STATUS_INVALID_PARAMETER             = <span class=\"number\">30</span>,</span><br><span class=\"line\">    STATUS_MAX_VALUE                     = <span class=\"number\">30</span>,</span><br><span class=\"line\">    <span class=\"comment\">// Note: if you add a new status value you must make the following</span></span><br><span class=\"line\">    <span class=\"comment\">// additional updates:</span></span><br><span class=\"line\">    <span class=\"comment\">// (1)  Modify STATUS_MAX_VALUE to have a value equal to the</span></span><br><span class=\"line\">    <span class=\"comment\">//      largest defined status value, and make sure its definition</span></span><br><span class=\"line\">    <span class=\"comment\">//      is the last one in the list. STATUS_MAX_VALUE is used</span></span><br><span class=\"line\">    <span class=\"comment\">//      primarily for testing.</span></span><br><span class=\"line\">    <span class=\"comment\">// (2)  Add new entries in the tables \"messages\" and \"symbols\" in</span></span><br><span class=\"line\">    <span class=\"comment\">//      Status.cc.</span></span><br><span class=\"line\">    <span class=\"comment\">// (3)  Add a new exception class to ClientException.h</span></span><br><span class=\"line\">    <span class=\"comment\">// (4)  Add a new \"case\" to ClientException::throwException to map</span></span><br><span class=\"line\">    <span class=\"comment\">//      from the status value to a status-specific ClientException</span></span><br><span class=\"line\">    <span class=\"comment\">//      subclass.</span></span><br><span class=\"line\">    <span class=\"comment\">// (5)  In the Java bindings, add a static class for the exception</span></span><br><span class=\"line\">    <span class=\"comment\">//      to ClientException.java</span></span><br><span class=\"line\">    <span class=\"comment\">// (6)  Add a case for the status of the exception to throw the</span></span><br><span class=\"line\">    <span class=\"comment\">//      exception in ClientException.java</span></span><br><span class=\"line\">    <span class=\"comment\">// (7)  Add the exception to the Status enum in Status.java, making</span></span><br><span class=\"line\">    <span class=\"comment\">//      sure the status is in the correct position corresponding to</span></span><br><span class=\"line\">    <span class=\"comment\">//      its status code.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>New status values will be added at the end of the existing list, so the comments are also placed at the end, where they are most likely to be seen.</p>\n<blockquote>\n<p>新状态值将添加到现有列表的末尾，因此注释也将放置在最有可能出现的末尾。</p>\n</blockquote>\n<p>Unfortunately, in many cases there is not an obvious central place to put cross-module documentation. One example from the RAMCloud storage system was the code for dealing with zombie servers, which are servers that the system believes have crashed, but in fact are still running. Neutralizing zombie servers required code in several different modules, and these pieces of code all depend on each other. None of the pieces of code is an obvious central place to put documentation. One possibility is to duplicate parts of the documentation in each location that depends on it. However, this is awkward, and it is difficult to keep such documentation up to date as the system evolves. Alternatively, the documentation can be located in one of the places where it is needed, but in this case it’s unlikely that developers will see the documentation or know where to look for it.</p>\n<blockquote>\n<p>不幸的是，在许多情况下，并没有一个明显的中心位置来放置跨模块文档。RAMCloud 存储系统中的一个例子是处理僵尸服务器的代码，僵尸服务器是系统认为已经崩溃但实际上仍在运行的服务器。中和 zombie server 需要几个不同模块中的代码，这些代码都相互依赖。没有一段代码明显是放置文档的中心位置。一种可能性是在每个依赖文档的位置复制文档的部分。然而，这是令人尴尬的，并且随着系统的发展，很难使这样的文档保持最新。或者，文档可以位于需要它的位置之一，但是在这种情况下，开发人员不太可能看到文档或者知道在哪里查找它。</p>\n</blockquote>\n<p>I have recently been experimenting with an approach where cross-module issues are documented in a central file called designNotes. The file is divided up into clearly labeled sections, one for each major topic. For example, here is an excerpt from the file:</p>\n<blockquote>\n<p>我最近一直在尝试一种方法，该方法将跨模块问题记录在一个名为 designNotes 的中央文件中。该文件分为清楚标记的部分，每个主要主题一个。例如，以下是该文件的摘录：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Zombies</span><br><span class=\"line\">-------</span><br><span class=\"line\">A zombie is a server that is considered dead by the rest of the</span><br><span class=\"line\">cluster; any data stored on the server has been recovered and will</span><br><span class=\"line\">be managed by other servers. However, if a zombie is not actually</span><br><span class=\"line\">dead (e.g., it was just disconnected from the other servers for a</span><br><span class=\"line\">while) two forms of inconsistency can arise:</span><br><span class=\"line\">* A zombie server must not serve read requests once replacement servers have taken over; otherwise it may return stale data that does not reflect writes accepted by the replacement servers.</span><br><span class=\"line\">* The zombie server must not accept write requests once replacement servers have begun replaying its log during recovery; if it does, these writes may be lost (the new values may not be stored on the replacement servers and thus will not be returned by reads).</span><br><span class=\"line\"></span><br><span class=\"line\">RAMCloud uses two techniques to neutralize zombies. First,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Then, in any piece of code that relates to one of these issues there is a short comment referring to the designNotes file:</p>\n<blockquote>\n<p>然后，在与这些问题之一相关的任何代码段中，都有一条简短的注释引用了 designNotes 文件：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// See \"Zombies\" in designNotes.</span></span><br></pre></td></tr></table></figure>\n\n<p>With this approach, there is only a single copy of the documentation and it is relatively easy for developers to find it when they need it. However, this has the disadvantage that the documentation is not near any of the pieces of code that depend on it, so it may be difficult to keep up-to-date as the system evolves.</p>\n<blockquote>\n<p>使用这种方法，文档只有一个副本，因此开发人员在需要时可以相对容易地找到它。但是，这样做的缺点是，文档离它依赖的任何代码段都不近，因此随着系统的发展，可能难以保持最新。</p>\n</blockquote>\n<h2 id=\"13-8-Conclusion-结论\"><a href=\"#13-8-Conclusion-结论\" class=\"headerlink\" title=\"13.8 Conclusion 结论\"></a>13.8 Conclusion 结论</h2><p>The goal of comments is to ensure that the structure and behavior of the system is obvious to readers, so they can quickly find the information they need and make modifications to the system with confidence that they will work. Some of this information can be represented in the code in a way that will already be obvious to readers, but there is a significant amount of information that can’t easily be deduced from the code. Comments fill in this information.</p>\n<blockquote>\n<p>评论的目的是确保系统的结构和行为对读者来说是显而易见的，因此他们可以快速找到所需的信息，并有信心对其进行修改，以对系统进行修改。这些信息中的某些信息可以以对读者来说显而易见的方式表示在代码中，但是有大量信息无法从代码中轻易推导出。注释将填写此信息。</p>\n</blockquote>\n<p>When following the rule that comments should describe things that aren’t obvious from the code, “obvious” is from the perspective of someone reading your code for the first time (not you). When writing comments, try to put yourself in the mindset of the reader and ask yourself what are the key things he or she will need to know. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious. Instead of arguing, try to understand what they found confusing and see if you can clarify that, either with better comments or better code.</p>\n<blockquote>\n<p>当遵循注释应描述代码中不明显的内容的规则时，“明显”是从第一次读取您的代码的人（不是您）的角度出发。在撰写评论时，请尝试使自己进入读者的心态，并问自己他或她需要知道哪些关键事项。如果您的代码正在接受审核，并且审核者告诉您某些不明显的内容，请不要与他们争论。如果读者认为它不明显，那么它就不明显。不用争论，而是尝试了解他们发现的令人困惑的地方，并查看是否可以通过更好的注释或更好的代码来澄清它们。</p>\n</blockquote>\n<h2 id=\"13-9-Answers-to-questions-from-Section-13-5-回答第-13-5-节中的问题\"><a href=\"#13-9-Answers-to-questions-from-Section-13-5-回答第-13-5-节中的问题\" class=\"headerlink\" title=\"13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题\"></a>13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题</h2><p>Does a developer need to know each of the following pieces of information in order to use the IndexLookup class?</p>\n<blockquote>\n<p>开发人员是否需要了解以下每条信息才能使用 IndexLookup 类？</p>\n</blockquote>\n<ol>\n<li>The format of messages that the IndexLookup class sends to the servers holding indexes and objects. No: this is an implementation detail that should be hidden within the class.</li>\n<li>The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?). Yes: users of the class need to know this information.</li>\n<li>The data structure used to store indexes on servers. No: this information should be encapsulated on the servers; not even the implementation of IndexLookup should need to know this.</li>\n<li>Whether or not IndexLookup issues multiple requests to different servers concurrently. Possibly: if IndexLookup uses special techniques to improve performance, then the documentation should provide some high-level information about this, since users may care about performance.</li>\n<li>The mechanism for handling server crashes. No: RAMCloud recovers automatically from server crashes, so crashes are not visible to application-level software; thus, there is no need to mention crashes in the interface documentation for IndexLookup. If crashes were reflected up to applications, then the interface documentation would need to describe how they manifest themselves (but not the details of how crash recovery works).</li>\n</ol>\n<hr>\n<blockquote>\n<ol>\n<li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。否：这是应隐藏在类中的实现细节。</li>\n<li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。是：该课程的用户需要了解此信息。</li>\n<li>用于在服务器上存储索引的数据结构。否：此信息应封装在服务器上；甚至 IndexLookup 的实现都不需要知道这一点。</li>\n<li>IndexLookup 是否同时向多个服务器发出多个请求。可能：如果 IndexLookup 使用特殊技术来提高性能，则文档应提供有关此问题的一些高级信息，因为用户可能会在意性能。</li>\n<li>处理服务器崩溃的机制。否：RAMCloud 可从服务器崩溃中自动恢复，因此崩溃对于应用程序级软件不可见；因此，在 IndexLookup 的接口文档中无需提及崩溃。如果崩溃反映到应用程序中，则接口文档将需要描述它们如何表现出来（而不是崩溃恢复如何工作的详细信息）。</li>\n</ol>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>注释应该描述代码中不明显的内容</p>","more":"<h1 id=\"第-13-章-注释应该描述代码中不明显的内容\"><a href=\"#第-13-章-注释应该描述代码中不明显的内容\" class=\"headerlink\" title=\"第 13 章 注释应该描述代码中不明显的内容\"></a>第 13 章 注释应该描述代码中不明显的内容</h1><blockquote>\n<p>Chapter 13 Comments Should Describe Things that Aren’t Obvious from the Code</p>\n</blockquote>\n<p>The reason for writing comments is that statements in a programming language can’t capture all of the important information that was in the mind of the developer when the code was written. Comments record this information so that developers who come along later can easily understand and modify the code. The guiding principle for comments is that comments should describe things that aren’t obvious from the code.</p>\n<blockquote>\n<p>编写注释的原因是，使用编程语言编写的语句无法捕获编写代码时开发人员想到的所有重要信息。注释记录了这些信息，以便后来的开发人员可以轻松地理解和修改代码。注释的指导原则是，注释应描述代码中不明显的内容。</p>\n</blockquote>\n<p>There are many things that aren’t obvious from the code. Sometimes it’s low-level details that aren’t obvious. For example, when a pair of indices describe a range, it isn’t obvious whether the elements given by the indices are inside the range or out. Sometimes it’s not clear why code is needed, or why it was implemented in a particular way. Sometimes there are rules the developer followed, such as “always invoke a before b.” You might be able to guess at a rule by looking at all of the code, but this is painful and error-prone; a comment can make the rule explicit and clear.</p>\n<blockquote>\n<p>从代码中看不到很多事情。有时，底层细节并不明显。例如，当一对索引描述一个范围时，由索引给出的元素是在范围之内还是之外并不明显。有时不清楚为什么需要代码，或者为什么要以特定方式实现代码。有时，开发人员遵循一些规则，例如“总是在 b 之前调用 a”。您可能可以通过查看所有代码来猜测规则，但这很痛苦且容易出错。注释可以使规则清晰明了。</p>\n</blockquote>\n<p>One of the most important reasons for comments is abstractions, which include a lot of information that isn’t obvious from the code. The idea of an abstraction is to provide a simple way of thinking about something, but code is so detailed that it can be hard to see the abstraction just from reading the code. Comments can provide a simpler, higher-level view (“after this method is invoked, network traffic will be limited to maxBandwidth bytes per second”). Even if this information can be deduced by reading the code, we don’t want to force users of a module to do that: reading the code is time-consuming and forces them to consider a lot of information that isn’t needed to use the module. Developers should be able to understand the abstraction provided by a module without reading any code other than its externally visible declarations. The only way to do this is by supplementing the declarations with comments.</p>\n<blockquote>\n<p>注释的最重要原因之一是抽象，其中包括许多从代码中看不到的信息。抽象的思想是提供一种思考问题的简单方法，但是代码是如此详细，以至于仅通过阅读代码就很难看到抽象。注释可以提供一个更简单，更高级的视图（“调用此方法后，网络流量将被限制为每秒 maxBandwidth 字节”）。即使可以通过阅读代码推断出此信息，我们也不想强迫模块用户这样做：阅读代码很耗时，并且迫使他们考虑很多不需要使用的信息模块。开发人员应该能够理解模块提供的抽象，而无需阅读其外部可见声明以外的任何代码。</p>\n</blockquote>\n<p>This chapter discusses what information needs to be described in comments and how to write good comments. As you will see, good comments typically explain things at a different level of detail than the code, which is more detailed in some situations and less detailed (more abstract) in others.</p>\n<blockquote>\n<p>本章讨论需要在注释中描述哪些信息以及如何编写良好的注释。就像您将看到的那样，好的注释通常以与代码不同的详细程度来解释事物，在某些情况下，注释会更详细，而在某些情况下，代码则较不抽象（更抽象）。</p>\n</blockquote>\n<h2 id=\"13-1-Pick-conventions\"><a href=\"#13-1-Pick-conventions\" class=\"headerlink\" title=\"13.1 Pick conventions\"></a>13.1 Pick conventions</h2><p>The first step in writing comments is to decide on conventions for commenting, such as what you will comment and the format you will use for comments. If you are programming in a language for which there exists a document compilation tool, such as Javadoc for Java, Doxygen for C++, or godoc for Go!, follow the conventions of the tools. None of these conventions is perfect, but the tools provide enough benefits to make up for that. If you are programming in an environment where there are no existing conventions to follow, try to adopt the conventions from some other language or project that is similar; this will make it easier for other developers to understand and adhere to your conventions.</p>\n<blockquote>\n<p>编写注释的第一步是确定注释的约定，例如您要注释的内容和注释的格式。如果您正在使用存在文档编译工具的语言进行编程，例如 Java 的 Javadoc，C ++的 Doxygen 或 Go！的 godoc，请遵循工具的约定。这些约定都不是完美的，但是这些工具可提供足够的好处来弥补这一缺点。如果在没有现有约定可遵循的环境中进行编程，请尝试从其他类似的语言或项目中采用这些约定；这将使其他开发人员更容易理解和遵守您的约定。</p>\n</blockquote>\n<p>Conventions serve two purposes. First, they ensure consistency, which makes comments easier to read and understand. Second, they help to ensure that you actually write comments. If you don’t have a clear idea what you are going to comment and how, it’s easy to end up writing no comments at all.</p>\n<blockquote>\n<p>约定有两个目的。首先，它们确保一致性，这使得注释更易于阅读和理解。其次，它们有助于确保您实际编写评论。如果您不清楚要发表的评论以及发表评论的方式，那么很容易最终根本不发表评论。</p>\n</blockquote>\n<p>Most comments fall into one of the following categories:</p>\n<blockquote>\n<p>大多数评论属于以下类别之一：</p>\n</blockquote>\n<p>Interface: a comment block that immediately precedes the declaration of a module such as a class, data structure, function, or method. The comment describe’s the module’s interface. For a class, the comment describes the overall abstraction provided by the class. For a method or function, the comment describes its overall behavior, its arguments and return value, if any, any side effects or exceptions that it generates, and any other requirements the caller must satisfy before invoking the method.</p>\n<blockquote>\n<p>接口：在模块声明（例如类，数据结构，函数或方法）之前的注释块。注释描述模块的接口。对于一个类，注释描述了该类提供的整体抽象。对于方法或函数，注释描述其整体行为，其参数和返回值（如果有），其生成的任何副作用或异常，以及调用者在调用该方法之前必须满足的任何其他要求。</p>\n</blockquote>\n<p>Data structure member: a comment next to the declaration of a field in a data structure, such as an instance variable or static variable for a class.</p>\n<blockquote>\n<p>数据结构成员：数据结构中字段声明旁边的注释，例如类的实例变量或静态变量。</p>\n</blockquote>\n<p>Implementation comment: a comment inside the code of a method or function, which describes how the code works internally.</p>\n<blockquote>\n<p>实现注释：方法或函数代码内部的注释，它描述代码在内部的工作方式。</p>\n</blockquote>\n<p>Cross-module comment: a comment describing dependencies that cross module boundaries.</p>\n<blockquote>\n<p>跨模块注释：描述跨模块边界的依赖项的注释。</p>\n</blockquote>\n<p>The most important comments are those in the first two categories. Every class should have an interface comment, every class variable should have a comment, and every method should have an interface comment. Occasionally, the declaration for a variable or method is so obvious that there is nothing useful to add in a comment (getters and setters sometimes fall in this category), but this is rare; it is easier to comment everything rather than spend energy worrying about whether a comment is needed. Implementation comments are often unnecessary (see Section 13.6 below). Cross-module comments are the most rare of all and they are problematic to write, but when they are needed they are quite important; Section 13.7 discusses them in more detail.</p>\n<blockquote>\n<p>最重要的评论是前两个类别中的评论。每个类都应有一个接口注释，每个类变量应有一个注释，每个方法都应有一个接口注释。有时，变量或方法的声明是如此明显，以至于在注释中没有添加任何有用的东西（getter 和 setter 有时都属于此类），但这很少见。评论所有内容要比花精力担心是否需要评论要容易得多。实施注释通常是不必要的（请参阅下面的 13.6 节）。跨模块注释是最罕见的，而且编写起来很成问题，但是当需要它们时，它们就很重要。第 13.7 节将更详细地讨论它们。</p>\n</blockquote>\n<h2 id=\"13-2-Don’t-repeat-the-code-不要重复代码\"><a href=\"#13-2-Don’t-repeat-the-code-不要重复代码\" class=\"headerlink\" title=\"13.2 Don’t repeat the code 不要重复代码\"></a>13.2 Don’t repeat the code 不要重复代码</h2><p>Unfortunately, many comments are not particularly helpful. The most common reason is that the comments repeat the code: all of the information in the comment can easily be deduced from the code next to the comment. Here is a code sample that appeared in a recent research paper:</p>\n<blockquote>\n<p>不幸的是，许多评论并不是特别有用。最常见的原因是注释重复了代码：可以轻松地从注释旁边的代码中推断出注释中的所有信息。这是最近研究论文中出现的代码示例：</p>\n</blockquote>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ptr_copy = get_copy(obj)            <span class=\"comment\"># Get pointer copy</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> is_unlocked(ptr_copy):           <span class=\"comment\"># Is obj free?</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj                      <span class=\"comment\"># return current obj</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> is_copy(ptr_copy):               <span class=\"comment\"># Already a copy?</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> obj                      <span class=\"comment\"># return obj</span></span><br><span class=\"line\">thread_id = get_thread_id(ptr_copy)</span><br><span class=\"line\"><span class=\"keyword\">if</span> thread_id == ctx.thread_id:      <span class=\"comment\"># Locked by current ctx</span></span><br><span class=\"line\">    <span class=\"built_in\">return</span> ptr_copy                 <span class=\"comment\"># Return copy</span></span><br></pre></td></tr></table></figure>\n\n<p>There is no useful information in any of these comments except for the “Locked by” comment, which suggests something about the thread that might not be obvious from the code. Notice that these comments are at roughly the same level of detail as the code: there is one comment per line of code, which describes that line. Comments like this are rarely useful.</p>\n<blockquote>\n<p>这些注释中没有任何有用的信息，但“ Locked by”注释除外，该注释暗示了有关线程的某些信息可能在代码中并不明显。请注意，这些注释的详细程度与代码大致相同：每行代码有一个注释，用于描述该行。这样的注释很少有用。</p>\n</blockquote>\n<p>Here are more examples of comments that repeat the code:</p>\n<blockquote>\n<p>以下是重复代码的注释的更多示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Add a horizontal scroll bar</span></span><br><span class=\"line\">hScrollBar = <span class=\"keyword\">new</span> JScrollBar(JScrollBar.HORIZONTAL);</span><br><span class=\"line\">add(hScrollBar, BorderLayout.SOUTH);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Add a vertical scroll bar</span></span><br><span class=\"line\">vScrollBar = <span class=\"keyword\">new</span> JScrollBar(JScrollBar.VERTICAL);</span><br><span class=\"line\">add(vScrollBar, BorderLayout.EAST);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Initialize the caret-position related values</span></span><br><span class=\"line\">caretX     = <span class=\"number\">0</span>;</span><br><span class=\"line\">caretY     = <span class=\"number\">0</span>;</span><br><span class=\"line\">caretMemX  = <span class=\"keyword\">null</span>;</span><br></pre></td></tr></table></figure>\n\n<p>None of these comments provide any value. For the first two comments, the code is already clear enough that it doesn’t really need comments; in the third case, a comment might be useful, but the current comment doesn’t provide enough detail to be helpful.</p>\n<blockquote>\n<p>这些评论均未提供任何价值。对于前两个注释，代码已经很清楚了，它实际上不需要注释。在第三种情况下，注释可能有用，但是当前注释没有提供足够的细节来提供帮助。</p>\n</blockquote>\n<p>After you have written a comment, ask yourself the following question: could someone who has never seen the code write the comment just by looking at the code next to the comment? If the answer is yes, as in the examples above, then the comment doesn’t make the code any easier to understand. Comments like these are why some people think that comments are worthless.</p>\n<blockquote>\n<p>编写评论后，请问自己以下问题：从未看过代码的人能否仅通过查看评论旁边的代码来编写评论？如果答案是肯定的（如上述示例所示），则注释不会使代码更易于理解。像这样的评论是为什么有些人认为评论毫无价值的原因。</p>\n</blockquote>\n<p>Another common mistake is to use the same words in the comment that appear in the name of the entity being documented:</p>\n<blockquote>\n<p>另一个常见的错误是在注释中使用与要记录的实体名称相同的词：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Obtain a normalized resource name from REQ.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> String[] getNormalizedResourceNames(</span><br><span class=\"line\">            HTTPRequest req) ...</span><br><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Downcast PARAMETER to TYPE.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object <span class=\"title\">downCastParameter</span><span class=\"params\">(String parameter, String type)</span> ...</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">/*</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> * The horizontal padding of each line in the text.</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\"> */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textHorizontalPadding </span>= <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>These comments just take the words from the method or variable name, perhaps add a few words from argument names and types, and form them into a sentence. For example, the only thing in the second comment that isn’t in the code is the word “to”! Once again, these comments could be written just by looking at the declarations, without any understanding the methods of variables; as a result, they have no value.</p>\n<blockquote>\n<p>这些注释只是从方法或变量名中提取单词，或者从参数名称和类型中添加几个单词，然后将它们组成一个句子。例如，第二个注释中唯一不在代码中的是单词“ to”！再说一次，这些注释可以仅通过查看声明来编写，而无需任何了解变量的方法。结果，它们没有价值。</p>\n</blockquote>\n<p>img Red Flag: Comment Repeats Code img</p>\n<p>If the information in a comment is already obvious from the code next to the comment, then the comment isn’t helpful. One example of this is when the comment uses the same words that make up the name of the thing it is describing.</p>\n<blockquote>\n<p>如果注释旁边的代码中的注释信息已经很明显，则注释无济于事。这样的一个例子是，当注释使用与所描述事物名称相同的单词时。</p>\n</blockquote>\n<p>At the same time, there is important information that is missing from the comments: for example, what is a “normalized resource name”, and what are the elements of the array returned by getNormalizedResourceNames? What does “downcast” mean? What are the units of padding, and is the padding on one side of each line or both? Describing these things in comments would be helpful.</p>\n<blockquote>\n<p>同时，注释中缺少一些重要信息：例如，什么是“标准化资源名称”，以及 getNormalizedResourceNames 返回的数组的元素是什么？“贬低”是什么意思？填充的单位是什么，填充是在每行的一侧还是在两者的两侧？在注释中描述这些内容将很有帮助。</p>\n</blockquote>\n<p>A first step towards writing good comments is to use different words in the comment from those in the name of the entity being described. Pick words for the comment that provide additional information about the meaning of the entity, rather than just repeating its name. For example, here is a better comment for textHorizontalPadding:</p>\n<blockquote>\n<p>编写良好评论的第一步是在评论中使用与所描述实体名称不同的词。为注释选择单词，以提供有关实体含义的更多信息，而不仅仅是重复其名称。例如，以下是针对 textHorizo​​ntalPadding 的更好注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * The amount of blank space to leave on the left and</span></span><br><span class=\"line\"><span class=\"comment\"> * right sides of each line of text, in pixels.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> textHorizontalPadding = <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure>\n\n<p>This comment provides additional information that is not obvious from the declaration itself, such as the units (pixels) and the fact that padding applies to both sides of each line. Instead of using the term “padding”, the comment explains what padding is, in case the reader isn’t already familiar with the term.</p>\n<blockquote>\n<p>该注释提供了从声明本身不明显的其他信息，例如单位（像素）以及填充适用于每行两边的事实。如果读者不熟悉该术语，则注释将解释什么是填充，而不是使用术语“填充”。</p>\n</blockquote>\n<h2 id=\"13-3-Lower-level-comments-add-precision-低级注释可提高精度\"><a href=\"#13-3-Lower-level-comments-add-precision-低级注释可提高精度\" class=\"headerlink\" title=\"13.3 Lower-level comments add precision 低级注释可提高精度\"></a>13.3 Lower-level comments add precision 低级注释可提高精度</h2><p>Now that you know what not to do, let’s discuss what information you should put in comments. Comments augment the code by providing information at a different level of detail. Some comments provide information at a lower, more detailed, level than the code; these comments add precision by clarifying the exact meaning of the code. Other comments provide information at a higher, more abstract, level than the code; these comments offer intuition, such as the reasoning behind the code, or a simpler and more abstract way of thinking about the code. Comments at the same level as the code are likely to repeat the code. This section discusses the lower-level approach in more detail, and the next section discusses the higher-level approach.</p>\n<blockquote>\n<p>现在您知道了不应该做的事情，让我们讨论应该在注释中添加哪些信息。注释通过提供不同详细程度的信息来增强代码。一些注释提供了比代码更低，更详细的信息。这些注释通过阐明代码的确切含 ​​ 义来增加精度。其他注释提供了比代码更高，更抽象的信息。这些注释提供了直觉，例如代码背后的推理，或者更简单，更抽象的代码思考方式。与代码处于同一级别的注释可能会重复该代码。本节将更详细地讨论下层方法，而下一节将讨论上层方法。</p>\n</blockquote>\n<p>Precision is most useful when commenting variable declarations such as class instance variables, method arguments, and return values. The name and type in a variable declaration are typically not very precise. Comments can fill in missing details such as:</p>\n<blockquote>\n<p>在注释变量声明（例如类实例变量，方法参数和返回值）时，精度最有用。变量声明中的名称和类型通常不是很精确。注释可以填写缺少的详细信息，例如：</p>\n</blockquote>\n<ul>\n<li>What are the units for this variable?</li>\n<li>Are the boundary conditions inclusive or exclusive?</li>\n<li>If a null value is permitted, what does it imply?</li>\n<li>If a variable refers to a resource that must eventually be freed or closed, who is responsible for freeing or closing it?</li>\n<li>Are there certain properties that are always true for the variable (invariants), such as “this list always contains at least one entry”?</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>此变量的单位是什么？</li>\n<li>边界条件是包容性还是排他性？</li>\n<li>如果允许使用空值，则意味着什么？</li>\n<li>如果变量引用了最终必须释放或关闭的资源，那么谁负责释放或关闭该资源？</li>\n<li>是否存在某些对于变量始终不变的属性（不变量），例如“此列表始终包含至少一个条目”？</li>\n</ul>\n</blockquote>\n<p>Some of this information could potentially be figured out by examining all of the code where the variable is used. However, this is time-consuming and error-prone; the declaration’s comment should be clear and complete enough to make this unnecessary. When I say that the comment for a declaration should describe things that aren’t obvious from the code, “the code” refers to the code next to the comment (the declaration), not “all of the code in the application.”</p>\n<blockquote>\n<p>通过检查使用该变量的所有代码，可以潜在地了解某些信息。但是，这很耗时且容易出错。宣言的评论应清晰，完整，以免不必要。当我说声明的注释应描述代码中不明显的内容时，“代码”是指注释（声明）旁边的代码，而不是“应用程序中的所有代码”。</p>\n</blockquote>\n<p>The most common problem with comments for variables is that the comments are too vague. Here are two examples of comments that aren’t precise enough:</p>\n<blockquote>\n<p>变量注释最常见的问题是注释太模糊。这是两个不够精确的注释示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Current offset in resp Buffer</span></span><br><span class=\"line\">uint32_t offset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Contains all line-widths inside the document and</span></span><br><span class=\"line\"><span class=\"comment\">// number of appearances.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; lineWidths;</span><br></pre></td></tr></table></figure>\n\n<p>In the first example, it’s not clear what “current” means. In the second example, it’s not clear that the keys in the TreeMap are line widths and values are occurrence counts. Also, are widths measured in pixels or characters? The revised comments below provide additional details:</p>\n<blockquote>\n<p>在第一个示例中，尚不清楚“当前”的含义。在第二个示例中，尚不清楚 TreeMap 中的键是线宽，值是出现次数。另外，宽度是以像素或字符为单位测量的吗？以下修订后的注释提供了更多详细信息：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//  Position in this buffer of the first object that hasn't</span></span><br><span class=\"line\"><span class=\"comment\">//  been returned to the client.</span></span><br><span class=\"line\">uint32_t offset;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//  Holds statistics about line lengths of the form &lt;length, count&gt;</span></span><br><span class=\"line\"><span class=\"comment\">//  where length is the number of characters in a line (including</span></span><br><span class=\"line\"><span class=\"comment\">//  the newline), and count is the number of lines with</span></span><br><span class=\"line\"><span class=\"comment\">//  exactly that many characters. If there are no lines with</span></span><br><span class=\"line\"><span class=\"comment\">//  a particular length, then there is no entry for that length.</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> TreeMap&lt;Integer, Integer&gt; numLinesWithLength;</span><br></pre></td></tr></table></figure>\n\n<p>The second declaration uses a longer name that conveys more information. It also changes “width” to “length”, because this term is more likely to make people think that the units are characters rather than pixels. Notice that the second comment documents not only the details of each entry, but also what it means if an entry is missing.</p>\n<blockquote>\n<p>第二个声明使用一个较长的名称来传达更多信息。它还将“宽度”更改为“长度”，因为该术语更可能使人们认为单位是字符而不是像素。请注意，第二条注释不仅记录了每个条目的详细信息，还记录了缺少条目的含义。</p>\n</blockquote>\n<p>When documenting a variable, think nouns, not verbs. In other words, focus on what the variable represents, not how it is manipulated. Consider the following comment:</p>\n<blockquote>\n<p>在记录变量时，请考虑名词而不是动词。换句话说，关注变量代表什么，而不是如何操纵变量。考虑以下评论：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* FOLLOWER VARIABLE: indicator variable that allows the Receiver and the</span></span><br><span class=\"line\"><span class=\"comment\"> * PeriodicTasks thread to communicate about whether a heartbeat has been</span></span><br><span class=\"line\"><span class=\"comment\"> * received within the follower's election timeout window.</span></span><br><span class=\"line\"><span class=\"comment\"> * Toggled to TRUE when a valid heartbeat is received.</span></span><br><span class=\"line\"><span class=\"comment\"> * Toggled to FALSE when the election timeout window is reset.  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure>\n\n<p>This documentation describes how the variable is modified by several pieces of code in the class. The comment will be both shorter and more useful if it describes what the variable represents rather than mirroring the code structure:</p>\n<blockquote>\n<p>本文档描述了如何通过类中的几段代码来修改变量。如果注释描述变量代表什么而不是镜像代码结构，则注释将更短且更有用：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* True means that a heartbeat has been received since the last time</span></span><br><span class=\"line\"><span class=\"comment\"> * the election timer was reset. Used for communication between the</span></span><br><span class=\"line\"><span class=\"comment\"> * Receiver and PeriodicTasks threads.  */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> receivedValidHeartbeat;</span><br></pre></td></tr></table></figure>\n\n<p>Given this documentation, it’s easy to infer that the variable must be set to true when a heartbeat is received and false when the election timer is reset.</p>\n<blockquote>\n<p>根据本文档，很容易推断出，当接收到心跳信号时，变量必须设置为 true；而当重置选举计时器时，则必须将变量设置为 false。</p>\n</blockquote>\n<h2 id=\"13-4-Higher-level-comments-enhance-intuition-高级注释可增强直觉\"><a href=\"#13-4-Higher-level-comments-enhance-intuition-高级注释可增强直觉\" class=\"headerlink\" title=\"13.4 Higher-level comments enhance intuition 高级注释可增强直觉\"></a>13.4 Higher-level comments enhance intuition 高级注释可增强直觉</h2><p>The second way in which comments can augment code is by providing intuition. These comments are written at a higher level than the code. They omit details and help the reader to understand the overall intent and structure of the code. This approach is commonly used for comments inside methods, and for interface comments. For example, consider the following code:</p>\n<blockquote>\n<p>注释可以增加代码的第二种方法是提供直觉。这些注释是在比代码更高的级别上编写的。它们忽略了细节，并帮助读者理解了代码的整体意图和结构。此方法通常用于方法内部的注释以及接口注释。例如，考虑以下代码：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// If there is a LOADING readRpc using the same session</span></span><br><span class=\"line\"><span class=\"comment\">// as PKHash pointed to by assignPos, and the last PKHash</span></span><br><span class=\"line\"><span class=\"comment\">// in that readRPC is smaller than current assigning</span></span><br><span class=\"line\"><span class=\"comment\">// PKHash, then we put assigning PKHash into that readRPC.</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> readActiveRpcId = RPC_ID_NOT_ASSIGNED;</span><br><span class=\"line\"><span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; NUM_READ_RPC; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (session == readRpc[i].session</span><br><span class=\"line\">            &amp;&amp; readRpc[i].status == LOADING</span><br><span class=\"line\">            &amp;&amp; readRpc[i].maxPos &lt; assignPos</span><br><span class=\"line\">            &amp;&amp; readRpc[i].numHashes &lt; MAX_PKHASHES_PERRPC) &#123;</span><br><span class=\"line\">        readActiveRpcId = i;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The comment is too low-level and detailed. On the one hand, it partially repeats the code: “if there is a LOADING readRPC” just duplicates the test <code>readRpc[i].status == LOADING</code>. On the other hand, the comment doesn’t explain the overall purpose of this code, or how it fits into the method that contains it. As a result, the comment doesn’t help the reader to understand the code.</p>\n<blockquote>\n<p>该评论太底层和太详细。一方面，它部分重复了代码：“如果有 LOADING readRPC”仅重复测试 <code>readRpc[i].status == LOADING</code>。另一方面，注释不能解释此代码的总体目的，也不能解释其如何适合包含此代码的方法。如此一来注释不能帮助读者理解代码。</p>\n</blockquote>\n<p>Here is a better comment:</p>\n<blockquote>\n<p>这是一个更好的评论：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Try to append the current key hash onto an existing</span></span><br><span class=\"line\"><span class=\"comment\">// RPC to the desired server that hasn't been sent yet.</span></span><br></pre></td></tr></table></figure>\n\n<p>This comment doesn’t contain any details; instead, it describes the code’s overall function at a higher level. With this high-level information, a reader can explain almost everything that happens in the code: the loop must be iterating over all the existing remote procedure calls (RPCs); the session test is probably used to see if a particular RPC is destined for the right server; the LOADING test suggests that RPCs can have multiple states, and in some states it isn’t safe to add more hashes; the MAX - PKHASHES_PERRPC test suggests that there is a limit to how many hashes can be sent in a single RPC. The only thing not explained by the comment is the maxPos test. Furthermore, the new comment provides a basis for readers to judge the code: does it do everything that is needed to add the key hash to an existing RPC? The original comment didn’t describe the overall intent of the code, so it’s hard for a reader to decide whether the code is behaving correctly.</p>\n<blockquote>\n<p>此评论不包含任何详细信息。相反，它在更高级别上描述了代码的整体功能。有了这些高级信息，读者就可以解释代码中几乎发生的所有事情：循环必须遍历所有现有的远程过程调用（RPC）；会话测试可能用于查看特定的 RPC 是否发往正确的服务器；LOADING 测试表明 RPC 可以具有多个状态，在某些状态下添加更多的哈希值是不安全的；MAX-PKHASHES_PERRPC 测试表明在单个 RPC 中可以发送多少个哈希值是有限制的。注释中唯一没有解释的是 maxPos 测试。此外，新注释为读者判断代码提供了基础：它可以完成将密钥哈希添加到现有 RPC 所需的一切吗？原始注释并未描述代码的整体意图，因此，读者很难确定代码是否行为正确。</p>\n</blockquote>\n<p>Higher-level comments are more difficult to write than lower-level comments because you must think about the code in a different way. Ask yourself: What is this code trying to do? What is the simplest thing you can say that explains everything in the code? What is the most important thing about this code?</p>\n<blockquote>\n<p>高级别的注释比低级别的注释更难编写，因为您必须以不同的方式考虑代码。问问自己：这段代码要做什么？您能说什么最简单的东西来解释代码中的所有内容？这段代码最重要的是什么？</p>\n</blockquote>\n<p>Engineers tend to be very detail-oriented. We love details and are good at managing lots of them; this is essential for being a good engineer. But, great software designers can also step back from the details and think about a system at a higher level. This means deciding which aspects of the system are most important, and being able to ignore the low-level details and think about the system only in terms of its most fundamental characteristics. This is the essence of abstraction (finding a simple way to think about a complex entity), and it’s also what you must do when writing higher-level comments. A good higher-level comment expresses one or a few simple ideas that provide a conceptual framework, such as “append to an existing RPC.” Given the framework, it becomes easy to see how specific code statements relate to the overall goal.</p>\n<blockquote>\n<p>工程师往往非常注重细节。我们喜欢细节，善于管理其中的许多细节；这对于成为一名优秀的工程师至关重要。但是，优秀的软件设计师也可以从细节退后一步，从更高层次考虑系统。这意味着要确定系统的哪些方面最重要，并且能够忽略底层细节，仅根据系统的最基本特征来考虑系统。这是抽象的本质（找到一种思考复杂实体的简单方法），这也是编写高级注释时必须执行的操作。一个好的高层注释表达了一个或几个简单的想法，这些想法提供了一个概念框架，例如“附加到现有的 RPC”。使用该框架，可以很容易地看到特定的代码语句与总体目标之间的关系。</p>\n</blockquote>\n<p>Here is another code sample, which has a good higher-level comment:</p>\n<blockquote>\n<p>这是另一个代码示例，具有较高层次的注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> (numProcessedPKHashes &lt; readRpc[i].numHashes) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// Some of the key hashes couldn't be looked up in</span></span><br><span class=\"line\">    <span class=\"comment\">// this request (either because they aren't stored</span></span><br><span class=\"line\">    <span class=\"comment\">// on the server, the server crashed, or there</span></span><br><span class=\"line\">    <span class=\"comment\">// wasn't enough space in the response message).</span></span><br><span class=\"line\">    <span class=\"comment\">// Mark the unprocessed hashes so they will get</span></span><br><span class=\"line\">    <span class=\"comment\">// reassigned to new RPCs.</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (size_t p = removePos; p &lt; insertPos; p++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (activeRpcId[p] == i) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (numProcessedPKHashes &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                numProcessedPKHashes--;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (p &lt; assignPos)</span><br><span class=\"line\">                    assignPos = p;</span><br><span class=\"line\">                activeRpcId[p] = RPC_ID_NOT_ASSIGNED;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This comment does two things. The second sentence provides an abstract description of what the code does. The first sentence is different: it explains (in high level terms) why the code is executed. Comments of the form “how we get here” are very useful for helping people to understand code. For example, when documenting a method, it can be very helpful to describe the conditions under which the method is most likely to be invoked (especially if the method is only invoked in unusual situations).</p>\n<blockquote>\n<p>此评论有两件事。第二句话提供了代码功能的抽象描述。第一句话是不同的：它以高级的方式解释了为什么执行代码。“如何到达这里”形式的注释对于帮助人们理解代码非常有用。例如，在记录方法时，描述最有可能在什么情况下调用该方法的条件（特别是仅在异常情况下调用该方法的情况）会非常有帮助。</p>\n</blockquote>\n<h2 id=\"13-5-Interface-documentation-接口文档\"><a href=\"#13-5-Interface-documentation-接口文档\" class=\"headerlink\" title=\"13.5 Interface documentation 接口文档\"></a>13.5 Interface documentation 接口文档</h2><p>One of the most important roles for comments is to define abstractions. Recall from Chapter 4 that an abstraction is a simplified view of an entity, which preserves essential information but omits details that can safely be ignored. Code isn’t suitable for describing abstractions; it’s too low level and it includes implementation details that shouldn’t be visible in the abstraction. The only way to describe an abstraction is with comments. If you want code that presents good abstractions, you must document those abstractions with comments.</p>\n<blockquote>\n<p>注释最重要的作用之一就是定义抽象。回想一下第 4 章，抽象是实体的简化视图，它保留了基本信息，但省略了可以安全忽略的细节。代码不适合描述抽象；它的级别太低，它包含实现细节，这些细节在抽象中不应该看到。描述抽象的唯一方法是使用注释。如果您想要呈现良好抽象的代码，则必须用注释记录这些抽象。</p>\n</blockquote>\n<p>The first step in documenting abstractions is to separate interface comments from implementation comments. Interface comments provide information that someone needs to know in order to use a class or method; they define the abstraction. Implementation comments describe how a class or method works internally in order to implement the abstraction. It’s important to separate these two kinds of comments, so that users of an interface are not exposed to implementation details. Furthermore, these two forms had better be different. If interface comments must also describe the implementation, then the class or method is shallow. This means that the act of writing comments can provide clues about the quality of a design; Chapter 15 will return to this idea.</p>\n<blockquote>\n<p>记录抽象的第一步是将接口注释与实现注释分开。接口注释提供了使用类或方法时需要知道的信息。他们定义了抽象。实现注释描述了类或方法如何在内部工作以实现抽象。区分这两种注释很重要，这样界面的用户就不会暴露于实现细节。此外，这两种形式最好有所不同。如果接口注释也必须描述实现，则该类或方法很浅。这意味着撰写评论的行为可以提供有关设计质量的线索；第 15 章将回到这个想法。</p>\n</blockquote>\n<p>The interface comment for a class provides a high-level description of the abstraction provided by the class, such as the following:</p>\n<blockquote>\n<p>类的接口注释提供了该类提供的抽象的高级描述，例如：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * This class implements a simple server-side interface to the HTTP</span></span><br><span class=\"line\"><span class=\"comment\"> * protocol: by using this class, an application can receive HTTP</span></span><br><span class=\"line\"><span class=\"comment\"> * requests, process them, and return responses. Each instance of</span></span><br><span class=\"line\"><span class=\"comment\"> * this class corresponds to a particular socket used to receive</span></span><br><span class=\"line\"><span class=\"comment\"> * requests. The current implementation is single-threaded and</span></span><br><span class=\"line\"><span class=\"comment\"> * processes one request at a time.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Http</span> </span>&#123;...&#125;</span><br></pre></td></tr></table></figure>\n\n<p>This comment describes the overall capabilities of the class, without any implementation details or even the specifics of particular methods. It also describes what each instance of the class represents. Finally, the comments describe the limitations of the class (it does not support concurrent access from multiple threads), which may be important to developers contemplating whether to use it.</p>\n<blockquote>\n<p>该注释描述了类的整体功能，没有任何实现细节，甚至没有特定方法的细节。它还描述了该类的每个实例代表什么。最后，注释描述了该类的限制（它不支持从多个线程的并发访问），这对于考虑是否使用它的开发人员可能很重要。</p>\n</blockquote>\n<p>The interface comment for a method includes both higher-level information for abstraction and lower-level details for precision:</p>\n<blockquote>\n<p>方法的接口注释既包括用于抽象的高层信息，又包括用于精度的低层细节：</p>\n</blockquote>\n<ul>\n<li>The comment usually starts with a sentence or two describing the behavior of the method as perceived by callers; this is the higher-level abstraction.</li>\n<li>The comment must describe each argument and the return value (if any). These comments must be very precise, and must describe any constraints on argument values as well as dependencies between arguments.</li>\n<li>If the method has any side effects, these must be documented in the interface comment. A side effect is any consequence of the method that affects the future behavior of the system but is not part of the result. For example, if the method adds a value to an internal data structure, which can be retrieved by future method calls, this is a side effect; writing to the file system is also a side effect.</li>\n<li>A method’s interface comment must describe any exceptions that can emanate from the method.</li>\n<li>If there are any preconditions that must be satisfied before a method is invoked, these must be described (perhaps some other method must be invoked first; for a binary search method, the list being searched must be sorted). It is a good idea to minimize preconditions, but any that remain must be documented.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>注释通常以一两个句子开头，描述调用者感知到的方法的行为。这是更高层次的抽象。</li>\n<li>注释必须描述每个参数和返回值（如果有）。这些注释必须非常精确，并且必须描述对参数值的任何约束以及参数之间的依赖关系。</li>\n<li>如果该方法有任何副作用，则必须在界面注释中记录这些副作用。副作用是该方法的任何结果都会影响系统的未来行为，但不属于结果的一部分。例如，如果该方法将一个值添加到内部数据结构中，可以通过将来的方法调用来检索该值，则这是副作用。写入文件系统也是一个副作用。</li>\n<li>方法的界面注释必须描述该方法可能产生的任何异常。</li>\n<li>如果在调用某个方法之前必须满足任何前提条件，则必须对其进行描述（也许必须先调用其他方法；对于二进制搜索方法，必须对要搜索的列表进行排序）。尽量减少前提条件是一个好主意，但是任何保留的条件都必须记录在案。</li>\n</ul>\n</blockquote>\n<p>Here is the interface comment for a method that copies data out of a Buffer object:</p>\n<blockquote>\n<p>这是从 Buffer 对象复制数据的方法的接口注释：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Copy a range of bytes from a buffer to an external location.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param offset</span></span><br><span class=\"line\"><span class=\"comment\"> *        Index within the buffer of the first byte to copy.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param length</span></span><br><span class=\"line\"><span class=\"comment\"> *        Number of bytes to copy.</span></span><br><span class=\"line\"><span class=\"comment\"> * \\param dest</span></span><br><span class=\"line\"><span class=\"comment\"> *        Where to copy the bytes: must have room for at least</span></span><br><span class=\"line\"><span class=\"comment\"> *        length bytes.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *        The return value is the actual number of bytes copied,</span></span><br><span class=\"line\"><span class=\"comment\"> *        which may be less than length if the requested range of</span></span><br><span class=\"line\"><span class=\"comment\"> *        bytes extends past the end of the buffer. 0 is returned</span></span><br><span class=\"line\"><span class=\"comment\"> *        if there is no overlap between the requested range and</span></span><br><span class=\"line\"><span class=\"comment\"> *        the actual buffer.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\">uint32_t</span><br><span class=\"line\">Buffer::copy(uint32_t offset, uint32_t length, <span class=\"keyword\">void</span>* dest)</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>The syntax of this comment (e.g., \\return) follows the conventions of Doxygen, a program that extracts comments from C/C++ code and compiles them into Web pages. The goal of the comment is to provide all the information a developer needs in order to invoke the method, including how special cases are handled (note how this method follows the advice of Chapter 10 and defines out of existence any errors associated with the range specification). The developer should not need to read the body of the method in order to invoke it, and the interface comment provides no information about how the method is implemented, such as how it scans its internal data structures to find the desired data.</p>\n<blockquote>\n<p>此注释的语法（例如\\ return）遵循 Doxygen 的约定，该程序从 C / C ++代码中提取注释并将其编译为 Web 页。注释的目的是提供开发人员调用该方法所需的所有信息，包括特殊情况的处理方式（请注意，此方法如何遵循第 10 章的建议并定义与范围规范相关的任何错误。 ）。开发人员不必为了调用它而阅读方法的主体，并且接口注释不提供有关如何实现该方法的信息，例如它如何扫描其内部数据结构以查找所需的数据。</p>\n</blockquote>\n<p>For a more extended example, let’s consider a class called IndexLookup, which is part of a distributed storage system. The storage system holds a collection of tables, each of which contains many objects. In addition, each table can have one or more indexes; each index provides efficient access to objects in the table based on a particular field of the object. For example, one index might be used to look up objects based on their name field, and another index might be used to look up objects based on their age field. With these indexes, applications can quickly extract all of the objects with a particular name, or all of those with an age in a given range.</p>\n<blockquote>\n<p>对于更扩展的示例，让我们考虑一个称为 IndexLookup 的类，该类是分布式存储系统的一部分。存储系统拥有一个表集合，每个表包含许多对象。另外，每个表可以具有一个或多个索引；每个索引都基于对象的特定字段提供对表中对象的有效访问。例如，一个索引可以用于根据对象的名称字段查找对象，而另一个索引可以用于根据对象的年龄字段查找对象。使用这些索引，应用程序可以快速提取具有特定名称的所有对象，或具有给定范围内的年龄的所有对象。</p>\n</blockquote>\n<p>The IndexLookup class provides a convenient interface for performing indexed lookups. Here is an example of how it might be used in an application:</p>\n<blockquote>\n<p>IndexLookup 类为执行索引查找提供了一个方便的接口。这是一个如何在应用程序中使用的示例：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">query = <span class=\"keyword\">new</span> IndexLookup(table, index, key1, key2);</span><br><span class=\"line\"><span class=\"keyword\">while</span>  (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">    object = query.getNext();</span><br><span class=\"line\">    <span class=\"keyword\">if</span>  (object == NULL) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ... process object ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>The application first constructs an object of type IndexLookup, providing arguments that select a table, an index, and a range within the index (for example, if the index is based on an age field, key1 and key2 might be specified as 21 and 65 to select all objects with ages between those values). Then the application calls the getNext method repeatedly. Each invocation returns one object that falls within the desired range; once all of the matching objects have been returned, getNext returns NULL. Because the storage system is distributed, the implementation of this class is somewhat complex. The objects in a table may be spread across multiple servers, and each index may also be distributed across a different set of servers; the code in the IndexLookup class must first communicate with all of the relevant index servers to collect information about the objects in the range, then it must communicate with the servers that actually store the objects in order to retrieve their values.</p>\n<blockquote>\n<p>应用程序首先构造一个类型为 IndexLookup 的对象，并提供用于选择表，索引和索引内范围的参数（例如，如果索引基于年龄字段，则 key1 和 key2 可以指定为 21 和 65 选择年龄介于这些值之间的所有对象）。然后，应用程序重复调用 getNext 方法。每次调用都返回一个位于所需范围内的对象。一旦返回所有匹配的对象，getNext 将返回 NULL。因为存储系统是分布式的，所以此类的实现有些复杂。表中的对象可以分布在多个服务器上，每个索引也可以分布在一组不同的服务器上。</p>\n</blockquote>\n<p>Now let’s consider what information needs to be included in the interface comment for this class. For each piece of information given below, ask yourself whether a developer needs to know that information in order to use the class (my answers to the questions are at the end of the chapter):</p>\n<blockquote>\n<p>现在，让我们考虑该类的接口注释中需要包含哪些信息。对于下面给出的每条信息，问自己一个开发人员是否需要知道该信息才能使用该类（我对问题的回答在本章的结尾）：</p>\n</blockquote>\n<ol>\n<li>The format of messages that the IndexLookup class sends to the servers holding indexes and objects.</li>\n<li>The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?).</li>\n<li>The data structure used to store indexes on servers.</li>\n<li>Whether or not IndexLookup issues multiple requests to different servers concurrently.</li>\n<li>The mechanism for handling server crashes.</li>\n</ol>\n<blockquote>\n<ol>\n<li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。</li>\n<li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。</li>\n<li>用于在服务器上存储索引的数据结构。</li>\n<li>IndexLookup 是否同时向多个服务器发出多个请求。</li>\n<li>处理服务器崩溃的机制。</li>\n</ol>\n</blockquote>\n<hr>\n<p>Here is the original version of the interface comment for the IndexLookup class; the excerpt also includes a few lines from the class’s definition, which are referred to in the comment:</p>\n<blockquote>\n<p>这是 IndexLookup 类的接口注释的原始版本；摘录还包括类定义的几行内容，在注释中进行了引用：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * This class implements the client side framework for index range</span></span><br><span class=\"line\"><span class=\"comment\"> * lookups. It manages a single LookupIndexKeys RPC and multiple</span></span><br><span class=\"line\"><span class=\"comment\"> * IndexedRead RPCs. Client side just includes \"IndexLookup.h\" in</span></span><br><span class=\"line\"><span class=\"comment\"> * its header to use IndexLookup class. Several parameters can be set</span></span><br><span class=\"line\"><span class=\"comment\"> * in the config below:</span></span><br><span class=\"line\"><span class=\"comment\"> * - The number of concurrent indexedRead RPCs</span></span><br><span class=\"line\"><span class=\"comment\"> * - The max number of PKHashes a indexedRead RPC can hold at a time</span></span><br><span class=\"line\"><span class=\"comment\"> * - The size of the active PKHashes</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To use IndexLookup, the client creates an object of this class by</span></span><br><span class=\"line\"><span class=\"comment\"> * providing all necessary information. After construction of</span></span><br><span class=\"line\"><span class=\"comment\"> * IndexLookup, client can call getNext() function to move to next</span></span><br><span class=\"line\"><span class=\"comment\"> * available object. If getNext() returns NULL, it means we reached</span></span><br><span class=\"line\"><span class=\"comment\"> * the last object. Client can use getKey, getKeyLength, getValue,</span></span><br><span class=\"line\"><span class=\"comment\"> * and getValueLength to get object data of current object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IndexLookup</span> &#123;</span></span><br><span class=\"line\">       ...</span><br><span class=\"line\">   <span class=\"keyword\">private</span>:</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of concurrent indexedRead RPCs</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">uint8_t</span> NUM_READ_RPC = <span class=\"number\">10</span>;</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of PKHashes that can be sent in one</span></span><br><span class=\"line\">       <span class=\"comment\">/// indexedRead RPC</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">uint32_t</span> MAX_PKHASHES_PERRPC = <span class=\"number\">256</span>;</span><br><span class=\"line\">       <span class=\"comment\">/// Max number of PKHashes that activeHashes can</span></span><br><span class=\"line\">       <span class=\"comment\">/// hold at once.</span></span><br><span class=\"line\">       <span class=\"keyword\">static</span> <span class=\"keyword\">const</span> <span class=\"keyword\">size_t</span> MAX_NUM_PK = (<span class=\"number\">1</span> &lt;&lt; LG_BUFFER_SIZE);</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Before reading further, see if you can identify the problems with this comment. Here are the problems that I found:</p>\n<blockquote>\n<p>在进一步阅读之前，请先查看您是否可以使用此注释确定问题所在。这是我发现的问题：</p>\n</blockquote>\n<ul>\n<li>Most of the first paragraph concerns the implementation, not the interface. As one example, users don’t need to know the names of the particular remote procedure calls used to communicate with the servers. The configuration parameters referred to in the second half of the first paragraph are all private variables that are relevant only to the maintainer of the class, not to its users. All of this implementation information should be omitted from the comment.</li>\n<li>The comment also includes several things that are obvious. For example, there’s no need to tell users to include IndexLookup.h: anyone who writes C++ code will be able to guess that this is necessary. In addition, the text “by providing all necessary information” says nothing, so it can be omitted.</li>\n</ul>\n<hr>\n<blockquote>\n<ul>\n<li>第一段的大部分与实现有关，而不是接口。举一个例子，用户不需要知道用于与服务器通信的特定远程过程调用的名称。在第一段的后半部分中提到的配置参数都是所有私有变量，它们仅与类的维护者相关，而与类的用户无关。所有这些实现信息都应从注释中省略。</li>\n<li>该评论还包括一些显而易见的事情。例如，不需要告诉用户包括 IndexLookup.h：任何编写 C ++代码的人都可以猜测这是必要的。另外，“通过提供所有必要的信息”一词无语，因此可以省略。</li>\n</ul>\n</blockquote>\n<p>A shorter comment for this class is sufficient (and preferable):</p>\n<blockquote>\n<p>对此类的简短评论就足够了（并且更可取）：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * This class is used by client applications to make range queries</span></span><br><span class=\"line\"><span class=\"comment\"> * using indexes. Each instance represents a single range query.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * To start a range query, a client creates an instance of this</span></span><br><span class=\"line\"><span class=\"comment\"> * class. The client can then call getNext() to retrieve the objects</span></span><br><span class=\"line\"><span class=\"comment\"> * in the desired range. For each object returned by getNext(), the</span></span><br><span class=\"line\"><span class=\"comment\"> * caller can invoke getKey(), getKeyLength(), getValue(), and</span></span><br><span class=\"line\"><span class=\"comment\"> * getValueLength() to get information about that object.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>The last paragraph of this comment is not strictly necessary, since it mostly duplicates information in the comments for individual methods. However, it can be helpful to have examples in the class documentation that illustrate how its methods work together, particularly for deep classes with usage patterns that are nonobvious. Note that the new comment does not mention NULL return values from getNext. This comment is not intended to document every detail of each method; it just provides high level information to help readers understand how the methods work together and when each method might be invoked. For details, readers can refer to the interface comments for individual methods. This comment also does not mention server crashes; that is because server crashes are invisible to users of this class (the system automatically recovers from them).</p>\n<blockquote>\n<p>此注释的最后一段不是严格必需的，因为它主要针对单个方法复制了注释中的信息。但是，在类文档中提供示例来说明其方法如何协同工作可能会有所帮助，特别是对于使用模式不明显的深层类尤其如此。注意，新注释未提及 getNext 的 NULL 返回值。此注释无意记录每种方法的每个细节；它只是提供高级信息，以帮助读者了解这些方法如何协同工作以及何时可以调用每种方法。有关详细信息，读者可以参考接口注释中的各个方法。此评论也没有提到服务器崩溃；这是因为此类服务器的用户看不到服务器崩溃（系统会自动从中恢复）。</p>\n</blockquote>\n<p>img Red Flag: Implementation Documentation Contaminates Interface img</p>\n<p>This red flag occurs when interface documentation, such as that for a method, describes implementation details that aren’t needed in order to use the thing being documented.</p>\n<blockquote>\n<p>当接口文档（例如方法的文档）描述了不需要使用要记录的事物的实现详细信息时，就会出现此红色标记。</p>\n</blockquote>\n<p>Now consider the following code, which shows the first version of the documentation for the isReady method in IndexLookup:</p>\n<blockquote>\n<p>现在考虑以下代码，该代码显示 IndexLookup 中 isReady 方法的文档的第一版：</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Check if the next object is RESULT_READY. This function is</span></span><br><span class=\"line\"><span class=\"comment\"> * implemented in a DCFT module, each execution of isReady() tries</span></span><br><span class=\"line\"><span class=\"comment\"> * to make small progress, and getNext() invokes isReady() in a</span></span><br><span class=\"line\"><span class=\"comment\"> * while loop, until isReady() returns true.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * isReady() is implemented in a rule-based approach. We check</span></span><br><span class=\"line\"><span class=\"comment\"> * different rules by following a particular order, and perform</span></span><br><span class=\"line\"><span class=\"comment\"> * certain actions if some rule is satisfied.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *         True means the next Object is available. Otherwise, return</span></span><br><span class=\"line\"><span class=\"comment\"> *         false.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">IndexLookup::isReady</span><span class=\"params\">()</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>\n\n<p>Once again, most of this documentation, such as the reference to DCFT and the entire second paragraph, concerns the implementation, so it doesn’t belong here; this is one of the most common errors in interface comments. Some of the implementation documentation is useful, but it should go inside the method, where it will be clearly separated from interface documentation. In addition, the first sentence of the documentation is cryptic (what does RESULT_READY mean?) and some important information is missing. Finally, it isn’t necessary to describe the implementation of getNext here. Here is a better version of the comment:</p>\n<blockquote>\n<p>再一次，本文档中的大多数内容，例如对 DCFT 的引用以及整个第二段，都与实现有关，因此不属于此处。这是界面注释中最常见的错误之一。某些实现文档很有用，但应放在方法内部，在该方法中应将其与接口文档明确分开。此外，文档的第一句话是含糊的（RESULT_READY 是什么意思？），并且缺少一些重要信息。最后，无需在此处描述 getNext 的实现。这是评论的更好版本：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\"> * Indicates whether an indexed read has made enough progress for</span></span><br><span class=\"line\"><span class=\"comment\"> * getNext to return immediately without blocking. In addition, this</span></span><br><span class=\"line\"><span class=\"comment\"> * method does most of the real work for indexed reads, so it must</span></span><br><span class=\"line\"><span class=\"comment\"> * be invoked (either directly, or indirectly by calling getNext) in</span></span><br><span class=\"line\"><span class=\"comment\"> * order for the indexed read to make progress.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * \\return</span></span><br><span class=\"line\"><span class=\"comment\"> *         True means that the next invocation of getNext will not block</span></span><br><span class=\"line\"><span class=\"comment\"> *         (at least one object is available to return, or the end of the</span></span><br><span class=\"line\"><span class=\"comment\"> *         lookup has been reached); false means getNext may block.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br></pre></td></tr></table></figure>\n\n<p>This version of the comment provides more precise information about what “ready” means, and it provides the important information that this method must eventually be invoked if the indexed retrieval is to move forward.</p>\n<blockquote>\n<p>此注释版本提供了有关“就绪”含义的更精确信息，并且提供了重要信息，如果要继续进行索引检索，则必须最终调用此方法。</p>\n</blockquote>\n<h2 id=\"13-6-Implementation-comments-what-and-why-not-how-实施注释：什么以及为什么，而不是如何\"><a href=\"#13-6-Implementation-comments-what-and-why-not-how-实施注释：什么以及为什么，而不是如何\" class=\"headerlink\" title=\"13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何\"></a>13.6 Implementation comments: what and why, not how 实施注释：什么以及为什么，而不是如何</h2><p>Implementation comments are the comments that appear inside methods to help readers understand how they work internally. Most methods are so short and simple that they don’t need any implementation comments: given the code and the interface comments, it’s easy to figure out how a method works.</p>\n<blockquote>\n<p>实现注释是出现在方法内部的注释，以帮助读者了解它们在内部的工作方式。大多数方法是如此简短，简单，以至于它们不需要任何实现注释：有了代码和接口注释，就很容易弄清楚方法的工作原理。</p>\n</blockquote>\n<p>The main goal of implementation comments is to help readers understand what the code is doing (not how it does it). Once readers know what the code is trying to do, it’s usually easy to understand how the code works. For short methods, the code only does one thing, which is already described in its interface comment, so no implementation comments are needed. Longer methods have several blocks of code that do different things as part of the method’s overall task. Add a comment before each of the major blocks to provide a high-level (more abstract) description of what that block does. Here is an example:</p>\n<blockquote>\n<p>实现注释的主要目的是帮助读者理解代码在做什么（而不是代码如何工作）。一旦读者知道了代码要做什么，通常就很容易理解代码的工作原理。对于简短的方法，代码只做一件事，该问题已在其接口注释中进行了描述，因此不需要实现注释。较长的方法具有多个代码块，这些代码块作为方法的整体任务的一部分执行不同的操作。在每个主要块之前添加注释，以提供对该块的作用的高级（更抽象）描述。这是一个例子：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Phase 1: Scan active RPCs to see if any have completed.</span></span><br></pre></td></tr></table></figure>\n\n<p>For loops, it’s helpful to have a comment before the loop that describes what happens in each iteration:</p>\n<blockquote>\n<p>对于循环，在循环前加一个注释来描述每次迭代中发生的事情是有帮助的：</p>\n</blockquote>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// Each iteration of the following loop extracts one request from</span></span><br><span class=\"line\"><span class=\"comment\">// the request message, increments the corresponding object, and</span></span><br><span class=\"line\"><span class=\"comment\">// appends a response to the response message.</span></span><br></pre></td></tr></table></figure>\n\n<p>Notice how this comment describes the loop at a more abstract and intuitive level; it doesn’t go into any details about how a request is extracted from the request message or how the object is incremented. Loop comments are only needed for longer or more complex loops, where it may not be obvious what the loop is doing; many loops are short and simple enough that their behavior is already obvious.</p>\n<blockquote>\n<p>请注意，此注释如何更抽象和直观地描述循环。它没有详细介绍如何从请求消息中提取请求或对象如何递增。仅对于更长或更复杂的循环才需要循环注释，在这种情况下，循环的作用可能并不明显。许多循环足够短且简单，以至于其行为已经很明显。</p>\n</blockquote>\n<p>In addition to describing what the code is doing, implementation comments are also useful to explain why. If there are tricky aspects to the code that won’t be obvious from reading it, you should document them. For example, if a bug fix requires the addition of code whose purpose isn’t totally obvious, add a comment describing why the code is needed. For bug fixes where there is a well-written bug report describing the problem, the comment can refer to the issue in the bug tracking database rather than repeating all its details (“Fixes RAM-436, related to device driver crashes in Linux 2.4.x”). Developers can look in the bug database for more details (this is an example of avoiding duplication in comments, which will be discussed in Chapter 16).</p>\n<blockquote>\n<p>除了描述代码在做什么之外，实现注释还有助于解释原因。如果代码中有些棘手的方面从阅读中看不出来，则应将它们记录下来。例如，如果一个错误修复程序需要添加目的不是很明显的代码，请添加注释以说明为什么需要该代码。对于错误修复，其中有写得很好的错误报告来描述问题，该注释可以引用错误跟踪数据库中的问题，而不是重复其所有详细信息（“修复 RAM-436，与 Linux 2.4 中的设备驱动程序崩溃有关。” X”）。开发人员可以在 bug 数据库中查找更多详细信息（这是一个避免注释重复的示例，这将在第 16 章中进行讨论）。</p>\n</blockquote>\n<p>For longer methods, it can be helpful to write comments for a few of the most important local variables. However, most local variables don’t need documentation if they have good names. If all of the uses of a variable are visible within a few lines of each other, it’s usually easy to understand the variable’s purpose without a comment. In this case it’s OK to let readers read the code to figure out the meaning of the variable. However, if the variable is used over a large span of code, then you should consider adding a comment to describe the variable. When documenting variables, focus on what the variable represents, not how it is manipulated in the code.</p>\n<blockquote>\n<p>对于更长的方法，为一些最重要的局部变量写注释会很有帮助。但是，如果大多数局部变量具有好名字，则不需要文档。如果变量的所有用法在几行之内都是可见的，则通常无需注释即可轻松理解变量的用途。在这种情况下，可以让读者阅读代码来弄清楚变量的含义。但是，如果在大量代码中使用了该变量，则应考虑添加注释以描述该变量。在记录变量时，应关注变量表示的内容，而不是代码中如何对其进行操作。</p>\n</blockquote>\n<h2 id=\"13-7-Cross-module-design-decisions-跨模块设计决策\"><a href=\"#13-7-Cross-module-design-decisions-跨模块设计决策\" class=\"headerlink\" title=\"13.7 Cross-module design decisions 跨模块设计决策\"></a>13.7 Cross-module design decisions 跨模块设计决策</h2><p>In a perfect world, every important design decision would be encapsulated within a single class. Unfortunately, real systems inevitably end up with design decisions that affect multiple classes. For example, the design of a network protocol will affect both the sender and the receiver, and these may be implemented in different places. Cross-module decisions are often complex and subtle, and they account for many bugs, so good documentation for them is crucial.</p>\n<blockquote>\n<p>在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p>\n</blockquote>\n<p>The biggest challenge with cross-module documentation is finding a place to put it where it will naturally be discovered by developers. Sometimes there is an obvious central place to put such documentation. For example, the RAMCloud storage system defines a Status value, which is returned by each request to indicate success or failure. Adding a Status for a new error condition requires modifying many different files (one file maps Status values to exceptions, another provides a human-readable message for each Status, and so on). Fortunately, there is one obvious place where developers will have to go when adding a new status value, which is the declaration of the Status enum. We took advantage of this by adding comments in that enum to identify all of the other places that must also be modified:</p>\n<blockquote>\n<p>跨模块文档的最大挑战是找到一个放置它的位置，以便开发人员自然地发现它。有时，放置此类文档的中心位置很明显。例如，RAMCloud 存储系统定义一个状态值，每个请求均返回该状态值以指示成功或失败。为新的错误状况添加状态需要修改许多不同的文件（一个文件将状态值映射到异常，另一个文件为每个状态提供人类可读的消息，依此类推）。幸运的是，添加新的状态值（即 Status 枚举的声明）时，开发人员必须去一个明显的地方。我们通过在该枚举中添加注释来标识所有其他必须修改的地方，从而利用了这一点：在理想环境中，每个重要的设计决策都将封装在一个类中。不幸的是，真实的系统不可避免地最终会影响到多个类的设计决策。例如，网络协议的设计将影响发送方和接收方，并且它们可以在不同的地方实现。跨模块决策通常是复杂而微妙的，并且会导致许多错误，因此，为它们提供良好的文档至关重要。</p>\n</blockquote>\n<figure class=\"highlight cpp\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">enum</span> Status &#123;</span><br><span class=\"line\">    STATUS_OK = <span class=\"number\">0</span>,</span><br><span class=\"line\">    STATUS_UNKNOWN_TABLET                = <span class=\"number\">1</span>,</span><br><span class=\"line\">    STATUS_WRONG_VERSION                 = <span class=\"number\">2</span>,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    STATUS_INDEX_DOESNT_EXIST            = <span class=\"number\">29</span>,</span><br><span class=\"line\">    STATUS_INVALID_PARAMETER             = <span class=\"number\">30</span>,</span><br><span class=\"line\">    STATUS_MAX_VALUE                     = <span class=\"number\">30</span>,</span><br><span class=\"line\">    <span class=\"comment\">// Note: if you add a new status value you must make the following</span></span><br><span class=\"line\">    <span class=\"comment\">// additional updates:</span></span><br><span class=\"line\">    <span class=\"comment\">// (1)  Modify STATUS_MAX_VALUE to have a value equal to the</span></span><br><span class=\"line\">    <span class=\"comment\">//      largest defined status value, and make sure its definition</span></span><br><span class=\"line\">    <span class=\"comment\">//      is the last one in the list. STATUS_MAX_VALUE is used</span></span><br><span class=\"line\">    <span class=\"comment\">//      primarily for testing.</span></span><br><span class=\"line\">    <span class=\"comment\">// (2)  Add new entries in the tables \"messages\" and \"symbols\" in</span></span><br><span class=\"line\">    <span class=\"comment\">//      Status.cc.</span></span><br><span class=\"line\">    <span class=\"comment\">// (3)  Add a new exception class to ClientException.h</span></span><br><span class=\"line\">    <span class=\"comment\">// (4)  Add a new \"case\" to ClientException::throwException to map</span></span><br><span class=\"line\">    <span class=\"comment\">//      from the status value to a status-specific ClientException</span></span><br><span class=\"line\">    <span class=\"comment\">//      subclass.</span></span><br><span class=\"line\">    <span class=\"comment\">// (5)  In the Java bindings, add a static class for the exception</span></span><br><span class=\"line\">    <span class=\"comment\">//      to ClientException.java</span></span><br><span class=\"line\">    <span class=\"comment\">// (6)  Add a case for the status of the exception to throw the</span></span><br><span class=\"line\">    <span class=\"comment\">//      exception in ClientException.java</span></span><br><span class=\"line\">    <span class=\"comment\">// (7)  Add the exception to the Status enum in Status.java, making</span></span><br><span class=\"line\">    <span class=\"comment\">//      sure the status is in the correct position corresponding to</span></span><br><span class=\"line\">    <span class=\"comment\">//      its status code.</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>New status values will be added at the end of the existing list, so the comments are also placed at the end, where they are most likely to be seen.</p>\n<blockquote>\n<p>新状态值将添加到现有列表的末尾，因此注释也将放置在最有可能出现的末尾。</p>\n</blockquote>\n<p>Unfortunately, in many cases there is not an obvious central place to put cross-module documentation. One example from the RAMCloud storage system was the code for dealing with zombie servers, which are servers that the system believes have crashed, but in fact are still running. Neutralizing zombie servers required code in several different modules, and these pieces of code all depend on each other. None of the pieces of code is an obvious central place to put documentation. One possibility is to duplicate parts of the documentation in each location that depends on it. However, this is awkward, and it is difficult to keep such documentation up to date as the system evolves. Alternatively, the documentation can be located in one of the places where it is needed, but in this case it’s unlikely that developers will see the documentation or know where to look for it.</p>\n<blockquote>\n<p>不幸的是，在许多情况下，并没有一个明显的中心位置来放置跨模块文档。RAMCloud 存储系统中的一个例子是处理僵尸服务器的代码，僵尸服务器是系统认为已经崩溃但实际上仍在运行的服务器。中和 zombie server 需要几个不同模块中的代码，这些代码都相互依赖。没有一段代码明显是放置文档的中心位置。一种可能性是在每个依赖文档的位置复制文档的部分。然而，这是令人尴尬的，并且随着系统的发展，很难使这样的文档保持最新。或者，文档可以位于需要它的位置之一，但是在这种情况下，开发人员不太可能看到文档或者知道在哪里查找它。</p>\n</blockquote>\n<p>I have recently been experimenting with an approach where cross-module issues are documented in a central file called designNotes. The file is divided up into clearly labeled sections, one for each major topic. For example, here is an excerpt from the file:</p>\n<blockquote>\n<p>我最近一直在尝试一种方法，该方法将跨模块问题记录在一个名为 designNotes 的中央文件中。该文件分为清楚标记的部分，每个主要主题一个。例如，以下是该文件的摘录：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">...</span><br><span class=\"line\">Zombies</span><br><span class=\"line\">-------</span><br><span class=\"line\">A zombie is a server that is considered dead by the rest of the</span><br><span class=\"line\">cluster; any data stored on the server has been recovered and will</span><br><span class=\"line\">be managed by other servers. However, if a zombie is not actually</span><br><span class=\"line\">dead (e.g., it was just disconnected from the other servers for a</span><br><span class=\"line\">while) two forms of inconsistency can arise:</span><br><span class=\"line\">* A zombie server must not serve read requests once replacement servers have taken over; otherwise it may return stale data that does not reflect writes accepted by the replacement servers.</span><br><span class=\"line\">* The zombie server must not accept write requests once replacement servers have begun replaying its log during recovery; if it does, these writes may be lost (the new values may not be stored on the replacement servers and thus will not be returned by reads).</span><br><span class=\"line\"></span><br><span class=\"line\">RAMCloud uses two techniques to neutralize zombies. First,</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n\n<p>Then, in any piece of code that relates to one of these issues there is a short comment referring to the designNotes file:</p>\n<blockquote>\n<p>然后，在与这些问题之一相关的任何代码段中，都有一条简短的注释引用了 designNotes 文件：</p>\n</blockquote>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// See \"Zombies\" in designNotes.</span></span><br></pre></td></tr></table></figure>\n\n<p>With this approach, there is only a single copy of the documentation and it is relatively easy for developers to find it when they need it. However, this has the disadvantage that the documentation is not near any of the pieces of code that depend on it, so it may be difficult to keep up-to-date as the system evolves.</p>\n<blockquote>\n<p>使用这种方法，文档只有一个副本，因此开发人员在需要时可以相对容易地找到它。但是，这样做的缺点是，文档离它依赖的任何代码段都不近，因此随着系统的发展，可能难以保持最新。</p>\n</blockquote>\n<h2 id=\"13-8-Conclusion-结论\"><a href=\"#13-8-Conclusion-结论\" class=\"headerlink\" title=\"13.8 Conclusion 结论\"></a>13.8 Conclusion 结论</h2><p>The goal of comments is to ensure that the structure and behavior of the system is obvious to readers, so they can quickly find the information they need and make modifications to the system with confidence that they will work. Some of this information can be represented in the code in a way that will already be obvious to readers, but there is a significant amount of information that can’t easily be deduced from the code. Comments fill in this information.</p>\n<blockquote>\n<p>评论的目的是确保系统的结构和行为对读者来说是显而易见的，因此他们可以快速找到所需的信息，并有信心对其进行修改，以对系统进行修改。这些信息中的某些信息可以以对读者来说显而易见的方式表示在代码中，但是有大量信息无法从代码中轻易推导出。注释将填写此信息。</p>\n</blockquote>\n<p>When following the rule that comments should describe things that aren’t obvious from the code, “obvious” is from the perspective of someone reading your code for the first time (not you). When writing comments, try to put yourself in the mindset of the reader and ask yourself what are the key things he or she will need to know. If your code is undergoing review and a reviewer tells you that something is not obvious, don’t argue with them; if a reader thinks it’s not obvious, then it’s not obvious. Instead of arguing, try to understand what they found confusing and see if you can clarify that, either with better comments or better code.</p>\n<blockquote>\n<p>当遵循注释应描述代码中不明显的内容的规则时，“明显”是从第一次读取您的代码的人（不是您）的角度出发。在撰写评论时，请尝试使自己进入读者的心态，并问自己他或她需要知道哪些关键事项。如果您的代码正在接受审核，并且审核者告诉您某些不明显的内容，请不要与他们争论。如果读者认为它不明显，那么它就不明显。不用争论，而是尝试了解他们发现的令人困惑的地方，并查看是否可以通过更好的注释或更好的代码来澄清它们。</p>\n</blockquote>\n<h2 id=\"13-9-Answers-to-questions-from-Section-13-5-回答第-13-5-节中的问题\"><a href=\"#13-9-Answers-to-questions-from-Section-13-5-回答第-13-5-节中的问题\" class=\"headerlink\" title=\"13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题\"></a>13.9 Answers to questions from Section 13.5 回答第 13.5 节中的问题</h2><p>Does a developer need to know each of the following pieces of information in order to use the IndexLookup class?</p>\n<blockquote>\n<p>开发人员是否需要了解以下每条信息才能使用 IndexLookup 类？</p>\n</blockquote>\n<ol>\n<li>The format of messages that the IndexLookup class sends to the servers holding indexes and objects. No: this is an implementation detail that should be hidden within the class.</li>\n<li>The comparison function used to determine whether a particular object falls in the desired range (is comparison done using integers, floating-point numbers, or strings?). Yes: users of the class need to know this information.</li>\n<li>The data structure used to store indexes on servers. No: this information should be encapsulated on the servers; not even the implementation of IndexLookup should need to know this.</li>\n<li>Whether or not IndexLookup issues multiple requests to different servers concurrently. Possibly: if IndexLookup uses special techniques to improve performance, then the documentation should provide some high-level information about this, since users may care about performance.</li>\n<li>The mechanism for handling server crashes. No: RAMCloud recovers automatically from server crashes, so crashes are not visible to application-level software; thus, there is no need to mention crashes in the interface documentation for IndexLookup. If crashes were reflected up to applications, then the interface documentation would need to describe how they manifest themselves (but not the details of how crash recovery works).</li>\n</ol>\n<hr>\n<blockquote>\n<ol>\n<li>IndexLookup 类发送给包含索引和对象的服务器的消息格式。否：这是应隐藏在类中的实现细节。</li>\n<li>用于确定特定对象是否在所需范围内的比较功能（使用整数，浮点数或字符串进行比较吗？）。是：该课程的用户需要了解此信息。</li>\n<li>用于在服务器上存储索引的数据结构。否：此信息应封装在服务器上；甚至 IndexLookup 的实现都不需要知道这一点。</li>\n<li>IndexLookup 是否同时向多个服务器发出多个请求。可能：如果 IndexLookup 使用特殊技术来提高性能，则文档应提供有关此问题的一些高级信息，因为用户可能会在意性能。</li>\n<li>处理服务器崩溃的机制。否：RAMCloud 可从服务器崩溃中自动恢复，因此崩溃对于应用程序级软件不可见；因此，在 IndexLookup 的接口文档中无需提及崩溃。如果崩溃反映到应用程序中，则接口文档将需要描述它们如何表现出来（而不是崩溃恢复如何工作的详细信息）。</li>\n</ol>\n</blockquote>"},{"title":"北漂的日子（九）平凡的一年终于过去了","date":"2014-01-03T17:01:00.000Z","_content":"\n2013，是平凡的一年。没有惊喜的剧情，没有跌宕的狗血。如白开水，清透，平淡。\n\n2013，是平静的一年。没有结婚，没有生子，没有买房，没有买车，没有升职，没有涨工资，没有换东家，没有换老板，甚至连计划好的驾照也米有拿到。\n\n2013，是平淡的一年。坐在2011年就开始坐的办公桌前，做着2012年就在做的工作，住在2012年就租住的院子，还是赶着642路上班，还是刷着2011年就开始刷的那个打卡机，还是坐破旧的303路转乘安河桥北地铁。\n\n2013年，是简单的一年。只是陪着女友去了趟她家，回了几次我家。我们没有出去旅游，也没有请朋友吃饭，没买一件有档次的衣服，去动批买衣服就算是进城逛街了，我们蜗居在海淀西北郊的一个小村子，几乎忘记了自己生活在帝都。我们最奢侈的事就是自助烤肉。\n\n尽管如此，我不会忘记这平凡的2013年。\n\n这一年，我第一次坐27个小时的火车南下，第一次跨过淮河，第一次看见了湖北的民居，四川的山水。\n这一年，我第一次赤脚长江水，偷摘路边橙。\n这一年，我第一次住在离长江那么近的地方，夜晚可以听见长江浪声。\n这一年，我第一次和远在重庆深山里的一户人家建立了深厚的联系。\n这一年，我第一次参与一本专业书籍的翻译，并且这本书已经出版发售了。\n这一年，我第一次上了电视新闻。\n这一年，我第一次骑行超过30公里。\n这一年，我第一次单次游泳超过2000米。\n这一年，我第一次体验了连续5天的自驾。\n这一年，我第一次自京北上，领略草原的辽阔壮丽。\n这一年，我第一次在草原上策马前行。\n这一年，我第一次在海边钓鱼，钓到了我的第一条海鱼。\n这一年，我第一次为父母买了一件我认为的奢侈品。\n这一年，我第一次为我的未来迷茫，不知道了前方的路在哪里。\n\n。。。。。。\n\n还有很多第一次......，第一次拆硬盘，第一次因喝酒过度而去急诊，第一次喝清酒，第一次认真的一秒钟不拉的看完一场球赛，第一次自毕业以来，认真的一页不拉的看完一篇中篇小说。。。。。\n\n岁月就这在第一次，第二次，第n次中流过，平静而笃定。\n\n沿着2012年的远去的那条路，2013年也渐渐远去， 没有准备好，2014年就扑面而来，生活重复着昨天的故事，我还是那个平庸的人，时间丝毫没有让我伟大或者发达。\n\n我虽好吃，却是不馋。\n我虽好色，却不放荡。\n2014，平凡的过吧。 ","source":"_posts/北漂的日子（九）平凡的一年终于过去了.md","raw":"---\ntitle: 北漂的日子（九）平凡的一年终于过去了\ndate: 2014-1-4 01:01\n---\n\n2013，是平凡的一年。没有惊喜的剧情，没有跌宕的狗血。如白开水，清透，平淡。\n\n2013，是平静的一年。没有结婚，没有生子，没有买房，没有买车，没有升职，没有涨工资，没有换东家，没有换老板，甚至连计划好的驾照也米有拿到。\n\n2013，是平淡的一年。坐在2011年就开始坐的办公桌前，做着2012年就在做的工作，住在2012年就租住的院子，还是赶着642路上班，还是刷着2011年就开始刷的那个打卡机，还是坐破旧的303路转乘安河桥北地铁。\n\n2013年，是简单的一年。只是陪着女友去了趟她家，回了几次我家。我们没有出去旅游，也没有请朋友吃饭，没买一件有档次的衣服，去动批买衣服就算是进城逛街了，我们蜗居在海淀西北郊的一个小村子，几乎忘记了自己生活在帝都。我们最奢侈的事就是自助烤肉。\n\n尽管如此，我不会忘记这平凡的2013年。\n\n这一年，我第一次坐27个小时的火车南下，第一次跨过淮河，第一次看见了湖北的民居，四川的山水。\n这一年，我第一次赤脚长江水，偷摘路边橙。\n这一年，我第一次住在离长江那么近的地方，夜晚可以听见长江浪声。\n这一年，我第一次和远在重庆深山里的一户人家建立了深厚的联系。\n这一年，我第一次参与一本专业书籍的翻译，并且这本书已经出版发售了。\n这一年，我第一次上了电视新闻。\n这一年，我第一次骑行超过30公里。\n这一年，我第一次单次游泳超过2000米。\n这一年，我第一次体验了连续5天的自驾。\n这一年，我第一次自京北上，领略草原的辽阔壮丽。\n这一年，我第一次在草原上策马前行。\n这一年，我第一次在海边钓鱼，钓到了我的第一条海鱼。\n这一年，我第一次为父母买了一件我认为的奢侈品。\n这一年，我第一次为我的未来迷茫，不知道了前方的路在哪里。\n\n。。。。。。\n\n还有很多第一次......，第一次拆硬盘，第一次因喝酒过度而去急诊，第一次喝清酒，第一次认真的一秒钟不拉的看完一场球赛，第一次自毕业以来，认真的一页不拉的看完一篇中篇小说。。。。。\n\n岁月就这在第一次，第二次，第n次中流过，平静而笃定。\n\n沿着2012年的远去的那条路，2013年也渐渐远去， 没有准备好，2014年就扑面而来，生活重复着昨天的故事，我还是那个平庸的人，时间丝毫没有让我伟大或者发达。\n\n我虽好吃，却是不馋。\n我虽好色，却不放荡。\n2014，平凡的过吧。 ","slug":"北漂的日子（九）平凡的一年终于过去了","published":1,"updated":"2022-01-30T17:10:33.601Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sl60000ojzohs7h2ie0","content":"<p>2013，是平凡的一年。没有惊喜的剧情，没有跌宕的狗血。如白开水，清透，平淡。</p>\n<p>2013，是平静的一年。没有结婚，没有生子，没有买房，没有买车，没有升职，没有涨工资，没有换东家，没有换老板，甚至连计划好的驾照也米有拿到。</p>\n<p>2013，是平淡的一年。坐在2011年就开始坐的办公桌前，做着2012年就在做的工作，住在2012年就租住的院子，还是赶着642路上班，还是刷着2011年就开始刷的那个打卡机，还是坐破旧的303路转乘安河桥北地铁。</p>\n<p>2013年，是简单的一年。只是陪着女友去了趟她家，回了几次我家。我们没有出去旅游，也没有请朋友吃饭，没买一件有档次的衣服，去动批买衣服就算是进城逛街了，我们蜗居在海淀西北郊的一个小村子，几乎忘记了自己生活在帝都。我们最奢侈的事就是自助烤肉。</p>\n<p>尽管如此，我不会忘记这平凡的2013年。</p>\n<p>这一年，我第一次坐27个小时的火车南下，第一次跨过淮河，第一次看见了湖北的民居，四川的山水。<br>这一年，我第一次赤脚长江水，偷摘路边橙。<br>这一年，我第一次住在离长江那么近的地方，夜晚可以听见长江浪声。<br>这一年，我第一次和远在重庆深山里的一户人家建立了深厚的联系。<br>这一年，我第一次参与一本专业书籍的翻译，并且这本书已经出版发售了。<br>这一年，我第一次上了电视新闻。<br>这一年，我第一次骑行超过30公里。<br>这一年，我第一次单次游泳超过2000米。<br>这一年，我第一次体验了连续5天的自驾。<br>这一年，我第一次自京北上，领略草原的辽阔壮丽。<br>这一年，我第一次在草原上策马前行。<br>这一年，我第一次在海边钓鱼，钓到了我的第一条海鱼。<br>这一年，我第一次为父母买了一件我认为的奢侈品。<br>这一年，我第一次为我的未来迷茫，不知道了前方的路在哪里。</p>\n<p>。。。。。。</p>\n<p>还有很多第一次……，第一次拆硬盘，第一次因喝酒过度而去急诊，第一次喝清酒，第一次认真的一秒钟不拉的看完一场球赛，第一次自毕业以来，认真的一页不拉的看完一篇中篇小说。。。。。</p>\n<p>岁月就这在第一次，第二次，第n次中流过，平静而笃定。</p>\n<p>沿着2012年的远去的那条路，2013年也渐渐远去， 没有准备好，2014年就扑面而来，生活重复着昨天的故事，我还是那个平庸的人，时间丝毫没有让我伟大或者发达。</p>\n<p>我虽好吃，却是不馋。<br>我虽好色，却不放荡。<br>2014，平凡的过吧。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>2013，是平凡的一年。没有惊喜的剧情，没有跌宕的狗血。如白开水，清透，平淡。</p>\n<p>2013，是平静的一年。没有结婚，没有生子，没有买房，没有买车，没有升职，没有涨工资，没有换东家，没有换老板，甚至连计划好的驾照也米有拿到。</p>\n<p>2013，是平淡的一年。坐在2011年就开始坐的办公桌前，做着2012年就在做的工作，住在2012年就租住的院子，还是赶着642路上班，还是刷着2011年就开始刷的那个打卡机，还是坐破旧的303路转乘安河桥北地铁。</p>\n<p>2013年，是简单的一年。只是陪着女友去了趟她家，回了几次我家。我们没有出去旅游，也没有请朋友吃饭，没买一件有档次的衣服，去动批买衣服就算是进城逛街了，我们蜗居在海淀西北郊的一个小村子，几乎忘记了自己生活在帝都。我们最奢侈的事就是自助烤肉。</p>\n<p>尽管如此，我不会忘记这平凡的2013年。</p>\n<p>这一年，我第一次坐27个小时的火车南下，第一次跨过淮河，第一次看见了湖北的民居，四川的山水。<br>这一年，我第一次赤脚长江水，偷摘路边橙。<br>这一年，我第一次住在离长江那么近的地方，夜晚可以听见长江浪声。<br>这一年，我第一次和远在重庆深山里的一户人家建立了深厚的联系。<br>这一年，我第一次参与一本专业书籍的翻译，并且这本书已经出版发售了。<br>这一年，我第一次上了电视新闻。<br>这一年，我第一次骑行超过30公里。<br>这一年，我第一次单次游泳超过2000米。<br>这一年，我第一次体验了连续5天的自驾。<br>这一年，我第一次自京北上，领略草原的辽阔壮丽。<br>这一年，我第一次在草原上策马前行。<br>这一年，我第一次在海边钓鱼，钓到了我的第一条海鱼。<br>这一年，我第一次为父母买了一件我认为的奢侈品。<br>这一年，我第一次为我的未来迷茫，不知道了前方的路在哪里。</p>\n<p>。。。。。。</p>\n<p>还有很多第一次……，第一次拆硬盘，第一次因喝酒过度而去急诊，第一次喝清酒，第一次认真的一秒钟不拉的看完一场球赛，第一次自毕业以来，认真的一页不拉的看完一篇中篇小说。。。。。</p>\n<p>岁月就这在第一次，第二次，第n次中流过，平静而笃定。</p>\n<p>沿着2012年的远去的那条路，2013年也渐渐远去， 没有准备好，2014年就扑面而来，生活重复着昨天的故事，我还是那个平庸的人，时间丝毫没有让我伟大或者发达。</p>\n<p>我虽好吃，却是不馋。<br>我虽好色，却不放荡。<br>2014，平凡的过吧。 </p>\n"},{"title":"北漂的日子（五）","date":"2012-11-03T15:02:00.000Z","_content":"\n2007年，我上大三。那一年有一个病毒很恐怖，他的名字叫“熊猫烧香”，很幸运，那时候我没亲身看过他的发作。\n今天重温了一下那个源代码，很邪恶，但是也很普通。说他邪恶，是因为他的破坏力足够强，说他普通是因为使用的技术并不高深。\n\n但就是这么一个普通的病毒程序竟然席卷全国，让人惊愕，他给我们一个警醒：网络带来的不仅仅是馅饼，还有陷阱。\n这个事件伴着一个个的专杀和武汉男孩的忏悔书而慢慢消失匿迹。\n\n但是时至今日，类似程序仍运行在神州大地的数不清的的电脑上，比如6*60，他就像狗皮膏药一样，你一旦使用，就贴在了你的电脑上，他也像野草，一旦在你的机器上发芽开花，用不了多久，你的机器就会成为一片垃圾软件的草场。\n\n网络时代，每个人都是网络的主人翁，守护网络安全，人人有责。维护网络健康，人人有份。","source":"_posts/北漂的日子（五）.md","raw":"---\ntitle: 北漂的日子（五）\ndate: 2012-11-3 23:02\n---\n\n2007年，我上大三。那一年有一个病毒很恐怖，他的名字叫“熊猫烧香”，很幸运，那时候我没亲身看过他的发作。\n今天重温了一下那个源代码，很邪恶，但是也很普通。说他邪恶，是因为他的破坏力足够强，说他普通是因为使用的技术并不高深。\n\n但就是这么一个普通的病毒程序竟然席卷全国，让人惊愕，他给我们一个警醒：网络带来的不仅仅是馅饼，还有陷阱。\n这个事件伴着一个个的专杀和武汉男孩的忏悔书而慢慢消失匿迹。\n\n但是时至今日，类似程序仍运行在神州大地的数不清的的电脑上，比如6*60，他就像狗皮膏药一样，你一旦使用，就贴在了你的电脑上，他也像野草，一旦在你的机器上发芽开花，用不了多久，你的机器就会成为一片垃圾软件的草场。\n\n网络时代，每个人都是网络的主人翁，守护网络安全，人人有责。维护网络健康，人人有份。","slug":"北漂的日子（五）","published":1,"updated":"2022-01-30T17:16:06.873Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sle0001ojzo61zwa5xl","content":"<p>2007年，我上大三。那一年有一个病毒很恐怖，他的名字叫“熊猫烧香”，很幸运，那时候我没亲身看过他的发作。<br>今天重温了一下那个源代码，很邪恶，但是也很普通。说他邪恶，是因为他的破坏力足够强，说他普通是因为使用的技术并不高深。</p>\n<p>但就是这么一个普通的病毒程序竟然席卷全国，让人惊愕，他给我们一个警醒：网络带来的不仅仅是馅饼，还有陷阱。<br>这个事件伴着一个个的专杀和武汉男孩的忏悔书而慢慢消失匿迹。</p>\n<p>但是时至今日，类似程序仍运行在神州大地的数不清的的电脑上，比如6*60，他就像狗皮膏药一样，你一旦使用，就贴在了你的电脑上，他也像野草，一旦在你的机器上发芽开花，用不了多久，你的机器就会成为一片垃圾软件的草场。</p>\n<p>网络时代，每个人都是网络的主人翁，守护网络安全，人人有责。维护网络健康，人人有份。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>2007年，我上大三。那一年有一个病毒很恐怖，他的名字叫“熊猫烧香”，很幸运，那时候我没亲身看过他的发作。<br>今天重温了一下那个源代码，很邪恶，但是也很普通。说他邪恶，是因为他的破坏力足够强，说他普通是因为使用的技术并不高深。</p>\n<p>但就是这么一个普通的病毒程序竟然席卷全国，让人惊愕，他给我们一个警醒：网络带来的不仅仅是馅饼，还有陷阱。<br>这个事件伴着一个个的专杀和武汉男孩的忏悔书而慢慢消失匿迹。</p>\n<p>但是时至今日，类似程序仍运行在神州大地的数不清的的电脑上，比如6*60，他就像狗皮膏药一样，你一旦使用，就贴在了你的电脑上，他也像野草，一旦在你的机器上发芽开花，用不了多久，你的机器就会成为一片垃圾软件的草场。</p>\n<p>网络时代，每个人都是网络的主人翁，守护网络安全，人人有责。维护网络健康，人人有份。</p>\n"},{"title":"北漂的日子（七）","date":"2013-04-21T07:53:00.000Z","_content":"\n又他娘的地震了！","source":"_posts/北漂的日子（七）.md","raw":"---\ntitle: 北漂的日子（七）\ndate: 2013-4-21 15:53\n---\n\n又他娘的地震了！","slug":"北漂的日子（七）","published":1,"updated":"2022-01-30T17:12:56.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slk0002ojzo6xt06rfv","content":"<p>又他娘的地震了！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>又他娘的地震了！</p>\n"},{"title":"北漂的日子（三）","date":"2012-08-19T15:30:00.000Z","_content":"\nbeijing的繁荣实质在于政治，大大小小，林林总总的衙门不知道养活了多少的公司和掮客。政治运转的具体表现之一就是公司了。这儿的公司与其他地方公司的不同之处在于：其他地方的公司在于创造社会价值，而很多北京的公司在于转移社会价值。北京是中国政治、文化、教育和国际交流中心，而唯独不是工业实业中心。而政治、文化、教育和国际交流中心基本上属于扯淡的事，所以这就不难理解北京人的扯淡精神了。所以北京的很多公司也传承和发扬了“扯淡”这一光荣传统。\n\n公司里，人来人往，尔虞我诈，貌似规则齐整，实则一盘散沙。没有人认可”牺牲自我，成就大家“的理念，有的是“宁可我负天下人 不可天下人负我” 的曹操主义。公司外时时刻刻上演着春秋战国般的商业战，宋襄公自古是被人耻笑的对象，今天就更是了。人心不古，廉耻不存。游戏规则越多，我们离分崩离析越近。","source":"_posts/北漂的日子（二）.md","raw":"---\ntitle: 北漂的日子（三）\ndate: 2012-8-19 23:30\n---\n\nbeijing的繁荣实质在于政治，大大小小，林林总总的衙门不知道养活了多少的公司和掮客。政治运转的具体表现之一就是公司了。这儿的公司与其他地方公司的不同之处在于：其他地方的公司在于创造社会价值，而很多北京的公司在于转移社会价值。北京是中国政治、文化、教育和国际交流中心，而唯独不是工业实业中心。而政治、文化、教育和国际交流中心基本上属于扯淡的事，所以这就不难理解北京人的扯淡精神了。所以北京的很多公司也传承和发扬了“扯淡”这一光荣传统。\n\n公司里，人来人往，尔虞我诈，貌似规则齐整，实则一盘散沙。没有人认可”牺牲自我，成就大家“的理念，有的是“宁可我负天下人 不可天下人负我” 的曹操主义。公司外时时刻刻上演着春秋战国般的商业战，宋襄公自古是被人耻笑的对象，今天就更是了。人心不古，廉耻不存。游戏规则越多，我们离分崩离析越近。","slug":"北漂的日子（二）","published":1,"updated":"2022-01-30T17:19:38.244Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slk0003ojzoa3vk5kcb","content":"<p>beijing的繁荣实质在于政治，大大小小，林林总总的衙门不知道养活了多少的公司和掮客。政治运转的具体表现之一就是公司了。这儿的公司与其他地方公司的不同之处在于：其他地方的公司在于创造社会价值，而很多北京的公司在于转移社会价值。北京是中国政治、文化、教育和国际交流中心，而唯独不是工业实业中心。而政治、文化、教育和国际交流中心基本上属于扯淡的事，所以这就不难理解北京人的扯淡精神了。所以北京的很多公司也传承和发扬了“扯淡”这一光荣传统。</p>\n<p>公司里，人来人往，尔虞我诈，貌似规则齐整，实则一盘散沙。没有人认可”牺牲自我，成就大家“的理念，有的是“宁可我负天下人 不可天下人负我” 的曹操主义。公司外时时刻刻上演着春秋战国般的商业战，宋襄公自古是被人耻笑的对象，今天就更是了。人心不古，廉耻不存。游戏规则越多，我们离分崩离析越近。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>beijing的繁荣实质在于政治，大大小小，林林总总的衙门不知道养活了多少的公司和掮客。政治运转的具体表现之一就是公司了。这儿的公司与其他地方公司的不同之处在于：其他地方的公司在于创造社会价值，而很多北京的公司在于转移社会价值。北京是中国政治、文化、教育和国际交流中心，而唯独不是工业实业中心。而政治、文化、教育和国际交流中心基本上属于扯淡的事，所以这就不难理解北京人的扯淡精神了。所以北京的很多公司也传承和发扬了“扯淡”这一光荣传统。</p>\n<p>公司里，人来人往，尔虞我诈，貌似规则齐整，实则一盘散沙。没有人认可”牺牲自我，成就大家“的理念，有的是“宁可我负天下人 不可天下人负我” 的曹操主义。公司外时时刻刻上演着春秋战国般的商业战，宋襄公自古是被人耻笑的对象，今天就更是了。人心不古，廉耻不存。游戏规则越多，我们离分崩离析越近。</p>\n"},{"title":"北漂的日子（六）","date":"2012-11-26T16:29:00.000Z","_content":"\n周六晚上躺在床上看书，发现一只老鼠在我的床边看着我，眼睛滴溜溜的，似有所求，我挥了挥手中的平板，示意它离开，它却丝毫不懂我的意思，仍然专注的看着我，我起身去拿相机，想给拍照，它却迅速爬下床，不见了踪影。\n\n刚搬进来不久的房子怎么会有老鼠呢，也许是从外面草地上溜进来的，看来明天该收拾房子了。我突然明天该怎么处理这只小老鼠呢？如果刚才我手中是一本书，我当时就摔了过去。这只老鼠显然是不太明白事理，它可以在进出我的房间里，但是不能在我的眼前晃来晃去，因为任何肉食动物都有防卫自己领地的意识，更何况人呢，更何况这房子是我租的，凭什么老鼠说来就来，招呼都不打一个，更不用说交房租了。\n\n卧榻之侧岂容他人鼾睡。更何况不懂礼数的小老鼠呢，我想周日有三种方案对付这只不速之客，一曰，留一扇门让它光明正大的走出去，二曰，让它急风骤雨般的跑出去，三曰，让它躺着出去。\n\n这让我想起以前在家里时对待这种不请自来的老鼠都是棍棒，只要它见了我的面，我一般是像秋风扫落叶一般的残忍的把它干掉。因为在农村老鼠是天经地义的人们的敌人。我曾亲眼见过老鼠的破坏性，自己舍不得穿的衣服，它给穿个洞，存的粮食它会去糟蹋。所谓见敌之害，方有恨敌之心。\n\n可是随着慢慢的远离自然的生活，我却渐渐的忘了老鼠这害处的。况且我也没了以前生擒老鼠的勇气，甚至于有时候竟然起怜悯之心。突然觉得这上下班的生活让我消磨了对抗自然的勇气和意识。\n\n面对我屋里的这只老鼠，我想环视看运气吧，现在来看，我不是不想伤害它，我已然是没了伤害它的本事了。","source":"_posts/北漂的日子（六）.md","raw":"---\ntitle: 北漂的日子（六）\ndate: 2012-11-27 00:29\n---\n\n周六晚上躺在床上看书，发现一只老鼠在我的床边看着我，眼睛滴溜溜的，似有所求，我挥了挥手中的平板，示意它离开，它却丝毫不懂我的意思，仍然专注的看着我，我起身去拿相机，想给拍照，它却迅速爬下床，不见了踪影。\n\n刚搬进来不久的房子怎么会有老鼠呢，也许是从外面草地上溜进来的，看来明天该收拾房子了。我突然明天该怎么处理这只小老鼠呢？如果刚才我手中是一本书，我当时就摔了过去。这只老鼠显然是不太明白事理，它可以在进出我的房间里，但是不能在我的眼前晃来晃去，因为任何肉食动物都有防卫自己领地的意识，更何况人呢，更何况这房子是我租的，凭什么老鼠说来就来，招呼都不打一个，更不用说交房租了。\n\n卧榻之侧岂容他人鼾睡。更何况不懂礼数的小老鼠呢，我想周日有三种方案对付这只不速之客，一曰，留一扇门让它光明正大的走出去，二曰，让它急风骤雨般的跑出去，三曰，让它躺着出去。\n\n这让我想起以前在家里时对待这种不请自来的老鼠都是棍棒，只要它见了我的面，我一般是像秋风扫落叶一般的残忍的把它干掉。因为在农村老鼠是天经地义的人们的敌人。我曾亲眼见过老鼠的破坏性，自己舍不得穿的衣服，它给穿个洞，存的粮食它会去糟蹋。所谓见敌之害，方有恨敌之心。\n\n可是随着慢慢的远离自然的生活，我却渐渐的忘了老鼠这害处的。况且我也没了以前生擒老鼠的勇气，甚至于有时候竟然起怜悯之心。突然觉得这上下班的生活让我消磨了对抗自然的勇气和意识。\n\n面对我屋里的这只老鼠，我想环视看运气吧，现在来看，我不是不想伤害它，我已然是没了伤害它的本事了。","slug":"北漂的日子（六）","published":1,"updated":"2022-01-30T17:14:51.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sll0004ojzocbqn120f","content":"<p>周六晚上躺在床上看书，发现一只老鼠在我的床边看着我，眼睛滴溜溜的，似有所求，我挥了挥手中的平板，示意它离开，它却丝毫不懂我的意思，仍然专注的看着我，我起身去拿相机，想给拍照，它却迅速爬下床，不见了踪影。</p>\n<p>刚搬进来不久的房子怎么会有老鼠呢，也许是从外面草地上溜进来的，看来明天该收拾房子了。我突然明天该怎么处理这只小老鼠呢？如果刚才我手中是一本书，我当时就摔了过去。这只老鼠显然是不太明白事理，它可以在进出我的房间里，但是不能在我的眼前晃来晃去，因为任何肉食动物都有防卫自己领地的意识，更何况人呢，更何况这房子是我租的，凭什么老鼠说来就来，招呼都不打一个，更不用说交房租了。</p>\n<p>卧榻之侧岂容他人鼾睡。更何况不懂礼数的小老鼠呢，我想周日有三种方案对付这只不速之客，一曰，留一扇门让它光明正大的走出去，二曰，让它急风骤雨般的跑出去，三曰，让它躺着出去。</p>\n<p>这让我想起以前在家里时对待这种不请自来的老鼠都是棍棒，只要它见了我的面，我一般是像秋风扫落叶一般的残忍的把它干掉。因为在农村老鼠是天经地义的人们的敌人。我曾亲眼见过老鼠的破坏性，自己舍不得穿的衣服，它给穿个洞，存的粮食它会去糟蹋。所谓见敌之害，方有恨敌之心。</p>\n<p>可是随着慢慢的远离自然的生活，我却渐渐的忘了老鼠这害处的。况且我也没了以前生擒老鼠的勇气，甚至于有时候竟然起怜悯之心。突然觉得这上下班的生活让我消磨了对抗自然的勇气和意识。</p>\n<p>面对我屋里的这只老鼠，我想环视看运气吧，现在来看，我不是不想伤害它，我已然是没了伤害它的本事了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>周六晚上躺在床上看书，发现一只老鼠在我的床边看着我，眼睛滴溜溜的，似有所求，我挥了挥手中的平板，示意它离开，它却丝毫不懂我的意思，仍然专注的看着我，我起身去拿相机，想给拍照，它却迅速爬下床，不见了踪影。</p>\n<p>刚搬进来不久的房子怎么会有老鼠呢，也许是从外面草地上溜进来的，看来明天该收拾房子了。我突然明天该怎么处理这只小老鼠呢？如果刚才我手中是一本书，我当时就摔了过去。这只老鼠显然是不太明白事理，它可以在进出我的房间里，但是不能在我的眼前晃来晃去，因为任何肉食动物都有防卫自己领地的意识，更何况人呢，更何况这房子是我租的，凭什么老鼠说来就来，招呼都不打一个，更不用说交房租了。</p>\n<p>卧榻之侧岂容他人鼾睡。更何况不懂礼数的小老鼠呢，我想周日有三种方案对付这只不速之客，一曰，留一扇门让它光明正大的走出去，二曰，让它急风骤雨般的跑出去，三曰，让它躺着出去。</p>\n<p>这让我想起以前在家里时对待这种不请自来的老鼠都是棍棒，只要它见了我的面，我一般是像秋风扫落叶一般的残忍的把它干掉。因为在农村老鼠是天经地义的人们的敌人。我曾亲眼见过老鼠的破坏性，自己舍不得穿的衣服，它给穿个洞，存的粮食它会去糟蹋。所谓见敌之害，方有恨敌之心。</p>\n<p>可是随着慢慢的远离自然的生活，我却渐渐的忘了老鼠这害处的。况且我也没了以前生擒老鼠的勇气，甚至于有时候竟然起怜悯之心。突然觉得这上下班的生活让我消磨了对抗自然的勇气和意识。</p>\n<p>面对我屋里的这只老鼠，我想环视看运气吧，现在来看，我不是不想伤害它，我已然是没了伤害它的本事了。</p>\n"},{"title":"北漂的日子（一）","date":"2012-08-19T14:22:00.000Z","_content":"\n站在远大路东口的天桥上，望着停车场上连绵不绝的小车，琳琅满目的小车品牌，哥只能站在桥上，深呼吸一口，让自己淡定。\n身边的妹儿白衣飘飘，车上的哥儿煞有介事。金源这个地方就像是个催化剂，昂首挺胸进去，垂头丧气出来。一套家具20万，一个手镯七八千，我靠，这日子咋过？\n\n有时候真想成为周》》》克。。。花，轰轰烈烈一辈子，后事都不用自己操心。有时候也想成为干。。。露。露。。炒作炒作一陈子，稀里哗啦挣票子。醒了发现自己不是亡命之徒，也不是犯贱之人。只能从了上天的安排，乖乖做人。\n\n北漂就是这样，你总是想成为一个牛B的人，哪怕是混蛋中的极致，哪怕小姐中的花魁，只要它是是貌似nb的样子，就有很多人追随，模仿。很多人在高档的写字楼办公，晚上却住在低矮肮脏的民宅，每天ta都穿梭在北京两个极致的角落，路过灯红酒绿，享受歌舞升平，回到自己的窝，只剩下寂寞和疲乏。没有人关注北漂的精神世界，更没有制度引导北漂的行为，北漂族心里每天在潮起潮落，这种变化是理想与现实的激烈对撞，白天你发现理想实现近在咫尺，晚上的时候，理想却远在梦乡。\n\n\n于是，北漂写就煎熬。\n于是，北漂养成贪婪，成就浮躁。","source":"_posts/北漂的日子（一）.md","raw":"---\ntitle: 北漂的日子（一）\ndate: 2012-8-19 22:22\n---\n\n站在远大路东口的天桥上，望着停车场上连绵不绝的小车，琳琅满目的小车品牌，哥只能站在桥上，深呼吸一口，让自己淡定。\n身边的妹儿白衣飘飘，车上的哥儿煞有介事。金源这个地方就像是个催化剂，昂首挺胸进去，垂头丧气出来。一套家具20万，一个手镯七八千，我靠，这日子咋过？\n\n有时候真想成为周》》》克。。。花，轰轰烈烈一辈子，后事都不用自己操心。有时候也想成为干。。。露。露。。炒作炒作一陈子，稀里哗啦挣票子。醒了发现自己不是亡命之徒，也不是犯贱之人。只能从了上天的安排，乖乖做人。\n\n北漂就是这样，你总是想成为一个牛B的人，哪怕是混蛋中的极致，哪怕小姐中的花魁，只要它是是貌似nb的样子，就有很多人追随，模仿。很多人在高档的写字楼办公，晚上却住在低矮肮脏的民宅，每天ta都穿梭在北京两个极致的角落，路过灯红酒绿，享受歌舞升平，回到自己的窝，只剩下寂寞和疲乏。没有人关注北漂的精神世界，更没有制度引导北漂的行为，北漂族心里每天在潮起潮落，这种变化是理想与现实的激烈对撞，白天你发现理想实现近在咫尺，晚上的时候，理想却远在梦乡。\n\n\n于是，北漂写就煎熬。\n于是，北漂养成贪婪，成就浮躁。","slug":"北漂的日子（一）","published":1,"updated":"2022-01-30T17:21:59.456Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sll0005ojzo8xkkgfok","content":"<p>站在远大路东口的天桥上，望着停车场上连绵不绝的小车，琳琅满目的小车品牌，哥只能站在桥上，深呼吸一口，让自己淡定。<br>身边的妹儿白衣飘飘，车上的哥儿煞有介事。金源这个地方就像是个催化剂，昂首挺胸进去，垂头丧气出来。一套家具20万，一个手镯七八千，我靠，这日子咋过？</p>\n<p>有时候真想成为周》》》克。。。花，轰轰烈烈一辈子，后事都不用自己操心。有时候也想成为干。。。露。露。。炒作炒作一陈子，稀里哗啦挣票子。醒了发现自己不是亡命之徒，也不是犯贱之人。只能从了上天的安排，乖乖做人。</p>\n<p>北漂就是这样，你总是想成为一个牛B的人，哪怕是混蛋中的极致，哪怕小姐中的花魁，只要它是是貌似nb的样子，就有很多人追随，模仿。很多人在高档的写字楼办公，晚上却住在低矮肮脏的民宅，每天ta都穿梭在北京两个极致的角落，路过灯红酒绿，享受歌舞升平，回到自己的窝，只剩下寂寞和疲乏。没有人关注北漂的精神世界，更没有制度引导北漂的行为，北漂族心里每天在潮起潮落，这种变化是理想与现实的激烈对撞，白天你发现理想实现近在咫尺，晚上的时候，理想却远在梦乡。</p>\n<p>于是，北漂写就煎熬。<br>于是，北漂养成贪婪，成就浮躁。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>站在远大路东口的天桥上，望着停车场上连绵不绝的小车，琳琅满目的小车品牌，哥只能站在桥上，深呼吸一口，让自己淡定。<br>身边的妹儿白衣飘飘，车上的哥儿煞有介事。金源这个地方就像是个催化剂，昂首挺胸进去，垂头丧气出来。一套家具20万，一个手镯七八千，我靠，这日子咋过？</p>\n<p>有时候真想成为周》》》克。。。花，轰轰烈烈一辈子，后事都不用自己操心。有时候也想成为干。。。露。露。。炒作炒作一陈子，稀里哗啦挣票子。醒了发现自己不是亡命之徒，也不是犯贱之人。只能从了上天的安排，乖乖做人。</p>\n<p>北漂就是这样，你总是想成为一个牛B的人，哪怕是混蛋中的极致，哪怕小姐中的花魁，只要它是是貌似nb的样子，就有很多人追随，模仿。很多人在高档的写字楼办公，晚上却住在低矮肮脏的民宅，每天ta都穿梭在北京两个极致的角落，路过灯红酒绿，享受歌舞升平，回到自己的窝，只剩下寂寞和疲乏。没有人关注北漂的精神世界，更没有制度引导北漂的行为，北漂族心里每天在潮起潮落，这种变化是理想与现实的激烈对撞，白天你发现理想实现近在咫尺，晚上的时候，理想却远在梦乡。</p>\n<p>于是，北漂写就煎熬。<br>于是，北漂养成贪婪，成就浮躁。</p>\n"},{"title":"北漂的日子（八）","date":"2013-09-02T12:43:00.000Z","_content":"\n日子过的很苦，我对我自己说，我这辈子的任务就是把苦日子过成甜日子。\n\n工作不好做，我对我自己说，这辈子就是把愚笨的我变成丰富的我们。\n\n精神很苦闷，我对自己说，名命由天定，何必虑天。","source":"_posts/北漂的日子（八）.md","raw":"---\ntitle: 北漂的日子（八）\ndate: 2013-9-2 20:43\n---\n\n日子过的很苦，我对我自己说，我这辈子的任务就是把苦日子过成甜日子。\n\n工作不好做，我对我自己说，这辈子就是把愚笨的我变成丰富的我们。\n\n精神很苦闷，我对自己说，名命由天定，何必虑天。","slug":"北漂的日子（八）","published":1,"updated":"2022-01-30T17:11:47.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slm0006ojzo4mz3c9yy","content":"<p>日子过的很苦，我对我自己说，我这辈子的任务就是把苦日子过成甜日子。</p>\n<p>工作不好做，我对我自己说，这辈子就是把愚笨的我变成丰富的我们。</p>\n<p>精神很苦闷，我对自己说，名命由天定，何必虑天。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>日子过的很苦，我对我自己说，我这辈子的任务就是把苦日子过成甜日子。</p>\n<p>工作不好做，我对我自己说，这辈子就是把愚笨的我变成丰富的我们。</p>\n<p>精神很苦闷，我对自己说，名命由天定，何必虑天。</p>\n"},{"title":"《一句顶一万句》读后感-北漂的日子（十二）","date":"2014-12-21T13:58:00.000Z","_content":"\n好久不写东西，一来因为工作忙了没有时间考虑一些自认矫情的事了，二来年龄大了却似乎觉得对很多事看不透了，写出来未免贻笑大方。\n\n近日从老家回京，火车上无事，随意找了一遍小说来看，就是刘震云的《一句顶一万句》，篇幅虽长，还是一口气看完了。小说结构简单就是两个主题，出延津和回延津；内涵就是三个字：“说得着”；描述了一对隔代人相似的情感经历，以及里面形形色色的人对友情和孤独的理解和诠释。小说时间跨度有70年，虽然书中未明确说明时间，也没有具体的历史痕迹，但是从中语言描写和环境中透露应该是20世纪20年代到80年代。\n\n文中以第三人称的角度，讲述第一位线索人物名从杨百顺到杨摩西到吴摩西到罗长礼的过程，以及他所经历他一直在追寻，但是小说没有说明他到底在追寻的具体东西，和我们现实人一样，在苦苦的追寻，追寻物质，追寻精神的，到底都是在追寻一个能“说的着”“指得上”有心灵默契的人。小说下部是第二位线索人物牛爱国的追寻的过程。他追寻的到底什么，也许是爱情，也许是友情，也许是亲情，也许是孤独，也许是愧疚....这需要读者去仔细的思索，感悟。\n\n小说的优劣我不敢妄下评论，但是它却让我想到了一些平时忽略了的东西。\n\n友情是个永恒的话题。在百度中搜索“友情”关键字，大约会有数以亿记得收录，可见的使用范围之大之广。虽然小说围绕友情来说，但是全篇几十万字竟没有“友亲”二字的出现。朋友之间最重要的就是“说的着”，这也许是对“人生得一知己足矣，斯世，当同怀视之”这一名句最世俗最生动的诠释。\n\n没有永远的朋友。 人的一生有会有很多所谓的朋友，但是朋友是有距离的，也是有时间的。也许我们同时有好几个密友，能说的上话，能推心置腹，但是我们很难一生一世都和同一个人保持这种亲密无间的关系。世事在变化，人也在变化，朋友也在变化。对待朋友我们应该了解这个常情，对彼此以诚相待，不能做一生一世相知的人，也要做一生一世真诚的相识人。这样就能避免很多误会，避免好友反目的情况。\n\n找朋友和交朋友。我一直认为朋友是由相识的熟人慢慢成为相知的朋友，可是现在随着社会分工的专业化和明细化，我们的社交关系也和传统的认知发生了很大的变化。从微信摇一摇到陌陌的IPO我们就可以感觉这个世界虽然热闹，却又是多么的孤独和寂寞。找朋友是追寻的过程，能在茫茫人海中找到一个相知的人，能“说的着”的人多么困难。小说中杨百顺在困苦的生活中挣扎，却也在寻找那个说得着的人，为了找到“说的着”继女，懦弱的他竟然走出了延津，这就是找朋友。交朋友和找朋友最大的不同是在相识人中磨合出一位相知的人。现实中我们一般都是交朋友，从同学，同事，邻里等等相识的人中磨合成朋友。\n\n事情从根上就是坏的。生活中的很多事都是绕出来，一步一步赶出来的，很多大事件的由头往前捋一捋都是一些很小的事引发的。人们总是习惯都是找原因，把一些事情的推导出个一二三。佛说大千世界都是因果。时间是因，生活是果。当我们悲观是，我们说事情从根上就是坏的，可是这根有在哪呢？做好当下每一件事，才能捋出一条正常的生活时间线。\n","source":"_posts/北漂的日子（十二）《一句顶一万句》读后感-.md","raw":"---\ntitle: 《一句顶一万句》读后感-北漂的日子（十二）\ndate: 2014-12-21 21:58\n---\n\n好久不写东西，一来因为工作忙了没有时间考虑一些自认矫情的事了，二来年龄大了却似乎觉得对很多事看不透了，写出来未免贻笑大方。\n\n近日从老家回京，火车上无事，随意找了一遍小说来看，就是刘震云的《一句顶一万句》，篇幅虽长，还是一口气看完了。小说结构简单就是两个主题，出延津和回延津；内涵就是三个字：“说得着”；描述了一对隔代人相似的情感经历，以及里面形形色色的人对友情和孤独的理解和诠释。小说时间跨度有70年，虽然书中未明确说明时间，也没有具体的历史痕迹，但是从中语言描写和环境中透露应该是20世纪20年代到80年代。\n\n文中以第三人称的角度，讲述第一位线索人物名从杨百顺到杨摩西到吴摩西到罗长礼的过程，以及他所经历他一直在追寻，但是小说没有说明他到底在追寻的具体东西，和我们现实人一样，在苦苦的追寻，追寻物质，追寻精神的，到底都是在追寻一个能“说的着”“指得上”有心灵默契的人。小说下部是第二位线索人物牛爱国的追寻的过程。他追寻的到底什么，也许是爱情，也许是友情，也许是亲情，也许是孤独，也许是愧疚....这需要读者去仔细的思索，感悟。\n\n小说的优劣我不敢妄下评论，但是它却让我想到了一些平时忽略了的东西。\n\n友情是个永恒的话题。在百度中搜索“友情”关键字，大约会有数以亿记得收录，可见的使用范围之大之广。虽然小说围绕友情来说，但是全篇几十万字竟没有“友亲”二字的出现。朋友之间最重要的就是“说的着”，这也许是对“人生得一知己足矣，斯世，当同怀视之”这一名句最世俗最生动的诠释。\n\n没有永远的朋友。 人的一生有会有很多所谓的朋友，但是朋友是有距离的，也是有时间的。也许我们同时有好几个密友，能说的上话，能推心置腹，但是我们很难一生一世都和同一个人保持这种亲密无间的关系。世事在变化，人也在变化，朋友也在变化。对待朋友我们应该了解这个常情，对彼此以诚相待，不能做一生一世相知的人，也要做一生一世真诚的相识人。这样就能避免很多误会，避免好友反目的情况。\n\n找朋友和交朋友。我一直认为朋友是由相识的熟人慢慢成为相知的朋友，可是现在随着社会分工的专业化和明细化，我们的社交关系也和传统的认知发生了很大的变化。从微信摇一摇到陌陌的IPO我们就可以感觉这个世界虽然热闹，却又是多么的孤独和寂寞。找朋友是追寻的过程，能在茫茫人海中找到一个相知的人，能“说的着”的人多么困难。小说中杨百顺在困苦的生活中挣扎，却也在寻找那个说得着的人，为了找到“说的着”继女，懦弱的他竟然走出了延津，这就是找朋友。交朋友和找朋友最大的不同是在相识人中磨合出一位相知的人。现实中我们一般都是交朋友，从同学，同事，邻里等等相识的人中磨合成朋友。\n\n事情从根上就是坏的。生活中的很多事都是绕出来，一步一步赶出来的，很多大事件的由头往前捋一捋都是一些很小的事引发的。人们总是习惯都是找原因，把一些事情的推导出个一二三。佛说大千世界都是因果。时间是因，生活是果。当我们悲观是，我们说事情从根上就是坏的，可是这根有在哪呢？做好当下每一件事，才能捋出一条正常的生活时间线。\n","slug":"北漂的日子（十二）《一句顶一万句》读后感-","published":1,"updated":"2022-01-30T17:07:29.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sln0007ojzo7wo99sw4","content":"<p>好久不写东西，一来因为工作忙了没有时间考虑一些自认矫情的事了，二来年龄大了却似乎觉得对很多事看不透了，写出来未免贻笑大方。</p>\n<p>近日从老家回京，火车上无事，随意找了一遍小说来看，就是刘震云的《一句顶一万句》，篇幅虽长，还是一口气看完了。小说结构简单就是两个主题，出延津和回延津；内涵就是三个字：“说得着”；描述了一对隔代人相似的情感经历，以及里面形形色色的人对友情和孤独的理解和诠释。小说时间跨度有70年，虽然书中未明确说明时间，也没有具体的历史痕迹，但是从中语言描写和环境中透露应该是20世纪20年代到80年代。</p>\n<p>文中以第三人称的角度，讲述第一位线索人物名从杨百顺到杨摩西到吴摩西到罗长礼的过程，以及他所经历他一直在追寻，但是小说没有说明他到底在追寻的具体东西，和我们现实人一样，在苦苦的追寻，追寻物质，追寻精神的，到底都是在追寻一个能“说的着”“指得上”有心灵默契的人。小说下部是第二位线索人物牛爱国的追寻的过程。他追寻的到底什么，也许是爱情，也许是友情，也许是亲情，也许是孤独，也许是愧疚….这需要读者去仔细的思索，感悟。</p>\n<p>小说的优劣我不敢妄下评论，但是它却让我想到了一些平时忽略了的东西。</p>\n<p>友情是个永恒的话题。在百度中搜索“友情”关键字，大约会有数以亿记得收录，可见的使用范围之大之广。虽然小说围绕友情来说，但是全篇几十万字竟没有“友亲”二字的出现。朋友之间最重要的就是“说的着”，这也许是对“人生得一知己足矣，斯世，当同怀视之”这一名句最世俗最生动的诠释。</p>\n<p>没有永远的朋友。 人的一生有会有很多所谓的朋友，但是朋友是有距离的，也是有时间的。也许我们同时有好几个密友，能说的上话，能推心置腹，但是我们很难一生一世都和同一个人保持这种亲密无间的关系。世事在变化，人也在变化，朋友也在变化。对待朋友我们应该了解这个常情，对彼此以诚相待，不能做一生一世相知的人，也要做一生一世真诚的相识人。这样就能避免很多误会，避免好友反目的情况。</p>\n<p>找朋友和交朋友。我一直认为朋友是由相识的熟人慢慢成为相知的朋友，可是现在随着社会分工的专业化和明细化，我们的社交关系也和传统的认知发生了很大的变化。从微信摇一摇到陌陌的IPO我们就可以感觉这个世界虽然热闹，却又是多么的孤独和寂寞。找朋友是追寻的过程，能在茫茫人海中找到一个相知的人，能“说的着”的人多么困难。小说中杨百顺在困苦的生活中挣扎，却也在寻找那个说得着的人，为了找到“说的着”继女，懦弱的他竟然走出了延津，这就是找朋友。交朋友和找朋友最大的不同是在相识人中磨合出一位相知的人。现实中我们一般都是交朋友，从同学，同事，邻里等等相识的人中磨合成朋友。</p>\n<p>事情从根上就是坏的。生活中的很多事都是绕出来，一步一步赶出来的，很多大事件的由头往前捋一捋都是一些很小的事引发的。人们总是习惯都是找原因，把一些事情的推导出个一二三。佛说大千世界都是因果。时间是因，生活是果。当我们悲观是，我们说事情从根上就是坏的，可是这根有在哪呢？做好当下每一件事，才能捋出一条正常的生活时间线。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>好久不写东西，一来因为工作忙了没有时间考虑一些自认矫情的事了，二来年龄大了却似乎觉得对很多事看不透了，写出来未免贻笑大方。</p>\n<p>近日从老家回京，火车上无事，随意找了一遍小说来看，就是刘震云的《一句顶一万句》，篇幅虽长，还是一口气看完了。小说结构简单就是两个主题，出延津和回延津；内涵就是三个字：“说得着”；描述了一对隔代人相似的情感经历，以及里面形形色色的人对友情和孤独的理解和诠释。小说时间跨度有70年，虽然书中未明确说明时间，也没有具体的历史痕迹，但是从中语言描写和环境中透露应该是20世纪20年代到80年代。</p>\n<p>文中以第三人称的角度，讲述第一位线索人物名从杨百顺到杨摩西到吴摩西到罗长礼的过程，以及他所经历他一直在追寻，但是小说没有说明他到底在追寻的具体东西，和我们现实人一样，在苦苦的追寻，追寻物质，追寻精神的，到底都是在追寻一个能“说的着”“指得上”有心灵默契的人。小说下部是第二位线索人物牛爱国的追寻的过程。他追寻的到底什么，也许是爱情，也许是友情，也许是亲情，也许是孤独，也许是愧疚….这需要读者去仔细的思索，感悟。</p>\n<p>小说的优劣我不敢妄下评论，但是它却让我想到了一些平时忽略了的东西。</p>\n<p>友情是个永恒的话题。在百度中搜索“友情”关键字，大约会有数以亿记得收录，可见的使用范围之大之广。虽然小说围绕友情来说，但是全篇几十万字竟没有“友亲”二字的出现。朋友之间最重要的就是“说的着”，这也许是对“人生得一知己足矣，斯世，当同怀视之”这一名句最世俗最生动的诠释。</p>\n<p>没有永远的朋友。 人的一生有会有很多所谓的朋友，但是朋友是有距离的，也是有时间的。也许我们同时有好几个密友，能说的上话，能推心置腹，但是我们很难一生一世都和同一个人保持这种亲密无间的关系。世事在变化，人也在变化，朋友也在变化。对待朋友我们应该了解这个常情，对彼此以诚相待，不能做一生一世相知的人，也要做一生一世真诚的相识人。这样就能避免很多误会，避免好友反目的情况。</p>\n<p>找朋友和交朋友。我一直认为朋友是由相识的熟人慢慢成为相知的朋友，可是现在随着社会分工的专业化和明细化，我们的社交关系也和传统的认知发生了很大的变化。从微信摇一摇到陌陌的IPO我们就可以感觉这个世界虽然热闹，却又是多么的孤独和寂寞。找朋友是追寻的过程，能在茫茫人海中找到一个相知的人，能“说的着”的人多么困难。小说中杨百顺在困苦的生活中挣扎，却也在寻找那个说得着的人，为了找到“说的着”继女，懦弱的他竟然走出了延津，这就是找朋友。交朋友和找朋友最大的不同是在相识人中磨合出一位相知的人。现实中我们一般都是交朋友，从同学，同事，邻里等等相识的人中磨合成朋友。</p>\n<p>事情从根上就是坏的。生活中的很多事都是绕出来，一步一步赶出来的，很多大事件的由头往前捋一捋都是一些很小的事引发的。人们总是习惯都是找原因，把一些事情的推导出个一二三。佛说大千世界都是因果。时间是因，生活是果。当我们悲观是，我们说事情从根上就是坏的，可是这根有在哪呢？做好当下每一件事，才能捋出一条正常的生活时间线。</p>\n"},{"title":"致敬2014-北漂的日子(十三)","date":"2015-01-09T15:23:00.000Z","_content":"\n感觉2013年的年终总结刚刚写完，又要写2014的年终总结了，不得不感叹时光飞快，岁月催人。\n\n如果说2013是平凡一年，那么2014注定是我人生中记得永远珍藏的一年。\n\n这一年，站在而立之年的边缘，我终于和命中注定的她结为连理，成为夫妻， 组成了自己的小家庭，增加了一个社会角色——丈夫。\n结婚了，要和以前的一些自己永远的告别了，以后再也不是一个人，身上有了责任，肩上有了担子。\n结婚了，感情告一段落了，回想这么几年，年轻的自己做过很多轻狂的事，愚蠢的事，错误的事，值得骄傲的事，有过张狂，有过担当，有过单纯，有过欢天喜地，有过懦弱，有过失败，有过悔恨。。。点点滴滴我都会一一珍藏。\n结婚了，我爱现在的她。我会珍藏住以前的爱，以前的恨，以前的校园羞涩暗恋，以前初恋情窦，让它们成为我人生美好的回忆。我已原谅伤害过我的人，我也祈祷我伤害过的人能够原谅我。\n结婚了，我要用一个男人的责任和爱撑起我自己的家庭，孝敬父母，抚育儿女，艰苦奋斗，自力更生。\n\n这一年，实现了我的几个梦想。\n10月份，听趵突泉声，漫步大明湖，圆满了小时候对济南的的种种幻想。\n12月份，在上海祭奠了二姐，算是弥补了我没有实现她愿望的遗憾。\n\n\n这一年其实也我迷茫的一年，转眼已经毕业6年，工作上却毫无建树，生活也依然是北漂一族，彷徨于对未来职业方向的计划，苦闷于对未来的生活不定。这一年，读了一些关于人生的书，努力想在书中找到答案，其实答案在自己手里。但是这些书让我对自己有了进一步的认识，对生活和人性有了跟多的理解。\n\n这一年在苦苦的思索中我换了一份新工作，工作职责由软件开发工程师成为前端开发工程师，职责的变化，让我对工作和职业有了新的认识。工作中我也对简单可依赖的的理念有了更深的理解，其实就我等普通人来说，不管对待家人，朋友，同事，还是工作生活，我们只要努力做到简单可依赖，就没有那么多烦恼和麻烦。\n\n对新的一年的我有几个期望，希望明年总结时不会有遗憾。\n行路不止，读书不倦。\n树欲静而风不止，子欲养而亲不待。\n芝麻开花节节高。\n\n致敬2014，拥抱2015！","source":"_posts/北漂的日子（十三）致敬2014.md","raw":"---\ntitle: 致敬2014-北漂的日子(十三)\ndate: 2015-1-9 23:23\n---\n\n感觉2013年的年终总结刚刚写完，又要写2014的年终总结了，不得不感叹时光飞快，岁月催人。\n\n如果说2013是平凡一年，那么2014注定是我人生中记得永远珍藏的一年。\n\n这一年，站在而立之年的边缘，我终于和命中注定的她结为连理，成为夫妻， 组成了自己的小家庭，增加了一个社会角色——丈夫。\n结婚了，要和以前的一些自己永远的告别了，以后再也不是一个人，身上有了责任，肩上有了担子。\n结婚了，感情告一段落了，回想这么几年，年轻的自己做过很多轻狂的事，愚蠢的事，错误的事，值得骄傲的事，有过张狂，有过担当，有过单纯，有过欢天喜地，有过懦弱，有过失败，有过悔恨。。。点点滴滴我都会一一珍藏。\n结婚了，我爱现在的她。我会珍藏住以前的爱，以前的恨，以前的校园羞涩暗恋，以前初恋情窦，让它们成为我人生美好的回忆。我已原谅伤害过我的人，我也祈祷我伤害过的人能够原谅我。\n结婚了，我要用一个男人的责任和爱撑起我自己的家庭，孝敬父母，抚育儿女，艰苦奋斗，自力更生。\n\n这一年，实现了我的几个梦想。\n10月份，听趵突泉声，漫步大明湖，圆满了小时候对济南的的种种幻想。\n12月份，在上海祭奠了二姐，算是弥补了我没有实现她愿望的遗憾。\n\n\n这一年其实也我迷茫的一年，转眼已经毕业6年，工作上却毫无建树，生活也依然是北漂一族，彷徨于对未来职业方向的计划，苦闷于对未来的生活不定。这一年，读了一些关于人生的书，努力想在书中找到答案，其实答案在自己手里。但是这些书让我对自己有了进一步的认识，对生活和人性有了跟多的理解。\n\n这一年在苦苦的思索中我换了一份新工作，工作职责由软件开发工程师成为前端开发工程师，职责的变化，让我对工作和职业有了新的认识。工作中我也对简单可依赖的的理念有了更深的理解，其实就我等普通人来说，不管对待家人，朋友，同事，还是工作生活，我们只要努力做到简单可依赖，就没有那么多烦恼和麻烦。\n\n对新的一年的我有几个期望，希望明年总结时不会有遗憾。\n行路不止，读书不倦。\n树欲静而风不止，子欲养而亲不待。\n芝麻开花节节高。\n\n致敬2014，拥抱2015！","slug":"北漂的日子（十三）致敬2014","published":1,"updated":"2022-01-30T17:07:34.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slo0008ojzodgus6p4o","content":"<p>感觉2013年的年终总结刚刚写完，又要写2014的年终总结了，不得不感叹时光飞快，岁月催人。</p>\n<p>如果说2013是平凡一年，那么2014注定是我人生中记得永远珍藏的一年。</p>\n<p>这一年，站在而立之年的边缘，我终于和命中注定的她结为连理，成为夫妻， 组成了自己的小家庭，增加了一个社会角色——丈夫。<br>结婚了，要和以前的一些自己永远的告别了，以后再也不是一个人，身上有了责任，肩上有了担子。<br>结婚了，感情告一段落了，回想这么几年，年轻的自己做过很多轻狂的事，愚蠢的事，错误的事，值得骄傲的事，有过张狂，有过担当，有过单纯，有过欢天喜地，有过懦弱，有过失败，有过悔恨。。。点点滴滴我都会一一珍藏。<br>结婚了，我爱现在的她。我会珍藏住以前的爱，以前的恨，以前的校园羞涩暗恋，以前初恋情窦，让它们成为我人生美好的回忆。我已原谅伤害过我的人，我也祈祷我伤害过的人能够原谅我。<br>结婚了，我要用一个男人的责任和爱撑起我自己的家庭，孝敬父母，抚育儿女，艰苦奋斗，自力更生。</p>\n<p>这一年，实现了我的几个梦想。<br>10月份，听趵突泉声，漫步大明湖，圆满了小时候对济南的的种种幻想。<br>12月份，在上海祭奠了二姐，算是弥补了我没有实现她愿望的遗憾。</p>\n<p>这一年其实也我迷茫的一年，转眼已经毕业6年，工作上却毫无建树，生活也依然是北漂一族，彷徨于对未来职业方向的计划，苦闷于对未来的生活不定。这一年，读了一些关于人生的书，努力想在书中找到答案，其实答案在自己手里。但是这些书让我对自己有了进一步的认识，对生活和人性有了跟多的理解。</p>\n<p>这一年在苦苦的思索中我换了一份新工作，工作职责由软件开发工程师成为前端开发工程师，职责的变化，让我对工作和职业有了新的认识。工作中我也对简单可依赖的的理念有了更深的理解，其实就我等普通人来说，不管对待家人，朋友，同事，还是工作生活，我们只要努力做到简单可依赖，就没有那么多烦恼和麻烦。</p>\n<p>对新的一年的我有几个期望，希望明年总结时不会有遗憾。<br>行路不止，读书不倦。<br>树欲静而风不止，子欲养而亲不待。<br>芝麻开花节节高。</p>\n<p>致敬2014，拥抱2015！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>感觉2013年的年终总结刚刚写完，又要写2014的年终总结了，不得不感叹时光飞快，岁月催人。</p>\n<p>如果说2013是平凡一年，那么2014注定是我人生中记得永远珍藏的一年。</p>\n<p>这一年，站在而立之年的边缘，我终于和命中注定的她结为连理，成为夫妻， 组成了自己的小家庭，增加了一个社会角色——丈夫。<br>结婚了，要和以前的一些自己永远的告别了，以后再也不是一个人，身上有了责任，肩上有了担子。<br>结婚了，感情告一段落了，回想这么几年，年轻的自己做过很多轻狂的事，愚蠢的事，错误的事，值得骄傲的事，有过张狂，有过担当，有过单纯，有过欢天喜地，有过懦弱，有过失败，有过悔恨。。。点点滴滴我都会一一珍藏。<br>结婚了，我爱现在的她。我会珍藏住以前的爱，以前的恨，以前的校园羞涩暗恋，以前初恋情窦，让它们成为我人生美好的回忆。我已原谅伤害过我的人，我也祈祷我伤害过的人能够原谅我。<br>结婚了，我要用一个男人的责任和爱撑起我自己的家庭，孝敬父母，抚育儿女，艰苦奋斗，自力更生。</p>\n<p>这一年，实现了我的几个梦想。<br>10月份，听趵突泉声，漫步大明湖，圆满了小时候对济南的的种种幻想。<br>12月份，在上海祭奠了二姐，算是弥补了我没有实现她愿望的遗憾。</p>\n<p>这一年其实也我迷茫的一年，转眼已经毕业6年，工作上却毫无建树，生活也依然是北漂一族，彷徨于对未来职业方向的计划，苦闷于对未来的生活不定。这一年，读了一些关于人生的书，努力想在书中找到答案，其实答案在自己手里。但是这些书让我对自己有了进一步的认识，对生活和人性有了跟多的理解。</p>\n<p>这一年在苦苦的思索中我换了一份新工作，工作职责由软件开发工程师成为前端开发工程师，职责的变化，让我对工作和职业有了新的认识。工作中我也对简单可依赖的的理念有了更深的理解，其实就我等普通人来说，不管对待家人，朋友，同事，还是工作生活，我们只要努力做到简单可依赖，就没有那么多烦恼和麻烦。</p>\n<p>对新的一年的我有几个期望，希望明年总结时不会有遗憾。<br>行路不止，读书不倦。<br>树欲静而风不止，子欲养而亲不待。<br>芝麻开花节节高。</p>\n<p>致敬2014，拥抱2015！</p>\n"},{"title":"北漂的日子(十五) 写在2022年的开头","date":"2022-01-30T17:22:43.000Z","_content":"\n我出生在1985年或者1986年，在计划生育的年代，我的父母东躲西藏的在山里的姑奶奶家生下了我，又是各种凑钱缴了超生费，我才能上的户口，我虽然那个时候不记得任何事情，幸好我对那段历史有足够的理解和认知，我大概能想象的出我出生时，我的父母及我的家人的艰难境地，所以对于我到底是哪年的出生的我的确不太在乎。从法律上说，我是1986年出生的，因为身份证上这么记的，这么算，2022年是我的本命年，也在35岁之后的第一个年。\n\n啰嗦这么多，是为了纪念《北漂的日子(十四) 》7年，我老婆是这个系列的忠实读者，怎奈时间有限和工作繁忙。另外也是因为公司的交流用QQ，在QQ上更新日志会让大家看到我赤裸的灵魂，这可能是所谓的职场大忌，羞愧之，惭愧之。现在公司的交流切到slack上，QQ已经和工作关系不大，又慢慢成为了我的个人小窝了。\n\n现在是2021年最后一天的凌晨，窗外刚下过一场小雪，小区里静谧祥和，看不太出来疫情带来的影响。疫情的这两年了，有很多天，这个点（2022-01-31 01:39:17），我都还在公司，或者在回家的路上，回想过往有很多感慨，展望未来又深感任重道远。\n\n2017年2月份，老婆给我生了一个孩子，男孩，5斤多点，现在已经快5岁了。取名为 刘牧山，我出生在山东的蒙山沂水，我老婆出生在三峡库区的重庆云阳那里山多水多，名字意为，观云卷云舒，听溪水潺潺，牧之自然，不负山水。我们是大山里的孩子，我们用这个名字表达我们对大山的敬畏和尊崇，小名是mumu，为了纪念那时在UMU工作的经历，很像王建国，李重庆这种命名法。\n\n2020年底的疫情，改变了很多事情，也改变了很多观念，戴口罩，健康码，核酸检测，已经成为生活中不可或缺的一部分\n\n父母已经年过古稀，对我来说特别想多陪陪他们，在我观念里，所谓“漂”就是和父母的距离太远。\n\n对于新的一年，我想要多花时间在父母和家庭上；在工作和事业上，脚踏实地的做工作，坚持长期主义做事业，更上层楼；在个人发展上开阔视野，提升格局和做事的能力，锤炼思想和信念，坚守初心，坚持奋斗；","source":"_posts/北漂的日子（十五）写在2022年的尾巴.md","raw":"---\ntitle: 北漂的日子(十五) 写在2022年的开头\ndate: 2022-01-31 01:22:43\n---\n\n我出生在1985年或者1986年，在计划生育的年代，我的父母东躲西藏的在山里的姑奶奶家生下了我，又是各种凑钱缴了超生费，我才能上的户口，我虽然那个时候不记得任何事情，幸好我对那段历史有足够的理解和认知，我大概能想象的出我出生时，我的父母及我的家人的艰难境地，所以对于我到底是哪年的出生的我的确不太在乎。从法律上说，我是1986年出生的，因为身份证上这么记的，这么算，2022年是我的本命年，也在35岁之后的第一个年。\n\n啰嗦这么多，是为了纪念《北漂的日子(十四) 》7年，我老婆是这个系列的忠实读者，怎奈时间有限和工作繁忙。另外也是因为公司的交流用QQ，在QQ上更新日志会让大家看到我赤裸的灵魂，这可能是所谓的职场大忌，羞愧之，惭愧之。现在公司的交流切到slack上，QQ已经和工作关系不大，又慢慢成为了我的个人小窝了。\n\n现在是2021年最后一天的凌晨，窗外刚下过一场小雪，小区里静谧祥和，看不太出来疫情带来的影响。疫情的这两年了，有很多天，这个点（2022-01-31 01:39:17），我都还在公司，或者在回家的路上，回想过往有很多感慨，展望未来又深感任重道远。\n\n2017年2月份，老婆给我生了一个孩子，男孩，5斤多点，现在已经快5岁了。取名为 刘牧山，我出生在山东的蒙山沂水，我老婆出生在三峡库区的重庆云阳那里山多水多，名字意为，观云卷云舒，听溪水潺潺，牧之自然，不负山水。我们是大山里的孩子，我们用这个名字表达我们对大山的敬畏和尊崇，小名是mumu，为了纪念那时在UMU工作的经历，很像王建国，李重庆这种命名法。\n\n2020年底的疫情，改变了很多事情，也改变了很多观念，戴口罩，健康码，核酸检测，已经成为生活中不可或缺的一部分\n\n父母已经年过古稀，对我来说特别想多陪陪他们，在我观念里，所谓“漂”就是和父母的距离太远。\n\n对于新的一年，我想要多花时间在父母和家庭上；在工作和事业上，脚踏实地的做工作，坚持长期主义做事业，更上层楼；在个人发展上开阔视野，提升格局和做事的能力，锤炼思想和信念，坚守初心，坚持奋斗；","slug":"北漂的日子（十五）写在2022年的尾巴","published":1,"updated":"2022-02-19T09:32:44.834Z","_id":"ckztm8slo0009ojzo5axkf07k","comments":1,"layout":"post","photos":[],"link":"","content":"<p>我出生在1985年或者1986年，在计划生育的年代，我的父母东躲西藏的在山里的姑奶奶家生下了我，又是各种凑钱缴了超生费，我才能上的户口，我虽然那个时候不记得任何事情，幸好我对那段历史有足够的理解和认知，我大概能想象的出我出生时，我的父母及我的家人的艰难境地，所以对于我到底是哪年的出生的我的确不太在乎。从法律上说，我是1986年出生的，因为身份证上这么记的，这么算，2022年是我的本命年，也在35岁之后的第一个年。</p>\n<p>啰嗦这么多，是为了纪念《北漂的日子(十四) 》7年，我老婆是这个系列的忠实读者，怎奈时间有限和工作繁忙。另外也是因为公司的交流用QQ，在QQ上更新日志会让大家看到我赤裸的灵魂，这可能是所谓的职场大忌，羞愧之，惭愧之。现在公司的交流切到slack上，QQ已经和工作关系不大，又慢慢成为了我的个人小窝了。</p>\n<p>现在是2021年最后一天的凌晨，窗外刚下过一场小雪，小区里静谧祥和，看不太出来疫情带来的影响。疫情的这两年了，有很多天，这个点（2022-01-31 01:39:17），我都还在公司，或者在回家的路上，回想过往有很多感慨，展望未来又深感任重道远。</p>\n<p>2017年2月份，老婆给我生了一个孩子，男孩，5斤多点，现在已经快5岁了。取名为 刘牧山，我出生在山东的蒙山沂水，我老婆出生在三峡库区的重庆云阳那里山多水多，名字意为，观云卷云舒，听溪水潺潺，牧之自然，不负山水。我们是大山里的孩子，我们用这个名字表达我们对大山的敬畏和尊崇，小名是mumu，为了纪念那时在UMU工作的经历，很像王建国，李重庆这种命名法。</p>\n<p>2020年底的疫情，改变了很多事情，也改变了很多观念，戴口罩，健康码，核酸检测，已经成为生活中不可或缺的一部分</p>\n<p>父母已经年过古稀，对我来说特别想多陪陪他们，在我观念里，所谓“漂”就是和父母的距离太远。</p>\n<p>对于新的一年，我想要多花时间在父母和家庭上；在工作和事业上，脚踏实地的做工作，坚持长期主义做事业，更上层楼；在个人发展上开阔视野，提升格局和做事的能力，锤炼思想和信念，坚守初心，坚持奋斗；</p>\n","site":{"data":{}},"excerpt":"","more":"<p>我出生在1985年或者1986年，在计划生育的年代，我的父母东躲西藏的在山里的姑奶奶家生下了我，又是各种凑钱缴了超生费，我才能上的户口，我虽然那个时候不记得任何事情，幸好我对那段历史有足够的理解和认知，我大概能想象的出我出生时，我的父母及我的家人的艰难境地，所以对于我到底是哪年的出生的我的确不太在乎。从法律上说，我是1986年出生的，因为身份证上这么记的，这么算，2022年是我的本命年，也在35岁之后的第一个年。</p>\n<p>啰嗦这么多，是为了纪念《北漂的日子(十四) 》7年，我老婆是这个系列的忠实读者，怎奈时间有限和工作繁忙。另外也是因为公司的交流用QQ，在QQ上更新日志会让大家看到我赤裸的灵魂，这可能是所谓的职场大忌，羞愧之，惭愧之。现在公司的交流切到slack上，QQ已经和工作关系不大，又慢慢成为了我的个人小窝了。</p>\n<p>现在是2021年最后一天的凌晨，窗外刚下过一场小雪，小区里静谧祥和，看不太出来疫情带来的影响。疫情的这两年了，有很多天，这个点（2022-01-31 01:39:17），我都还在公司，或者在回家的路上，回想过往有很多感慨，展望未来又深感任重道远。</p>\n<p>2017年2月份，老婆给我生了一个孩子，男孩，5斤多点，现在已经快5岁了。取名为 刘牧山，我出生在山东的蒙山沂水，我老婆出生在三峡库区的重庆云阳那里山多水多，名字意为，观云卷云舒，听溪水潺潺，牧之自然，不负山水。我们是大山里的孩子，我们用这个名字表达我们对大山的敬畏和尊崇，小名是mumu，为了纪念那时在UMU工作的经历，很像王建国，李重庆这种命名法。</p>\n<p>2020年底的疫情，改变了很多事情，也改变了很多观念，戴口罩，健康码，核酸检测，已经成为生活中不可或缺的一部分</p>\n<p>父母已经年过古稀，对我来说特别想多陪陪他们，在我观念里，所谓“漂”就是和父母的距离太远。</p>\n<p>对于新的一年，我想要多花时间在父母和家庭上；在工作和事业上，脚踏实地的做工作，坚持长期主义做事业，更上层楼；在个人发展上开阔视野，提升格局和做事的能力，锤炼思想和信念，坚守初心，坚持奋斗；</p>\n"},{"title":"阴雨天北戴河水鸟——北漂的日子（十一）","date":"2014-06-22T14:59:00.000Z","_content":"\n黝黑海水，酣醉。\n夏至星宇，蒙灰。\n欲飞，似铅坠。\n旧梦，随风碎。","source":"_posts/北漂的日子（十一）阴雨天北戴河水鸟.md","raw":"---\ntitle: 阴雨天北戴河水鸟——北漂的日子（十一）\ndate: 2014-6-22 22:59\n---\n\n黝黑海水，酣醉。\n夏至星宇，蒙灰。\n欲飞，似铅坠。\n旧梦，随风碎。","slug":"北漂的日子（十一）阴雨天北戴河水鸟","published":1,"updated":"2022-01-30T17:07:45.645Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slp000aojzo6oskei9g","content":"<p>黝黑海水，酣醉。<br>夏至星宇，蒙灰。<br>欲飞，似铅坠。<br>旧梦，随风碎。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>黝黑海水，酣醉。<br>夏至星宇，蒙灰。<br>欲飞，似铅坠。<br>旧梦，随风碎。</p>\n"},{"title":"杂说-北漂的日子(十四)","date":"2015-10-28T17:44:00.000Z","_content":"\n这个系列的日志越来越像年终总结了，其实偶尔该静下来反思一下自己，以前工作空闲的时候，经常静下来，想想自己从哪来的，要到哪里去？其实想也白想，当时改变不了什么。要改变早就改变了，改变不了的，那可能就是命了，我也奇怪，刚到而立之年，为啥这么消极。静下来想，其实不是消极，这是命。佛教中说千千世界里的因果，人的一生又何尝不是，从出生到死亡，其中五味陈杂之事，又何尝不是环环相扣，丝丝入骨呢。懒惰有懒惰的原因，失败有失败的起因，成功有成功的推力，幸福有幸福的缘由......\n\n改变不了啥，不等于这个事就像个屁一样，放了就放了，看清眼前的路，才能走的更明白，即便是路是崎岖无比，即便是泥泞曲折，我也想走的清楚一点。\n\n我自愧读书不多，常常自责，常常自省，不懂人生，不解人世。人的一生有像数学模型般规律吗？ 如果有，规律是啥，如果没有，我们又为何而生？为谁而活呢？滔滔历史长河，数千年的人类文明史，有没有总结出人活得规律？或许有，某些原因，前人不想留给后人。  人不可能两次踏进同一条河流。每个人有自己的独有的人生轨迹。历史的书写者不能关照每个人的生活，所以历史写不出人生的规律，由此观点看去，每个人都是独一无二的，你的活法，你的体验，都是独一无二，未来不会有人和你一样，过去也没有人和你耦合。\n\n于是，我想在自己个人这个层次上，我有自己的命，我有自己独特的人生，可是这不是人本身这个生物体处于舒适区间的条件，也不是人这个意识体处于自由的区间 。于是我即便这么想了自己的人生，我还时要明天早起上班 ，还是要挤地铁，当现实和理想拥挤时，就像你在拥挤的早高峰的路上，在地铁，是肉与肉的拥挤，在高速上是铁与铁的拥挤。在地铁上的拥挤更真切，因为这是让人这个生物体感到拥挤。于是理想与生物体的生存发生冲撞时，理想会投降。\n\n有人说，理想总会绽放，只要你去浇灌。我也时常对自己说，会的，其实想想，这是有点自欺欺人，越年长，对自己的认识越深刻广泛，越觉得自己的无知无能，在我在成长的每个里程碑上我都有留下了太多的遗憾，而这些遗憾里面有一些我突破不了的东西，我渐渐的明白有些东西争是争不来，因为在没上起跑线我就输了。\n\n到年关了，地铁里又能看见很多大包小包的农民工兄弟，看到他们我经常想起我初中时，我哥骑自行车带我去剪头发，问我一个问题：你长大了想干什么？我当时正好翻看了一下我哥带回家的一本大学教程《微观经济学》，我对里面的边际效应，最佳资源配置等似懂非懂的词非常感兴趣，我当时觉得经济可以改变我家的贫困面貌。于是我坐在自行车座后面，说，我要做经济学家，我要搞清楚为什么有人每天拼命却挣不着钱，有人每天很悠闲却很有钱，然后再找到办法，让这个社会不再有穷人......已经过去十几年了，这个理想其实一直在我心里。有人说，你去实现了这个理想啊，人生的每一步都是带着历史的包袱和与现实的妥协一步一步走来，这个过程会给我的性格带来各种影响，而这种影响又会在不同的现实条件中相互作用。这理想会越来越细化量化，我一直在努力。其实这些过程也可以用的这些农民工兄弟身上，他们走在在繁华的拥挤的街道，挤在早高峰的地铁里， 穿着习惯和周边的人格格不入，但是他们在奋力的改变自己，或者改变自己的子女，他们也有儿时的理想也许记得，也许忘却.....他们不需要我的同情，因为我也是他们中的一员，只是因为我的自卑，故意把自己弄得不像一个大包小包的农民工。\n\n我给自己前三十年做了个定位：穷人。穷者，缺乏财物，处境恶劣。人者，人也。处境如此，不堪其忧。 粗缯大布裹生涯，却腹无诗书。采菊南山下，只为付房租。与其说在奋斗，不如说是挣扎。人生苦短，何其寥寥。结合前面的思量，前三十年和父辈的后三十年是顺承的，富贵也好，穷困也罢，这是命，你改变逃脱的可能性不大。后三十年是运，是顺承自己的前三十年的积累和铺垫。我对自己的后三十年没有规划，但是我觉得我有很多值得我去做的事情，也许改变的不仅仅是我自己。\n\n续。\n\n投降的理想会这么样？我不知道。\n熬夜的我，该怎么办？我知道。\n\n承。\n\n\n晚安。\n\n初：2015-10-29 01:44\n查缺补漏：2015年12月28日00:56:07","source":"_posts/北漂的日子（十四）杂说.md","raw":"---\ntitle: 杂说-北漂的日子(十四)\ndate: 2015-10-29 01:44\n---\n\n这个系列的日志越来越像年终总结了，其实偶尔该静下来反思一下自己，以前工作空闲的时候，经常静下来，想想自己从哪来的，要到哪里去？其实想也白想，当时改变不了什么。要改变早就改变了，改变不了的，那可能就是命了，我也奇怪，刚到而立之年，为啥这么消极。静下来想，其实不是消极，这是命。佛教中说千千世界里的因果，人的一生又何尝不是，从出生到死亡，其中五味陈杂之事，又何尝不是环环相扣，丝丝入骨呢。懒惰有懒惰的原因，失败有失败的起因，成功有成功的推力，幸福有幸福的缘由......\n\n改变不了啥，不等于这个事就像个屁一样，放了就放了，看清眼前的路，才能走的更明白，即便是路是崎岖无比，即便是泥泞曲折，我也想走的清楚一点。\n\n我自愧读书不多，常常自责，常常自省，不懂人生，不解人世。人的一生有像数学模型般规律吗？ 如果有，规律是啥，如果没有，我们又为何而生？为谁而活呢？滔滔历史长河，数千年的人类文明史，有没有总结出人活得规律？或许有，某些原因，前人不想留给后人。  人不可能两次踏进同一条河流。每个人有自己的独有的人生轨迹。历史的书写者不能关照每个人的生活，所以历史写不出人生的规律，由此观点看去，每个人都是独一无二的，你的活法，你的体验，都是独一无二，未来不会有人和你一样，过去也没有人和你耦合。\n\n于是，我想在自己个人这个层次上，我有自己的命，我有自己独特的人生，可是这不是人本身这个生物体处于舒适区间的条件，也不是人这个意识体处于自由的区间 。于是我即便这么想了自己的人生，我还时要明天早起上班 ，还是要挤地铁，当现实和理想拥挤时，就像你在拥挤的早高峰的路上，在地铁，是肉与肉的拥挤，在高速上是铁与铁的拥挤。在地铁上的拥挤更真切，因为这是让人这个生物体感到拥挤。于是理想与生物体的生存发生冲撞时，理想会投降。\n\n有人说，理想总会绽放，只要你去浇灌。我也时常对自己说，会的，其实想想，这是有点自欺欺人，越年长，对自己的认识越深刻广泛，越觉得自己的无知无能，在我在成长的每个里程碑上我都有留下了太多的遗憾，而这些遗憾里面有一些我突破不了的东西，我渐渐的明白有些东西争是争不来，因为在没上起跑线我就输了。\n\n到年关了，地铁里又能看见很多大包小包的农民工兄弟，看到他们我经常想起我初中时，我哥骑自行车带我去剪头发，问我一个问题：你长大了想干什么？我当时正好翻看了一下我哥带回家的一本大学教程《微观经济学》，我对里面的边际效应，最佳资源配置等似懂非懂的词非常感兴趣，我当时觉得经济可以改变我家的贫困面貌。于是我坐在自行车座后面，说，我要做经济学家，我要搞清楚为什么有人每天拼命却挣不着钱，有人每天很悠闲却很有钱，然后再找到办法，让这个社会不再有穷人......已经过去十几年了，这个理想其实一直在我心里。有人说，你去实现了这个理想啊，人生的每一步都是带着历史的包袱和与现实的妥协一步一步走来，这个过程会给我的性格带来各种影响，而这种影响又会在不同的现实条件中相互作用。这理想会越来越细化量化，我一直在努力。其实这些过程也可以用的这些农民工兄弟身上，他们走在在繁华的拥挤的街道，挤在早高峰的地铁里， 穿着习惯和周边的人格格不入，但是他们在奋力的改变自己，或者改变自己的子女，他们也有儿时的理想也许记得，也许忘却.....他们不需要我的同情，因为我也是他们中的一员，只是因为我的自卑，故意把自己弄得不像一个大包小包的农民工。\n\n我给自己前三十年做了个定位：穷人。穷者，缺乏财物，处境恶劣。人者，人也。处境如此，不堪其忧。 粗缯大布裹生涯，却腹无诗书。采菊南山下，只为付房租。与其说在奋斗，不如说是挣扎。人生苦短，何其寥寥。结合前面的思量，前三十年和父辈的后三十年是顺承的，富贵也好，穷困也罢，这是命，你改变逃脱的可能性不大。后三十年是运，是顺承自己的前三十年的积累和铺垫。我对自己的后三十年没有规划，但是我觉得我有很多值得我去做的事情，也许改变的不仅仅是我自己。\n\n续。\n\n投降的理想会这么样？我不知道。\n熬夜的我，该怎么办？我知道。\n\n承。\n\n\n晚安。\n\n初：2015-10-29 01:44\n查缺补漏：2015年12月28日00:56:07","slug":"北漂的日子（十四）杂说","published":1,"updated":"2022-01-30T17:07:40.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slq000bojzo23n39o2p","content":"<p>这个系列的日志越来越像年终总结了，其实偶尔该静下来反思一下自己，以前工作空闲的时候，经常静下来，想想自己从哪来的，要到哪里去？其实想也白想，当时改变不了什么。要改变早就改变了，改变不了的，那可能就是命了，我也奇怪，刚到而立之年，为啥这么消极。静下来想，其实不是消极，这是命。佛教中说千千世界里的因果，人的一生又何尝不是，从出生到死亡，其中五味陈杂之事，又何尝不是环环相扣，丝丝入骨呢。懒惰有懒惰的原因，失败有失败的起因，成功有成功的推力，幸福有幸福的缘由……</p>\n<p>改变不了啥，不等于这个事就像个屁一样，放了就放了，看清眼前的路，才能走的更明白，即便是路是崎岖无比，即便是泥泞曲折，我也想走的清楚一点。</p>\n<p>我自愧读书不多，常常自责，常常自省，不懂人生，不解人世。人的一生有像数学模型般规律吗？ 如果有，规律是啥，如果没有，我们又为何而生？为谁而活呢？滔滔历史长河，数千年的人类文明史，有没有总结出人活得规律？或许有，某些原因，前人不想留给后人。  人不可能两次踏进同一条河流。每个人有自己的独有的人生轨迹。历史的书写者不能关照每个人的生活，所以历史写不出人生的规律，由此观点看去，每个人都是独一无二的，你的活法，你的体验，都是独一无二，未来不会有人和你一样，过去也没有人和你耦合。</p>\n<p>于是，我想在自己个人这个层次上，我有自己的命，我有自己独特的人生，可是这不是人本身这个生物体处于舒适区间的条件，也不是人这个意识体处于自由的区间 。于是我即便这么想了自己的人生，我还时要明天早起上班 ，还是要挤地铁，当现实和理想拥挤时，就像你在拥挤的早高峰的路上，在地铁，是肉与肉的拥挤，在高速上是铁与铁的拥挤。在地铁上的拥挤更真切，因为这是让人这个生物体感到拥挤。于是理想与生物体的生存发生冲撞时，理想会投降。</p>\n<p>有人说，理想总会绽放，只要你去浇灌。我也时常对自己说，会的，其实想想，这是有点自欺欺人，越年长，对自己的认识越深刻广泛，越觉得自己的无知无能，在我在成长的每个里程碑上我都有留下了太多的遗憾，而这些遗憾里面有一些我突破不了的东西，我渐渐的明白有些东西争是争不来，因为在没上起跑线我就输了。</p>\n<p>到年关了，地铁里又能看见很多大包小包的农民工兄弟，看到他们我经常想起我初中时，我哥骑自行车带我去剪头发，问我一个问题：你长大了想干什么？我当时正好翻看了一下我哥带回家的一本大学教程《微观经济学》，我对里面的边际效应，最佳资源配置等似懂非懂的词非常感兴趣，我当时觉得经济可以改变我家的贫困面貌。于是我坐在自行车座后面，说，我要做经济学家，我要搞清楚为什么有人每天拼命却挣不着钱，有人每天很悠闲却很有钱，然后再找到办法，让这个社会不再有穷人……已经过去十几年了，这个理想其实一直在我心里。有人说，你去实现了这个理想啊，人生的每一步都是带着历史的包袱和与现实的妥协一步一步走来，这个过程会给我的性格带来各种影响，而这种影响又会在不同的现实条件中相互作用。这理想会越来越细化量化，我一直在努力。其实这些过程也可以用的这些农民工兄弟身上，他们走在在繁华的拥挤的街道，挤在早高峰的地铁里， 穿着习惯和周边的人格格不入，但是他们在奋力的改变自己，或者改变自己的子女，他们也有儿时的理想也许记得，也许忘却…..他们不需要我的同情，因为我也是他们中的一员，只是因为我的自卑，故意把自己弄得不像一个大包小包的农民工。</p>\n<p>我给自己前三十年做了个定位：穷人。穷者，缺乏财物，处境恶劣。人者，人也。处境如此，不堪其忧。 粗缯大布裹生涯，却腹无诗书。采菊南山下，只为付房租。与其说在奋斗，不如说是挣扎。人生苦短，何其寥寥。结合前面的思量，前三十年和父辈的后三十年是顺承的，富贵也好，穷困也罢，这是命，你改变逃脱的可能性不大。后三十年是运，是顺承自己的前三十年的积累和铺垫。我对自己的后三十年没有规划，但是我觉得我有很多值得我去做的事情，也许改变的不仅仅是我自己。</p>\n<p>续。</p>\n<p>投降的理想会这么样？我不知道。<br>熬夜的我，该怎么办？我知道。</p>\n<p>承。</p>\n<p>晚安。</p>\n<p>初：2015-10-29 01:44<br>查缺补漏：2015年12月28日00:56:07</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个系列的日志越来越像年终总结了，其实偶尔该静下来反思一下自己，以前工作空闲的时候，经常静下来，想想自己从哪来的，要到哪里去？其实想也白想，当时改变不了什么。要改变早就改变了，改变不了的，那可能就是命了，我也奇怪，刚到而立之年，为啥这么消极。静下来想，其实不是消极，这是命。佛教中说千千世界里的因果，人的一生又何尝不是，从出生到死亡，其中五味陈杂之事，又何尝不是环环相扣，丝丝入骨呢。懒惰有懒惰的原因，失败有失败的起因，成功有成功的推力，幸福有幸福的缘由……</p>\n<p>改变不了啥，不等于这个事就像个屁一样，放了就放了，看清眼前的路，才能走的更明白，即便是路是崎岖无比，即便是泥泞曲折，我也想走的清楚一点。</p>\n<p>我自愧读书不多，常常自责，常常自省，不懂人生，不解人世。人的一生有像数学模型般规律吗？ 如果有，规律是啥，如果没有，我们又为何而生？为谁而活呢？滔滔历史长河，数千年的人类文明史，有没有总结出人活得规律？或许有，某些原因，前人不想留给后人。  人不可能两次踏进同一条河流。每个人有自己的独有的人生轨迹。历史的书写者不能关照每个人的生活，所以历史写不出人生的规律，由此观点看去，每个人都是独一无二的，你的活法，你的体验，都是独一无二，未来不会有人和你一样，过去也没有人和你耦合。</p>\n<p>于是，我想在自己个人这个层次上，我有自己的命，我有自己独特的人生，可是这不是人本身这个生物体处于舒适区间的条件，也不是人这个意识体处于自由的区间 。于是我即便这么想了自己的人生，我还时要明天早起上班 ，还是要挤地铁，当现实和理想拥挤时，就像你在拥挤的早高峰的路上，在地铁，是肉与肉的拥挤，在高速上是铁与铁的拥挤。在地铁上的拥挤更真切，因为这是让人这个生物体感到拥挤。于是理想与生物体的生存发生冲撞时，理想会投降。</p>\n<p>有人说，理想总会绽放，只要你去浇灌。我也时常对自己说，会的，其实想想，这是有点自欺欺人，越年长，对自己的认识越深刻广泛，越觉得自己的无知无能，在我在成长的每个里程碑上我都有留下了太多的遗憾，而这些遗憾里面有一些我突破不了的东西，我渐渐的明白有些东西争是争不来，因为在没上起跑线我就输了。</p>\n<p>到年关了，地铁里又能看见很多大包小包的农民工兄弟，看到他们我经常想起我初中时，我哥骑自行车带我去剪头发，问我一个问题：你长大了想干什么？我当时正好翻看了一下我哥带回家的一本大学教程《微观经济学》，我对里面的边际效应，最佳资源配置等似懂非懂的词非常感兴趣，我当时觉得经济可以改变我家的贫困面貌。于是我坐在自行车座后面，说，我要做经济学家，我要搞清楚为什么有人每天拼命却挣不着钱，有人每天很悠闲却很有钱，然后再找到办法，让这个社会不再有穷人……已经过去十几年了，这个理想其实一直在我心里。有人说，你去实现了这个理想啊，人生的每一步都是带着历史的包袱和与现实的妥协一步一步走来，这个过程会给我的性格带来各种影响，而这种影响又会在不同的现实条件中相互作用。这理想会越来越细化量化，我一直在努力。其实这些过程也可以用的这些农民工兄弟身上，他们走在在繁华的拥挤的街道，挤在早高峰的地铁里， 穿着习惯和周边的人格格不入，但是他们在奋力的改变自己，或者改变自己的子女，他们也有儿时的理想也许记得，也许忘却…..他们不需要我的同情，因为我也是他们中的一员，只是因为我的自卑，故意把自己弄得不像一个大包小包的农民工。</p>\n<p>我给自己前三十年做了个定位：穷人。穷者，缺乏财物，处境恶劣。人者，人也。处境如此，不堪其忧。 粗缯大布裹生涯，却腹无诗书。采菊南山下，只为付房租。与其说在奋斗，不如说是挣扎。人生苦短，何其寥寥。结合前面的思量，前三十年和父辈的后三十年是顺承的，富贵也好，穷困也罢，这是命，你改变逃脱的可能性不大。后三十年是运，是顺承自己的前三十年的积累和铺垫。我对自己的后三十年没有规划，但是我觉得我有很多值得我去做的事情，也许改变的不仅仅是我自己。</p>\n<p>续。</p>\n<p>投降的理想会这么样？我不知道。<br>熬夜的我，该怎么办？我知道。</p>\n<p>承。</p>\n<p>晚安。</p>\n<p>初：2015-10-29 01:44<br>查缺补漏：2015年12月28日00:56:07</p>\n"},{"title":"北漂的日子（四）","date":"2012-10-31T14:20:00.000Z","_content":"\n这阵子终于忙过去了，虽然还有两个遗留的bug，但是我也可以暂时性的不用去管了。\n\n说是一阵子，其实是半年有余，突然发现自己还是喜欢比较紧张充实的生活节奏。\n\n这阵子一直要约得的人没有约成，聚餐的机会也错过了，好吧，希望他们以后还能给我机会弥补。\n\n有些遗憾，不过要迎来我的2012下半年的第一个双休了，高兴。\n\n这阵子电视看得很多，从《天天向上》到《爱笑会议室》，从《爱情公寓3》到《新白发魔女传》，从《锵锵三人行》到《第一财经》，\n\n这阵子从电视上看认识很多演员，知道了马苏，知道了修睿，还知道了吴奇隆原来是小虎队的，不是飞虎队的。\n\n这阵子书读的很少，买的很多，很担心搬家的时候会怎样。\n\n这阵子很少进城，不知道城里还堵不堵车。\n\n这阵子bug很多，不能解的也很多。\n\n这阵子的工作受敏捷理念的影响，但是身体却越来越不敏捷了。\n\n这阵子结婚的朋友很多，很替他们高兴，随份子钱的时候我都会对着红包吹口气，祈祷他们这是最后一次结婚。\n\n这阵子有很多事，都拖延着。。。。\n\n这阵子很忙，下阵子更忙，因为下阵子要把这阵子拖延的事完成。\n\n传说世界末日要到了。。。。。。\n\n爷爷说，忙死总比闲死好。","source":"_posts/北漂的日子（四）.md","raw":"---\ntitle: 北漂的日子（四）\ndate: 2012-10-31 22:20\n---\n\n这阵子终于忙过去了，虽然还有两个遗留的bug，但是我也可以暂时性的不用去管了。\n\n说是一阵子，其实是半年有余，突然发现自己还是喜欢比较紧张充实的生活节奏。\n\n这阵子一直要约得的人没有约成，聚餐的机会也错过了，好吧，希望他们以后还能给我机会弥补。\n\n有些遗憾，不过要迎来我的2012下半年的第一个双休了，高兴。\n\n这阵子电视看得很多，从《天天向上》到《爱笑会议室》，从《爱情公寓3》到《新白发魔女传》，从《锵锵三人行》到《第一财经》，\n\n这阵子从电视上看认识很多演员，知道了马苏，知道了修睿，还知道了吴奇隆原来是小虎队的，不是飞虎队的。\n\n这阵子书读的很少，买的很多，很担心搬家的时候会怎样。\n\n这阵子很少进城，不知道城里还堵不堵车。\n\n这阵子bug很多，不能解的也很多。\n\n这阵子的工作受敏捷理念的影响，但是身体却越来越不敏捷了。\n\n这阵子结婚的朋友很多，很替他们高兴，随份子钱的时候我都会对着红包吹口气，祈祷他们这是最后一次结婚。\n\n这阵子有很多事，都拖延着。。。。\n\n这阵子很忙，下阵子更忙，因为下阵子要把这阵子拖延的事完成。\n\n传说世界末日要到了。。。。。。\n\n爷爷说，忙死总比闲死好。","slug":"北漂的日子（四）","published":1,"updated":"2022-01-30T17:17:17.793Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8slr000cojzo41qvf1qn","content":"<p>这阵子终于忙过去了，虽然还有两个遗留的bug，但是我也可以暂时性的不用去管了。</p>\n<p>说是一阵子，其实是半年有余，突然发现自己还是喜欢比较紧张充实的生活节奏。</p>\n<p>这阵子一直要约得的人没有约成，聚餐的机会也错过了，好吧，希望他们以后还能给我机会弥补。</p>\n<p>有些遗憾，不过要迎来我的2012下半年的第一个双休了，高兴。</p>\n<p>这阵子电视看得很多，从《天天向上》到《爱笑会议室》，从《爱情公寓3》到《新白发魔女传》，从《锵锵三人行》到《第一财经》，</p>\n<p>这阵子从电视上看认识很多演员，知道了马苏，知道了修睿，还知道了吴奇隆原来是小虎队的，不是飞虎队的。</p>\n<p>这阵子书读的很少，买的很多，很担心搬家的时候会怎样。</p>\n<p>这阵子很少进城，不知道城里还堵不堵车。</p>\n<p>这阵子bug很多，不能解的也很多。</p>\n<p>这阵子的工作受敏捷理念的影响，但是身体却越来越不敏捷了。</p>\n<p>这阵子结婚的朋友很多，很替他们高兴，随份子钱的时候我都会对着红包吹口气，祈祷他们这是最后一次结婚。</p>\n<p>这阵子有很多事，都拖延着。。。。</p>\n<p>这阵子很忙，下阵子更忙，因为下阵子要把这阵子拖延的事完成。</p>\n<p>传说世界末日要到了。。。。。。</p>\n<p>爷爷说，忙死总比闲死好。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这阵子终于忙过去了，虽然还有两个遗留的bug，但是我也可以暂时性的不用去管了。</p>\n<p>说是一阵子，其实是半年有余，突然发现自己还是喜欢比较紧张充实的生活节奏。</p>\n<p>这阵子一直要约得的人没有约成，聚餐的机会也错过了，好吧，希望他们以后还能给我机会弥补。</p>\n<p>有些遗憾，不过要迎来我的2012下半年的第一个双休了，高兴。</p>\n<p>这阵子电视看得很多，从《天天向上》到《爱笑会议室》，从《爱情公寓3》到《新白发魔女传》，从《锵锵三人行》到《第一财经》，</p>\n<p>这阵子从电视上看认识很多演员，知道了马苏，知道了修睿，还知道了吴奇隆原来是小虎队的，不是飞虎队的。</p>\n<p>这阵子书读的很少，买的很多，很担心搬家的时候会怎样。</p>\n<p>这阵子很少进城，不知道城里还堵不堵车。</p>\n<p>这阵子bug很多，不能解的也很多。</p>\n<p>这阵子的工作受敏捷理念的影响，但是身体却越来越不敏捷了。</p>\n<p>这阵子结婚的朋友很多，很替他们高兴，随份子钱的时候我都会对着红包吹口气，祈祷他们这是最后一次结婚。</p>\n<p>这阵子有很多事，都拖延着。。。。</p>\n<p>这阵子很忙，下阵子更忙，因为下阵子要把这阵子拖延的事完成。</p>\n<p>传说世界末日要到了。。。。。。</p>\n<p>爷爷说，忙死总比闲死好。</p>\n"},{"title":"北漂的日子（三）","date":"2012-10-23T14:42:00.000Z","_content":"\n漂，是飘零的意思。南宋文天祥有“辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。”的飘零之叹。作为后世敬仰的民族英雄，他叹的是国家兴亡，而今我也经常用它来描述我作为一个北漂的真实的生存状态。\n南宋自贾似道弄权以来，便以风雨飘摇，被蒙古或者大金灭掉那只是时间问题。而此时心怀匡国之志的文天祥不计之前在朝廷上所受的排挤，在蒙古军攻陷     (dai xu)","source":"_posts/北漂的日志（三）.md","raw":"---\ntitle: 北漂的日子（三）\ndate: 2012-10-23 22:42\n---\n\n漂，是飘零的意思。南宋文天祥有“辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。”的飘零之叹。作为后世敬仰的民族英雄，他叹的是国家兴亡，而今我也经常用它来描述我作为一个北漂的真实的生存状态。\n南宋自贾似道弄权以来，便以风雨飘摇，被蒙古或者大金灭掉那只是时间问题。而此时心怀匡国之志的文天祥不计之前在朝廷上所受的排挤，在蒙古军攻陷     (dai xu)","slug":"北漂的日志（三）","published":1,"updated":"2022-01-30T17:18:55.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sls000dojzodrnidk1o","content":"<p>漂，是飘零的意思。南宋文天祥有“辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。”的飘零之叹。作为后世敬仰的民族英雄，他叹的是国家兴亡，而今我也经常用它来描述我作为一个北漂的真实的生存状态。<br>南宋自贾似道弄权以来，便以风雨飘摇，被蒙古或者大金灭掉那只是时间问题。而此时心怀匡国之志的文天祥不计之前在朝廷上所受的排挤，在蒙古军攻陷     (dai xu)</p>\n","site":{"data":{}},"excerpt":"","more":"<p>漂，是飘零的意思。南宋文天祥有“辛苦遭逢起一经，干戈寥落四周星。山河破碎风飘絮，身世浮沉雨打萍。”的飘零之叹。作为后世敬仰的民族英雄，他叹的是国家兴亡，而今我也经常用它来描述我作为一个北漂的真实的生存状态。<br>南宋自贾似道弄权以来，便以风雨飘摇，被蒙古或者大金灭掉那只是时间问题。而此时心怀匡国之志的文天祥不计之前在朝廷上所受的排挤，在蒙古军攻陷     (dai xu)</p>\n"},{"title":"北漂的日子（十）- 致我们终将逝去的童贞","date":"2014-05-31T19:32:00.000Z","_content":"\n托屈原老先生的福，今年的六一竟然在假期了。\n\n内心窃想，虽然已近而立之年，但还未完婚，目前无娃，上有父母大人，应该可以过这个节。\n\n小学时有一年的期末考试临近六一，我印象深刻，因为我们是拿着小板凳在偌大的操场上，炎热的太阳底下，一两百人一同考试，那次的作文题目大概是“记你印象深刻的六一儿童节”，当时写的啥已经忘记了，我想大概应该无非是好人郝建之类的事了。\n\n我已经对我小学时的儿童节没有特别的记忆了，印象中应该是放假一天。90年代农村的孩子，特别是我这种相对贫困的农村孩子，儿童节应该是很淡的，无非是在家待一天。\n\n（一）\n\n但是儿童的快乐和记忆，我换是有的。现在想来很后悔没有认真过我的儿童节。\n\n童年的欢乐有很多：吃顿饺子，哪怕是萝卜馅的、玩一下午泥巴，哪怕只是摔一下午“哇哇响”、去东河洗澡，哪怕只是无尽的扎猛子，掀螃蟹、老哥带着我出去玩，哪怕是只是跟屁虫的角色、出门“旅游”，哪怕是到东岭的看了千百次的小洞口瞄一眼，那时我的欢乐点数很低，只要是消磨时间事情都能让我的日子充满乐趣。\n\n小学的时候我已经不怎么玩过家家了。但是和发小们换是偶尔玩，貌似那时候我已经隐约知道过家家似乎是没大志向的事情（不过现在想想过家家真是了不起的一个游戏，社会上玩数理化，玩金融法律，玩航海航空各种玩法，终归都是过家家里的一个部分）。 因为认识了很多同学，所以“人脉”大了，于是 开始全村乱窜。当时的村子换没有现在大，也就是到现在的西大路那，对我来说。已经类似于出国了，兴奋的很，所以星期六下午基本上是和西大路的同学鬼混。我记得那时候，没有双休，只是周六休半天，周日全天休。\n\n小学三年级的时候，貌似发现乱窜也不是什么有趣的事，但是除了这，就是和小伙伴们玩之前玩的东西。我是比较懒的人，学开和明杰糊的风筝飞得很高的时候，我也不想自己糊一个。我也是比较笨的，那时候他们粘知了粘很多，我始终赶不上他们，一次一次实践证明，我玩动手的事是玩不过学开、明杰、清发他们的，这也让我对这些玩法慢慢失去了兴趣，因为太打击人，老玩不过其他他们。不过这时候 我有了另一个朋友圈，这帮小伙伴比较喜欢学习，如修虎，光田，庆磊，照真兄弟，虽然我也玩不过他们，但至少我还有点兴趣。现在想来，我的不执著的毛病是从那时养成的习惯。\n\n那时候，我最感兴趣的事情是和庆磊一块到修虎家看书。修虎有好几箱子卡通书，画册。那时候闭塞的我知道了贝塔，知道了百慕大，知道了西游记。每个周六下午，庆磊、我都会到修虎家，先把老师留的作业做完，我有时候会抄他们俩的，他们俩学习都很好，所以我的作业质量换算过得去，当然就是字写的比他们的难看很多，我记得修虎同学的字写的很漂亮。写完作业，修虎就会翻出一箱书，大家一起看。那时候竟然一看就能看一下午，这也是童年的周末啊，现在想来真不敢相信。\n现在想来我觉我能上学能一路下来，真得感谢修虎的那几箱子书。现在大家都在奔各自生活，虽然同村，却好多年不见他们了，我想他们也会偶尔想起我，大家一起看书的星期六下午。\n\n现在想来，我们已经再也回不到那样的星期六下午了。\n\n（二）\n\n我最不情愿的事情就是放麦假，民办老师也是家里劳力，要收麦子，而我这样的小学生要帮家里看家、拾麦穗、看场、晒麦子，以上这些我倒不反感，因为这些活，都可以找点乐趣，比如在家可以看电视，看书，至少不被晒。看场，虽然热，刺挠，至少清闲。  最最不情愿的就是早上四点就被父母来起来去捆麦子，收麦子。眼睛都睁不起来，更关键是刺挠，热，晒，挥汗如雨。干一天，皮肤都脱皮了。不过晚上可以吃顿好吃的，  改善下伙食，大家围坐在堂屋西旁的梧桐树下，吃着热气腾腾的绿豆疙瘩饭，闻着成熟的麦香，听着不时隆隆作响的打麦机响，再来个凉拌黄瓜，真香！这时候，西院的二哥都会过来唠唠嗑，说说今年的收成，东边的三哥也会带着高群过来唠唠，小院子里热闹而和睦，劳累而快乐。\n\n这时候老爹现身说法，说好好上学就可以不用干这个了。然后举例说明谁家老几学习怎样，然后进城，然后怎样。然后我也对我说要争气。可是到目前为止我也没挣到这口气，估计要留给我孩子了。然后大家七嘴八舌的家长里短起来了。\n\n那时家里7口人，8亩多地，只有父母大姐二姐忙活儿，想想那时候生活太劳累了了。可是现在想来，全家人一块干活，平平安安，健健康康的，团团圆圆，真是一种天大的幸福。因为现在我也再也看不到我这个场景里的老爷，二姐，二哥了。\n\n现在想来，我已经再也吃不到吃不到那个味道的晚饭了。\n\n不上学我是农民，上了学，现在是码农，原来生产粮食，现在生产代码，现在想来我是从一个火坑跳的另一个火坑，以我目前人生经验来看，人生就是一个火坑跳到另外的火坑。人生真谛就是带着火花跳，才跳的精彩！\n\n\n（三）\n\n那个时候的北村小学操场换很大，西边是生产队时期的兔子场，东边是下场大雨就能冲出个骨头来的的大水沟。前面是条东西大路，路对过是一个大水汪，水很清，春夏经常有人在里面洗芹菜，洗衣服，我们也时常中午去那里用罐头瓶子捞鱼。最让我感兴趣的是大路上有两个买零食的摊，各种好吃的，各种好玩的，我时常从家里偷拿钱，消费到 这里了，为这，没少挨凑挨骂。那时候学校大概有两列四排八座房子，每座房子2口教室，最前面是牛b的5年级和办公室，依次类推，年级越低越靠后，想想那时候老师很讲究面子工程，这么排布教室，即使一二年级再乱，从学校门口看去，学校整体秩序换是很好滴。\n\n那时候我换不知道电铃这回事，学校也没有，有个大铁钟挂在办公室前面的老榆树上，老师们看着表，敲钟上下课。那时候我心目中最神圣的就是那个大钟，它庄重而权威，全校师生都要听它的，我那时候的最大梦想就是能够自己敲它一下。这个梦想有没有实现已经不存在记忆里了。不过，有一次我和照锋同学把办公室的门锁用火柴棒塞上了，导致第二天全校早上上不了课，我却记得清清楚楚。这些都已成为往事和回忆。这个校园也不复存在。现在这块地已经是宅基地了。\n\n现在想来，这个校园我们再也无法拥有，我再也回不到这个学校听漂亮的曹老师讲a,b,c,d了。\n\n\n（四）\n \n我的童年就是这样无聊平凡。\n我的童真就是这样枯燥单纯。\n我的童趣就是这样乏味单调。\n我的童贞就是这样没有了，没有波澜，我还不知道我已经拥有，它就已经溜走了。\n\n凡此种种，以致敬那些逝去的儿童节！\n真心祝福我和小伙伴们儿童节快乐！\n\n\n\n劉盗愚\n2014年6月1日03:53:24","source":"_posts/北漂的日子（十）致我们终将逝去的童贞.md","raw":"---\ntitle: 北漂的日子（十）- 致我们终将逝去的童贞\ndate: 2014-6-1 03:32\n---\n\n托屈原老先生的福，今年的六一竟然在假期了。\n\n内心窃想，虽然已近而立之年，但还未完婚，目前无娃，上有父母大人，应该可以过这个节。\n\n小学时有一年的期末考试临近六一，我印象深刻，因为我们是拿着小板凳在偌大的操场上，炎热的太阳底下，一两百人一同考试，那次的作文题目大概是“记你印象深刻的六一儿童节”，当时写的啥已经忘记了，我想大概应该无非是好人郝建之类的事了。\n\n我已经对我小学时的儿童节没有特别的记忆了，印象中应该是放假一天。90年代农村的孩子，特别是我这种相对贫困的农村孩子，儿童节应该是很淡的，无非是在家待一天。\n\n（一）\n\n但是儿童的快乐和记忆，我换是有的。现在想来很后悔没有认真过我的儿童节。\n\n童年的欢乐有很多：吃顿饺子，哪怕是萝卜馅的、玩一下午泥巴，哪怕只是摔一下午“哇哇响”、去东河洗澡，哪怕只是无尽的扎猛子，掀螃蟹、老哥带着我出去玩，哪怕是只是跟屁虫的角色、出门“旅游”，哪怕是到东岭的看了千百次的小洞口瞄一眼，那时我的欢乐点数很低，只要是消磨时间事情都能让我的日子充满乐趣。\n\n小学的时候我已经不怎么玩过家家了。但是和发小们换是偶尔玩，貌似那时候我已经隐约知道过家家似乎是没大志向的事情（不过现在想想过家家真是了不起的一个游戏，社会上玩数理化，玩金融法律，玩航海航空各种玩法，终归都是过家家里的一个部分）。 因为认识了很多同学，所以“人脉”大了，于是 开始全村乱窜。当时的村子换没有现在大，也就是到现在的西大路那，对我来说。已经类似于出国了，兴奋的很，所以星期六下午基本上是和西大路的同学鬼混。我记得那时候，没有双休，只是周六休半天，周日全天休。\n\n小学三年级的时候，貌似发现乱窜也不是什么有趣的事，但是除了这，就是和小伙伴们玩之前玩的东西。我是比较懒的人，学开和明杰糊的风筝飞得很高的时候，我也不想自己糊一个。我也是比较笨的，那时候他们粘知了粘很多，我始终赶不上他们，一次一次实践证明，我玩动手的事是玩不过学开、明杰、清发他们的，这也让我对这些玩法慢慢失去了兴趣，因为太打击人，老玩不过其他他们。不过这时候 我有了另一个朋友圈，这帮小伙伴比较喜欢学习，如修虎，光田，庆磊，照真兄弟，虽然我也玩不过他们，但至少我还有点兴趣。现在想来，我的不执著的毛病是从那时养成的习惯。\n\n那时候，我最感兴趣的事情是和庆磊一块到修虎家看书。修虎有好几箱子卡通书，画册。那时候闭塞的我知道了贝塔，知道了百慕大，知道了西游记。每个周六下午，庆磊、我都会到修虎家，先把老师留的作业做完，我有时候会抄他们俩的，他们俩学习都很好，所以我的作业质量换算过得去，当然就是字写的比他们的难看很多，我记得修虎同学的字写的很漂亮。写完作业，修虎就会翻出一箱书，大家一起看。那时候竟然一看就能看一下午，这也是童年的周末啊，现在想来真不敢相信。\n现在想来我觉我能上学能一路下来，真得感谢修虎的那几箱子书。现在大家都在奔各自生活，虽然同村，却好多年不见他们了，我想他们也会偶尔想起我，大家一起看书的星期六下午。\n\n现在想来，我们已经再也回不到那样的星期六下午了。\n\n（二）\n\n我最不情愿的事情就是放麦假，民办老师也是家里劳力，要收麦子，而我这样的小学生要帮家里看家、拾麦穗、看场、晒麦子，以上这些我倒不反感，因为这些活，都可以找点乐趣，比如在家可以看电视，看书，至少不被晒。看场，虽然热，刺挠，至少清闲。  最最不情愿的就是早上四点就被父母来起来去捆麦子，收麦子。眼睛都睁不起来，更关键是刺挠，热，晒，挥汗如雨。干一天，皮肤都脱皮了。不过晚上可以吃顿好吃的，  改善下伙食，大家围坐在堂屋西旁的梧桐树下，吃着热气腾腾的绿豆疙瘩饭，闻着成熟的麦香，听着不时隆隆作响的打麦机响，再来个凉拌黄瓜，真香！这时候，西院的二哥都会过来唠唠嗑，说说今年的收成，东边的三哥也会带着高群过来唠唠，小院子里热闹而和睦，劳累而快乐。\n\n这时候老爹现身说法，说好好上学就可以不用干这个了。然后举例说明谁家老几学习怎样，然后进城，然后怎样。然后我也对我说要争气。可是到目前为止我也没挣到这口气，估计要留给我孩子了。然后大家七嘴八舌的家长里短起来了。\n\n那时家里7口人，8亩多地，只有父母大姐二姐忙活儿，想想那时候生活太劳累了了。可是现在想来，全家人一块干活，平平安安，健健康康的，团团圆圆，真是一种天大的幸福。因为现在我也再也看不到我这个场景里的老爷，二姐，二哥了。\n\n现在想来，我已经再也吃不到吃不到那个味道的晚饭了。\n\n不上学我是农民，上了学，现在是码农，原来生产粮食，现在生产代码，现在想来我是从一个火坑跳的另一个火坑，以我目前人生经验来看，人生就是一个火坑跳到另外的火坑。人生真谛就是带着火花跳，才跳的精彩！\n\n\n（三）\n\n那个时候的北村小学操场换很大，西边是生产队时期的兔子场，东边是下场大雨就能冲出个骨头来的的大水沟。前面是条东西大路，路对过是一个大水汪，水很清，春夏经常有人在里面洗芹菜，洗衣服，我们也时常中午去那里用罐头瓶子捞鱼。最让我感兴趣的是大路上有两个买零食的摊，各种好吃的，各种好玩的，我时常从家里偷拿钱，消费到 这里了，为这，没少挨凑挨骂。那时候学校大概有两列四排八座房子，每座房子2口教室，最前面是牛b的5年级和办公室，依次类推，年级越低越靠后，想想那时候老师很讲究面子工程，这么排布教室，即使一二年级再乱，从学校门口看去，学校整体秩序换是很好滴。\n\n那时候我换不知道电铃这回事，学校也没有，有个大铁钟挂在办公室前面的老榆树上，老师们看着表，敲钟上下课。那时候我心目中最神圣的就是那个大钟，它庄重而权威，全校师生都要听它的，我那时候的最大梦想就是能够自己敲它一下。这个梦想有没有实现已经不存在记忆里了。不过，有一次我和照锋同学把办公室的门锁用火柴棒塞上了，导致第二天全校早上上不了课，我却记得清清楚楚。这些都已成为往事和回忆。这个校园也不复存在。现在这块地已经是宅基地了。\n\n现在想来，这个校园我们再也无法拥有，我再也回不到这个学校听漂亮的曹老师讲a,b,c,d了。\n\n\n（四）\n \n我的童年就是这样无聊平凡。\n我的童真就是这样枯燥单纯。\n我的童趣就是这样乏味单调。\n我的童贞就是这样没有了，没有波澜，我还不知道我已经拥有，它就已经溜走了。\n\n凡此种种，以致敬那些逝去的儿童节！\n真心祝福我和小伙伴们儿童节快乐！\n\n\n\n劉盗愚\n2014年6月1日03:53:24","slug":"北漂的日子（十）致我们终将逝去的童贞","published":1,"updated":"2022-01-30T17:07:21.003Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckztm8sm1000eojzo1iab8el1","content":"<p>托屈原老先生的福，今年的六一竟然在假期了。</p>\n<p>内心窃想，虽然已近而立之年，但还未完婚，目前无娃，上有父母大人，应该可以过这个节。</p>\n<p>小学时有一年的期末考试临近六一，我印象深刻，因为我们是拿着小板凳在偌大的操场上，炎热的太阳底下，一两百人一同考试，那次的作文题目大概是“记你印象深刻的六一儿童节”，当时写的啥已经忘记了，我想大概应该无非是好人郝建之类的事了。</p>\n<p>我已经对我小学时的儿童节没有特别的记忆了，印象中应该是放假一天。90年代农村的孩子，特别是我这种相对贫困的农村孩子，儿童节应该是很淡的，无非是在家待一天。</p>\n<p>（一）</p>\n<p>但是儿童的快乐和记忆，我换是有的。现在想来很后悔没有认真过我的儿童节。</p>\n<p>童年的欢乐有很多：吃顿饺子，哪怕是萝卜馅的、玩一下午泥巴，哪怕只是摔一下午“哇哇响”、去东河洗澡，哪怕只是无尽的扎猛子，掀螃蟹、老哥带着我出去玩，哪怕是只是跟屁虫的角色、出门“旅游”，哪怕是到东岭的看了千百次的小洞口瞄一眼，那时我的欢乐点数很低，只要是消磨时间事情都能让我的日子充满乐趣。</p>\n<p>小学的时候我已经不怎么玩过家家了。但是和发小们换是偶尔玩，貌似那时候我已经隐约知道过家家似乎是没大志向的事情（不过现在想想过家家真是了不起的一个游戏，社会上玩数理化，玩金融法律，玩航海航空各种玩法，终归都是过家家里的一个部分）。 因为认识了很多同学，所以“人脉”大了，于是 开始全村乱窜。当时的村子换没有现在大，也就是到现在的西大路那，对我来说。已经类似于出国了，兴奋的很，所以星期六下午基本上是和西大路的同学鬼混。我记得那时候，没有双休，只是周六休半天，周日全天休。</p>\n<p>小学三年级的时候，貌似发现乱窜也不是什么有趣的事，但是除了这，就是和小伙伴们玩之前玩的东西。我是比较懒的人，学开和明杰糊的风筝飞得很高的时候，我也不想自己糊一个。我也是比较笨的，那时候他们粘知了粘很多，我始终赶不上他们，一次一次实践证明，我玩动手的事是玩不过学开、明杰、清发他们的，这也让我对这些玩法慢慢失去了兴趣，因为太打击人，老玩不过其他他们。不过这时候 我有了另一个朋友圈，这帮小伙伴比较喜欢学习，如修虎，光田，庆磊，照真兄弟，虽然我也玩不过他们，但至少我还有点兴趣。现在想来，我的不执著的毛病是从那时养成的习惯。</p>\n<p>那时候，我最感兴趣的事情是和庆磊一块到修虎家看书。修虎有好几箱子卡通书，画册。那时候闭塞的我知道了贝塔，知道了百慕大，知道了西游记。每个周六下午，庆磊、我都会到修虎家，先把老师留的作业做完，我有时候会抄他们俩的，他们俩学习都很好，所以我的作业质量换算过得去，当然就是字写的比他们的难看很多，我记得修虎同学的字写的很漂亮。写完作业，修虎就会翻出一箱书，大家一起看。那时候竟然一看就能看一下午，这也是童年的周末啊，现在想来真不敢相信。<br>现在想来我觉我能上学能一路下来，真得感谢修虎的那几箱子书。现在大家都在奔各自生活，虽然同村，却好多年不见他们了，我想他们也会偶尔想起我，大家一起看书的星期六下午。</p>\n<p>现在想来，我们已经再也回不到那样的星期六下午了。</p>\n<p>（二）</p>\n<p>我最不情愿的事情就是放麦假，民办老师也是家里劳力，要收麦子，而我这样的小学生要帮家里看家、拾麦穗、看场、晒麦子，以上这些我倒不反感，因为这些活，都可以找点乐趣，比如在家可以看电视，看书，至少不被晒。看场，虽然热，刺挠，至少清闲。  最最不情愿的就是早上四点就被父母来起来去捆麦子，收麦子。眼睛都睁不起来，更关键是刺挠，热，晒，挥汗如雨。干一天，皮肤都脱皮了。不过晚上可以吃顿好吃的，  改善下伙食，大家围坐在堂屋西旁的梧桐树下，吃着热气腾腾的绿豆疙瘩饭，闻着成熟的麦香，听着不时隆隆作响的打麦机响，再来个凉拌黄瓜，真香！这时候，西院的二哥都会过来唠唠嗑，说说今年的收成，东边的三哥也会带着高群过来唠唠，小院子里热闹而和睦，劳累而快乐。</p>\n<p>这时候老爹现身说法，说好好上学就可以不用干这个了。然后举例说明谁家老几学习怎样，然后进城，然后怎样。然后我也对我说要争气。可是到目前为止我也没挣到这口气，估计要留给我孩子了。然后大家七嘴八舌的家长里短起来了。</p>\n<p>那时家里7口人，8亩多地，只有父母大姐二姐忙活儿，想想那时候生活太劳累了了。可是现在想来，全家人一块干活，平平安安，健健康康的，团团圆圆，真是一种天大的幸福。因为现在我也再也看不到我这个场景里的老爷，二姐，二哥了。</p>\n<p>现在想来，我已经再也吃不到吃不到那个味道的晚饭了。</p>\n<p>不上学我是农民，上了学，现在是码农，原来生产粮食，现在生产代码，现在想来我是从一个火坑跳的另一个火坑，以我目前人生经验来看，人生就是一个火坑跳到另外的火坑。人生真谛就是带着火花跳，才跳的精彩！</p>\n<p>（三）</p>\n<p>那个时候的北村小学操场换很大，西边是生产队时期的兔子场，东边是下场大雨就能冲出个骨头来的的大水沟。前面是条东西大路，路对过是一个大水汪，水很清，春夏经常有人在里面洗芹菜，洗衣服，我们也时常中午去那里用罐头瓶子捞鱼。最让我感兴趣的是大路上有两个买零食的摊，各种好吃的，各种好玩的，我时常从家里偷拿钱，消费到 这里了，为这，没少挨凑挨骂。那时候学校大概有两列四排八座房子，每座房子2口教室，最前面是牛b的5年级和办公室，依次类推，年级越低越靠后，想想那时候老师很讲究面子工程，这么排布教室，即使一二年级再乱，从学校门口看去，学校整体秩序换是很好滴。</p>\n<p>那时候我换不知道电铃这回事，学校也没有，有个大铁钟挂在办公室前面的老榆树上，老师们看着表，敲钟上下课。那时候我心目中最神圣的就是那个大钟，它庄重而权威，全校师生都要听它的，我那时候的最大梦想就是能够自己敲它一下。这个梦想有没有实现已经不存在记忆里了。不过，有一次我和照锋同学把办公室的门锁用火柴棒塞上了，导致第二天全校早上上不了课，我却记得清清楚楚。这些都已成为往事和回忆。这个校园也不复存在。现在这块地已经是宅基地了。</p>\n<p>现在想来，这个校园我们再也无法拥有，我再也回不到这个学校听漂亮的曹老师讲a,b,c,d了。</p>\n<p>（四）</p>\n<p>我的童年就是这样无聊平凡。<br>我的童真就是这样枯燥单纯。<br>我的童趣就是这样乏味单调。<br>我的童贞就是这样没有了，没有波澜，我还不知道我已经拥有，它就已经溜走了。</p>\n<p>凡此种种，以致敬那些逝去的儿童节！<br>真心祝福我和小伙伴们儿童节快乐！</p>\n<p>劉盗愚<br>2014年6月1日03:53:24</p>\n","site":{"data":{}},"excerpt":"","more":"<p>托屈原老先生的福，今年的六一竟然在假期了。</p>\n<p>内心窃想，虽然已近而立之年，但还未完婚，目前无娃，上有父母大人，应该可以过这个节。</p>\n<p>小学时有一年的期末考试临近六一，我印象深刻，因为我们是拿着小板凳在偌大的操场上，炎热的太阳底下，一两百人一同考试，那次的作文题目大概是“记你印象深刻的六一儿童节”，当时写的啥已经忘记了，我想大概应该无非是好人郝建之类的事了。</p>\n<p>我已经对我小学时的儿童节没有特别的记忆了，印象中应该是放假一天。90年代农村的孩子，特别是我这种相对贫困的农村孩子，儿童节应该是很淡的，无非是在家待一天。</p>\n<p>（一）</p>\n<p>但是儿童的快乐和记忆，我换是有的。现在想来很后悔没有认真过我的儿童节。</p>\n<p>童年的欢乐有很多：吃顿饺子，哪怕是萝卜馅的、玩一下午泥巴，哪怕只是摔一下午“哇哇响”、去东河洗澡，哪怕只是无尽的扎猛子，掀螃蟹、老哥带着我出去玩，哪怕是只是跟屁虫的角色、出门“旅游”，哪怕是到东岭的看了千百次的小洞口瞄一眼，那时我的欢乐点数很低，只要是消磨时间事情都能让我的日子充满乐趣。</p>\n<p>小学的时候我已经不怎么玩过家家了。但是和发小们换是偶尔玩，貌似那时候我已经隐约知道过家家似乎是没大志向的事情（不过现在想想过家家真是了不起的一个游戏，社会上玩数理化，玩金融法律，玩航海航空各种玩法，终归都是过家家里的一个部分）。 因为认识了很多同学，所以“人脉”大了，于是 开始全村乱窜。当时的村子换没有现在大，也就是到现在的西大路那，对我来说。已经类似于出国了，兴奋的很，所以星期六下午基本上是和西大路的同学鬼混。我记得那时候，没有双休，只是周六休半天，周日全天休。</p>\n<p>小学三年级的时候，貌似发现乱窜也不是什么有趣的事，但是除了这，就是和小伙伴们玩之前玩的东西。我是比较懒的人，学开和明杰糊的风筝飞得很高的时候，我也不想自己糊一个。我也是比较笨的，那时候他们粘知了粘很多，我始终赶不上他们，一次一次实践证明，我玩动手的事是玩不过学开、明杰、清发他们的，这也让我对这些玩法慢慢失去了兴趣，因为太打击人，老玩不过其他他们。不过这时候 我有了另一个朋友圈，这帮小伙伴比较喜欢学习，如修虎，光田，庆磊，照真兄弟，虽然我也玩不过他们，但至少我还有点兴趣。现在想来，我的不执著的毛病是从那时养成的习惯。</p>\n<p>那时候，我最感兴趣的事情是和庆磊一块到修虎家看书。修虎有好几箱子卡通书，画册。那时候闭塞的我知道了贝塔，知道了百慕大，知道了西游记。每个周六下午，庆磊、我都会到修虎家，先把老师留的作业做完，我有时候会抄他们俩的，他们俩学习都很好，所以我的作业质量换算过得去，当然就是字写的比他们的难看很多，我记得修虎同学的字写的很漂亮。写完作业，修虎就会翻出一箱书，大家一起看。那时候竟然一看就能看一下午，这也是童年的周末啊，现在想来真不敢相信。<br>现在想来我觉我能上学能一路下来，真得感谢修虎的那几箱子书。现在大家都在奔各自生活，虽然同村，却好多年不见他们了，我想他们也会偶尔想起我，大家一起看书的星期六下午。</p>\n<p>现在想来，我们已经再也回不到那样的星期六下午了。</p>\n<p>（二）</p>\n<p>我最不情愿的事情就是放麦假，民办老师也是家里劳力，要收麦子，而我这样的小学生要帮家里看家、拾麦穗、看场、晒麦子，以上这些我倒不反感，因为这些活，都可以找点乐趣，比如在家可以看电视，看书，至少不被晒。看场，虽然热，刺挠，至少清闲。  最最不情愿的就是早上四点就被父母来起来去捆麦子，收麦子。眼睛都睁不起来，更关键是刺挠，热，晒，挥汗如雨。干一天，皮肤都脱皮了。不过晚上可以吃顿好吃的，  改善下伙食，大家围坐在堂屋西旁的梧桐树下，吃着热气腾腾的绿豆疙瘩饭，闻着成熟的麦香，听着不时隆隆作响的打麦机响，再来个凉拌黄瓜，真香！这时候，西院的二哥都会过来唠唠嗑，说说今年的收成，东边的三哥也会带着高群过来唠唠，小院子里热闹而和睦，劳累而快乐。</p>\n<p>这时候老爹现身说法，说好好上学就可以不用干这个了。然后举例说明谁家老几学习怎样，然后进城，然后怎样。然后我也对我说要争气。可是到目前为止我也没挣到这口气，估计要留给我孩子了。然后大家七嘴八舌的家长里短起来了。</p>\n<p>那时家里7口人，8亩多地，只有父母大姐二姐忙活儿，想想那时候生活太劳累了了。可是现在想来，全家人一块干活，平平安安，健健康康的，团团圆圆，真是一种天大的幸福。因为现在我也再也看不到我这个场景里的老爷，二姐，二哥了。</p>\n<p>现在想来，我已经再也吃不到吃不到那个味道的晚饭了。</p>\n<p>不上学我是农民，上了学，现在是码农，原来生产粮食，现在生产代码，现在想来我是从一个火坑跳的另一个火坑，以我目前人生经验来看，人生就是一个火坑跳到另外的火坑。人生真谛就是带着火花跳，才跳的精彩！</p>\n<p>（三）</p>\n<p>那个时候的北村小学操场换很大，西边是生产队时期的兔子场，东边是下场大雨就能冲出个骨头来的的大水沟。前面是条东西大路，路对过是一个大水汪，水很清，春夏经常有人在里面洗芹菜，洗衣服，我们也时常中午去那里用罐头瓶子捞鱼。最让我感兴趣的是大路上有两个买零食的摊，各种好吃的，各种好玩的，我时常从家里偷拿钱，消费到 这里了，为这，没少挨凑挨骂。那时候学校大概有两列四排八座房子，每座房子2口教室，最前面是牛b的5年级和办公室，依次类推，年级越低越靠后，想想那时候老师很讲究面子工程，这么排布教室，即使一二年级再乱，从学校门口看去，学校整体秩序换是很好滴。</p>\n<p>那时候我换不知道电铃这回事，学校也没有，有个大铁钟挂在办公室前面的老榆树上，老师们看着表，敲钟上下课。那时候我心目中最神圣的就是那个大钟，它庄重而权威，全校师生都要听它的，我那时候的最大梦想就是能够自己敲它一下。这个梦想有没有实现已经不存在记忆里了。不过，有一次我和照锋同学把办公室的门锁用火柴棒塞上了，导致第二天全校早上上不了课，我却记得清清楚楚。这些都已成为往事和回忆。这个校园也不复存在。现在这块地已经是宅基地了。</p>\n<p>现在想来，这个校园我们再也无法拥有，我再也回不到这个学校听漂亮的曹老师讲a,b,c,d了。</p>\n<p>（四）</p>\n<p>我的童年就是这样无聊平凡。<br>我的童真就是这样枯燥单纯。<br>我的童趣就是这样乏味单调。<br>我的童贞就是这样没有了，没有波澜，我还不知道我已经拥有，它就已经溜走了。</p>\n<p>凡此种种，以致敬那些逝去的儿童节！<br>真心祝福我和小伙伴们儿童节快乐！</p>\n<p>劉盗愚<br>2014年6月1日03:53:24</p>\n"},{"title":"2022年清明组诗","abbrlink":29238,"date":"2022-04-05T13:20:13.000Z","_content":"\n# 序\n今年这波疫情严重，山东老家各市地基本全部出现了确诊病例，听父母说老家那边严阵以待，封村封路。自2021年十一国庆假期回家至今，春节，清明都没有回去看望父母，双亲都已经七十多岁了，我常年工作在外，不提跟前尽孝，即便假期现在也不能回去，实在非常不安。另外一位多年同事的外婆离世因疫情而无法床前尽孝以致遗憾，树欲动而风不止，子欲养而亲不待，适逢清明假期，有感而发。\n\n是为序。\n\n# 一\n\n**遭逢时疫乡难回** \n\n**双亲来电问否归** \n\n**千里无归经几岁** \n\n**和风难抚心中愧** \n\n\n# 二\n**春风微拂夜已深** \n\n**下班无车徒步回**\n\n**路口纸火点点亮** \n\n**又是谁家悼往岁**\n\n# 三\n**微雨细风过清明** \n\n**杨柳徘徊踏青行**\n\n**绵绵春泥护远茔** \n\n**悠悠近愁数归省**  \n\n","source":"_posts/2022清明组诗.md","raw":"---\ntitle: 2022年清明组诗\nabbrlink: 29238\ndate: 2022-04-05 21:20:13\n---\n\n# 序\n今年这波疫情严重，山东老家各市地基本全部出现了确诊病例，听父母说老家那边严阵以待，封村封路。自2021年十一国庆假期回家至今，春节，清明都没有回去看望父母，双亲都已经七十多岁了，我常年工作在外，不提跟前尽孝，即便假期现在也不能回去，实在非常不安。另外一位多年同事的外婆离世因疫情而无法床前尽孝以致遗憾，树欲动而风不止，子欲养而亲不待，适逢清明假期，有感而发。\n\n是为序。\n\n# 一\n\n**遭逢时疫乡难回** \n\n**双亲来电问否归** \n\n**千里无归经几岁** \n\n**和风难抚心中愧** \n\n\n# 二\n**春风微拂夜已深** \n\n**下班无车徒步回**\n\n**路口纸火点点亮** \n\n**又是谁家悼往岁**\n\n# 三\n**微雨细风过清明** \n\n**杨柳徘徊踏青行**\n\n**绵绵春泥护远茔** \n\n**悠悠近愁数归省**  \n\n","slug":"2022清明组诗","published":1,"updated":"2022-04-05T13:49:02.475Z","_id":"cl1m6hm6o0000rsqb0ipfh8tq","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>今年这波疫情严重，山东老家各市地基本全部出现了确诊病例，听父母说老家那边严阵以待，封村封路。自2021年十一国庆假期回家至今，春节，清明都没有回去看望父母，双亲都已经七十多岁了，我常年工作在外，不提跟前尽孝，即便假期现在也不能回去，实在非常不安。另外一位多年同事的外婆离世因疫情而无法床前尽孝以致遗憾，树欲动而风不止，子欲养而亲不待，适逢清明假期，有感而发。</p>\n<p>是为序。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p><strong>遭逢时疫乡难回</strong> </p>\n<p><strong>双亲来电问否归</strong> </p>\n<p><strong>千里无归经几岁</strong> </p>\n<p><strong>和风难抚心中愧</strong> </p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p><strong>春风微拂夜已深</strong> </p>\n<p><strong>下班无车徒步回</strong></p>\n<p><strong>路口纸火点点亮</strong> </p>\n<p><strong>又是谁家悼往岁</strong></p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p><strong>微雨细风过清明</strong> </p>\n<p><strong>杨柳徘徊踏青行</strong></p>\n<p><strong>绵绵春泥护远茔</strong> </p>\n<p><strong>悠悠近愁数归省</strong>  </p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序\"><a href=\"#序\" class=\"headerlink\" title=\"序\"></a>序</h1><p>今年这波疫情严重，山东老家各市地基本全部出现了确诊病例，听父母说老家那边严阵以待，封村封路。自2021年十一国庆假期回家至今，春节，清明都没有回去看望父母，双亲都已经七十多岁了，我常年工作在外，不提跟前尽孝，即便假期现在也不能回去，实在非常不安。另外一位多年同事的外婆离世因疫情而无法床前尽孝以致遗憾，树欲动而风不止，子欲养而亲不待，适逢清明假期，有感而发。</p>\n<p>是为序。</p>\n<h1 id=\"一\"><a href=\"#一\" class=\"headerlink\" title=\"一\"></a>一</h1><p><strong>遭逢时疫乡难回</strong> </p>\n<p><strong>双亲来电问否归</strong> </p>\n<p><strong>千里无归经几岁</strong> </p>\n<p><strong>和风难抚心中愧</strong> </p>\n<h1 id=\"二\"><a href=\"#二\" class=\"headerlink\" title=\"二\"></a>二</h1><p><strong>春风微拂夜已深</strong> </p>\n<p><strong>下班无车徒步回</strong></p>\n<p><strong>路口纸火点点亮</strong> </p>\n<p><strong>又是谁家悼往岁</strong></p>\n<h1 id=\"三\"><a href=\"#三\" class=\"headerlink\" title=\"三\"></a>三</h1><p><strong>微雨细风过清明</strong> </p>\n<p><strong>杨柳徘徊踏青行</strong></p>\n<p><strong>绵绵春泥护远茔</strong> </p>\n<p><strong>悠悠近愁数归省</strong>  </p>\n"},{"title":"厚读《赢在中国》","abbrlink":23004,"date":"2022-10-01T16:00:00.000Z","_content":"\n利用假期好好学习一下《赢在中国》里面的很多观点和思考。摘录了马云的一些点评和观点，有些可以理解，有些还需要继续琢磨。使用“把书读厚”的方式来读。\n\n```\n少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。\n\n主题20问：\n1，商业的基本规律是什么？包括哪些内容？\n2，怎么理解“少做就是多做”？\n3，少做为什么就是多做？\n4，在一个范围和程度内，如何评估是多做了还是少做了？\n5，“少做”的付出是什么？结果是什么？副产品是什么？\n6，“多做”的付出是什么？结果是什么？有何不好的影响，有何好的影响？\n7，如何统筹理解“少做”和“多做”的现实关系和取舍，\n8，从发展的角度，如何动态的调整“少做”和“多做”\n9，少做和多做的关系，背后的根本原因是什么\n10，举一个例子说明，少做 比 多做 更好或者更坏？\n11，举一个例子说明，多做 比 少做更好 或者更坏？？\n12，做精做透的内涵是指啥？\n13，如何找到强大对手没有做好的的地方？\n14，如何界定“挑战”和“补充”？\n15，如何低调的发展，不让对手所有防范？\n16，生存和战略是企业中始终要思考的问题\n17，商业的本质是什么？\n18，如何看待和竞争对手的关系？\n19，从18的思考开始，这一点往深里思考，涉及到了一个人的商业价值观？本质上我们如何做生意？做生意为了什么？\n20，“少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。”这就话到底该如何理解？\n```\n\n```\n这世界上没有优秀的理念，只有脚踏实地的结果。\n主题20问：\n1，‘理念’到底是一种什么东西？\n2，‘理念’是如何形成的？\n3，‘理念’是如何影响我们的思考和行为的？\n4，如何定义的结果？\n5，要用哪些维度来定义结果？比如 时间、金钱，情感，情绪，认同，心理，享受，体验等等\n6，你能举例说明，影响你自己的理念有哪些？\n7，如何定义“优秀”？\n8，如何定义“优秀的理念”？\n9，尽可能多的举例你所知道的“理念”？\n10，从上面列举的“理念”中，你认为“优秀的理念”有哪些，说明你的理由？\n11，“脚踏实地”用来形容怎样的一种行动？\n12，“脚踏实地的结果” 和 不“脚踏实地的结果”有何区别？\n13，如何理解 “没有...., 只有...” 这种句式？\n14，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的积极意义？\n15，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的消极意义？\n16，如何创造/发明一个‘理念’？\n17，从“理念”到“结果”，中间到底要经历什么？\n18，”结果“如何达成？\n19，说说你的“理念”和“结果”的辩证关系？\n20，从因果论的角度，简述【9】中的一个理念，在你的工作生活中形成了怎样的结果？\n```\n\n```\n永远不要让资本说话，要让资本赚钱。\n主题20问：\n1，资本永远是贪婪的\n2，资本不是万能的，他可能不会说话，很可能说的不对\n3，资本的目的是赚钱，让他说话，他也会嫌累，不在其位不谋其政\n4，契约很重要，明确企业的目标和责任义务，约束资本的目标和责任义务\n5，坚定自己的立场，明确自己的存在的价值，资本要是说话了，就没你啥事了\n6，资本也是脆弱和敏感的，资本其实非常脆弱，抗压力是最弱的，最值得保护的\n7，说的好听点的，资本想是企业的爹娘，能给你企业温暖和基础的生命力，但是企业不能遇到啥事都找爹娘，但是爹娘对企业的啥事有都爱操心\n8，说的不好听的，资本是苍蝇，不管是臭味的蛋，还是香味的蛋，只要让它看见缝，它都想盯一下\n9，\n10，\n11，\n12，\n13，\n14，\n15，\n16，\n17，\n18，\n19，\n20，\n```\n\n```\n我觉得一个好东西往往是说不清楚的，说的清楚的往往不是好东西。\n主题20问：\n1，哲学思辨色彩浓厚，背后是丰厚的经验和敏锐的洞察，这种能力很难轻易获得\n2，这个论断的一个背景思考是，分类思维。“东西”很多种类，这里的“东西”应该是“创意”，“观点”，“方案”，“战略方向”，“思路”，“思想”等\n3，我想起了一句老话，只可意会不可言传。\n4，当然很多“好东西”是说的清楚的，说不清楚不是好事\n5，这里的说不清楚的意思应该是指，没有更多的基于事实的数据，现象或者现有的理论让别人相信或者理解你所说的内容（如2所列举的那些），经过若干时间后，这些内容直接或间接造成的后果被证实是符合预想的\n6，说的清楚的往往不是好东西，这句话其实很有深意。试想我们身边什么东西是你说不清楚的呢？或者说的清楚呢？每个人很难对身边的所有的现象能用现存知识说清楚，即便是再博学的人\n7，说不清楚 意味着可能2个事，1是你的本身的知识太少，不足以说清楚，2是内容本身足够复杂，你说不清楚\n8，作为工程师，不管是好东西还是坏东西，都要有说清楚的能力，这是非常基础和重要的能力，说清楚的东西才能成为一种现实，才能作为技术决策的因素\n9，\n10，\n11，\n12，\n13，\n14，\n15，\n16，\n17，\n18，\n19，\n20，\n```\n \n```\n    我没有关系，也没有钱，我是一点点起来， 我相信关系非凡不可靠，做生意不能凭关系，做生 意不能凭小聪明，做生意最重要的是你明白客户需 要什么，实实在在创造价值，坚持下去。这世界最 不可靠的东西就是关系。\n\n    关于【关系】20问：\n        1，为什么说关系不可靠？\n        2，这个“关系”本质上什么呢？\n        3，关系有哪些分类？ \n        4，何时需要关系？\n        5，何时需要主动的稳定关系？\n        6，何时需要增强关系？\n        7，何时需要减弱关系？\n        8，何时需要主动断绝关系？\n        9，我们需要什么什么样的关系？\n        10，形成关系的因素是\n        11，可靠的关系是什么样子的？\n        12，做生意为什么要凭关系?\n        13，关系对于生意人意味什么？\n        14，关系的生命周期是怎样？\n        15，如何从无到有的创建一个关系？\n        16，如何处理多个关系之间的关系？\n        17，关系怎么产生利益？\n        18，关系会对目标达成产生什么样的影响？\n        19，关系的的负反馈是什么？\n        20，关系管理的原则是什么？\n```","source":"_posts/重读《赢在中国》.md","raw":"---\ntitle: 厚读《赢在中国》\ntags: 学习笔记 思考总结\nabbrlink: 23004\ndate: 2022-10-02 00:00:00\n---\n\n利用假期好好学习一下《赢在中国》里面的很多观点和思考。摘录了马云的一些点评和观点，有些可以理解，有些还需要继续琢磨。使用“把书读厚”的方式来读。\n\n```\n少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。\n\n主题20问：\n1，商业的基本规律是什么？包括哪些内容？\n2，怎么理解“少做就是多做”？\n3，少做为什么就是多做？\n4，在一个范围和程度内，如何评估是多做了还是少做了？\n5，“少做”的付出是什么？结果是什么？副产品是什么？\n6，“多做”的付出是什么？结果是什么？有何不好的影响，有何好的影响？\n7，如何统筹理解“少做”和“多做”的现实关系和取舍，\n8，从发展的角度，如何动态的调整“少做”和“多做”\n9，少做和多做的关系，背后的根本原因是什么\n10，举一个例子说明，少做 比 多做 更好或者更坏？\n11，举一个例子说明，多做 比 少做更好 或者更坏？？\n12，做精做透的内涵是指啥？\n13，如何找到强大对手没有做好的的地方？\n14，如何界定“挑战”和“补充”？\n15，如何低调的发展，不让对手所有防范？\n16，生存和战略是企业中始终要思考的问题\n17，商业的本质是什么？\n18，如何看待和竞争对手的关系？\n19，从18的思考开始，这一点往深里思考，涉及到了一个人的商业价值观？本质上我们如何做生意？做生意为了什么？\n20，“少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。”这就话到底该如何理解？\n```\n\n```\n这世界上没有优秀的理念，只有脚踏实地的结果。\n主题20问：\n1，‘理念’到底是一种什么东西？\n2，‘理念’是如何形成的？\n3，‘理念’是如何影响我们的思考和行为的？\n4，如何定义的结果？\n5，要用哪些维度来定义结果？比如 时间、金钱，情感，情绪，认同，心理，享受，体验等等\n6，你能举例说明，影响你自己的理念有哪些？\n7，如何定义“优秀”？\n8，如何定义“优秀的理念”？\n9，尽可能多的举例你所知道的“理念”？\n10，从上面列举的“理念”中，你认为“优秀的理念”有哪些，说明你的理由？\n11，“脚踏实地”用来形容怎样的一种行动？\n12，“脚踏实地的结果” 和 不“脚踏实地的结果”有何区别？\n13，如何理解 “没有...., 只有...” 这种句式？\n14，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的积极意义？\n15，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的消极意义？\n16，如何创造/发明一个‘理念’？\n17，从“理念”到“结果”，中间到底要经历什么？\n18，”结果“如何达成？\n19，说说你的“理念”和“结果”的辩证关系？\n20，从因果论的角度，简述【9】中的一个理念，在你的工作生活中形成了怎样的结果？\n```\n\n```\n永远不要让资本说话，要让资本赚钱。\n主题20问：\n1，资本永远是贪婪的\n2，资本不是万能的，他可能不会说话，很可能说的不对\n3，资本的目的是赚钱，让他说话，他也会嫌累，不在其位不谋其政\n4，契约很重要，明确企业的目标和责任义务，约束资本的目标和责任义务\n5，坚定自己的立场，明确自己的存在的价值，资本要是说话了，就没你啥事了\n6，资本也是脆弱和敏感的，资本其实非常脆弱，抗压力是最弱的，最值得保护的\n7，说的好听点的，资本想是企业的爹娘，能给你企业温暖和基础的生命力，但是企业不能遇到啥事都找爹娘，但是爹娘对企业的啥事有都爱操心\n8，说的不好听的，资本是苍蝇，不管是臭味的蛋，还是香味的蛋，只要让它看见缝，它都想盯一下\n9，\n10，\n11，\n12，\n13，\n14，\n15，\n16，\n17，\n18，\n19，\n20，\n```\n\n```\n我觉得一个好东西往往是说不清楚的，说的清楚的往往不是好东西。\n主题20问：\n1，哲学思辨色彩浓厚，背后是丰厚的经验和敏锐的洞察，这种能力很难轻易获得\n2，这个论断的一个背景思考是，分类思维。“东西”很多种类，这里的“东西”应该是“创意”，“观点”，“方案”，“战略方向”，“思路”，“思想”等\n3，我想起了一句老话，只可意会不可言传。\n4，当然很多“好东西”是说的清楚的，说不清楚不是好事\n5，这里的说不清楚的意思应该是指，没有更多的基于事实的数据，现象或者现有的理论让别人相信或者理解你所说的内容（如2所列举的那些），经过若干时间后，这些内容直接或间接造成的后果被证实是符合预想的\n6，说的清楚的往往不是好东西，这句话其实很有深意。试想我们身边什么东西是你说不清楚的呢？或者说的清楚呢？每个人很难对身边的所有的现象能用现存知识说清楚，即便是再博学的人\n7，说不清楚 意味着可能2个事，1是你的本身的知识太少，不足以说清楚，2是内容本身足够复杂，你说不清楚\n8，作为工程师，不管是好东西还是坏东西，都要有说清楚的能力，这是非常基础和重要的能力，说清楚的东西才能成为一种现实，才能作为技术决策的因素\n9，\n10，\n11，\n12，\n13，\n14，\n15，\n16，\n17，\n18，\n19，\n20，\n```\n \n```\n    我没有关系，也没有钱，我是一点点起来， 我相信关系非凡不可靠，做生意不能凭关系，做生 意不能凭小聪明，做生意最重要的是你明白客户需 要什么，实实在在创造价值，坚持下去。这世界最 不可靠的东西就是关系。\n\n    关于【关系】20问：\n        1，为什么说关系不可靠？\n        2，这个“关系”本质上什么呢？\n        3，关系有哪些分类？ \n        4，何时需要关系？\n        5，何时需要主动的稳定关系？\n        6，何时需要增强关系？\n        7，何时需要减弱关系？\n        8，何时需要主动断绝关系？\n        9，我们需要什么什么样的关系？\n        10，形成关系的因素是\n        11，可靠的关系是什么样子的？\n        12，做生意为什么要凭关系?\n        13，关系对于生意人意味什么？\n        14，关系的生命周期是怎样？\n        15，如何从无到有的创建一个关系？\n        16，如何处理多个关系之间的关系？\n        17，关系怎么产生利益？\n        18，关系会对目标达成产生什么样的影响？\n        19，关系的的负反馈是什么？\n        20，关系管理的原则是什么？\n```","slug":"重读《赢在中国》","published":1,"updated":"2022-10-16T04:15:07.628Z","_id":"cl8rd3qu70000v6qb4ff04jdc","comments":1,"layout":"post","photos":[],"link":"","content":"<p>利用假期好好学习一下《赢在中国》里面的很多观点和思考。摘录了马云的一些点评和观点，有些可以理解，有些还需要继续琢磨。使用“把书读厚”的方式来读。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。</span><br><span class=\"line\"></span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，商业的基本规律是什么？包括哪些内容？</span><br><span class=\"line\">2，怎么理解“少做就是多做”？</span><br><span class=\"line\">3，少做为什么就是多做？</span><br><span class=\"line\">4，在一个范围和程度内，如何评估是多做了还是少做了？</span><br><span class=\"line\">5，“少做”的付出是什么？结果是什么？副产品是什么？</span><br><span class=\"line\">6，“多做”的付出是什么？结果是什么？有何不好的影响，有何好的影响？</span><br><span class=\"line\">7，如何统筹理解“少做”和“多做”的现实关系和取舍，</span><br><span class=\"line\">8，从发展的角度，如何动态的调整“少做”和“多做”</span><br><span class=\"line\">9，少做和多做的关系，背后的根本原因是什么</span><br><span class=\"line\">10，举一个例子说明，少做 比 多做 更好或者更坏？</span><br><span class=\"line\">11，举一个例子说明，多做 比 少做更好 或者更坏？？</span><br><span class=\"line\">12，做精做透的内涵是指啥？</span><br><span class=\"line\">13，如何找到强大对手没有做好的的地方？</span><br><span class=\"line\">14，如何界定“挑战”和“补充”？</span><br><span class=\"line\">15，如何低调的发展，不让对手所有防范？</span><br><span class=\"line\">16，生存和战略是企业中始终要思考的问题</span><br><span class=\"line\">17，商业的本质是什么？</span><br><span class=\"line\">18，如何看待和竞争对手的关系？</span><br><span class=\"line\">19，从18的思考开始，这一点往深里思考，涉及到了一个人的商业价值观？本质上我们如何做生意？做生意为了什么？</span><br><span class=\"line\">20，“少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。”这就话到底该如何理解？</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这世界上没有优秀的理念，只有脚踏实地的结果。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，‘理念’到底是一种什么东西？</span><br><span class=\"line\">2，‘理念’是如何形成的？</span><br><span class=\"line\">3，‘理念’是如何影响我们的思考和行为的？</span><br><span class=\"line\">4，如何定义的结果？</span><br><span class=\"line\">5，要用哪些维度来定义结果？比如 时间、金钱，情感，情绪，认同，心理，享受，体验等等</span><br><span class=\"line\">6，你能举例说明，影响你自己的理念有哪些？</span><br><span class=\"line\">7，如何定义“优秀”？</span><br><span class=\"line\">8，如何定义“优秀的理念”？</span><br><span class=\"line\">9，尽可能多的举例你所知道的“理念”？</span><br><span class=\"line\">10，从上面列举的“理念”中，你认为“优秀的理念”有哪些，说明你的理由？</span><br><span class=\"line\">11，“脚踏实地”用来形容怎样的一种行动？</span><br><span class=\"line\">12，“脚踏实地的结果” 和 不“脚踏实地的结果”有何区别？</span><br><span class=\"line\">13，如何理解 “没有...., 只有...” 这种句式？</span><br><span class=\"line\">14，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的积极意义？</span><br><span class=\"line\">15，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的消极意义？</span><br><span class=\"line\">16，如何创造&#x2F;发明一个‘理念’？</span><br><span class=\"line\">17，从“理念”到“结果”，中间到底要经历什么？</span><br><span class=\"line\">18，”结果“如何达成？</span><br><span class=\"line\">19，说说你的“理念”和“结果”的辩证关系？</span><br><span class=\"line\">20，从因果论的角度，简述【9】中的一个理念，在你的工作生活中形成了怎样的结果？</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">永远不要让资本说话，要让资本赚钱。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，资本永远是贪婪的</span><br><span class=\"line\">2，资本不是万能的，他可能不会说话，很可能说的不对</span><br><span class=\"line\">3，资本的目的是赚钱，让他说话，他也会嫌累，不在其位不谋其政</span><br><span class=\"line\">4，契约很重要，明确企业的目标和责任义务，约束资本的目标和责任义务</span><br><span class=\"line\">5，坚定自己的立场，明确自己的存在的价值，资本要是说话了，就没你啥事了</span><br><span class=\"line\">6，资本也是脆弱和敏感的，资本其实非常脆弱，抗压力是最弱的，最值得保护的</span><br><span class=\"line\">7，说的好听点的，资本想是企业的爹娘，能给你企业温暖和基础的生命力，但是企业不能遇到啥事都找爹娘，但是爹娘对企业的啥事有都爱操心</span><br><span class=\"line\">8，说的不好听的，资本是苍蝇，不管是臭味的蛋，还是香味的蛋，只要让它看见缝，它都想盯一下</span><br><span class=\"line\">9，</span><br><span class=\"line\">10，</span><br><span class=\"line\">11，</span><br><span class=\"line\">12，</span><br><span class=\"line\">13，</span><br><span class=\"line\">14，</span><br><span class=\"line\">15，</span><br><span class=\"line\">16，</span><br><span class=\"line\">17，</span><br><span class=\"line\">18，</span><br><span class=\"line\">19，</span><br><span class=\"line\">20，</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我觉得一个好东西往往是说不清楚的，说的清楚的往往不是好东西。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，哲学思辨色彩浓厚，背后是丰厚的经验和敏锐的洞察，这种能力很难轻易获得</span><br><span class=\"line\">2，这个论断的一个背景思考是，分类思维。“东西”很多种类，这里的“东西”应该是“创意”，“观点”，“方案”，“战略方向”，“思路”，“思想”等</span><br><span class=\"line\">3，我想起了一句老话，只可意会不可言传。</span><br><span class=\"line\">4，当然很多“好东西”是说的清楚的，说不清楚不是好事</span><br><span class=\"line\">5，这里的说不清楚的意思应该是指，没有更多的基于事实的数据，现象或者现有的理论让别人相信或者理解你所说的内容（如2所列举的那些），经过若干时间后，这些内容直接或间接造成的后果被证实是符合预想的</span><br><span class=\"line\">6，说的清楚的往往不是好东西，这句话其实很有深意。试想我们身边什么东西是你说不清楚的呢？或者说的清楚呢？每个人很难对身边的所有的现象能用现存知识说清楚，即便是再博学的人</span><br><span class=\"line\">7，说不清楚 意味着可能2个事，1是你的本身的知识太少，不足以说清楚，2是内容本身足够复杂，你说不清楚</span><br><span class=\"line\">8，作为工程师，不管是好东西还是坏东西，都要有说清楚的能力，这是非常基础和重要的能力，说清楚的东西才能成为一种现实，才能作为技术决策的因素</span><br><span class=\"line\">9，</span><br><span class=\"line\">10，</span><br><span class=\"line\">11，</span><br><span class=\"line\">12，</span><br><span class=\"line\">13，</span><br><span class=\"line\">14，</span><br><span class=\"line\">15，</span><br><span class=\"line\">16，</span><br><span class=\"line\">17，</span><br><span class=\"line\">18，</span><br><span class=\"line\">19，</span><br><span class=\"line\">20，</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我没有关系，也没有钱，我是一点点起来， 我相信关系非凡不可靠，做生意不能凭关系，做生 意不能凭小聪明，做生意最重要的是你明白客户需 要什么，实实在在创造价值，坚持下去。这世界最 不可靠的东西就是关系。</span><br><span class=\"line\"></span><br><span class=\"line\">关于【关系】20问：</span><br><span class=\"line\">    1，为什么说关系不可靠？</span><br><span class=\"line\">    2，这个“关系”本质上什么呢？</span><br><span class=\"line\">    3，关系有哪些分类？ </span><br><span class=\"line\">    4，何时需要关系？</span><br><span class=\"line\">    5，何时需要主动的稳定关系？</span><br><span class=\"line\">    6，何时需要增强关系？</span><br><span class=\"line\">    7，何时需要减弱关系？</span><br><span class=\"line\">    8，何时需要主动断绝关系？</span><br><span class=\"line\">    9，我们需要什么什么样的关系？</span><br><span class=\"line\">    10，形成关系的因素是</span><br><span class=\"line\">    11，可靠的关系是什么样子的？</span><br><span class=\"line\">    12，做生意为什么要凭关系?</span><br><span class=\"line\">    13，关系对于生意人意味什么？</span><br><span class=\"line\">    14，关系的生命周期是怎样？</span><br><span class=\"line\">    15，如何从无到有的创建一个关系？</span><br><span class=\"line\">    16，如何处理多个关系之间的关系？</span><br><span class=\"line\">    17，关系怎么产生利益？</span><br><span class=\"line\">    18，关系会对目标达成产生什么样的影响？</span><br><span class=\"line\">    19，关系的的负反馈是什么？</span><br><span class=\"line\">    20，关系管理的原则是什么？</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<p>利用假期好好学习一下《赢在中国》里面的很多观点和思考。摘录了马云的一些点评和观点，有些可以理解，有些还需要继续琢磨。使用“把书读厚”的方式来读。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。</span><br><span class=\"line\"></span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，商业的基本规律是什么？包括哪些内容？</span><br><span class=\"line\">2，怎么理解“少做就是多做”？</span><br><span class=\"line\">3，少做为什么就是多做？</span><br><span class=\"line\">4，在一个范围和程度内，如何评估是多做了还是少做了？</span><br><span class=\"line\">5，“少做”的付出是什么？结果是什么？副产品是什么？</span><br><span class=\"line\">6，“多做”的付出是什么？结果是什么？有何不好的影响，有何好的影响？</span><br><span class=\"line\">7，如何统筹理解“少做”和“多做”的现实关系和取舍，</span><br><span class=\"line\">8，从发展的角度，如何动态的调整“少做”和“多做”</span><br><span class=\"line\">9，少做和多做的关系，背后的根本原因是什么</span><br><span class=\"line\">10，举一个例子说明，少做 比 多做 更好或者更坏？</span><br><span class=\"line\">11，举一个例子说明，多做 比 少做更好 或者更坏？？</span><br><span class=\"line\">12，做精做透的内涵是指啥？</span><br><span class=\"line\">13，如何找到强大对手没有做好的的地方？</span><br><span class=\"line\">14，如何界定“挑战”和“补充”？</span><br><span class=\"line\">15，如何低调的发展，不让对手所有防范？</span><br><span class=\"line\">16，生存和战略是企业中始终要思考的问题</span><br><span class=\"line\">17，商业的本质是什么？</span><br><span class=\"line\">18，如何看待和竞争对手的关系？</span><br><span class=\"line\">19，从18的思考开始，这一点往深里思考，涉及到了一个人的商业价值观？本质上我们如何做生意？做生意为了什么？</span><br><span class=\"line\">20，“少做就是多做，不要贪多，做精做透很重要，碰到一个强大的对手事，不要去挑战它，而应该去补充它，做它做不到的，服务好它，先求生存，再求战略，这是所有商家的基本规律。”这就话到底该如何理解？</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">这世界上没有优秀的理念，只有脚踏实地的结果。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，‘理念’到底是一种什么东西？</span><br><span class=\"line\">2，‘理念’是如何形成的？</span><br><span class=\"line\">3，‘理念’是如何影响我们的思考和行为的？</span><br><span class=\"line\">4，如何定义的结果？</span><br><span class=\"line\">5，要用哪些维度来定义结果？比如 时间、金钱，情感，情绪，认同，心理，享受，体验等等</span><br><span class=\"line\">6，你能举例说明，影响你自己的理念有哪些？</span><br><span class=\"line\">7，如何定义“优秀”？</span><br><span class=\"line\">8，如何定义“优秀的理念”？</span><br><span class=\"line\">9，尽可能多的举例你所知道的“理念”？</span><br><span class=\"line\">10，从上面列举的“理念”中，你认为“优秀的理念”有哪些，说明你的理由？</span><br><span class=\"line\">11，“脚踏实地”用来形容怎样的一种行动？</span><br><span class=\"line\">12，“脚踏实地的结果” 和 不“脚踏实地的结果”有何区别？</span><br><span class=\"line\">13，如何理解 “没有...., 只有...” 这种句式？</span><br><span class=\"line\">14，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的积极意义？</span><br><span class=\"line\">15，如何理解“这世界上没有优秀的理念，只有脚踏实地的结果。”的消极意义？</span><br><span class=\"line\">16，如何创造&#x2F;发明一个‘理念’？</span><br><span class=\"line\">17，从“理念”到“结果”，中间到底要经历什么？</span><br><span class=\"line\">18，”结果“如何达成？</span><br><span class=\"line\">19，说说你的“理念”和“结果”的辩证关系？</span><br><span class=\"line\">20，从因果论的角度，简述【9】中的一个理念，在你的工作生活中形成了怎样的结果？</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">永远不要让资本说话，要让资本赚钱。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，资本永远是贪婪的</span><br><span class=\"line\">2，资本不是万能的，他可能不会说话，很可能说的不对</span><br><span class=\"line\">3，资本的目的是赚钱，让他说话，他也会嫌累，不在其位不谋其政</span><br><span class=\"line\">4，契约很重要，明确企业的目标和责任义务，约束资本的目标和责任义务</span><br><span class=\"line\">5，坚定自己的立场，明确自己的存在的价值，资本要是说话了，就没你啥事了</span><br><span class=\"line\">6，资本也是脆弱和敏感的，资本其实非常脆弱，抗压力是最弱的，最值得保护的</span><br><span class=\"line\">7，说的好听点的，资本想是企业的爹娘，能给你企业温暖和基础的生命力，但是企业不能遇到啥事都找爹娘，但是爹娘对企业的啥事有都爱操心</span><br><span class=\"line\">8，说的不好听的，资本是苍蝇，不管是臭味的蛋，还是香味的蛋，只要让它看见缝，它都想盯一下</span><br><span class=\"line\">9，</span><br><span class=\"line\">10，</span><br><span class=\"line\">11，</span><br><span class=\"line\">12，</span><br><span class=\"line\">13，</span><br><span class=\"line\">14，</span><br><span class=\"line\">15，</span><br><span class=\"line\">16，</span><br><span class=\"line\">17，</span><br><span class=\"line\">18，</span><br><span class=\"line\">19，</span><br><span class=\"line\">20，</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我觉得一个好东西往往是说不清楚的，说的清楚的往往不是好东西。</span><br><span class=\"line\">主题20问：</span><br><span class=\"line\">1，哲学思辨色彩浓厚，背后是丰厚的经验和敏锐的洞察，这种能力很难轻易获得</span><br><span class=\"line\">2，这个论断的一个背景思考是，分类思维。“东西”很多种类，这里的“东西”应该是“创意”，“观点”，“方案”，“战略方向”，“思路”，“思想”等</span><br><span class=\"line\">3，我想起了一句老话，只可意会不可言传。</span><br><span class=\"line\">4，当然很多“好东西”是说的清楚的，说不清楚不是好事</span><br><span class=\"line\">5，这里的说不清楚的意思应该是指，没有更多的基于事实的数据，现象或者现有的理论让别人相信或者理解你所说的内容（如2所列举的那些），经过若干时间后，这些内容直接或间接造成的后果被证实是符合预想的</span><br><span class=\"line\">6，说的清楚的往往不是好东西，这句话其实很有深意。试想我们身边什么东西是你说不清楚的呢？或者说的清楚呢？每个人很难对身边的所有的现象能用现存知识说清楚，即便是再博学的人</span><br><span class=\"line\">7，说不清楚 意味着可能2个事，1是你的本身的知识太少，不足以说清楚，2是内容本身足够复杂，你说不清楚</span><br><span class=\"line\">8，作为工程师，不管是好东西还是坏东西，都要有说清楚的能力，这是非常基础和重要的能力，说清楚的东西才能成为一种现实，才能作为技术决策的因素</span><br><span class=\"line\">9，</span><br><span class=\"line\">10，</span><br><span class=\"line\">11，</span><br><span class=\"line\">12，</span><br><span class=\"line\">13，</span><br><span class=\"line\">14，</span><br><span class=\"line\">15，</span><br><span class=\"line\">16，</span><br><span class=\"line\">17，</span><br><span class=\"line\">18，</span><br><span class=\"line\">19，</span><br><span class=\"line\">20，</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">我没有关系，也没有钱，我是一点点起来， 我相信关系非凡不可靠，做生意不能凭关系，做生 意不能凭小聪明，做生意最重要的是你明白客户需 要什么，实实在在创造价值，坚持下去。这世界最 不可靠的东西就是关系。</span><br><span class=\"line\"></span><br><span class=\"line\">关于【关系】20问：</span><br><span class=\"line\">    1，为什么说关系不可靠？</span><br><span class=\"line\">    2，这个“关系”本质上什么呢？</span><br><span class=\"line\">    3，关系有哪些分类？ </span><br><span class=\"line\">    4，何时需要关系？</span><br><span class=\"line\">    5，何时需要主动的稳定关系？</span><br><span class=\"line\">    6，何时需要增强关系？</span><br><span class=\"line\">    7，何时需要减弱关系？</span><br><span class=\"line\">    8，何时需要主动断绝关系？</span><br><span class=\"line\">    9，我们需要什么什么样的关系？</span><br><span class=\"line\">    10，形成关系的因素是</span><br><span class=\"line\">    11，可靠的关系是什么样子的？</span><br><span class=\"line\">    12，做生意为什么要凭关系?</span><br><span class=\"line\">    13，关系对于生意人意味什么？</span><br><span class=\"line\">    14，关系的生命周期是怎样？</span><br><span class=\"line\">    15，如何从无到有的创建一个关系？</span><br><span class=\"line\">    16，如何处理多个关系之间的关系？</span><br><span class=\"line\">    17，关系怎么产生利益？</span><br><span class=\"line\">    18，关系会对目标达成产生什么样的影响？</span><br><span class=\"line\">    19，关系的的负反馈是什么？</span><br><span class=\"line\">    20，关系管理的原则是什么？</span><br></pre></td></tr></table></figure>"},{"title":"立场","abbrlink":45024,"date":"2022-10-16T04:16:17.000Z","_content":"\n很多人在思考问题时，有一个根本问题没有搞清楚，那就是自己的立场。如果一个人的思考范围是一个圆，立场就是这个圆的圆心，思考工具、思考材料、思考方法、个人经验都是圆心之外的辅助。\n\n立场是一定存在的。在生活工作中，你做的任何事情的背后都有立场的存在，有些立场藏得很深，七转八绕才能看见真正的立场，有的立场很明确，一眼就能被看透。当我们在争论一个技术方案，讨论一个社会问题时，所有论点的背后那个不动的东西就是立场。比如现在俄乌战争，很多人的言论是支持或者同情俄罗斯，很多人是支持或者同情乌克兰，也有很多人的是中国如何在这场冲突中的选择，各种观点都有，但是所有这些言论的立场基本上都是这场战争对我们个人意味着什么，趋利避害是在关于战争话题讨论中最根本的立场。立场丰富多样，其实是有限的，可以被识别的。这个世界复杂多变，很难理解。确立正确的立场才能更好的生存。没有立场的灵魂是苍白的。\n\n","source":"_posts/立场.md","raw":"---\ntitle: 立场\ntags: 思考 感悟\nabbrlink: 45024\ndate: 2022-10-16 12:16:17\n---\n\n很多人在思考问题时，有一个根本问题没有搞清楚，那就是自己的立场。如果一个人的思考范围是一个圆，立场就是这个圆的圆心，思考工具、思考材料、思考方法、个人经验都是圆心之外的辅助。\n\n立场是一定存在的。在生活工作中，你做的任何事情的背后都有立场的存在，有些立场藏得很深，七转八绕才能看见真正的立场，有的立场很明确，一眼就能被看透。当我们在争论一个技术方案，讨论一个社会问题时，所有论点的背后那个不动的东西就是立场。比如现在俄乌战争，很多人的言论是支持或者同情俄罗斯，很多人是支持或者同情乌克兰，也有很多人的是中国如何在这场冲突中的选择，各种观点都有，但是所有这些言论的立场基本上都是这场战争对我们个人意味着什么，趋利避害是在关于战争话题讨论中最根本的立场。立场丰富多样，其实是有限的，可以被识别的。这个世界复杂多变，很难理解。确立正确的立场才能更好的生存。没有立场的灵魂是苍白的。\n\n","slug":"立场","published":1,"updated":"2022-10-16T15:48:00.411Z","_id":"cl9biup670000grzo16sr5i2a","comments":1,"layout":"post","photos":[],"link":"","content":"<p>很多人在思考问题时，有一个根本问题没有搞清楚，那就是自己的立场。如果一个人的思考范围是一个圆，立场就是这个圆的圆心，思考工具、思考材料、思考方法、个人经验都是圆心之外的辅助。</p>\n<p>立场是一定存在的。在生活工作中，你做的任何事情的背后都有立场的存在，有些立场藏得很深，七转八绕才能看见真正的立场，有的立场很明确，一眼就能被看透。当我们在争论一个技术方案，讨论一个社会问题时，所有论点的背后那个不动的东西就是立场。比如现在俄乌战争，很多人的言论是支持或者同情俄罗斯，很多人是支持或者同情乌克兰，也有很多人的是中国如何在这场冲突中的选择，各种观点都有，但是所有这些言论的立场基本上都是这场战争对我们个人意味着什么，趋利避害是在关于战争话题讨论中最根本的立场。立场丰富多样，其实是有限的，可以被识别的。这个世界复杂多变，很难理解。确立正确的立场才能更好的生存。没有立场的灵魂是苍白的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>很多人在思考问题时，有一个根本问题没有搞清楚，那就是自己的立场。如果一个人的思考范围是一个圆，立场就是这个圆的圆心，思考工具、思考材料、思考方法、个人经验都是圆心之外的辅助。</p>\n<p>立场是一定存在的。在生活工作中，你做的任何事情的背后都有立场的存在，有些立场藏得很深，七转八绕才能看见真正的立场，有的立场很明确，一眼就能被看透。当我们在争论一个技术方案，讨论一个社会问题时，所有论点的背后那个不动的东西就是立场。比如现在俄乌战争，很多人的言论是支持或者同情俄罗斯，很多人是支持或者同情乌克兰，也有很多人的是中国如何在这场冲突中的选择，各种观点都有，但是所有这些言论的立场基本上都是这场战争对我们个人意味着什么，趋利避害是在关于战争话题讨论中最根本的立场。立场丰富多样，其实是有限的，可以被识别的。这个世界复杂多变，很难理解。确立正确的立场才能更好的生存。没有立场的灵魂是苍白的。</p>\n"},{"title":"常见javascript解析器","abbrlink":24882,"date":"2022-10-22T11:22:17.000Z","_content":"\n如果对编译器或者语言编译技术感兴趣，可以研究一些JavaScript解析器。\n\n# 常见的javascript解析器(JavaScript parser)列表\n\n##  [terser](https://github.com/terser/terser)\n\nA JavaScript mangler/compressor toolkit for ES6+.\n\n## [jsep](https://github.com/EricSmekens/jsep)\n\njsep: A Tiny JavaScript Expression Parser\n\njsep is a simple expression parser written in JavaScript. It can parse JavaScript expressions but not operations. The difference between expressions and operations is akin to the difference between a cell in an Excel spreadsheet vs. a proper JavaScript program.\n\n## [slimit](https://github.com/rspivak/slimit)\n\nlimIt is a JavaScript minifier written in Python. It compiles JavaScript into more compact code so that it downloads and runs faster.\n\nSlimIt also provides a library that includes a JavaScript parser, lexer, pretty printer and a tree visitor.\n\n##  [uglify-js](https://github.com/mishoo/UglifyJS)\n\n相关资源:\n\nhttps://github.com/mishoo\n\nhttp://lisperator.net/\n\n##  [Esprima](https://github.com/jquery/esprima)\n\n相关资源:\n\nhttps://ariya.io/about\n\nhttps://github.com/ariya\n\n\n##  [acorn](https://github.com/acornjs/acorn)\n\n相关资源:\n\nhttps://marijnhaverbeke.nl/\n\nhttps://github.com/marijnh\n\n\n##  [@babel/parser](https://github.com/babel/babel/tree/master/packages/babel-parser)\n\n\n##  [espree](https://github.com/eslint/espree)\n\n相关资源:\n\nhttps://github.com/nzakas\n\nhttps://humanwhocodes.com/\n\n\n##  [TypeScript](https://github.com/microsoft/TypeScript/tree/master/src/compiler)\n\n\n\n##  [sucrase](https://github.com/alangpierce/sucrase)\n\n相关资源:\n\nhttps://github.com/alangpierce\n\n\n##  [swc](https://github.com/swc-project/swc)\n\n相关资源:\n\nhttps://github.com/kdy1\n\nhttps://kdy1.github.io/\n\n\n\n##  [esbuild](https://github.com/evanw/esbuild/)\n\n相关资源:\n\nhttps://github.com/evanw\n\nhttp://madebyevan.com/\n\n\n##  [recast](https://github.com/benjamn/recast)\n\n相关资源:\n\nhttps://github.com/benjamn\n\nhttps://www.quora.com/profile/Ben-Newman\n\n\n##  [jscodeshift](https://github.com/facebook/jscodeshift)\n\n相关资源:\n\nhttps://github.com/fkling\n\nhttps://felix-kling.de/\n\n\n## [esprit](https://github.com/dherman/esprit)\n\nA JavaScript parser written in Rust.\n\n##  [ASTExplorer](https://github.com/fkling/astexplorer)\n\n## [pyjsparser](https://github.com/PiotrDabkowski/pyjsparser)\n\nFast JavaScript parser - manual translation of esprima.js to python. Takes 1 second to parse whole angular.js library so parsing speed is about 100k characters per second which makes it the fastest and most comprehensible JavaScript parser for python out there.\n\n# 其他的相关解析器\n\n## [css.js](https://github.com/jotform/css.js)\n\nA lightweight, battle tested, fast, css parser in JavaScript","source":"_posts/常见javascript解析器.md","raw":"---\ntitle: 常见javascript解析器\ntags: 技术汇总\nabbrlink: 24882\ndate: 2022-10-22 19:22:17\n---\n\n如果对编译器或者语言编译技术感兴趣，可以研究一些JavaScript解析器。\n\n# 常见的javascript解析器(JavaScript parser)列表\n\n##  [terser](https://github.com/terser/terser)\n\nA JavaScript mangler/compressor toolkit for ES6+.\n\n## [jsep](https://github.com/EricSmekens/jsep)\n\njsep: A Tiny JavaScript Expression Parser\n\njsep is a simple expression parser written in JavaScript. It can parse JavaScript expressions but not operations. The difference between expressions and operations is akin to the difference between a cell in an Excel spreadsheet vs. a proper JavaScript program.\n\n## [slimit](https://github.com/rspivak/slimit)\n\nlimIt is a JavaScript minifier written in Python. It compiles JavaScript into more compact code so that it downloads and runs faster.\n\nSlimIt also provides a library that includes a JavaScript parser, lexer, pretty printer and a tree visitor.\n\n##  [uglify-js](https://github.com/mishoo/UglifyJS)\n\n相关资源:\n\nhttps://github.com/mishoo\n\nhttp://lisperator.net/\n\n##  [Esprima](https://github.com/jquery/esprima)\n\n相关资源:\n\nhttps://ariya.io/about\n\nhttps://github.com/ariya\n\n\n##  [acorn](https://github.com/acornjs/acorn)\n\n相关资源:\n\nhttps://marijnhaverbeke.nl/\n\nhttps://github.com/marijnh\n\n\n##  [@babel/parser](https://github.com/babel/babel/tree/master/packages/babel-parser)\n\n\n##  [espree](https://github.com/eslint/espree)\n\n相关资源:\n\nhttps://github.com/nzakas\n\nhttps://humanwhocodes.com/\n\n\n##  [TypeScript](https://github.com/microsoft/TypeScript/tree/master/src/compiler)\n\n\n\n##  [sucrase](https://github.com/alangpierce/sucrase)\n\n相关资源:\n\nhttps://github.com/alangpierce\n\n\n##  [swc](https://github.com/swc-project/swc)\n\n相关资源:\n\nhttps://github.com/kdy1\n\nhttps://kdy1.github.io/\n\n\n\n##  [esbuild](https://github.com/evanw/esbuild/)\n\n相关资源:\n\nhttps://github.com/evanw\n\nhttp://madebyevan.com/\n\n\n##  [recast](https://github.com/benjamn/recast)\n\n相关资源:\n\nhttps://github.com/benjamn\n\nhttps://www.quora.com/profile/Ben-Newman\n\n\n##  [jscodeshift](https://github.com/facebook/jscodeshift)\n\n相关资源:\n\nhttps://github.com/fkling\n\nhttps://felix-kling.de/\n\n\n## [esprit](https://github.com/dherman/esprit)\n\nA JavaScript parser written in Rust.\n\n##  [ASTExplorer](https://github.com/fkling/astexplorer)\n\n## [pyjsparser](https://github.com/PiotrDabkowski/pyjsparser)\n\nFast JavaScript parser - manual translation of esprima.js to python. Takes 1 second to parse whole angular.js library so parsing speed is about 100k characters per second which makes it the fastest and most comprehensible JavaScript parser for python out there.\n\n# 其他的相关解析器\n\n## [css.js](https://github.com/jotform/css.js)\n\nA lightweight, battle tested, fast, css parser in JavaScript","slug":"常见javascript解析器","published":1,"updated":"2022-10-22T12:10:01.733Z","_id":"cl9juxzjp00002fzo024d5m9i","comments":1,"layout":"post","photos":[],"link":"","content":"<p>如果对编译器或者语言编译技术感兴趣，可以研究一些JavaScript解析器。</p>\n<h1 id=\"常见的javascript解析器-JavaScript-parser-列表\"><a href=\"#常见的javascript解析器-JavaScript-parser-列表\" class=\"headerlink\" title=\"常见的javascript解析器(JavaScript parser)列表\"></a>常见的javascript解析器(JavaScript parser)列表</h1><h2 id=\"terser\"><a href=\"#terser\" class=\"headerlink\" title=\"terser\"></a><a href=\"https://github.com/terser/terser\" target=\"_blank\" rel=\"noopener\">terser</a></h2><p>A JavaScript mangler/compressor toolkit for ES6+.</p>\n<h2 id=\"jsep\"><a href=\"#jsep\" class=\"headerlink\" title=\"jsep\"></a><a href=\"https://github.com/EricSmekens/jsep\" target=\"_blank\" rel=\"noopener\">jsep</a></h2><p>jsep: A Tiny JavaScript Expression Parser</p>\n<p>jsep is a simple expression parser written in JavaScript. It can parse JavaScript expressions but not operations. The difference between expressions and operations is akin to the difference between a cell in an Excel spreadsheet vs. a proper JavaScript program.</p>\n<h2 id=\"slimit\"><a href=\"#slimit\" class=\"headerlink\" title=\"slimit\"></a><a href=\"https://github.com/rspivak/slimit\" target=\"_blank\" rel=\"noopener\">slimit</a></h2><p>limIt is a JavaScript minifier written in Python. It compiles JavaScript into more compact code so that it downloads and runs faster.</p>\n<p>SlimIt also provides a library that includes a JavaScript parser, lexer, pretty printer and a tree visitor.</p>\n<h2 id=\"uglify-js\"><a href=\"#uglify-js\" class=\"headerlink\" title=\"uglify-js\"></a><a href=\"https://github.com/mishoo/UglifyJS\" target=\"_blank\" rel=\"noopener\">uglify-js</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/mishoo\" target=\"_blank\" rel=\"noopener\">https://github.com/mishoo</a></p>\n<p><a href=\"http://lisperator.net/\" target=\"_blank\" rel=\"noopener\">http://lisperator.net/</a></p>\n<h2 id=\"Esprima\"><a href=\"#Esprima\" class=\"headerlink\" title=\"Esprima\"></a><a href=\"https://github.com/jquery/esprima\" target=\"_blank\" rel=\"noopener\">Esprima</a></h2><p>相关资源:</p>\n<p><a href=\"https://ariya.io/about\" target=\"_blank\" rel=\"noopener\">https://ariya.io/about</a></p>\n<p><a href=\"https://github.com/ariya\" target=\"_blank\" rel=\"noopener\">https://github.com/ariya</a></p>\n<h2 id=\"acorn\"><a href=\"#acorn\" class=\"headerlink\" title=\"acorn\"></a><a href=\"https://github.com/acornjs/acorn\" target=\"_blank\" rel=\"noopener\">acorn</a></h2><p>相关资源:</p>\n<p><a href=\"https://marijnhaverbeke.nl/\" target=\"_blank\" rel=\"noopener\">https://marijnhaverbeke.nl/</a></p>\n<p><a href=\"https://github.com/marijnh\" target=\"_blank\" rel=\"noopener\">https://github.com/marijnh</a></p>\n<h2 id=\"babel-parser\"><a href=\"#babel-parser\" class=\"headerlink\" title=\"@babel/parser\"></a><a href=\"https://github.com/babel/babel/tree/master/packages/babel-parser\" target=\"_blank\" rel=\"noopener\">@babel/parser</a></h2><h2 id=\"espree\"><a href=\"#espree\" class=\"headerlink\" title=\"espree\"></a><a href=\"https://github.com/eslint/espree\" target=\"_blank\" rel=\"noopener\">espree</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/nzakas\" target=\"_blank\" rel=\"noopener\">https://github.com/nzakas</a></p>\n<p><a href=\"https://humanwhocodes.com/\" target=\"_blank\" rel=\"noopener\">https://humanwhocodes.com/</a></p>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a><a href=\"https://github.com/microsoft/TypeScript/tree/master/src/compiler\" target=\"_blank\" rel=\"noopener\">TypeScript</a></h2><h2 id=\"sucrase\"><a href=\"#sucrase\" class=\"headerlink\" title=\"sucrase\"></a><a href=\"https://github.com/alangpierce/sucrase\" target=\"_blank\" rel=\"noopener\">sucrase</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/alangpierce\" target=\"_blank\" rel=\"noopener\">https://github.com/alangpierce</a></p>\n<h2 id=\"swc\"><a href=\"#swc\" class=\"headerlink\" title=\"swc\"></a><a href=\"https://github.com/swc-project/swc\" target=\"_blank\" rel=\"noopener\">swc</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/kdy1\" target=\"_blank\" rel=\"noopener\">https://github.com/kdy1</a></p>\n<p><a href=\"https://kdy1.github.io/\" target=\"_blank\" rel=\"noopener\">https://kdy1.github.io/</a></p>\n<h2 id=\"esbuild\"><a href=\"#esbuild\" class=\"headerlink\" title=\"esbuild\"></a><a href=\"https://github.com/evanw/esbuild/\" target=\"_blank\" rel=\"noopener\">esbuild</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/evanw\" target=\"_blank\" rel=\"noopener\">https://github.com/evanw</a></p>\n<p><a href=\"http://madebyevan.com/\" target=\"_blank\" rel=\"noopener\">http://madebyevan.com/</a></p>\n<h2 id=\"recast\"><a href=\"#recast\" class=\"headerlink\" title=\"recast\"></a><a href=\"https://github.com/benjamn/recast\" target=\"_blank\" rel=\"noopener\">recast</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/benjamn\" target=\"_blank\" rel=\"noopener\">https://github.com/benjamn</a></p>\n<p><a href=\"https://www.quora.com/profile/Ben-Newman\" target=\"_blank\" rel=\"noopener\">https://www.quora.com/profile/Ben-Newman</a></p>\n<h2 id=\"jscodeshift\"><a href=\"#jscodeshift\" class=\"headerlink\" title=\"jscodeshift\"></a><a href=\"https://github.com/facebook/jscodeshift\" target=\"_blank\" rel=\"noopener\">jscodeshift</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/fkling\" target=\"_blank\" rel=\"noopener\">https://github.com/fkling</a></p>\n<p><a href=\"https://felix-kling.de/\" target=\"_blank\" rel=\"noopener\">https://felix-kling.de/</a></p>\n<h2 id=\"esprit\"><a href=\"#esprit\" class=\"headerlink\" title=\"esprit\"></a><a href=\"https://github.com/dherman/esprit\" target=\"_blank\" rel=\"noopener\">esprit</a></h2><p>A JavaScript parser written in Rust.</p>\n<h2 id=\"ASTExplorer\"><a href=\"#ASTExplorer\" class=\"headerlink\" title=\"ASTExplorer\"></a><a href=\"https://github.com/fkling/astexplorer\" target=\"_blank\" rel=\"noopener\">ASTExplorer</a></h2><h2 id=\"pyjsparser\"><a href=\"#pyjsparser\" class=\"headerlink\" title=\"pyjsparser\"></a><a href=\"https://github.com/PiotrDabkowski/pyjsparser\" target=\"_blank\" rel=\"noopener\">pyjsparser</a></h2><p>Fast JavaScript parser - manual translation of esprima.js to python. Takes 1 second to parse whole angular.js library so parsing speed is about 100k characters per second which makes it the fastest and most comprehensible JavaScript parser for python out there.</p>\n<h1 id=\"其他的相关解析器\"><a href=\"#其他的相关解析器\" class=\"headerlink\" title=\"其他的相关解析器\"></a>其他的相关解析器</h1><h2 id=\"css-js\"><a href=\"#css-js\" class=\"headerlink\" title=\"css.js\"></a><a href=\"https://github.com/jotform/css.js\" target=\"_blank\" rel=\"noopener\">css.js</a></h2><p>A lightweight, battle tested, fast, css parser in JavaScript</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果对编译器或者语言编译技术感兴趣，可以研究一些JavaScript解析器。</p>\n<h1 id=\"常见的javascript解析器-JavaScript-parser-列表\"><a href=\"#常见的javascript解析器-JavaScript-parser-列表\" class=\"headerlink\" title=\"常见的javascript解析器(JavaScript parser)列表\"></a>常见的javascript解析器(JavaScript parser)列表</h1><h2 id=\"terser\"><a href=\"#terser\" class=\"headerlink\" title=\"terser\"></a><a href=\"https://github.com/terser/terser\" target=\"_blank\" rel=\"noopener\">terser</a></h2><p>A JavaScript mangler/compressor toolkit for ES6+.</p>\n<h2 id=\"jsep\"><a href=\"#jsep\" class=\"headerlink\" title=\"jsep\"></a><a href=\"https://github.com/EricSmekens/jsep\" target=\"_blank\" rel=\"noopener\">jsep</a></h2><p>jsep: A Tiny JavaScript Expression Parser</p>\n<p>jsep is a simple expression parser written in JavaScript. It can parse JavaScript expressions but not operations. The difference between expressions and operations is akin to the difference between a cell in an Excel spreadsheet vs. a proper JavaScript program.</p>\n<h2 id=\"slimit\"><a href=\"#slimit\" class=\"headerlink\" title=\"slimit\"></a><a href=\"https://github.com/rspivak/slimit\" target=\"_blank\" rel=\"noopener\">slimit</a></h2><p>limIt is a JavaScript minifier written in Python. It compiles JavaScript into more compact code so that it downloads and runs faster.</p>\n<p>SlimIt also provides a library that includes a JavaScript parser, lexer, pretty printer and a tree visitor.</p>\n<h2 id=\"uglify-js\"><a href=\"#uglify-js\" class=\"headerlink\" title=\"uglify-js\"></a><a href=\"https://github.com/mishoo/UglifyJS\" target=\"_blank\" rel=\"noopener\">uglify-js</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/mishoo\" target=\"_blank\" rel=\"noopener\">https://github.com/mishoo</a></p>\n<p><a href=\"http://lisperator.net/\" target=\"_blank\" rel=\"noopener\">http://lisperator.net/</a></p>\n<h2 id=\"Esprima\"><a href=\"#Esprima\" class=\"headerlink\" title=\"Esprima\"></a><a href=\"https://github.com/jquery/esprima\" target=\"_blank\" rel=\"noopener\">Esprima</a></h2><p>相关资源:</p>\n<p><a href=\"https://ariya.io/about\" target=\"_blank\" rel=\"noopener\">https://ariya.io/about</a></p>\n<p><a href=\"https://github.com/ariya\" target=\"_blank\" rel=\"noopener\">https://github.com/ariya</a></p>\n<h2 id=\"acorn\"><a href=\"#acorn\" class=\"headerlink\" title=\"acorn\"></a><a href=\"https://github.com/acornjs/acorn\" target=\"_blank\" rel=\"noopener\">acorn</a></h2><p>相关资源:</p>\n<p><a href=\"https://marijnhaverbeke.nl/\" target=\"_blank\" rel=\"noopener\">https://marijnhaverbeke.nl/</a></p>\n<p><a href=\"https://github.com/marijnh\" target=\"_blank\" rel=\"noopener\">https://github.com/marijnh</a></p>\n<h2 id=\"babel-parser\"><a href=\"#babel-parser\" class=\"headerlink\" title=\"@babel/parser\"></a><a href=\"https://github.com/babel/babel/tree/master/packages/babel-parser\" target=\"_blank\" rel=\"noopener\">@babel/parser</a></h2><h2 id=\"espree\"><a href=\"#espree\" class=\"headerlink\" title=\"espree\"></a><a href=\"https://github.com/eslint/espree\" target=\"_blank\" rel=\"noopener\">espree</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/nzakas\" target=\"_blank\" rel=\"noopener\">https://github.com/nzakas</a></p>\n<p><a href=\"https://humanwhocodes.com/\" target=\"_blank\" rel=\"noopener\">https://humanwhocodes.com/</a></p>\n<h2 id=\"TypeScript\"><a href=\"#TypeScript\" class=\"headerlink\" title=\"TypeScript\"></a><a href=\"https://github.com/microsoft/TypeScript/tree/master/src/compiler\" target=\"_blank\" rel=\"noopener\">TypeScript</a></h2><h2 id=\"sucrase\"><a href=\"#sucrase\" class=\"headerlink\" title=\"sucrase\"></a><a href=\"https://github.com/alangpierce/sucrase\" target=\"_blank\" rel=\"noopener\">sucrase</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/alangpierce\" target=\"_blank\" rel=\"noopener\">https://github.com/alangpierce</a></p>\n<h2 id=\"swc\"><a href=\"#swc\" class=\"headerlink\" title=\"swc\"></a><a href=\"https://github.com/swc-project/swc\" target=\"_blank\" rel=\"noopener\">swc</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/kdy1\" target=\"_blank\" rel=\"noopener\">https://github.com/kdy1</a></p>\n<p><a href=\"https://kdy1.github.io/\" target=\"_blank\" rel=\"noopener\">https://kdy1.github.io/</a></p>\n<h2 id=\"esbuild\"><a href=\"#esbuild\" class=\"headerlink\" title=\"esbuild\"></a><a href=\"https://github.com/evanw/esbuild/\" target=\"_blank\" rel=\"noopener\">esbuild</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/evanw\" target=\"_blank\" rel=\"noopener\">https://github.com/evanw</a></p>\n<p><a href=\"http://madebyevan.com/\" target=\"_blank\" rel=\"noopener\">http://madebyevan.com/</a></p>\n<h2 id=\"recast\"><a href=\"#recast\" class=\"headerlink\" title=\"recast\"></a><a href=\"https://github.com/benjamn/recast\" target=\"_blank\" rel=\"noopener\">recast</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/benjamn\" target=\"_blank\" rel=\"noopener\">https://github.com/benjamn</a></p>\n<p><a href=\"https://www.quora.com/profile/Ben-Newman\" target=\"_blank\" rel=\"noopener\">https://www.quora.com/profile/Ben-Newman</a></p>\n<h2 id=\"jscodeshift\"><a href=\"#jscodeshift\" class=\"headerlink\" title=\"jscodeshift\"></a><a href=\"https://github.com/facebook/jscodeshift\" target=\"_blank\" rel=\"noopener\">jscodeshift</a></h2><p>相关资源:</p>\n<p><a href=\"https://github.com/fkling\" target=\"_blank\" rel=\"noopener\">https://github.com/fkling</a></p>\n<p><a href=\"https://felix-kling.de/\" target=\"_blank\" rel=\"noopener\">https://felix-kling.de/</a></p>\n<h2 id=\"esprit\"><a href=\"#esprit\" class=\"headerlink\" title=\"esprit\"></a><a href=\"https://github.com/dherman/esprit\" target=\"_blank\" rel=\"noopener\">esprit</a></h2><p>A JavaScript parser written in Rust.</p>\n<h2 id=\"ASTExplorer\"><a href=\"#ASTExplorer\" class=\"headerlink\" title=\"ASTExplorer\"></a><a href=\"https://github.com/fkling/astexplorer\" target=\"_blank\" rel=\"noopener\">ASTExplorer</a></h2><h2 id=\"pyjsparser\"><a href=\"#pyjsparser\" class=\"headerlink\" title=\"pyjsparser\"></a><a href=\"https://github.com/PiotrDabkowski/pyjsparser\" target=\"_blank\" rel=\"noopener\">pyjsparser</a></h2><p>Fast JavaScript parser - manual translation of esprima.js to python. Takes 1 second to parse whole angular.js library so parsing speed is about 100k characters per second which makes it the fastest and most comprehensible JavaScript parser for python out there.</p>\n<h1 id=\"其他的相关解析器\"><a href=\"#其他的相关解析器\" class=\"headerlink\" title=\"其他的相关解析器\"></a>其他的相关解析器</h1><h2 id=\"css-js\"><a href=\"#css-js\" class=\"headerlink\" title=\"css.js\"></a><a href=\"https://github.com/jotform/css.js\" target=\"_blank\" rel=\"noopener\">css.js</a></h2><p>A lightweight, battle tested, fast, css parser in JavaScript</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"ck60tw09m0000qlyxh0wo2cop","tag_id":"ck60tw09v0001qlyx5vrp5o1t","_id":"ck60tw09y0002qlyxcvbv7neo"},{"post_id":"ck63kzmlm0000jniy9mgo7r9o","tag_id":"ck63kzmlt0001jniyatfw1xxl","_id":"ck63kzmlw0002jniyeqgicf5d"},{"post_id":"ck67ln3vk0000tqiy39msbbid","tag_id":"ck67ln3vs0001tqiy60pah913","_id":"ck67ln3vv0002tqiy71zl3qf3"},{"post_id":"ck680o2sm0000iviyhqws7ymq","tag_id":"ck680o2sx0001iviy93cw0hhe","_id":"ck680o2t10002iviygc5549ds"},{"post_id":"ck6gg8kaa0000wkiy4jev0tpn","tag_id":"ck6gg8kah0001wkiyeoa0f953","_id":"ck6gg8kak0002wkiycwih5gs6"},{"post_id":"ck6tk5wce00001as66soy5c06","tag_id":"ck60tw09v0001qlyx5vrp5o1t","_id":"ck6tk5wcm00011as61h3gea3n"},{"post_id":"ck6wg1hod00009ts674ch13c8","tag_id":"ck6em1y3b0001fdiygd3w52tt","_id":"ck6wg1hol00029ts67kxrgbli"},{"post_id":"ck6wg1hok00019ts6ejuya9u5","tag_id":"ck6wg1hol00039ts60xt70wy9","_id":"ck6wg1hop00049ts65vgwf22r"},{"post_id":"ck73ki4ic0000vds61uwz5o2g","tag_id":"ck73ki4ij0001vds67fn80fu9","_id":"ck73ki4in0002vds69lkkc5e2"},{"post_id":"ck7am7mbd0000ufs61gyselwy","tag_id":"ck7am7mbk0001ufs68ruv9b8t","_id":"ck7am7mbo0002ufs6bp0m2la7"},{"post_id":"ck8o45s8c00001cs67a9baxju","tag_id":"ck8o45s8m00021cs69kwz64tt","_id":"ck8o45s8q00041cs6gktd1vnb"},{"post_id":"ck8o45s8k00011cs68urn23iu","tag_id":"ck8o45s8q00031cs6h7doaxr0","_id":"ck8o45s8r00051cs6g9lf2km6"},{"post_id":"ck8o4n7870000bps6ffhj66ac","tag_id":"ck8o4n78e0001bps65xved3o7","_id":"ck8o4n78j0002bps6crkq6cu2"},{"post_id":"ck9hghdgx0000d1s6gi0r0tc1","tag_id":"ck9hghdh60002d1s66i26ft9f","_id":"ck9hghdhc0004d1s6bx26e6w9"},{"post_id":"ck9hghdh50001d1s6e8mpfz1u","tag_id":"ck9hghdhb0003d1s67whz24xm","_id":"ck9hghdhc0005d1s67fqu3f9k"},{"post_id":"ck9ps6y250000x3s6cxztc0zc","tag_id":"ck5ypcycn0000q6iy5s8x7xsz","_id":"ck9ps6y2g0002x3s62aai0zt5"},{"post_id":"ck9ps6y2e0001x3s6ctwpdis0","tag_id":"ck5ypcycn0000q6iy5s8x7xsz","_id":"ck9ps6y2g0003x3s61lja8og5"},{"post_id":"ckalazpb90000ybyxgas5h8ul","tag_id":"ckalazpbi0001ybyx7vuecut7","_id":"ckalazpbn0002ybyx45q859ri"},{"post_id":"ckl6pcbzl0001s4iy73u211uw","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2v20001kiiy3vmrco8f"},{"post_id":"ckl6pcbze0000s4iy7pkhe0bd","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2v70003kiiy2qsfbhr1"},{"post_id":"ckl7iw2v60002kiiy0k7yh78g","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2v80004kiiy0hxxa2yx"},{"post_id":"ckl6pcbzy0002s4iy0jzr76u8","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2v90005kiiyg36i5wty"},{"post_id":"ckl6pcc1h0006s4iy1a6t4xxg","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2v90006kiiy7kl6a5t0"},{"post_id":"ckl6pcc020004s4iy7kxc96qh","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2va0007kiiy6vrr4aku"},{"post_id":"ckl6pcc1j0007s4iycvgue5zo","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2va0008kiiydkyk0urm"},{"post_id":"ckl7iw2vk0009kiiygbex2pak","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vm000bkiiyauk3carn"},{"post_id":"ckl7iw2vl000akiiyca6o1qx0","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vn000ckiiy2xxk4rod"},{"post_id":"ckl6pcc1r0008s4iy6afe3r69","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vo000dkiiy3n152kjh"},{"post_id":"ckl6pcc31000cs4iy5clsa5is","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vp000ekiiyejrg0rua"},{"post_id":"ckl6pcc33000es4iy9zu41ucr","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vp000fkiiyhvz81awi"},{"post_id":"ckl6pcc3k000fs4iyhqo79y5e","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vt000gkiiy7p2hae0j"},{"post_id":"ckl6pcc3m000hs4iy32w8hydn","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vt000hkiiy6hmm3u6u"},{"post_id":"ckl7iw2vv000ikiiy3qr8brw2","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vw000kkiiy8pwg03l0"},{"post_id":"ckl7iw2vw000jkiiyg30b174k","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vx000mkiiy4h28cwn3"},{"post_id":"ckl7iw2vw000lkiiy6ltj7e3e","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2vx000nkiiye2trfgv1"},{"post_id":"ckl7iw2w2000okiiydzl660cd","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2w4000pkiiy8cpm13mv"},{"post_id":"ckl7iw2w4000qkiiyfbor44s8","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2w5000rkiiy8s139mvk"},{"post_id":"ckl7iw2w6000skiiy4m1d1lty","tag_id":"ckl7iw2ut0000kiiy9xyhbqog","_id":"ckl7iw2w7000tkiiyfqvbduk2"},{"post_id":"cl8rd3qu70000v6qb4ff04jdc","tag_id":"cl8rd3qug0001v6qb3x296hoh","_id":"cl8rd3quq0002v6qb7m7w58oh"},{"post_id":"cl9biup670000grzo16sr5i2a","tag_id":"cl9biup6g0001grzo3cctdeby","_id":"cl9biup6n0002grzodgwtfnc7"},{"post_id":"cl9juxzjp00002fzo024d5m9i","tag_id":"cl9juxzjw00012fzoctxgdmrw","_id":"cl9juxzk400022fzo98su9nme"}],"Tag":[{"name":"生活 养娃","_id":"ck5ypcycn0000q6iy5s8x7xsz"},{"name":"shell 语言学习","_id":"ck60tw09v0001qlyx5vrp5o1t"},{"name":"nginx","_id":"ck63kzmlt0001jniyatfw1xxl"},{"name":"git","_id":"ck67ln3vs0001tqiy60pah913"},{"name":"社会思考","_id":"ck680o2sx0001iviy93cw0hhe"},{"name":"日常","_id":"ck6em1y3b0001fdiygd3w52tt"},{"name":"反思 个人成长","_id":"ck6gg8kah0001wkiyeoa0f953"},{"name":"日常 自制 创意","_id":"ck6wg1hol00039ts60xt70wy9"},{"name":"java android EventBus","_id":"ck73ki4ij0001vds67fn80fu9"},{"name":"go android linux 刷机 root","_id":"ck7am7mbk0001ufs68ruv9b8t"},{"name":"go 语言学习","_id":"ck8o45s8m00021cs69kwz64tt"},{"name":"技术杂想","_id":"ck8o45s8q00031cs6h7doaxr0"},{"name":"社会 感悟","_id":"ck8o4n78e0001bps65xved3o7"},{"name":"人生感悟","_id":"ck9hghdh60002d1s66i26ft9f"},{"name":"Python 语言学习","_id":"ck9hghdhb0003d1s67whz24xm"},{"name":"随想","_id":"ckalazpbi0001ybyx7vuecut7"},{"name":"软件设计的哲学 软件开发 方法论","_id":"ckl7iw2ut0000kiiy9xyhbqog"},{"name":"学习笔记 思考总结","_id":"cl8rd3qug0001v6qb3x296hoh"},{"name":"思考 感悟","_id":"cl9biup6g0001grzo3cctdeby"},{"name":"技术汇总","_id":"cl9juxzjw00012fzoctxgdmrw"}]}}